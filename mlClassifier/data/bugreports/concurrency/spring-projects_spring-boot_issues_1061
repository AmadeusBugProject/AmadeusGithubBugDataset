RunProcess signal handling isn't thread-safe
If you run an app and then kill it with `CTRL-C` it may report an NPE during shutdown. Here's an example from using `mvn spring-boot:run`:

```
[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.1.0.BUILD-SNAPSHOT:run (default-cli) on project spring-boot-sample-ws: Could not exec java: NullPointerException -> [Help 1]

org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.1.0.BUILD-SNAPSHOT:run (default-cli) on project spring-boot-sample-ws: Could not exec java
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:216)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:108)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:76)
    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:116)
    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:361)
    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:155)
    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:584)
    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:213)
    at org.apache.maven.cli.MavenCli.main(MavenCli.java:157)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoExecutionException: Could not exec java
    at org.springframework.boot.maven.RunMojo.run(RunMojo.java:172)
    at org.springframework.boot.maven.RunMojo.execute(RunMojo.java:134)
    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:133)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
    ... 19 more
Caused by: java.lang.NullPointerException
    at org.springframework.boot.loader.tools.RunProcess.run(RunProcess.java:78)
    at org.springframework.boot.loader.tools.RunProcess.run(RunProcess.java:52)
    at org.springframework.boot.maven.RunMojo.run(RunMojo.java:168)
    ... 22 more
```

The problem is that there's a race between the signal handler setting `this.process` to `null` on one thread while another thread in `run()` that was blocked on `this.process.waitFor()` then tries to call `this.process.exitValue()`. If the signal handling thread gets in first and manages to null out `this.process` the call to `exitValue()` will NPE.

The fix is to remove the call to `this.process.exitValue()` from `run()` and use the value returned from `this.process.waitFor()` instead.
