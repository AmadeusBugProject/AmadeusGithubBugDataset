{"projectName": "JodaOrg/joda-time", "bugLabels": ["Bug", "NotABug"], "captureTime": "Sat Jul  4 17:10:17 2020", "issues": [{"title": "Czech time format contains invalid UTF-8", "body": "Looks like https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/format/messages_cs.properties\r\nhas been overlooked in 0daee1292837cfea36dd452259d086f3e39cec3f.\r\n\r\nEdit: It was not present at that point.", "url": "https://github.com/JodaOrg/joda-time/issues/503", "user": "niklasf", "labels": ["Bug"], "created": "2019-05-09 11:53:17", "closed": "2019-05-09 13:01:59", "commits": {"d97a3c884cdb06b98438da896e72921d44003174": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "d97a3c884cdb06b98438da896e72921d44003174", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["bd79f1c4245e79b3c2c56d7b04fde2a6e191fa42"], "nameRev": "d97a3c884cdb06b98438da896e72921d44003174 tags/v2.10.2~4^2", "commitMessage": "Fix property file encoding (fixes #503)\n", "commitDateTime": "2019-05-09 14:17:24", "authoredDateTime": "2019-05-09 14:14:44", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/messages_cs.properties", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/org/joda/time/format/messages_ja.properties", "insertions": 22, "deletions": 22, "lines": 44}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d97a3c884cdb06b98438da896e72921d44003174"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 25, "deletions": 25, "lines": 50, "gitFilesChange": 2}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format/messages_ja.properties", "src/main/java/org/joda/time/format/messages_cs.properties"]}, {"title": "withTimeAtStartOfDay does not return the first occurrence of midnight when Daylight Saving Time ends", "body": "- Joda-Time version: 2.10\r\n- Result of `TimeZone.getDefault()`\r\n\r\n```\r\nsun.util.calendar.ZoneInfo[id=\"Europe/Madrid\",offset=3600000,dstSavings=3600000,useDaylight=true,transitions=163,lastRule=java.util.SimpleTimeZone[id=Europe/Madrid,offset=3600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\r\n```\r\n\r\n- Result of `DateTimeZone.getDefault()`\r\n\r\n```\r\nEurope/Madrid\r\n```\r\n\r\n### Problem description\r\n\r\nMethod `withTimeAtStartOfDay` of `DateTime` does not return the first occurrence of midnight when Daylight Saving Time ends. For example, Azores reverts daylight savings at 1am, falling back to 12am.\r\n\r\n### Test case\r\n\r\nActual:\r\n\r\n```\r\nnew DateTime(2018, 10, 28, 0, 0, DateTimeZone.forID(\"Atlantic/Azores\")).withTimeAtStartOfDay \r\nres1: DateTime = 2018-10-28T00:00:00.000-01:00 <- second occurrence\r\n```\r\n\r\nExpected:\r\n\r\n```\r\nres1: DateTime = 2018-10-28T00:00:00.000Z <- first occurrence\r\n```\r\n\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/488", "user": "glammers1", "labels": ["Bug", "Fixed"], "created": "2018-10-24 15:46:52", "closed": "2018-11-01 22:13:39", "commits": {"6a4ee6693216b70d36c8417165e3794b6e273f3c": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "6a4ee6693216b70d36c8417165e3794b6e273f3c", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["0d6b0b7a0c63f7e4d8ee9fed91cec1d29dfe0377"], "nameRev": "6a4ee6693216b70d36c8417165e3794b6e273f3c tags/website4~4", "commitMessage": "Fix DateTime.withTimeAtStartOfDay()\n\nFix when DST is at midnight\nFixes #488\n", "commitDateTime": "2018-11-01 22:08:39", "authoredDateTime": "2018-11-01 22:08:39", "commitGitStats": [{"filePath": "src/changes/changes.xml", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/LocalDate.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Basics.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/test/java/org/joda/time/TestLocalDate_Basics.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "LocalDate.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.LocalDate.toDateTimeAtStartOfDay(org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestDateTime_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Basics.testWithTimeAtStartOfDay()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestLocalDate_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestLocalDate_Basics.testToDateTimeAtStartOfDay_handleMidnightDST()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6a4ee6693216b70d36c8417165e3794b6e273f3c"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.LocalDate.toDateTimeAtStartOfDay(org.joda.time.DateTimeZone)"]}, {"title": "Incorrect Offset for \"Africa/Windhoek\" in 1993 ", "body": "Note: `752247698350` = `1993-11-02T13:41:38.350Z`\r\n\r\n\r\n```java\r\nDateTimeZone.forID(\"Africa/Windhoek\").getOffset(752247698350)\r\n````\r\n\r\nreturns `36k ms` == `1h`.\r\n\r\nThis is wrong, according to https://www.timeanddate.com/time/zone/namibia/windhoek?syear=1990 or https://en.wikipedia.org/wiki/Time_in_Namibia UTC+2 was used all throughout 1993.\r\n\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/485", "user": "original-brownbear", "labels": ["Bug", "Fixed"], "created": "2018-09-17 13:27:46", "closed": "2018-09-23 21:40:37", "commits": {"a0aead168930fdf739cd290e51a00ac95399af73": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "a0aead168930fdf739cd290e51a00ac95399af73", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["add3cf9f2ba7aad62f3f96a43fdd69ee944c3eae"], "nameRev": "a0aead168930fdf739cd290e51a00ac95399af73 tags/website1~6", "commitMessage": "Fix time-zone compiler for Namibia\n\nTZDB hack failed because 1990 to 1994 was standard time in TZDB\nHack needs to revert it to be summer time, even though not accurate\nFixes #485\n", "commitDateTime": "2018-09-23 22:30:03", "authoredDateTime": "2018-09-23 22:02:49", "commitGitStats": [{"filePath": "src/changes/changes.xml", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 21, "deletions": 2, "lines": 23}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZone.java", "insertions": 19, "deletions": 0, "lines": 19}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.Rule", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder,int,java.lang.String)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZone.testWindhoek()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a0aead168930fdf739cd290e51a00ac95399af73"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 21, "deletions": 2, "lines": 23, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.ZoneInfoCompiler.Rule", "org.joda.time.tz.ZoneInfoCompiler.RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder,int,java.lang.String)"]}, {"title": "Supported timezone documentation - Javadoc inconsistent with website; Javadoc inconsistent with behavior", "body": "### Key information\r\n\r\n- Joda-Time version: 2.9.9\r\n- Result of `TimeZone.getDefault()`: sun.util.calendar.ZoneInfo[id=\"America/Chicago\",offset=-21600000,dstSavings=3600000,useDaylight=true,transitions=235,lastRule=java.util.SimpleTimeZone[id=America/Chicago,offset=-21600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=3,startMonth=2,startDay=8,startDayOfWeek=1,startTime=7200000,startTimeMode=0,endMode=3,endMonth=10,endDay=1,endDayOfWeek=1,endTime=7200000,endTimeMode=0]]\r\n- Result of `DateTimeZone.getDefault()`:America/Chicago\r\n\r\n### Problem description\r\nThe Javadoc says explicitly that EST is not accepted by DateTimeZone:\r\n\r\nhttp://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeZone.html\r\n\r\n\"Thus EST and ECT are not accepted.\"\r\n\r\nHowever, this other documentation page that is linked directly from the main Joda-Time page:\r\n\r\nhttp://www.joda.org/joda-time/timezones.html\r\n\r\nlists EST as supported, and indeed EST works with the forID factory method\r\n\r\n### Test cases\r\n\r\nDateTimeZone.forID(\"EST\")\r\n> EST\r\n\r\nDateTimeZone.forID(\"ECT\")\r\n> throws IllegalArgumentException", "url": "https://github.com/JodaOrg/joda-time/issues/475", "user": "jacospain", "labels": ["Bug", "Fixed"], "created": "2018-05-11 00:12:30", "closed": "2018-05-30 20:52:39", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "Inconsistent timezones returned for abbreviations", "body": "joda-time version 2.9.9. JDK 1.8.144\r\n\r\nDifferent time zones are returned for ids EST, MST, HST using different methods (DateTimeZone#forID(id), DateTimeZone#forTimeZone(tz))\r\n\r\n### Test case\r\n```java\r\npublic static void main(String[] args) {\r\n    String datetime = \"2017-09-29T00:00:00.000\";\r\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\r\n    long tzMillis = formatter.withZone(DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"EST\"))).parseMillis(datetime);\r\n    long idMillis = formatter.withZone(DateTimeZone.forID(\"EST\")).parseMillis(datetime);\r\n\r\n    System.out.println(\"forTimeZone: \" + tzMillis);\r\n    System.out.println(\"forID:       \" + idMillis);\r\n}\r\n```\r\n\r\n```\r\nforTimeZone: 1506657600000\r\nforID:       1506661200000\r\n```", "url": "https://github.com/JodaOrg/joda-time/issues/449", "user": "raipc", "labels": ["Bug", "WontFix"], "created": "2017-10-25 08:28:39", "closed": "2017-12-17 06:13:43", "commits": {}, "ttf": 52.000277777777775, "commitsDetails": []}, {"title": "LenientChronology parser double counts out-of-range values", "body": "### Key information\r\n\r\n- Jodatime version = 2.8.1\r\n- Result of `TimeZone.getDefault()` = `sun.util.calendar.ZoneInfo[id=\"Asia/Singapore\",offset=28800000,dstSavings=0,useDaylight=false,transitions=9,lastRule=null]`\r\n- Result of `DateTimeZone.getDefault()` = Asia/Singapore\r\n\r\n### Problem description\r\nLenientChronology seems to double-count out of range values (i.e. seconds > 59)\r\n\r\n### Test case\r\n```\r\nimport org.joda.time.chrono.{ISOChronology, LenientChronology}\r\nimport org.joda.time.format.DateTimeFormatterBuilder\r\n\r\nval secondNumber = \"61\"\r\n\r\nval lenientChronology = LenientChronology.getInstance(ISOChronology.getInstanceUTC)\r\n\r\nval lenientParser = new DateTimeFormatterBuilder()\r\n  .appendSecondOfMinute(1).toFormatter.withChronology(lenientChronology)\r\n\r\nlenientParser.parseMillis(secondNumber)\r\n```\r\n\r\nThis returns 121,000ms instead of the expected 61,000ms.", "url": "https://github.com/JodaOrg/joda-time/issues/432", "user": "Woodz", "labels": ["Bug", "Fixed"], "created": "2017-06-20 02:09:39", "closed": "2017-07-18 16:18:26", "commits": {"66825d61bf5257445f62a8a91ffda9fff8dcc4dd": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 28.00027777777778, "commitsDetails": [{"commitHash": "66825d61bf5257445f62a8a91ffda9fff8dcc4dd", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["b3fdbc28743019bcf855c3dccd7dd07a2372a53f"], "nameRev": "66825d61bf5257445f62a8a91ffda9fff8dcc4dd tags/v2.10~25", "commitMessage": "Avoid double addition in lenient chronology\n\nSetting the field twice needs to be avoided\nFixes #432\n", "commitDateTime": "2017-07-18 17:18:21", "authoredDateTime": "2017-07-18 17:18:21", "commitGitStats": [{"filePath": "src/changes/changes.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/DateTimeParserBucket.java", "insertions": 3, "deletions": 1, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeParserBucket.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimeParserBucket.computeMillis(boolean,java.lang.CharSequence)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["66825d61bf5257445f62a8a91ffda9fff8dcc4dd"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 1, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.DateTimeParserBucket.computeMillis(boolean,java.lang.CharSequence)"]}, {"title": "Subtracting Integer.MAX_VALUE produces positive date", "body": "While upgrading joda-time version I have noticed that from 2.9.3 it produces positive result when subtracting Integer.MAX_VALUE months from DateTime. I think it was introduced while resolving #361 this issue. \r\n\r\nVersion 2.9.2:\r\n```groovy\r\n   @Grab(group='joda-time', module='joda-time', version='2.9.2')\r\n   import org.joda.time.*\r\n\r\n   new DateTime() - Months.months(Integer.MAX_VALUE)\r\n\r\n   Result: -178954954-08-09T11:37:18.012+01:41:16\r\n```\r\nVersion 2.9.3:\r\n```groovy\r\n    @Grab(group='joda-time', module='joda-time', version='2.9.3')\r\n    import org.joda.time.*\r\n\r\n    new DateTime() - Months.months(Integer.MAX_VALUE)\r\n\r\n    Result: 178958987-12-09T11:20:29.675+02:00\r\n```\r\n\r\nWith values near max int produces negative result. For example 2147483600 produces  -178954950-07-09T11:49:37.628+01:41:16. But at some point it starts to return positive dates", "url": "https://github.com/JodaOrg/joda-time/issues/418", "user": "dovydasvenckus", "labels": ["Bug", "Fixed"], "created": "2017-03-09 09:52:04", "closed": "2017-03-22 21:18:15", "commits": {"67e9e5c65c662c4cba609d30cb7fa2726f2ce7a9": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 13.000277777777777, "commitsDetails": [{"commitHash": "67e9e5c65c662c4cba609d30cb7fa2726f2ce7a9", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["ff0473de9fb45b9cfcb14add67eb53662a75011d"], "nameRev": "67e9e5c65c662c4cba609d30cb7fa2726f2ce7a9 tags/v2.9.8~3", "commitMessage": "Handle plus/minus of months correctly\n\nErrors close to Integer.MIN_VALUE/MAX_VALUE\nFixes #418\n", "commitDateTime": "2017-03-22 21:19:34", "authoredDateTime": "2017-03-22 21:19:34", "commitGitStats": [{"filePath": "src/changes/changes.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Basics.java", "insertions": 29, "deletions": 0, "lines": 29}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BasicMonthOfYearDateTimeField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long,int)", "TOT": 9, "UPD": 0, "INS": 3, "MOV": 5, "DEL": 1}]}, {"spoonFilePath": "TestDateTime_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Basics.testPlusMonths_intMin()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testMinusMonths_intMax()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testMinusMonths_intMin()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testPlusMonths_intMax()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["67e9e5c65c662c4cba609d30cb7fa2726f2ce7a9"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7, "deletions": 2, "lines": 9, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 9, "UPD": 0, "INS": 3, "MOV": 5, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long,int)"]}, {"title": "DateTimePrinterInternalPrinter appends the text twice if appending to a StringBuffer or Writer", "body": "### Key information\r\n\r\n- Joda-Time version - I'm using 2.9.7, but you can see the problem by reading the current master as well.\r\n- Time zone not important\r\n\r\n### Problem description\r\n\r\n`DateTimePrinterInternalPrinter#printTo` is implemented as follows:\r\n\r\n        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\r\n            if (appendable instanceof StringBuffer) {\r\n                StringBuffer buf = (StringBuffer) appendable;\r\n                underlying.printTo(buf, partial, locale);\r\n            }\r\n            if (appendable instanceof Writer) {\r\n                Writer out = (Writer) appendable;\r\n                underlying.printTo(out, partial, locale);\r\n            }\r\n            StringBuffer buf = new StringBuffer(estimatePrintedLength());\r\n            underlying.printTo(buf, partial, locale);\r\n            appendable.append(buf);\r\n        }\r\n\r\nThe other override has the same problem.\r\n\r\nSince neither if-block returns after appending, if you do pass in something which is a StringBuffer or a Writer, you end up with the text coming out twice in the resulting formatted date.\r\n\r\n### Test case\r\n\r\n    @Test\r\n    public void testCustomDateTimePrinter() {\r\n        DateTimePrinter printer = new DateTimeFormatterBuilder()\r\n                .append(new CustomDateTimePrinter())\r\n                .appendLiteral(' ')\r\n                .appendYear(4, 8)\r\n                .toPrinter();\r\n\r\n        StringBuffer buffer = new StringBuffer();\r\n        DateTimeZone zone = DateTimeZone.UTC;\r\n        Chronology chronology = ISOChronology.getInstance(zone);\r\n        long instant = new DateTime(2017, 1, 1, 0, 0, 0, chronology).getMillis();\r\n        printer.printTo(buffer, instant, chronology, 0, zone, Locale.ROOT);\r\n\r\n        assertThat(buffer.toString(), is(equalTo(\"Hi 2017\")));\r\n    }\r\n\r\n    private static class CustomDateTimePrinter implements DateTimePrinter {\r\n        @Override\r\n        public int estimatePrintedLength() {\r\n            return 2;\r\n        }\r\n\r\n        @Override\r\n        public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {\r\n            buf.append(\"Hi\");\r\n        }\r\n\r\n        @Override\r\n        public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\r\n            out.write(\"Hi\");\r\n        }\r\n\r\n        @Override\r\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\r\n            buf.append(\"Hi\");\r\n        }\r\n\r\n        @Override\r\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\r\n            out.write(\"hi\");\r\n        }\r\n    }\r\n\r\n### Result\r\n\r\n    java.lang.AssertionError: \r\n    Expected: is \"Hi 2017\"\r\n         but: was \"HiHi 2017\"\r\n\r\n### Workaround\r\n\r\nNot entirely sure. I'd say pass in another kind of Appendable (like StringBuilder), but it looks like the external API just doesn't let me pass in any kind. :(\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/409", "user": "trejkaz", "labels": ["Bug", "Fixed"], "created": "2017-01-01 08:33:46", "closed": "2017-01-06 17:51:41", "commits": {"52757eabf45fbecb04a877feecf1adc3ea765a3e": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "52757eabf45fbecb04a877feecf1adc3ea765a3e", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["43bd5b23aa547e04ee7759020f4eaf55c2f40893"], "nameRev": "52757eabf45fbecb04a877feecf1adc3ea765a3e tags/v2.9.8~9", "commitMessage": "Fix printer that outputs data twice\n\nFix bug in DateTimePrinterInternalPinter\nFixes #409\n", "commitDateTime": "2017-01-06 17:53:05", "authoredDateTime": "2017-01-06 17:53:05", "commitGitStats": [{"filePath": "pom.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/changes/changes.xml", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java", "insertions": 11, "deletions": 11, "lines": 22}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatter.java", "insertions": 45, "deletions": 1, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimePrinterInternalPrinter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimePrinterInternalPrinter.printTo(java.lang.Appendable,long,org.joda.time.Chronology,int,org.joda.time.DateTimeZone,java.util.Locale)", "TOT": 10, "UPD": 0, "INS": 1, "MOV": 7, "DEL": 2}, {"spoonMethodName": "org.joda.time.format.DateTimePrinterInternalPrinter.printTo(java.lang.Appendable,org.joda.time.ReadablePartial,java.util.Locale)", "TOT": 10, "UPD": 0, "INS": 1, "MOV": 7, "DEL": 2}]}, {"spoonFilePath": "TestDateTimeFormatter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testCustomDateTimePrinter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.CustomDateTimePrinter", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testPrint_bufferMethods()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testPrint_builderMethods()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testPrint_writerMethods()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["52757eabf45fbecb04a877feecf1adc3ea765a3e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 11, "deletions": 11, "lines": 22, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 20, "UPD": 0, "INS": 2, "MOV": 14, "DEL": 4, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.DateTimePrinterInternalPrinter.printTo(java.lang.Appendable,org.joda.time.ReadablePartial,java.util.Locale)", "org.joda.time.format.DateTimePrinterInternalPrinter.printTo(java.lang.Appendable,long,org.joda.time.Chronology,int,org.joda.time.DateTimeZone,java.util.Locale)"]}, {"title": "DateTimeComparator.getInstance().compare(null, null) sometimes returns -1", "body": "### Key information\n- Current branch: master, commit c61c1f3fb68c2bafb6eb6d73f2bdc505624a9e3a\n- Result of `TimeZone.getDefault()`:\n\n```\nsun.util.calendar.ZoneInfo[id=\"Europe/Zurich\",offset=3600000,dstSavings=3600000,useDaylight=true,transitions=119,lastRule=java.util.SimpleTimeZone[id=Europe/Zurich,offset=3600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\n```\n- Result of `DateTimeZone.getDefault()`: `Europe/Zurich`\n### Problem description\n- When running `DateTimeComparator.getInstance().compare(null, null)`, it would be expected that `0` is returned, because the `lhsObj` and `rhsObj` are equal.\n- However, if 1ms elapses between calculating `lhsMillis` and `rhsMillis`, `compare` returns `-1`\n- This happens for example when slowly stepping through the `compare` method with a debugger, or when the GC runs in an inconvenient moment.\n### Test case\n\n``` java\n\nint numFailures = 0;\nfor (int i = 0; i < 10000; i++) {\n    if (DateTimeComparator.getInstance().compare(null, null) != 0) {\n        System.out.println(\"Expected DateTimeComparator to return 0 for inputs null, null; failed after \" + i + \" iterations\");\n        numFailures += 1;\n    }\n}\n\nassertEquals(numFailures, 0);\n\n```\n\nResult on my machine (MacBook Pro (Retina, 13-inch, Mid 2014), OS X 10.11.6, Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode)), this happens in about 0.15% of the time:\n\n```\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 1278 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 1511 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 1715 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 1957 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 2728 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 3237 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 3388 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 3594 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 3972 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 4469 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 4922 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 5145 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 5709 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 7406 iterations\nExpected DateTimeComparator to return 0 for inputs null, null; failed after 8154 iterations\n\njava.lang.AssertionError: expected [0] but found [15]\nExpected :0\nActual   :15\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/404", "user": "bekoeppel", "labels": ["Bug", "Fixed"], "created": "2016-10-28 15:06:37", "closed": "2016-11-03 13:06:06", "commits": {"dc437656ff8b825e87d7edf72125dc368b21c885": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "dc437656ff8b825e87d7edf72125dc368b21c885", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["f81758e92881cb18bc1e0a84e2ac64464dd5ba85"], "nameRev": "dc437656ff8b825e87d7edf72125dc368b21c885 tags/v2.9.5~2", "commitMessage": "Comparing two nulls in DateTimeComparator\n\nFixed bug where clock read twice\nFixes #404\n", "commitDateTime": "2016-11-03 13:07:11", "authoredDateTime": "2016-11-03 13:07:11", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/DateTimeComparator.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/test/java/org/joda/time/TestDateTimeComparator.java", "insertions": 10, "deletions": 0, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeComparator.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeComparator.compare(java.lang.Object,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeComparator.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeComparator.testNullNowCheckedOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["dc437656ff8b825e87d7edf72125dc368b21c885"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6, "deletions": 0, "lines": 6, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeComparator.compare(java.lang.Object,java.lang.Object)"]}, {"title": "Joda-time relies on deafult locale", "body": "In ZoneInfoCompiler class at line 210 is not used proper toLower()/toUpper(). The issue is that if the server relies on the default locale and if the process was started with some non English compatible locale such as Turkish, toUpper/Lower will yield an incorrect result. For instance \"URI\".toLowerCase() will result in \"ur\u0131\" instead of \"uri\". The same applies to toUpperCase -> \"uri\".toUpperCase() will become \"UR\u0130\" and checks like \"string.toUpperCase().equals(someConstant)\" will fail.\n\nVERSION OF Joda-time is 2.7\n", "url": "https://github.com/JodaOrg/joda-time/issues/397", "user": "kal0ian", "labels": ["Bug", "Fixed"], "created": "2016-10-12 13:01:58", "closed": "2016-11-03 12:57:52", "commits": {"f81758e92881cb18bc1e0a84e2ac64464dd5ba85": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 21.00027777777778, "commitsDetails": [{"commitHash": "f81758e92881cb18bc1e0a84e2ac64464dd5ba85", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["4d84d89207088ff08fc76d00bf90a56525aa7589"], "nameRev": "f81758e92881cb18bc1e0a84e2ac64464dd5ba85 tags/v2.9.5~3", "commitMessage": "Handle locale correctly zone info compiler\n\nFixes #397\n", "commitDateTime": "2016-11-03 12:58:40", "authoredDateTime": "2016-11-03 12:58:40", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f81758e92881cb18bc1e0a84e2ac64464dd5ba85"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String,int)"]}, {"title": "BufferedReader is not closed properly", "body": "In ZoneInfoCompiler class at line 370 (the version of joda-time is 2.7) BufferedReader is opened and it is closed at line 372. If parseDataFile(in); throw Exception on line 371 the BufferedReader will remain opened.\n", "url": "https://github.com/JodaOrg/joda-time/issues/396", "user": "kal0ian", "labels": ["Bug", "Fixed"], "created": "2016-10-12 12:57:23", "closed": "2016-11-03 12:57:52", "commits": {"4d84d89207088ff08fc76d00bf90a56525aa7589": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 22.00027777777778, "commitsDetails": [{"commitHash": "4d84d89207088ff08fc76d00bf90a56525aa7589", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["eda629fffe60c8315f813950e811c21d8879c557"], "nameRev": "4d84d89207088ff08fc76d00bf90a56525aa7589 tags/v2.9.5~4", "commitMessage": "Close buffered reader correctly in zone info compiler\n\nFixes #396\n", "commitDateTime": "2016-11-03 12:56:05", "authoredDateTime": "2016-11-03 12:56:05", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 9, "deletions": 3, "lines": 12}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File,java.io.File[])", "TOT": 5, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["4d84d89207088ff08fc76d00bf90a56525aa7589"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 9, "deletions": 3, "lines": 12, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File,java.io.File[])"]}, {"title": "Issues on Java 9", "body": "### Key information\n- Joda-Time version `e6dd4ba04d1e16bbc9c98cfd19f330a15b6fd060`\n- Result of `TimeZone.getDefault()` `sun.util.calendar.ZoneInfo[id=\"Europe/London\",offset=0,dstSavings=3600000,useDaylight=true,transitions=242,lastRule=java.util.SimpleTimeZone[id=Europe/London,offset=0,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]`\n- Result of `DateTimeZone.getDefault()` `Europe/London`\n### Problem description\n\nHas anyone been looking at Joda on Java 9? The tests don't seem to pass at the moment.\n### Test case\n\n```\n$ JAVA_HOME=$JAVA8_HOME PATH=$JAVA8_HOME/bin:$PATH java -version\njava version \"1.8.0_102\"\nJava(TM) SE Runtime Environment (build 1.8.0_102-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)\n$ JAVA_HOME=$JAVA8_HOME PATH=$JAVA8_HOME/bin:$PATH mvn test\n[INFO] Scanning for projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Joda-Time 2.9.5-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-resources-plugin:2.7:resources (default-resources) @ joda-time ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 2 resources to META-INF\n[INFO] Copying 15 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.3:compile (default-compile) @ joda-time ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- exec-maven-plugin:1.4.0:java (compile-tzdb) @ joda-time ---\nWriting zoneinfo files\nWriting ZoneInfoMap\n[INFO] \n[INFO] --- maven-resources-plugin:2.7:testResources (default-testResources) @ joda-time ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 35 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.3:testCompile (default-testCompile) @ joda-time ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-surefire-plugin:2.18.1:test (default-test) @ joda-time ---\n[INFO] Surefire report directory: /Users/chrisseaton/Documents/ruby/joda-time/target/surefire-reports\n\n-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\nRunning org.joda.time.TestAllPackages\n\nTestBuddhistChronology.testCalendar\n\nTestCopticChronology.testCalendar\n\nTestEthiopicChronology.testCalendar\n\nTestIslamicChronology.testCalendar\n\nTesting Gregorian chronology over 1000 iterations\n100% complete (i=1000)\n\nTesting Julian chronology over 1000 iterations\n100% complete (i=1000)\nWriting zoneinfo files\nWriting ZoneInfoMap\nTests run: 4201, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.84 sec - in org.joda.time.TestAllPackages\n\nResults :\n\nTests run: 4201, Failures: 0, Errors: 0, Skipped: 0\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 4.817 s\n[INFO] Finished at: 2016-10-09T18:54:06+01:00\n[INFO] Final Memory: 12M/437M\n[INFO] ------------------------------------------------------------------------\n```\n\n```\n$ JAVA_HOME=$JAVA9_HOME PATH=$JAVA9_HOME/bin:$PATH java -version\njava version \"9-ea\"\nJava(TM) SE Runtime Environment (build 9-ea+138)\nJava HotSpot(TM) 64-Bit Server VM (build 9-ea+138, mixed mode)\n$ JAVA_HOME=$JAVA9_HOME PATH=$JAVA9_HOME/bin:$PATH mvn test\n[INFO] Scanning for projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Joda-Time 2.9.5-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-resources-plugin:2.7:resources (default-resources) @ joda-time ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 2 resources to META-INF\n[INFO] Copying 15 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.3:compile (default-compile) @ joda-time ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- exec-maven-plugin:1.4.0:java (compile-tzdb) @ joda-time ---\nWriting zoneinfo files\nWriting ZoneInfoMap\n[INFO] \n[INFO] --- maven-resources-plugin:2.7:testResources (default-testResources) @ joda-time ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 35 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.3:testCompile (default-testCompile) @ joda-time ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-surefire-plugin:2.18.1:test (default-test) @ joda-time ---\n[INFO] Surefire report directory: /Users/chrisseaton/Documents/ruby/joda-time/target/surefire-reports\n\n-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\nRunning org.joda.time.TestAllPackages\n\nTestBuddhistChronology.testCalendar\n\nTestCopticChronology.testCalendar\n\nTestEthiopicChronology.testCalendar\n\nTestIslamicChronology.testCalendar\n\nTesting Gregorian chronology over 1000 iterations\n100% complete (i=1000)\n\nTesting Julian chronology over 1000 iterations\n100% complete (i=1000)\nWriting zoneinfo files\nWriting ZoneInfoMap\nTests run: 4201, Failures: 6, Errors: 2, Skipped: 0, Time elapsed: 3.298 sec <<< FAILURE! - in org.joda.time.TestAllPackages\ntestGetName_berlin(org.joda.time.TestDateTimeZone)  Time elapsed: 0.005 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: expected:<Central European []Time> but was:<Central European [Standard ]Time>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at junit.framework.Assert.assertEquals(Assert.java:87)\n    at org.joda.time.TestDateTimeZone.testGetName_berlin(TestDateTimeZone.java:793)\n\ntestGetChronology_Object_Zone(org.joda.time.convert.TestCalendarConverter)  Time elapsed: 0.003 sec  <<< ERROR!\njava.lang.IllegalAccessException: class org.joda.time.convert.TestCalendarConverter cannot access class sun.util.BuddhistCalendar (in module java.base) because module java.base does not export sun.util to unnamed module @1165b38\n    at jdk.internal.reflect.Reflection.throwIllegalAccessException(java.base@9-ea/Reflection.java:405)\n    at jdk.internal.reflect.Reflection.throwIllegalAccessException(java.base@9-ea/Reflection.java:396)\n    at jdk.internal.reflect.Reflection.ensureMemberAccess(java.base@9-ea/Reflection.java:98)\n    at java.lang.Class.newInstance(java.base@9-ea/Class.java:560)\n    at org.joda.time.convert.TestCalendarConverter.testGetChronology_Object_Zone(TestCalendarConverter.java:122)\n\ntestGetChronology_Object_nullChronology(org.joda.time.convert.TestCalendarConverter)  Time elapsed: 0.002 sec  <<< ERROR!\njava.lang.IllegalAccessException: class org.joda.time.convert.TestCalendarConverter cannot access class sun.util.BuddhistCalendar (in module java.base) because module java.base does not export sun.util to unnamed module @1165b38\n    at jdk.internal.reflect.Reflection.throwIllegalAccessException(java.base@9-ea/Reflection.java:405)\n    at jdk.internal.reflect.Reflection.throwIllegalAccessException(java.base@9-ea/Reflection.java:396)\n    at jdk.internal.reflect.Reflection.ensureMemberAccess(java.base@9-ea/Reflection.java:98)\n    at java.lang.Class.newInstance(java.base@9-ea/Class.java:560)\n    at org.joda.time.convert.TestCalendarConverter.testGetChronology_Object_nullChronology(TestCalendarConverter.java:153)\n\ntestZoneShortNameNearTransition(org.joda.time.format.TestDateTimeFormatter)  Time elapsed: 0.003 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: expected:<...05-10-30 01:00:00.0 [EDT]> but was:<...05-10-30 01:00:00.0 [\u2205\u2205\u2205]>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at junit.framework.Assert.assertEquals(Assert.java:87)\n    at org.joda.time.format.TestDateTimeFormatter.testZoneShortNameNearTransition(TestDateTimeFormatter.java:1041)\n\ntestFormat_halfdayOfDay(org.joda.time.format.TestDateTimeFormat)  Time elapsed: 0.001 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: 2004-06-09T10:20:30.040Z expected:<[AM]> but was:<[am]>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at org.joda.time.format.TestDateTimeFormat.testFormat_halfdayOfDay(TestDateTimeFormat.java:628)\n\ntestFormat_zoneText(org.joda.time.format.TestDateTimeFormat)  Time elapsed: 0.001 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: 2004-06-09T06:20:30.040-04:00 expected:<[EDT]> but was:<[\u2205\u2205\u2205]>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at org.joda.time.format.TestDateTimeFormat.testFormat_zoneText(TestDateTimeFormat.java:760)\n\ntestFormatParse_textHalfdayAM_UK(org.joda.time.format.TestDateTimeFormat)  Time elapsed: 0 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: expected:<$06-[PM]-2007> but was:<$06-[pm]-2007>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at junit.framework.Assert.assertEquals(Assert.java:87)\n    at org.joda.time.format.TestDateTimeFormat.testFormatParse_textHalfdayAM_UK(TestDateTimeFormat.java:1009)\n\ntestFormatParse_textEraBC_France(org.joda.time.format.TestDateTimeFormat)  Time elapsed: 0 sec  <<< FAILURE!\njunit.framework.ComparisonFailure: expected:<$[BC]-0001> but was:<$[av. J.-C.]-0001>\n    at junit.framework.Assert.assertEquals(Assert.java:81)\n    at junit.framework.Assert.assertEquals(Assert.java:87)\n    at org.joda.time.format.TestDateTimeFormat.testFormatParse_textEraBC_France(TestDateTimeFormat.java:1069)\n\n\nResults :\n\nFailed tests: \n  org.joda.time.TestDateTimeZone#testGetName_berlin ComparisonFailure expected:<...\n  org.joda.time.format.TestDateTimeFormat#testFormatParse_textEraBC_France ComparisonFailure\n  org.joda.time.format.TestDateTimeFormat#testFormatParse_textHalfdayAM_UK ComparisonFailure\n  org.joda.time.format.TestDateTimeFormat#testFormat_halfdayOfDay ComparisonFailure\n  org.joda.time.format.TestDateTimeFormat#testFormat_zoneText ComparisonFailure ...\n  org.joda.time.format.TestDateTimeFormatter#testZoneShortNameNearTransition ComparisonFailure\nTests in error: \n  org.joda.time.convert.TestCalendarConverter#testGetChronology_Object_Zone IllegalAccessException\n  org.joda.time.convert.TestCalendarConverter#testGetChronology_Object_nullChronology IllegalAccessException\n\nTests run: 4201, Failures: 6, Errors: 2, Skipped: 0\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 5.665 s\n[INFO] Finished at: 2016-10-09T18:54:52+01:00\n[INFO] Final Memory: 10M/35M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.18.1:test (default-test) on project joda-time: There are test failures.\n[ERROR] \n[ERROR] Please refer to /Users/chrisseaton/Documents/ruby/joda-time/target/surefire-reports for the individual test results.\n[ERROR] -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/394", "user": "chrisseaton", "labels": ["Bug", "Fixed"], "created": "2016-10-09 17:57:08", "closed": "2016-11-03 15:56:02", "commits": {"fb2063b3f83610f29572b631edaa7e0471d249ac": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 24.00027777777778, "commitsDetails": [{"commitHash": "fb2063b3f83610f29572b631edaa7e0471d249ac", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["dc437656ff8b825e87d7edf72125dc368b21c885"], "nameRev": "fb2063b3f83610f29572b631edaa7e0471d249ac tags/v2.9.5~1", "commitMessage": "Update tests for JDK 9\n\nFixes #394\n", "commitDateTime": "2016-11-03 15:54:30", "authoredDateTime": "2016-11-03 15:53:54", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZone.java", "insertions": 41, "deletions": 18, "lines": 59}, {"filePath": "src/test/java/org/joda/time/convert/TestCalendarConverter.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormat.java", "insertions": 13, "deletions": 7, "lines": 20}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatter.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "TestDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZone", "TOT": 4, "UPD": 2, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZone.testGetName_berlin()", "TOT": 5, "UPD": 2, "INS": 0, "MOV": 3, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZone.testGetShortName_berlin()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZone.testGetName_berlin_english()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestCalendarConverter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.convert.TestCalendarConverter.testGetChronology_Object_Zone()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.convert.TestCalendarConverter.testGetChronology_Object_nullChronology()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeFormat.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormat.testFormatParse_textEraBC_France()", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormat.testFormat_zoneText()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormat.testFormat_zoneLongText()", "TOT": 4, "UPD": 1, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormat.testFormat_halfdayOfDay()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormat.testFormatParse_textHalfdayAM_UK()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeFormatter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testZoneShortNameNearTransition()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["fb2063b3f83610f29572b631edaa7e0471d249ac"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Timezone the binary search implementation doesn't pivot on string length correctly with trailing literals.", "body": "### Enviroment\n- Joda-Time 2.9.2 - 2.9.4\n- TimeZone.getDefault(): sun.util.calendar.ZoneInfo[id=\"America/Chicago\",offset=-21600000,dstSavings=3600000,useDaylight=true,transitions=235,lastRule=java.util.SimpleTimeZone[id=America/Chicago,offset=-21600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=3,startMonth=2,startDay=8,startDayOfWeek=1,startTime=7200000,startTimeMode=0,endMode=3,endMonth=10,endDay=1,endDayOfWeek=1,endTime=7200000,endTimeMode=0]]\n- DateTimeZone.getDefault(): America/Chicago\n### Problem description\n\nIt appears that https://github.com/JodaOrg/joda-time/pull/332 actually made parsing worse as it fails to handle literals after ZoneIds.\n#### 2.9.1\n\n2.9.1 is able to round trip (ZonedDateTime.toString()->DateTime->ZonedDateTime) 600 of 617 ZoneIds using a formatter designed to mimic ZonedDateTime's toString scheme (it is defined in the test below, it may not be perfect but worked for ~97% of ZoneIds).\n\nTotal Count: 617\nTranslation success Count: 600\nTranslation failed Count: 17\n\nThe failed ones are listed below:\n- Etc/GMT Invalid format: \"2016-07-13T19:26:56.352Z[Etc/GMT]\" is malformed at \"[Etc/GMT]\"\n- Etc/GMT+1 Invalid format: \"2016-07-13T18:26:56.367-01:00[Etc/GMT+1]\" is malformed at \"[Etc/GMT+1]\"\n- Etc/GMT-1 Invalid format: \"2016-07-13T20:26:56.367+01:00[Etc/GMT-1]\" is malformed at \"[Etc/GMT-1]\"\n- GMT Invalid format: \"2016-07-13T19:26:56.461Z[GMT]\" is malformed at \"[GMT]\"\n- SystemV/AST4 Invalid format: \"2016-07-13T15:26:56.508-04:00[SystemV/AST4]\" is malformed at \"[SystemV/AST4]\"\n- SystemV/AST4ADT Invalid format: \"2016-07-13T16:26:56.508-03:00[SystemV/AST4ADT]\" is malformed at \"[SystemV/AST4ADT]\"\n- SystemV/CST6 Invalid format: \"2016-07-13T13:26:56.508-06:00[SystemV/CST6]\" is malformed at \"[SystemV/CST6]\"\n- SystemV/CST6CDT Invalid format: \"2016-07-13T14:26:56.508-05:00[SystemV/CST6CDT]\" is malformed at \"[SystemV/CST6CDT]\"\n- SystemV/EST5 Invalid format: \"2016-07-13T14:26:56.508-05:00[SystemV/EST5]\" is malformed at \"[SystemV/EST5]\"\n- SystemV/EST5EDT Invalid format: \"2016-07-13T15:26:56.508-04:00[SystemV/EST5EDT]\" is malformed at \"[SystemV/EST5EDT]\"\n- SystemV/HST10 Invalid format: \"2016-07-13T09:26:56.508-10:00[SystemV/HST10]\" is malformed at \"[SystemV/HST10]\"\n- SystemV/MST7 Invalid format: \"2016-07-13T12:26:56.508-07:00[SystemV/MST7]\" is malformed at \"[SystemV/MST7]\"\n- SystemV/MST7MDT Invalid format: \"2016-07-13T13:26:56.508-06:00[SystemV/MST7MDT]\" is malformed at \"[SystemV/MST7MDT]\"\n- SystemV/PST8 Invalid format: \"2016-07-13T11:26:56.508-08:00[SystemV/PST8]\" is malformed at \"[SystemV/PST8]\"\n- SystemV/PST8PDT Invalid format: \"2016-07-13T12:26:56.508-07:00[SystemV/PST8PDT]\" is malformed at \"[SystemV/PST8PDT]\"\n- SystemV/YST9 Invalid format: \"2016-07-13T10:26:56.508-09:00[SystemV/YST9]\" is malformed at \"[SystemV/YST9]\"\n- SystemV/YST9YDT Invalid format: \"2016-07-13T11:26:56.508-08:00[SystemV/YST9YDT]\" is malformed at \"[SystemV/YST9YDT]\"\n#### 2.9.2 - 2.9.4\n\nTotal Count: 617\nTranslation success Count: 3\nTranslation failed Count: 614\n\nThe 614 fail with errors like this one:\nInvalid format: \"2016-07-13T23:13:04.160+03:00[Africa/Addis_Ababa]\" is malformed at \"[Africa/Addis_Ababa]\"\n### Test case\n\n``` java\n    @Test\n    public void test() {\n        class Results {\n            final DateTimeFormatter ZONED_ISO_DATE_TIME_FORMATTER = new DateTimeFormatterBuilder().appendYear(4, 4)\n                .appendLiteral('-')\n                .appendMonthOfYear(2)\n                .appendLiteral('-')\n                .appendDayOfMonth(2)\n                .appendLiteral('T')\n                .appendHourOfDay(2)\n                .appendLiteral(':')\n                .appendMinuteOfHour(2)\n                .appendLiteral(':')\n                .appendSecondOfMinute(2)\n                .appendLiteral('.')\n                .appendFractionOfSecond(0, 9)\n                .appendTimeZoneOffset(\"Z\", true, 2, 2)\n                .appendOptional(new DateTimeFormatterBuilder().appendLiteral('[')\n                    .appendTimeZoneId()\n                    .appendLiteral(']')\n                    .toParser())\n                .toFormatter();\n\n            final DateTimeFormatter ZONED_ISO_DATE_TIME_PRINTER = new DateTimeFormatterBuilder().appendYear(4, 4)\n                .appendLiteral('-')\n                .appendMonthOfYear(2)\n                .appendLiteral('-')\n                .appendDayOfMonth(2)\n                .appendLiteral('T')\n                .appendHourOfDay(2)\n                .appendLiteral(':')\n                .appendMinuteOfHour(2)\n                .appendLiteral(':')\n                .appendSecondOfMinute(2)\n                .appendLiteral('.')\n                .appendFractionOfSecond(0, 9)\n                .appendTimeZoneOffset(\"Z\", true, 2, 2)\n                .appendLiteral('[')\n                .appendTimeZoneId()\n                .appendLiteral(']')\n                .toFormatter();\n\n            final ZoneId zoneId;\n\n            final ZonedDateTime zonedDateTime;\n\n            final String zonedDateTimeAsString;\n\n            DateTime dateTime;\n\n            String dateTimeAsString;\n\n            String toDateTimeError;\n\n            ZonedDateTime zonedDateTimeFromDateTime;\n\n            String toZonedDateTimeError;\n\n            Boolean roundTripEquals;\n\n            Boolean roundTripIsEquals;\n\n            Results(ZoneId zoneId) {\n                this.zoneId = zoneId;\n                this.zonedDateTime = ZonedDateTime.now(zoneId);\n                this.zonedDateTimeAsString = this.zonedDateTime.toString();\n                this.toDateTime();\n                this.fromDateTime();\n            }\n\n            private void fromDateTime() {\n\n                if (this.dateTime != null) {\n\n                    try {\n                        this.zonedDateTimeFromDateTime = ZonedDateTime.parse(this.dateTimeAsString);\n                        this.roundTripEquals = this.zonedDateTime.equals(this.zonedDateTimeFromDateTime);\n                        this.roundTripIsEquals = this.zonedDateTime.isEqual(this.zonedDateTimeFromDateTime);\n\n                    } catch (Exception e) {\n                        this.toZonedDateTimeError = e.getMessage();\n                    }\n                }\n            }\n\n            void toDateTime() {\n                try {\n                    this.dateTime = this.ZONED_ISO_DATE_TIME_FORMATTER.parseDateTime(this.zonedDateTimeAsString);\n                    this.dateTimeAsString = this.dateTime.toString(this.ZONED_ISO_DATE_TIME_PRINTER);\n                } catch (Exception e) {\n                    this.toDateTimeError = e.getMessage();\n                }\n            }\n\n            public boolean failedToTranslation() {\n                return !(this.toDateTimeError == null && this.toZonedDateTimeError == null);\n            }\n\n            public boolean equalityFailed() {\n                return !this.failedToTranslation() && (!(this.roundTripEquals || this.roundTripIsEquals));\n            }\n\n            @Override\n            public String toString() {\n                return new StringBuilder().append(this.zoneId)\n                    .append('-')\n                    .append('[')\n                    .append(this.failedToTranslation() ? \"translation: failed\" : \"translation: passed\")\n                    .append(this.roundTripEquals != null ? this.equalityFailed() ? \", equality: failed\"\n                            : \", equality: passed\" : \"\")\n                    .append(']')\n                    .append(\"\\n\\n\\t\")\n                    .append(\"ZonedDateTime: \")\n                    .append(this.zonedDateTimeAsString)\n                    .append(\"\\n\\t\")\n                    .append(Optional.ofNullable(this.dateTime)\n                        .map(dt -> \"DateTime: \" + this.dateTime)\n                        .orElseGet(() -> \"ZoneDateTime to DateTime error: \" + this.toDateTimeError))\n                    .append(Optional.ofNullable(this.dateTimeAsString)\n                        .map(dts -> \"\\n\\tDateTime As ISO String: \" + dts)\n                        .orElse(\"\"))\n                    .append(Optional.ofNullable(this.zonedDateTimeFromDateTime)\n                        .map(rd -> \"\\n\\tZonedDateTime from DateTime: \" + rd)\n                        .orElse(\"\"))\n                    .append(Optional.ofNullable(this.roundTripEquals)\n                        .map(b -> \"\\n\\tRound Trip ZonedDateTime equals: \" + b)\n                        .orElse(\"\"))\n                    .append(Optional.ofNullable(this.roundTripIsEquals)\n                        .map(b -> \"\\n\\tRound Trip ZonedDateTime isEquals: \" + b)\n                        .orElse(\"\"))\n                    .append(Optional.ofNullable(this.toZonedDateTimeError)\n                        .map(err -> \"\\n\\tDateTime to ZonedDateTime error: \" + err)\n                        .orElse(\"\"))\n                    .append(\"\\n\\n\")\n                    .toString();\n\n            }\n        }\n\n        List<Results> results = Stream.of(TimeZone.getAvailableIDs())\n            .map(TimeZone::getTimeZone)\n            .map(TimeZone::toZoneId)\n            .map(Results::new)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Total Count: \" + results.stream()\n            .count());\n\n        System.out.println(\"Translation success Count: \" + results.stream()\n            .filter(r -> !r.failedToTranslation())\n            .count());\n\n        System.out.println(\"Translation failed Count: \" + results.stream()\n            .filter(r -> r.failedToTranslation())\n            .count());\n\n        System.out.println(\"Equality success Count: \" + results.stream()\n            .filter(r -> !r.equalityFailed() && !r.failedToTranslation())\n            .count());\n\n        System.out.println(\"Equality failed Count: \" + results.stream()\n            .filter(r -> r.equalityFailed())\n            .count());\n\n        System.out.println(\"Failed to translate:\\n\");\n        results.stream()\n            .filter(r -> r.failedToTranslation())\n            .forEach(System.out::println);\n\n        System.out.println(\"Successfully translated:\\n\");\n        results.stream()\n            .filter(r -> !r.failedToTranslation())\n            .forEach(System.out::println);\n\n        System.out.println(\"Failed to equality:\\n\");\n        results.stream()\n            .filter(r -> r.equalityFailed())\n            .forEach(System.out::println);\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/386", "user": "jmax01", "labels": ["Bug", "Fixed"], "created": "2016-07-13 20:26:35", "closed": "2016-07-20 23:25:27", "commits": {"80c7dedc1cf7ecaf81a206cd90c8f08975ed7d3f": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "80c7dedc1cf7ecaf81a206cd90c8f08975ed7d3f", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["f054298876a1f37f864eb5ed3fd0eb56134b2965"], "nameRev": "80c7dedc1cf7ecaf81a206cd90c8f08975ed7d3f tags/v2.9.5~16", "commitMessage": "Fix bug in time-zone binary search\n\nThe fix in v2.9.2 caused problems when the time-zone being parsed\nwas not the last element in the input string. New approach uses up-front\ngrouping to reduce the search space based on the common slash separator\nFixes #386\nSee #332\n", "commitDateTime": "2016-07-21 00:24:48", "authoredDateTime": "2016-07-21 00:24:48", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java", "insertions": 57, "deletions": 44, "lines": 101}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java", "insertions": 100, "deletions": 0, "lines": 100}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.prefixedStartPosition(java.lang.CharSequence,int)", "TOT": 26, "UPD": 8, "INS": 0, "MOV": 15, "DEL": 3}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.parseInto(org.joda.time.format.DateTimeParserBucket,java.lang.CharSequence,int)", "TOT": 41, "UPD": 10, "INS": 7, "MOV": 22, "DEL": 2}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.csCompare(java.lang.CharSequence,int,java.lang.String)", "TOT": 18, "UPD": 5, "INS": 0, "MOV": 8, "DEL": 5}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId", "TOT": 16, "UPD": 0, "INS": 3, "MOV": 12, "DEL": 1}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.estimatePrintedLength()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.printTo(java.lang.Appendable,long,org.joda.time.Chronology,int,org.joda.time.DateTimeZone,java.util.Locale)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.printTo(java.lang.Appendable,org.joda.time.ReadablePartial,java.util.Locale)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.estimateParsedLength()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawson()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawson_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneEtcGMT_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneGMT_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneEtcGMT1_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneEtcGMT10()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneEtcGMT10_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneMET()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneMET_suffix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Incorrect handling of IANA time zone data", "body": "### Key information\n- Joda-Time version: 2.9.3\n- Result of `TimeZone.getDefault()`: `sun.util.calendar.ZoneInfo[id=\"Europe/London\", [...]]`\n- Result of `DateTimeZone.getDefault()`: `Europe/London`\n### Problem description\n\nMy [tzvalidate](https://github.com/nodatime/tzvalidate) project aims to make it easy to validate that code intepreting the IANA time zone data all does it in the same way. Joda Time appears to have some discrepancies. (Without looking into the code, it's hard to guess how many code changes would be required.)\n### Test case\n\nAs a single example, using the 2016d data release, Joda Time claims America/Argentina/Catamarca had a transition at 1999-10-03T04:00:00Z; I believe this transition should be at 1999-10-03T03:00:00Z. (This was just a change from standard to daylight, but without any overall offset change.\n\nhttp://www.timeanddate.com/time/zone/argentina/catamarca confirms that this would have been at 3am UTC (midnight local)\n\nSample code:\n\n``` java\nimport java.io.*;\nimport java.util.*;\nimport org.joda.time.*;\nimport org.joda.time.tz.*;\n\npublic class Test\n{\n    public static void main(String[] args) throws Exception\n    {\n        ZoneInfoCompiler compiler = new ZoneInfoCompiler();\n        File[] files = { new File(\"southamerica\") }; // From 2016d\n        Map<String, DateTimeZone> zones = compiler.compile(null, files);\n        DateTimeZone zone = zones.get(\"America/Argentina/Catamarca\");\n\n        DateTime midJune = new DateTime(1999, 6, 15, 0, 0, 0, DateTimeZone.UTC);\n        long millis = zone.nextTransition(midJune.getMillis());\n        DateTime transition = new DateTime(millis, DateTimeZone.UTC);\n        System.out.println(transition);\n    }\n}\n```\n\nExpected output: 1999-10-03T03:00:00.000Z  \nActual output: 1999-10-03T04:00:00.000Z\n\nI'm very happy to provide the full tzvalidate files for 2016d - the one I'm treating as \"canonical\" agrees with both `zic` and Noda Time, as well as a third party implementation. I haven't attached the files here as they're rather large.\n", "url": "https://github.com/JodaOrg/joda-time/issues/373", "user": "jskeet", "labels": ["Bug"], "created": "2016-05-06 13:20:55", "closed": "2016-08-18 23:22:37", "commits": {"eaaff1d0687fc86a745ca8f3ea0b069b3cf54233": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "909046aa9aab5fae75e2152fd6ded722a4d5aba2": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 104.00027777777778, "commitsDetails": [{"commitHash": "eaaff1d0687fc86a745ca8f3ea0b069b3cf54233", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["381cca4018848c2fa75ae93efd44872c3d60cd59"], "nameRev": "eaaff1d0687fc86a745ca8f3ea0b069b3cf54233 tags/v2.9.5~11", "commitMessage": "Fix time-zone parser\n\nMeet tzvalidate test data\nFixes #373\n", "commitDateTime": "2016-08-19 00:14:55", "authoredDateTime": "2016-08-19 00:14:55", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java", "insertions": 14, "deletions": 4, "lines": 18}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 3, "deletions": 2, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZoneBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList,org.joda.time.tz.DateTimeZoneBuilder$Transition)", "TOT": 4, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.DateTimeZoneBuilder.Transition.withMillis(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.DateTimeZoneBuilder.Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String,org.joda.time.DateTimeZone)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "909046aa9aab5fae75e2152fd6ded722a4d5aba2", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["eaaff1d0687fc86a745ca8f3ea0b069b3cf54233"], "nameRev": "909046aa9aab5fae75e2152fd6ded722a4d5aba2 tags/v2.9.5~10", "commitMessage": "Fix historic time-zone data\n\nFixes #373\n", "commitDateTime": "2016-08-19 00:24:02", "authoredDateTime": "2016-08-19 00:24:02", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["eaaff1d0687fc86a745ca8f3ea0b069b3cf54233", "909046aa9aab5fae75e2152fd6ded722a4d5aba2"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 17, "deletions": 6, "lines": 23, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 11.0, "UPD": 1.0, "INS": 7.0, "MOV": 3.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.DateTimeZoneBuilder.Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)", "org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String,org.joda.time.DateTimeZone)", "org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList,org.joda.time.tz.DateTimeZoneBuilder$Transition)", "org.joda.time.tz.DateTimeZoneBuilder.Transition.withMillis(long)"]}, {"title": "Getting ArrayIndexOutOfBoundsException exception when changing date with  plusMonths", "body": "### Key information\n- Joda-Time version\n  2.9.2\n- Result of `TimeZone.getDefault()`\n  `sun.util.calendar.ZoneInfo[id=\"Europe/Moscow\",offset=10800000,dstSavings=0,useDaylight=false,transitions=79,lastRule=null]`\n- Result of `DateTimeZone.getDefault()`\n  `Europe/Moscow`\n### Problem description\n\nGetting ArrayIndexOutOfBoundsException exception when changing date with  plusMonths.\nSeems that in this case IllegalArgumentException or some specific exception would fit better.\n### Test case\n\n``` java\nDateTime dateTime = new DateTime(1455993437373l);\nDateTime date = dateTime.plusMonths(2147483647);\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/361", "user": "jingerbread", "labels": ["Bug", "Fixed"], "created": "2016-02-24 09:21:41", "closed": "2016-03-27 18:55:49", "commits": {"3195c2cad51f89a59041dae3130ec2d8e0546be0": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "72c59900d0f05257be01899b9353653ce481b032": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 32.000277777777775, "commitsDetails": [{"commitHash": "3195c2cad51f89a59041dae3130ec2d8e0546be0", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["fef3ce069e7ef19965fc70d743bbaaa246897700"], "nameRev": "3195c2cad51f89a59041dae3130ec2d8e0546be0 tags/v2.9.3~2", "commitMessage": "Fix bug when adding months\n\nFixes #361\n", "commitDateTime": "2016-03-27 19:55:32", "authoredDateTime": "2016-03-27 19:55:32", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "insertions": 8, "deletions": 3, "lines": 11}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Basics.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BasicMonthOfYearDateTimeField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long,int)", "TOT": 9, "UPD": 2, "INS": 3, "MOV": 3, "DEL": 1}]}, {"spoonFilePath": "TestDateTime_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Basics.testPlusMonths_intMax()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "72c59900d0f05257be01899b9353653ce481b032", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["3195c2cad51f89a59041dae3130ec2d8e0546be0"], "nameRev": "72c59900d0f05257be01899b9353653ce481b032 tags/v2.9.3~1", "commitMessage": "Fix bug when adding months\n\nFixes #361\n", "commitDateTime": "2016-03-27 19:59:18", "authoredDateTime": "2016-03-27 19:59:18", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3195c2cad51f89a59041dae3130ec2d8e0546be0"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 8, "deletions": 3, "lines": 11, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 9.0, "UPD": 2.0, "INS": 3.0, "MOV": 3.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long,int)"]}, {"title": "Etc/GMT not recognised as timezone id in 2.9.1", "body": "Joda 2.9.1 does not recognize the `Etc/GMT` timezone id.  It does recognise all its aliases, however.  \n\nSample test case below:\n\n```\npublic class TestJoda {\n @Test\n  public void testEtcGMT() {\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"ZZZ\");\n    // Test the aliases\n    f.parseDateTime(\"Etc/GMT+0\");\n    f.parseDateTime(\"Etc/UTC\");\n    f.parseDateTime(\"Greenwich\");\n    // Test the canonical id\n    f.parseDateTime(\"Etc/GMT\");  // <-- This fails\n  }\n}\n```\n\nThe `Etc/GMT` timezone is listed as a canonical id here: http://www.joda.org/joda-time/timezones.html\n", "url": "https://github.com/JodaOrg/joda-time/issues/347", "user": "hearnden", "labels": ["Bug", "Fixed"], "created": "2016-01-20 12:14:01", "closed": "2016-01-28 13:30:10", "commits": {"0b80f3ebf6c752debb8dbea87aa729968dcfa68e": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "0b80f3ebf6c752debb8dbea87aa729968dcfa68e", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["6c50ef551e56b01909b999eb2645996a9b670567"], "nameRev": "0b80f3ebf6c752debb8dbea87aa729968dcfa68e tags/v2.9.2~2", "commitMessage": "Ensure GMT parses\n\nSee #347\n", "commitDateTime": "2016-01-28 13:29:51", "authoredDateTime": "2016-01-28 13:29:51", "commitGitStats": [{"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java", "insertions": 10, "deletions": 0, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "TestDateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneGMT()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0b80f3ebf6c752debb8dbea87aa729968dcfa68e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Release 2.9.1 is incomplete (no dist release)", "body": "Is that an error ?\n", "url": "https://github.com/JodaOrg/joda-time/issues/336", "user": "martinm1000", "labels": ["Bug", "Fixed"], "created": "2015-12-07 22:08:02", "closed": "2015-12-07 22:59:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Date overflow in 2.9 when timezone offset crosses epoch", "body": "Starting from version 2.9, when I construct a DateTime in such a way that the timezone offset causes it to cross the epoch, the date overflows and jumps hundreds of millions of years ahead.\n\nSample code:\n\n```\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\n\npublic class JodaCrossingEpoch {\n    public static void main(String[] args) {\n        // prints 1970-01-01T01:02:03.456+10:00 in 2.8.1,\n        // but 292278994-08-17T17:12:55.807Z in 2.9\n        System.out.println(new DateTime(1970, 1, 1, 1, 2, 3, 456, DateTimeZone.forOffsetHours(10)));\n    }\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/328", "user": "ThrawnCA", "labels": ["Bug", "Fixed"], "created": "2015-11-12 02:22:07", "closed": "2015-11-12 11:25:58", "commits": {"c0cbd65f849645635110df3b719c7e9cc00104ca": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "c0cbd65f849645635110df3b719c7e9cc00104ca", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["556d2a007e74e51771f841ecbffb5b82f748dec3"], "nameRev": "c0cbd65f849645635110df3b719c7e9cc00104ca tags/v2.9.1~1", "commitMessage": "Fix bug around 1970-01-01\n\nBug introduced by min/max changes #190\nFixes #328\n", "commitDateTime": "2015-11-12 11:25:49", "authoredDateTime": "2015-11-12 11:23:54", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/org/joda/time/chrono/ZonedChronology.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "src/test/java/org/joda/time/TestMinMaxLong.java", "insertions": 9, "deletions": 0, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZonedChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.ZonedChronology.localToUTC(long)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}, {"spoonMethodName": "org.joda.time.chrono.ZonedChronology", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestMinMaxLong.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestMinMaxLong.testDateTime_aroundZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": " Error in the validation. Validation code and error message do not match", "body": "Raised at dead [sourceforge](https://sourceforge.net/p/joda-time/bugs/178/) issue tracker.\n\nError in the validation. Validation code and error message do not match. It should be end <= start. org.joda.time.base.AbstractInterval.checkInterval():\n\n```\nif (end < start) {\n    throw new IllegalArgumentException(\"The end instant must be greater or equal to the start\");\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/321", "user": "jodastephen", "labels": ["Bug", "Fixed"], "created": "2015-10-13 22:14:11", "closed": "2015-10-13 22:15:10", "commits": {"0a357a84750ac43ca0d1a068099390eadbfc0f8a": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0a357a84750ac43ca0d1a068099390eadbfc0f8a", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["dadca66121a67692d937f06c7df797886cf17d31"], "nameRev": "0a357a84750ac43ca0d1a068099390eadbfc0f8a tags/v2.9~4", "commitMessage": "Better error message for interval constructor\n\nFixes #321\n", "commitDateTime": "2015-10-13 23:15:01", "authoredDateTime": "2015-10-13 23:15:01", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/base/AbstractInterval.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractInterval.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.base.AbstractInterval.checkInterval(long,long)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0a357a84750ac43ca0d1a068099390eadbfc0f8a"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/base"], "changesInPackagesSPOON": ["org.joda.time.base.AbstractInterval.checkInterval(long,long)"]}, {"title": "Multiple calls to PeriodFormatterBuilder.toFormatter create different formatters", "body": "When testing PeriodFormatterBuilder in a scala console, I found myself doing this:\n\n```\nscala> val builder = new PeriodFormatterBuilder().printZeroAlways().appendYears().appendSuffix(\" years\").appendSeparator(\" \").appendMonths().appendSuffix(\" mons\").appendSeparator(\" \").appendDays().appendSuffix(\" days\").appendSeparator(\" \").appendHours().appendSuffix(\" hours\").appendSeparator(\" \").appendMinutes().appendSuffix(\" mins\").appendSeparator(\" \").appendSecondsWithMillis().appendSuffix(\" secs\")\nbuilder: org.joda.time.format.PeriodFormatterBuilder = org.joda.time.format.PeriodFormatterBuilder@39e62cb0\n\nscala> val p = new Period(0,0,0,1,0,0,0,0)\np: org.joda.time.Period = P1D\n\nscala> parser.toFormatter().print(p)\nres1: String = 0 years 0 mons 1 days 0 hours 0 mins 0.000 secs\n\nscala> builder.toFormatter().parsePeriod(\"0 years 0 mons 1 days 0 hours 0 mins 0.000 secs\")\njava.lang.IllegalArgumentException: Invalid format: \"0 years 0 mons 1 days 0 hours 0 mins 0.000 secs\" is too short\n  at org.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:330)                            \n  at org.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:308)                                   \n  ... 43 elided\n\nscala> builder.toFormatter().print(p)\nres2: String = 0 years 0 mons 1 days 0 hours 0 mins 0.000 secs0 mons 1 days 0 hours 0 mins 0.000 secs1 days 0 hours 0 mins 0.000 secs0 hours 0\nmins 0.000 secs0 mins 0.000 secs0.000 secs\n```\n\nThe PeriodFormatterBuilder seems to add each described field to an already built formatter. If I run the `builder.toFormatter().print(p)` many times, it does not add fields anymore. It keeps the malformed formatted in the exact same (malformed) state.\n\nTested on 2.8.1 and 2.8.2.\n", "url": "https://github.com/JodaOrg/joda-time/issues/309", "user": "judu", "labels": ["Bug", "WontFix"], "created": "2015-08-20 19:40:30", "closed": "2015-08-20 23:49:17", "commits": {"69ed639b41a4d1fe1fff68717681774c00ce56a5": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "69ed639b41a4d1fe1fff68717681774c00ce56a5", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["2948a362fdd63f2799794fd2ce316666756cacd5"], "nameRev": "69ed639b41a4d1fe1fff68717681774c00ce56a5 tags/v2.9~18", "commitMessage": "Clarify PeriodFormatterBuilder docs\n\nIt is in an invalid state once built\nWhile in theory this could be worked around,\nthe effort to do so exceeds the possible benefits\nFixes #309\n", "commitDateTime": "2015-08-21 00:49:10", "authoredDateTime": "2015-08-21 00:49:10", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["69ed639b41a4d1fe1fff68717681774c00ce56a5"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"]}, {"title": "Datetime fails to parse its own output when epoch = Long.MAX_VALUE (again !)", "body": "Hello, thank for the fix on #100 \nUnfortunately the check introduced  seems to work for only for `long` type, not for `Long` object, which causes the problem to reproduce\n\n`DateTime.parse(new DateTime(Long.valueOf(Long.MAX_VALUE)).toString());`\n\nthrows this exception:\n\n```\norg.joda.time.IllegalFieldValueException: Cannot parse \"292278994-08-17T07:12:55.807Z\": Value 292278994 for year must be in the range [-292275054,292278993]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:234)\n    at org.joda.time.chrono.BasicYearDateTimeField.set(BasicYearDateTimeField.java:83)\n    at org.joda.time.format.DateTimeParserBucket$SavedField.set(DateTimeParserBucket.java:568)\n    at org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:447)\n    at org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:411)\n    at org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:882)\n    at org.joda.time.DateTime.parse(DateTime.java:160)\n    at org.joda.time.DateTime.parse(DateTime.java:149)\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/297", "user": "martin-a", "labels": ["Bug", "Fixed"], "created": "2015-07-07 05:37:58", "closed": "2015-10-14 14:39:23", "commits": {"d7774f13ad2dc7cf7295bb8376c21bbf5c662fc4": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 99.00027777777778, "commitsDetails": [{"commitHash": "d7774f13ad2dc7cf7295bb8376c21bbf5c662fc4", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["0a357a84750ac43ca0d1a068099390eadbfc0f8a"], "nameRev": "d7774f13ad2dc7cf7295bb8376c21bbf5c662fc4 tags/v2.9~3", "commitMessage": "Allow min/max dates\n\nProvide some form of support for date-times up to the min/max of Long\nAt the margins, calculations will be slightly imperfect\nUTC is used for the min/max\nFixes #297\nFixes #190\n", "commitDateTime": "2015-10-14 15:34:26", "authoredDateTime": "2015-09-25 08:52:29", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/DateTimeField.java", "insertions": 15, "deletions": 1, "lines": 16}, {"filePath": "src/main/java/org/joda/time/base/BaseDateTime.java", "insertions": 11, "deletions": 5, "lines": 16}, {"filePath": "src/main/java/org/joda/time/chrono/BasicChronology.java", "insertions": 36, "deletions": 10, "lines": 46}, {"filePath": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "src/main/java/org/joda/time/chrono/ZonedChronology.java", "insertions": 11, "deletions": 1, "lines": 12}, {"filePath": "src/main/java/org/joda/time/format/DateTimeParserBucket.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/org/joda/time/TestAll.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Constructors.java", "insertions": 1, "deletions": 31, "lines": 32}, {"filePath": "src/test/java/org/joda/time/TestInterval_Constructors.java", "insertions": 51, "deletions": 1, "lines": 52}, {"filePath": "src/test/java/org/joda/time/TestMinMaxLong.java", "insertions": 317, "deletions": 0, "lines": 317}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Is time zone printing broken for upcoming JDK 1.8u60?", "body": "This class https://gist.github.com/tkowalcz/ac660693b852a85c14a0 will normally print:\n\n```\ndate = Mon, 04 May 2015 22:00:00 GMT\n```\n\nbut on 1.8u60 it will print:\n\n```\ndate = Mon, 04 May 2015 22:00:00 +00:00\n```\n\nI am not familiar with intricacies of time zones and loading their definitions from JDK resources, but was able to pinpoint where Joda Time breaks: In DefaultNameProvider::getNameSet when looking up time zone definitions there are checks:\n\n```\n135: if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n143: if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n```\n\nBut on 1.8u60 call to \n\n```\nDateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n```\n\nwill return array of arrays of seven (7!) elements.\n\nEarly release of this JDK version can be found here: https://jdk8.java.net/download.html\n\nThis will cause mayhem after the release (e.g. for us it will break all our apps talking to Amazon WebServices through their official client, as it will sen malformed requests).\n\nPlease advise.\n", "url": "https://github.com/JodaOrg/joda-time/issues/288", "user": "tkowalcz", "labels": ["Bug", "Fixed"], "created": "2015-06-10 11:14:19", "closed": "2015-06-15 14:05:13", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "AbstractReadableInstantFieldProperty.toInterval does not retain the time zone of the ReadableInstant", "body": "I ran into this because the UK has just switched over to DST, meaning it is no longer in line with UTC. Example:\n\n```\nDateTimeZone.setDefault(DateTimeZone.forID(\"Europe/London\"));\n\nDateTime now = DateTime.now(DateTimeZone.UTC));\nSystem.out.println(now); // 2015-03-31T11:20:14.923Z\nSystem.out.println(now.hourOfDay().roundFloorCopy()); // 2015-03-31T11:00:00.000Z\nSystem.out.println(now.hourOfDay().toInterval()); // 2015-03-31T12:00:00.000+01:00/2015-03-31T13:00:00.000+01:00\n```\n\nNote that the 1 hour offset to UTC reappears when calling toInterval despite starting with a DateTime in UTC. The [`toInterval` method](https://github.com/JodaOrg/joda-time/blob/4222b61dcefc4e621f6d016e0928da0280663f87/src/main/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java#L369) on AbstractReadableInstantFieldProperty uses the Interval constructor with two long arguments, meaning the Interval is constructed using the default time zone, instead of the time zone of the DateTime.\n\nI noticed that [LocalDate](https://github.com/JodaOrg/joda-time/blob/4222b61dcefc4e621f6d016e0928da0280663f87/src/main/java/org/joda/time/LocalDate.java#L991) and [DateMidnight](https://github.com/JodaOrg/joda-time/blob/4222b61dcefc4e621f6d016e0928da0280663f87/src/main/java/org/joda/time/DateMidnight.java#L894) have either an overloaded `toInterval` that takes a DateTimeZone parameter, or use the time zone of the object itself. Is the above behaviour intentional, or should all three methods behave in a similar way, e.g. should there be an overloaded method in AbstractReadableInstantFieldProperty?\n\nCurrently the only way around this (other than building a custom toInterval method) seems to be the following:\n\n```\nSystem.out.println(now.hourOfDay().toInterval().withChronology(ISOChronology.getInstanceUTC())); // 2015-03-31T11:00:00.000Z/2015-03-31T12:00:00.000Z\n```\n\nwhich is very long-winded.\n", "url": "https://github.com/JodaOrg/joda-time/issues/262", "user": "andersschuller", "labels": ["Bug", "Fixed"], "created": "2015-03-31 11:32:41", "closed": "2015-04-26 11:37:50", "commits": {"070bf6036e924eeb817440e8819a0c06025d44fb": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 26.00027777777778, "commitsDetails": [{"commitHash": "070bf6036e924eeb817440e8819a0c06025d44fb", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["6e008a1c643f4dce6cf23cae3587f7d463a0562a"], "nameRev": "070bf6036e924eeb817440e8819a0c06025d44fb tags/v2.8~4", "commitMessage": "Fix Property.toInterval()\n\nChange dateTime.hourOfDay().toInterval() to retain the chronology\nChange applies to abstract class, so affects most date-time classes\nFixes #262\n", "commitDateTime": "2015-04-26 12:37:36", "authoredDateTime": "2015-04-26 12:37:36", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Properties.java", "insertions": 3, "deletions": 3, "lines": 6}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractReadableInstantFieldProperty.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.field.AbstractReadableInstantFieldProperty.toInterval()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTime_Properties.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Properties.testPropertyToIntervalHourOfDay()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["070bf6036e924eeb817440e8819a0c06025d44fb"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/field"], "changesInPackagesSPOON": ["org.joda.time.field.AbstractReadableInstantFieldProperty.toInterval()"]}, {"title": "AbstactInstant javadoc is incorrect", "body": "https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/base/AbstractInstant.java#L388\n\n``` Java\n    /**\n     * Is this instant equal to the millisecond instant passed in\n     * comparing solely by millisecond.\n     *\n     * @param instant  a millisecond instant to check against\n     * @return true if this instant is before the instant passed in\n     */\n    public boolean isEqual(long instant) {\n        return (getMillis() == instant);\n    }\n```\n\nI believe `@returns` should be `true if this instant is equal to the instant passed in` instead. The same copy-paste error appears in `isEqualNow()` javadoc.\n", "url": "https://github.com/JodaOrg/joda-time/issues/241", "user": "mrsmith", "labels": ["Bug", "Fixed"], "created": "2015-02-10 01:48:48", "closed": "2015-02-10 15:12:59", "commits": {"fd323b4a8fa05348c67bdace8dde380ffa7b7435": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "fd323b4a8fa05348c67bdace8dde380ffa7b7435", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["48b6ae85b02f41bec0fac7110ee47239c53eee9d"], "nameRev": "fd323b4a8fa05348c67bdace8dde380ffa7b7435 tags/v2.8~13", "commitMessage": "Fix Javadoc\n\nFixes #241\n", "commitDateTime": "2015-02-10 15:12:48", "authoredDateTime": "2015-02-10 15:12:48", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/base/AbstractInstant.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractInstant.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["fd323b4a8fa05348c67bdace8dde380ffa7b7435"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/base"]}, {"title": "Period: parse does not always handle negative milliseconds field", "body": "I assume the intent is that `toString` and `parse` would roundtrip, but I could be wrong. Also, from what I can tell, having `Period`s with negative fields is permitted. Both are true of `Duration`. Let me know if either are not supported for `Period`.\n\nHere's an example:\n\n```\nPeriod pExpected = Period.new(0, 0, 0, -1); // negative 1 millisecond\nString correctString = pExpected.toString(); // \"PT-0.001S\"\nPeriod pActual = Period.parse(correctString); // positive 1 millisecond\n```\n\nHopefully that works. I'm using joda-time from Clojure, so I don't have a proper Java environment setup. I wanted to check with you before I tried to get the tests running, etc., and attempt a fix.\n\nIn case it helps, here is my original Clojure test, from which this was extracted:\n\n```\n(let [p (org.joda.time.Period. 0 0 0 -1)]\n  (= p\n     (org.joda.time.Period/parse (.toString p)))) ; => returns false\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/238", "user": "jonsmock", "labels": ["Bug", "Fixed"], "created": "2015-02-04 16:24:56", "closed": "2015-02-10 15:28:52", "commits": {"558c9282cedc6b0d8a4dcbb7e7157077872b1cda": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "558c9282cedc6b0d8a4dcbb7e7157077872b1cda", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["fd323b4a8fa05348c67bdace8dde380ffa7b7435"], "nameRev": "558c9282cedc6b0d8a4dcbb7e7157077872b1cda tags/v2.8~12", "commitMessage": "Fix Parsing of negative periods less than a second\n\nFixes #238\n", "commitDateTime": "2015-02-10 15:28:38", "authoredDateTime": "2015-02-10 15:27:36", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormatParsing.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.parseInto(org.joda.time.ReadWritablePeriod,java.lang.String,int,java.util.Locale)", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "TestPeriodFormatParsing.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestPeriodFormatParsing.testParseNegativeMillis1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatParsing.testParseNegativeMillis2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["558c9282cedc6b0d8a4dcbb7e7157077872b1cda"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 2, "lines": 5, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.parseInto(org.joda.time.ReadWritablePeriod,java.lang.String,int,java.util.Locale)"]}, {"title": "DateTime.withDate problem on specific days", "body": "When we call withDate on a DateTime it can happen that the received DateTime has a wrong time.\n\nFor instance\n\n``` java\nDateTime date1 = new DateTime(2015, 1, 28, 2, 55, 0, 0).withZoneRetainFields(DateTimeZone.forID(\"Europe/Zurich\"));\nSystem.out.println(date1.withDate(2010, 3, 10) + \" - \" + date1.getZone());\nDateTime date2 = new DateTime(2015, 1, 30, 2, 55, 0, 0).withZoneRetainFields(DateTimeZone.forID(\"Europe/Zurich\"));\nSystem.out.println(date2.withDate(2010, 3, 10) + \" - \" + date1.getZone());\n```\n\nWill print :\n2010-03-10T03:55:00.000+01:00\n2010-03-10T02:55:00.000+01:00\n\nThe first one is wrong. \nThis is because on the 03-28-2010 02:00:00 there was time change and the implementation of withDate will change first the year, then the month, then the day. The problem occured when the month is changed.\n", "url": "https://github.com/JodaOrg/joda-time/issues/233", "user": "jcedric", "labels": ["Bug", "Fixed"], "created": "2015-01-30 14:25:54", "closed": "2015-02-01 10:56:46", "commits": {"48b6ae85b02f41bec0fac7110ee47239c53eee9d": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "48b6ae85b02f41bec0fac7110ee47239c53eee9d", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["470a545bb065df2467b4f2e7dc5bda853e580708"], "nameRev": "48b6ae85b02f41bec0fac7110ee47239c53eee9d tags/v2.8~14", "commitMessage": "Fix DateTime.withDate() DateTime.withTime()\n\nAlgorithm incorrectly changed hour of day\nHappened mid-change when DST dates were hit\nNew algorithm avoids an IllegalInstantException when moving to DST gap\nFixes #233\n", "commitDateTime": "2015-02-01 10:56:27", "authoredDateTime": "2015-02-01 10:55:35", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/DateTime.java", "insertions": 13, "deletions": 11, "lines": 24}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Basics.java", "insertions": 33, "deletions": 0, "lines": 33}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTime.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTime.withDate(int,int,int)", "TOT": 15, "UPD": 2, "INS": 2, "MOV": 7, "DEL": 4}, {"spoonMethodName": "org.joda.time.DateTime.withTime(int,int,int,int)", "TOT": 20, "UPD": 4, "INS": 2, "MOV": 9, "DEL": 5}]}, {"spoonFilePath": "TestDateTime_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Basics.testWithDate_int_int_int_toDST1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testWithDate_int_int_int_toDST2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testWithDate_int_int_int_affectedByDST()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Basics.testWithTime_int_int_int_int_toDST()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["48b6ae85b02f41bec0fac7110ee47239c53eee9d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 13, "deletions": 11, "lines": 24, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 35, "UPD": 6, "INS": 4, "MOV": 16, "DEL": 9, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTime.withTime(int,int,int,int)", "org.joda.time.DateTime.withDate(int,int,int)"]}, {"title": "MonthDay.plusDays() stucks on February", "body": "The following Groovy code demontrates the issue:\n\n```\nimport org.joda.time.MonthDay\nprintln new MonthDay(1, 1).plusDays(59) // prints --02-29\nprintln new MonthDay(1, 1).plusDays(60) // prints --02-01\n```\n\nAt the last line I have expected March 1, not February\n", "url": "https://github.com/JodaOrg/joda-time/issues/232", "user": "nofate", "labels": ["Bug", "Fixed"], "created": "2015-01-30 13:04:22", "closed": "2015-01-30 13:07:03", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Incorrect SBT dependency info for SBT", "body": "The dependency info for SBT is incorrect\n\nlibraryDependencies += \"joda-time\" %% \"joda-time\" % \"2.7\"\n\nshould be\n\nlibraryDependencies += \"joda-time\" % \"joda-time\" % \"2.7\"\n\nI couldn't find it in the site code, not sure how you're generating it.\n\ncheers,\n\nJon\n", "url": "https://github.com/JodaOrg/joda-time/issues/230", "user": "jrmcauliffe", "labels": ["Bug", "Fixed"], "created": "2015-01-23 05:53:45", "closed": "2015-01-23 12:19:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "PeriodFormat string resources are in ISO 8859-1 encoding instead of UTF-8", "body": "migrated from _https://github.com/dlew/joda-time-android_ since the problem is in the upstream code\n### Description\n\nThe resource bundle strings for PeriodFormat (and possibly others) are using ISO Latin-1 encoding instead of UTF-8.\n\nFor example this file is not UTF-8 encoded (actual encoding is ISO 8859-1):\n\nhttps://github.com/dlew/joda-time-android/blob/master/library/src/org/joda/time/format/messages_es.properties.\n\nNOTE: _github shows it without problems because it detects it correctly as _ISO-8859-1__.\n\nThese files have incorrect encoding:\n\n```\nmessages_es.properties\nmessages_fr.properties\nmessages_da.properties\nmessages_pt.properties\n```\n### Actual result\n\nStrings render in android apps with broken accented characters.\n### Expected result\n\nAccented characters are displayed correctly.\n### Suggested solution\n\nRe-encode the `.properties` files to UTF-8 or to Unicode escapes.\n\nExample using `iconv`:\n\n```\niconv -f ISO-8859-1 -t UTF-8 messages_es.properties > messages_es_UTF8.properties\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/228", "user": "ghost", "labels": ["Bug", "Fixed"], "created": "2015-01-21 15:51:41", "closed": "2015-01-26 21:17:00", "commits": {"0daee1292837cfea36dd452259d086f3e39cec3f": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "0daee1292837cfea36dd452259d086f3e39cec3f", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["b95ebe240aa65d2d28deb84b76d8a7edacf922f8"], "nameRev": "0daee1292837cfea36dd452259d086f3e39cec3f tags/v2.8~16", "commitMessage": "Encode properties files using unicode escapes\n\nRe-encode files using unicode escapes to avoid encoding issues\nFixes #228\n", "commitDateTime": "2015-01-26 21:16:38", "authoredDateTime": "2015-01-26 21:05:25", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/format/messages_da.properties", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/org/joda/time/format/messages_es.properties", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/org/joda/time/format/messages_fr.properties", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/messages_pt.properties", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0daee1292837cfea36dd452259d086f3e39cec3f"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 11, "deletions": 11, "lines": 22, "gitFilesChange": 4}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format/messages_es.properties", "src/main/java/org/joda/time/format/messages_da.properties", "src/main/java/org/joda/time/format/messages_fr.properties", "src/main/java/org/joda/time/format/messages_pt.properties"]}, {"title": "Incorrect month-wrapping behavior in MonthDay.plusDays", "body": "`MonthDay.plusDays` does not return the expected value when adding a number of days that would cause the month to rollover more than once. The following (failing) test case shows the bug:\n\n``` java\npublic void testMonthDayPlusDaysWrapsMonthCorrectly() {\n    MonthDay d = new MonthDay(5,15);\n    assertEquals(d.plusDays(25).plusDays(25), d.plusDays(50));\n}\n```\n\n50 days after 5-15 should be 7-4, but `d.plusDays(50)` gives 6-4 instead. As far as I can tell, the bug is on this line: https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/field/BaseDateTimeField.java#L324. In this example, the problem is on the second iteration of that loop, when the month gets incremented again. It should be incremented from 6 to 7, but the increment is performed on the _original_ month in the `instant` variable, rather than the current month (and `instant` is never updated). Do you agree that this is a bug? \n\nAdditionally, I would like to propose an update to the `MonthDay.plusDays` Javadoc documentation that calls out that calculations that require wrapping past the end of February will be based on an assumption that February has 29 days, which will be incorrect in non-leap years. Calculations that require accuracy in this regard should use a type with a year field. For reference, the `MonthDay` class in the new Java 8 API calls this out in its documentation, and explicitly chose not to support date arithmetic for this very reason: http://docs.oracle.com/javase/8/docs/api/java/time/MonthDay.html.\n\nIf you're amenable to the doc update, I'll go ahead and send a pull request for my proposed change. If you agree the wrapping behavior is a bug, I'm happy to work on a patch (including test cases), but may need some guidance as the fix is not immediately obvious to me. \n", "url": "https://github.com/JodaOrg/joda-time/issues/227", "user": "dancavallaro", "labels": ["Bug", "Fixed"], "created": "2015-01-20 20:39:02", "closed": "2015-01-26 20:51:09", "commits": {"b95ebe240aa65d2d28deb84b76d8a7edacf922f8": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "b95ebe240aa65d2d28deb84b76d8a7edacf922f8", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["bef3d7c9871fd85373e8753dffb5132d8458d373"], "nameRev": "b95ebe240aa65d2d28deb84b76d8a7edacf922f8 tags/v2.8~17", "commitMessage": "Fix MonthDay.plusDays()\n\nAlgorithm incorrect when adding caused month to change twice\nUsed incorrect way of getting current value of partial\nFixes #227\n", "commitDateTime": "2015-01-26 20:50:05", "authoredDateTime": "2015-01-26 20:50:05", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 7, "deletions": 30, "lines": 37}, {"filePath": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/org/joda/time/TestMonthDay_Basics.java", "insertions": 19, "deletions": 12, "lines": 31}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BasicMonthOfYearDateTimeField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(org.joda.time.ReadablePartial,int,int[],int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "TestMonthDay_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestMonthDay_Basics.testPlusDays_int_wrapMonth()", "TOT": 8, "UPD": 3, "INS": 1, "MOV": 4, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMonthDay_Basics.testPlusDays_int_wrapMonthTwice()", "TOT": 9, "UPD": 3, "INS": 0, "MOV": 6, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMonthDay_Basics.testPlusDays_int_wrap50()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b95ebe240aa65d2d28deb84b76d8a7edacf922f8"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(org.joda.time.ReadablePartial,int,int[],int)"]}, {"title": "Doc site using a wrong groupId, for the Maven include dependencies?!", "body": "Hi there,\n\nOn the Joda site, the instructions for Maven dependencies are using a wrong `groupId`:\n\n``` xml\n<dependency>\n  <groupId>org.joda</groupId>\n  <artifactId>joda-time</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\nI believe the correct `groupId` should be this:\n\n``` xml\n   <groupId>joda-time</groupId>\n```\n\nHTH\nFlorin.\n", "url": "https://github.com/JodaOrg/joda-time/issues/214", "user": "florinpatrascu", "labels": ["Bug", "Fixed"], "created": "2014-12-05 14:53:41", "closed": "2014-12-05 18:11:21", "commits": {"5ee3b78500f67b464bc647d5834c62d05086b52c": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "5ee3b78500f67b464bc647d5834c62d05086b52c", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["76425421522a32aecb8d5ccb0b4098f0544ed96d"], "nameRev": "5ee3b78500f67b464bc647d5834c62d05086b52c tags/v2.7~10", "commitMessage": "Fix maven co-ordinates\n\nFixes #214", "commitDateTime": "2014-12-05 18:11:20", "authoredDateTime": "2014-12-05 18:11:20", "commitGitStats": [{"filePath": "src/site/markdown/index.md", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5ee3b78500f67b464bc647d5834c62d05086b52c"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "The time of  'Asia/Dhaka' is wrong by using Joda 2.5", "body": "Zone,            Joda,              Java,  Equal\nAsia/Dacca,2014.11.21:13.29.47,2014.11.21:12.29.47,false\nAsia/Dhaka,2014.11.21:13.29.47,2014.11.21:12.29.47,false\nROC,2014.11.21:14.29.47,2014.11.21:06.29.47,false\n\nHere you can see, the time generated by Java is correct, but Joda is wrong in Asia/Dhaka, cannot solve it by using the latest timezone database.\n", "url": "https://github.com/JodaOrg/joda-time/issues/208", "user": "danielwhitehall", "labels": ["Bug", "Fixed"], "created": "2014-11-21 06:32:15", "closed": "2015-01-05 00:00:53", "commits": {"87278482070aa5ba3b64f2a8e1406c69e4381657": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 44.000277777777775, "commitsDetails": [{"commitHash": "87278482070aa5ba3b64f2a8e1406c69e4381657", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["c6a92aebb9ba03440e4225dd3db205d46a49995e"], "nameRev": "87278482070aa5ba3b64f2a8e1406c69e4381657 tags/v2.7~4", "commitMessage": "Fix Asia/Dhaka time-zone\n\nProblem caused by time-zone ending at 24:00 on December 31st\nModel change as being as 23:59:59.999\nFixes #208\n", "commitDateTime": "2015-01-05 00:00:49", "authoredDateTime": "2015-01-05 00:00:49", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 13, "deletions": 8, "lines": 21}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 5, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["87278482070aa5ba3b64f2a8e1406c69e4381657"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 13, "deletions": 8, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6, "UPD": 0, "INS": 1, "MOV": 5, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear"]}, {"title": "PeriodFormatter ignores case sensitivity", "body": "The PeriodFormatter ignores case sensitivity (similar to issue #154):\n\n```\nprivate static final PeriodFormatter PERIOD_FORMATTER = new PeriodFormatterBuilder()\n\n        .appendYears().appendSuffix(\"Y\").appendSeparator(\" \")\n        .appendMonths().appendSuffix(\"M\").appendSeparator(\" \")\n        .appendWeeks().appendSuffix(\"W\").appendSeparator(\" \")\n        .appendDays().appendSuffix(\"D\").appendSeparator(\" \")\n\n        .appendHours().appendSuffix(\"h\").appendSeparator(\" \")\n        .appendMinutes().appendSuffix(\"m\").appendSeparator(\" \")\n        .appendSeconds().appendSuffix(\"s\")\n        .toFormatter();\n\n@Test\npublic void testMonthAndMinutes() {\n    String oneMonth = Period.months(1).toString(PERIOD_FORMATTER);\n    Assert.assertEquals(\"1M\", oneMonth);\n    Period period = PERIOD_FORMATTER.parsePeriod(oneMonth);\n    Assert.assertEquals(Period.months(1), period);\n    String oneMinute = Period.minutes(1).toString(PERIOD_FORMATTER);\n    Assert.assertEquals(\"1m\", oneMinute);\n    period = PERIOD_FORMATTER.parsePeriod(oneMinute);\n    Assert.assertEquals(Period.minutes(1), period);\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/194", "user": "deki", "labels": ["Bug", "Fixed"], "created": "2014-10-14 12:04:32", "closed": "2014-11-20 20:10:49", "commits": {"81cec147d0fe5d6ced2bf59283e557a0cc60baea": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}, "dbda260e5c2bfac5c20813c1a7645e8f15f89a6d": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 37.000277777777775, "commitsDetails": [{"commitHash": "81cec147d0fe5d6ced2bf59283e557a0cc60baea", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["5ba208f505bfba9155fcb28a6ae3f54b962438a4"], "nameRev": "81cec147d0fe5d6ced2bf59283e557a0cc60baea tags/v2.6~8", "commitMessage": "Formatter previously ignored case sensitivity when working with M and m, for months and minutes leading to an incorrect result. Aims to resolve issue #194\n", "commitDateTime": "2014-11-20 20:06:12", "authoredDateTime": "2014-11-10 20:32:16", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.SimpleAffix.scan(java.lang.String,int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestPeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testMonthsAndMinutesAreConsideredSeparateAndCaseIsNotIgnored()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "dbda260e5c2bfac5c20813c1a7645e8f15f89a6d", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["81cec147d0fe5d6ced2bf59283e557a0cc60baea"], "nameRev": "dbda260e5c2bfac5c20813c1a7645e8f15f89a6d tags/v2.6~7", "commitMessage": "Handle complex prefix/suffix combinations\n\nFor example, 'M' for months and 'm' for minutes.\nParser is generally case insensitive, but handle this specific case\nFixes #194\nFixes #203\n", "commitDateTime": "2014-11-20 20:09:06", "authoredDateTime": "2014-11-20 20:07:01", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "pom.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 13, "deletions": 10, "lines": 23}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java", "insertions": 33, "deletions": 5, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.SimpleAffix.scan(java.lang.String,int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix.finish(java.util.Set)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix.matchesOtherAffix(int,java.lang.String,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestPeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testMonthsAndMinutesAreConsideredSeparateAndCaseIsNotIgnored()", "TOT": 7, "UPD": 5, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixSimple4IgnoringPrefix()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testPluralAffixParseOrder()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixPlural4IgnoringPrefix()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testRegExAffixParseOrder()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixRegEx4IgnoringPrefix()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixComposite1()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixSimple5IgnoringPrefix()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixSimple6IgnoringPrefix()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatSuffixPlural4IgnoringPrefix()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatSuffixRegEx5IgnoringAffix()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatSuffixComposite1()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatSuffixComposite5IgnoringAffix()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["81cec147d0fe5d6ced2bf59283e557a0cc60baea"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.PeriodFormatterBuilder.SimpleAffix.scan(java.lang.String,int)"]}, {"title": "Release 2.5 not visible on GitHub releases page", "body": "Seems that 2.5 is already released but does not appear on https://github.com/JodaOrg/joda-time/releases\n", "url": "https://github.com/JodaOrg/joda-time/issues/192", "user": "goeldner", "labels": ["Bug", "Fixed"], "created": "2014-10-08 09:13:34", "closed": "2014-10-08 22:10:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Let \"withZone\" method change the original locale on PeriodFormatter", "body": "When accessing a `PeriodFormatter` with the method `PeriodFormat` > [`getDefault()`](http://www.joda.org/joda-time/apidocs/org/joda/time/format/PeriodFormat.html#getDefault%28%29) the locale is English, and with `PeriodFormat` > [`wordBased()`](http://www.joda.org/joda-time/apidocs/org/joda/time/format/PeriodFormat.html#wordBased%28%29) the locale is current JVM default locale. That is okay. \n\nThe problem is that in both cases, calling `withLocale()` on the resulting [`PeriodFormatter`](http://www.joda.org/joda-time/apidocs/org/joda/time/format/PeriodFormatter.html) has no effect. The locale as originally set remains. This behavior is inconsistent with other classes such as `DateTime` that always alters the locale when calling `withLocale`. And this behavior is illogical; why offer a `withLocale` method that does nothing?\n\nI suggest changing the behavior of PeriodFormatter to always respect a call to `withLocale` regardless of how the formatter was obtained.\n\nExample code follows.\n\n<!-- language: lang-java -->\n\n```\nDateTime now = DateTime.now( DateTimeZone.forID( \"America/Montreal\" ) );\nLocale locale = Locale.CANADA_FRENCH; // Same behavior for Locale.CANADA_FRENCH, Locale.FRENCH, and Locale.GERMAN.\n\n// Calling \"withLocale\" works on a DateTimeFormatter. LOCALE WORKS.\nDateTimeFormatter formatter = DateTimeFormat.forStyle( \"FF\" ).withLocale( locale );\nString outputDateTime = formatter.print( now );\n\n// Calling \"withLocale\" fails on a PeriodFormatter, has no effect. LOCALE FAILS.\nDateTime later = now.plusHours( 2 ).plusMinutes( 5 );\nPeriod period = new Period( now , later );\nPeriodFormatter periodFormatterDefault = PeriodFormat.getDefault().withLocale( locale );\nString outputPeriodDefault = periodFormatterDefault.print( period );\n\n// Same problem if period formatter obtained with \"wordBased\" (calling \"withLocale\" has no effect). LOCALE FAILS.\nPeriodFormatter periodFormatterWordBased = PeriodFormat.wordBased().withLocale( locale );\nString outputPeriodWordBased = periodFormatterWordBased.print( period );\n\n// The only way to set Locale is by passing one to \"wordBased()\". LOCALE WORKS.\nPeriodFormatter periodFormatterWordBasedPassingLocale = PeriodFormat.wordBased( locale );\nString outputPeriodWordBasedPassingLocale = periodFormatterWordBasedPassingLocale.print( period );\n\nSystem.out.println( \"outputDateTime: \" + outputDateTime );\nSystem.out.println( \"outputPeriodDefault: \" + outputPeriodDefault );\nSystem.out.println( \"outputPeriodWordBased: \" + outputPeriodWordBased );\nSystem.out.println( \"outputPeriodWordBasedPassingLocale: \" + outputPeriodWordBasedPassingLocale );\n```\n\nWhen run.\n\n```\noutputDateTime: mercredi 1 octobre 2014 23 h 01 EDT\noutputPeriodDefault: 2 hours and 5 minutes\noutputPeriodWordBased: 2 hours and 5 minutes\noutputPeriodWordBasedPassingLocale: 2 heures et 5 minutes\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/187", "user": "basil-bourque", "labels": ["Bug", "Fixed"], "created": "2014-10-02 03:05:32", "closed": "2015-01-12 00:09:57", "commits": {"e0958a6e0e98d656c0da5d523f4d7fca58e116d1": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 101.00027777777778, "commitsDetails": [{"commitHash": "e0958a6e0e98d656c0da5d523f4d7fca58e116d1", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["488a500c510d84c5c355cbe61ba0deb096e0f3be"], "nameRev": "e0958a6e0e98d656c0da5d523f4d7fca58e116d1 tags/v2.7~2", "commitMessage": "Ensure period formatting locale used\n\nPeriodFormatter.withLocale() now uses the locale to change the pattern\nPeriodFormat.wordBased() now pushes the locale into the formatter\nFixes #187\nFixes #191\n", "commitDateTime": "2015-01-12 00:09:06", "authoredDateTime": "2015-01-11 23:24:55", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormat.java", "insertions": 76, "deletions": 10, "lines": 86}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormatter.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormat.java", "insertions": 41, "deletions": 0, "lines": 41}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormat.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormat.wordBased(java.util.Locale)", "TOT": 11, "UPD": 0, "INS": 4, "MOV": 5, "DEL": 2}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.buildWordBased(java.util.Locale)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.DynamicWordBased", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.buildRegExFormatter(java.util.ResourceBundle,java.util.Locale)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.buildNonRegExFormatter(java.util.ResourceBundle,java.util.Locale)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.buildRegExFormatter(java.util.ResourceBundle)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.PeriodFormat.buildNonRegExFormatter(java.util.ResourceBundle)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "PeriodFormatter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatter", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "TestPeriodFormat.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestPeriodFormat.test_getDefault_localeValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormat.test_wordBased_localeValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormat.test_wordBasedWithLocale_localeValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestPeriodFormat.test_wordBased_en_withLocale_pt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "LocalDate toDateTime(LocalTime time, DateTimeZone zone) use currentTime throwing error \"Illegal instant due to time zone offset transition\" based on computerTime", "body": "Hi, \n\nWhen using toDateTime(LocalTime time, DateTimeZone zone) with a non-null, valid LocalTime in the given timezone and the computer currentTimeMillis is not-valid in the the timezone: The method throws an IllegalFieldValueException: \"Value xxxx for dayOfMonth is not supported: Illegal instant due to time zone offset transition\"\n\nThe following code snippet reproduce the bug\n\n``` java\nDateTimeUtils.setCurrentMillisFixed(new DateTime(System.currentTimeMillis()).withTime(23, 24, 0, 0).getMillis());\nnew LocalDate(1975, 4, 19).toDateTime(new LocalTime(13, 0), DateTimeZone.forID(\"Europe/Madrid\"));\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/177", "user": "fmarmar", "labels": ["Bug", "Fixed"], "created": "2014-09-15 15:12:13", "closed": "2014-09-16 12:32:20", "commits": {"19546b6960c41dcd053bd06e7345bd015946809c": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "986d905f76176322356df6ef520dc33256827f0a": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "19546b6960c41dcd053bd06e7345bd015946809c", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["1ecf8abe9a0a044b1a4da9eed855c49aac73c7d7"], "nameRev": "19546b6960c41dcd053bd06e7345bd015946809c tags/v2.5~7", "commitMessage": "Alter LocalDate.toDateTime to be more consistent\n\nAlter LocalDate.toDateTime(LocalTime)\nAlter LocalDate.toDateTime(LocalTime, DateTimeZone)\nDocument/test equivalent in LocalDateTime\n\nA null LocalTime is delegated to ensure no change in behaviour\nOtherwise daylight saving gap and overlap has changed\nDuring DST gap changed from IllegalFieldValueEx to IllegalInstantEx\nDuring DST overlap it now selected the earlier offset\n\nChange avoids use of currentTimeMillis() and avoids issue #177\nFixes #177\n", "commitDateTime": "2014-09-16 13:32:14", "authoredDateTime": "2014-09-16 13:31:10", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "src/main/java/org/joda/time/LocalDate.java", "insertions": 28, "deletions": 15, "lines": 43}, {"filePath": "src/main/java/org/joda/time/LocalDateTime.java", "insertions": 12, "deletions": 4, "lines": 16}, {"filePath": "src/test/java/org/joda/time/TestLocalDateTime_Basics.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "src/test/java/org/joda/time/TestLocalDate_Basics.java", "insertions": 27, "deletions": 0, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "LocalDate.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.LocalDate.toDateTime(org.joda.time.LocalTime,org.joda.time.DateTimeZone)", "TOT": 18, "UPD": 2, "INS": 8, "MOV": 3, "DEL": 5}]}, {"spoonFilePath": "LocalDateTime.java", "spoonMethods": []}, {"spoonFilePath": "TestLocalDateTime_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestLocalDateTime_Basics", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDateTime_Basics.testToDateTime_Zone_dstGap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDateTime_Basics.testToDateTime_Zone_dstOverlap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDateTime_Basics.testToDateTime_Zone_dstOverlap_NewYork()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestLocalDate_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestLocalDate_Basics", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDate_Basics.testToDateTime_LocalTime_Zone_dstGap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDate_Basics.testToDateTime_LocalTime_Zone_dstOverlap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestLocalDate_Basics.testToDateTime_LocalTime_Zone_dstOverlap_NewYork()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "986d905f76176322356df6ef520dc33256827f0a", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["19546b6960c41dcd053bd06e7345bd015946809c"], "nameRev": "986d905f76176322356df6ef520dc33256827f0a tags/v2.5~6", "commitMessage": "Alter LocalDate.toDateTime to be more consistent\n\nAdditional release notes\nFixes #177\n", "commitDateTime": "2014-09-16 13:38:40", "authoredDateTime": "2014-09-16 13:38:40", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["19546b6960c41dcd053bd06e7345bd015946809c"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 40, "deletions": 19, "lines": 59, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 18.0, "UPD": 2.0, "INS": 8.0, "MOV": 3.0, "DEL": 5.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.LocalDate.toDateTime(org.joda.time.LocalTime,org.joda.time.DateTimeZone)"]}, {"title": "Olson 2014g   EST /AEST/AEDT", "body": "After Olson 2014e, Australia/Sydney was updated to use AEST/AEDT instead of a fixed EST.\n\nI rebuilt JodaTime to use 2014g, but find the the DateTimeZone.shortName now returns the current offset rather than the relevant new shortname.\n\n:~/working/TzData-trunk$ /usr/bin/java -cp tmp/joda-time-2.4-olson2014g.jar:tmp/airnz-zdump-util.jar nz.co.airnz.zdump.ZDump jodatime 2013 2015 Australia/Sydney\nTransitions in zone Australia/Sydney from year 2013 upto year 2015 using JodaTime (DateTime)\nAustralia/Sydney  Sat Apr  6 15:59:59 2013 UT = Sun Apr  7 02:59:59 2013 +11:00 isdst=1 gmtoff=39600\nAustralia/Sydney  Sat Apr  6 16:00:00 2013 UT = Sun Apr  7 02:00:00 2013 +10:00 isdst=0 gmtoff=36000\nAustralia/Sydney  Sat Oct  5 15:59:59 2013 UT = Sun Oct  6 01:59:59 2013 +10:00 isdst=0 gmtoff=36000\nAustralia/Sydney  Sat Oct  5 16:00:00 2013 UT = Sun Oct  6 03:00:00 2013 +11:00 isdst=1 gmtoff=39600\nAustralia/Sydney  Sat Apr  5 15:59:59 2014 UT = Sun Apr  6 02:59:59 2014 +11:00 isdst=1 gmtoff=39600\nAustralia/Sydney  Sat Apr  5 16:00:00 2014 UT = Sun Apr  6 02:00:00 2014 +10:00 isdst=0 gmtoff=36000\nAustralia/Sydney  Sat Oct  4 15:59:59 2014 UT = Sun Oct  5 01:59:59 2014 +10:00 isdst=0 gmtoff=36000\nAustralia/Sydney  Sat Oct  4 16:00:00 2014 UT = Sun Oct  5 03:00:00 2014 +11:00 isdst=1 gmtoff=39600\n\nIt seems worth noting here that Ubuntu for one is still using 2014e.   The new Olson releases seem to have done much rework/clean up and at this time seem considered as unstable ?\n", "url": "https://github.com/JodaOrg/joda-time/issues/175", "user": "lordbuddha", "labels": ["Bug", "Fixed"], "created": "2014-09-15 01:46:19", "closed": "2014-12-01 14:24:34", "commits": {"70b440b9bbf31035a3ffbb5835ec7a5639a9e8e0": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 77.00027777777778, "commitsDetails": [{"commitHash": "70b440b9bbf31035a3ffbb5835ec7a5639a9e8e0", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["0a7eed9c47188e104079587966094770b80a4047"], "nameRev": "70b440b9bbf31035a3ffbb5835ec7a5639a9e8e0 tags/v2.6~2", "commitMessage": "Fix name provider\n\nName provider relied on tzdb short names matching JDK data names\nThis has ceased to be true due to recent changes in tzdb\nAdd improved matching based on summer/winter\nData returned still depends on the JDK data, not the tzdb\nFixes #175\n", "commitDateTime": "2014-12-01 14:21:23", "authoredDateTime": "2014-12-01 14:19:55", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 14, "deletions": 2, "lines": 16}, {"filePath": "src/main/java/org/joda/time/tz/DefaultNameProvider.java", "insertions": 57, "deletions": 0, "lines": 57}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone.getShortName(long,java.util.Locale)", "TOT": 8, "UPD": 0, "INS": 3, "MOV": 4, "DEL": 1}, {"spoonMethodName": "org.joda.time.DateTimeZone.getName(long,java.util.Locale)", "TOT": 8, "UPD": 0, "INS": 3, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "DefaultNameProvider.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.DefaultNameProvider", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale,java.lang.String,java.lang.String,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale,java.lang.String,java.lang.String,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale,java.lang.String,java.lang.String,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["70b440b9bbf31035a3ffbb5835ec7a5639a9e8e0"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 71, "deletions": 2, "lines": 73, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 20, "UPD": 0, "INS": 10, "MOV": 8, "DEL": 2, "spoonFilesChanged": 2, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz", "src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeZone.getShortName(long,java.util.Locale)", "org.joda.time.tz.DefaultNameProvider", "org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale,java.lang.String,java.lang.String,boolean)", "org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale,java.lang.String,java.lang.String,boolean)", "org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale,java.lang.String,java.lang.String,boolean)", "org.joda.time.DateTimeZone.getName(long,java.util.Locale)"]}, {"title": "JodaTime Handling of Olson Transitions Specified at 24:00 Incorrect ", "body": "Africa/Cairo  and Asia/Dhaka have transitions specified in the Olson DB as happening at 24:00. \n\ne.g.   Instant 1434056400000 which is 2015/06/11 21:00:00 +0000  (GMT)\n\nIn JDK with 2014g in timezone Africa/Cairo is 2015/06/11 23:00:00 +0200\nIn JodaTime with 2014g in timezone Africa/Cairo this is 2015/06/12 00:00:00 +0300\n\ni.e. wrong date and wrong offset.\n", "url": "https://github.com/JodaOrg/joda-time/issues/173", "user": "lordbuddha", "labels": ["Bug", "Fixed"], "created": "2014-09-10 21:57:22", "closed": "2014-10-02 22:28:28", "commits": {"404b6e6bf5050db51c5827f856cca2953b7294a4": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 22.00027777777778, "commitsDetails": [{"commitHash": "404b6e6bf5050db51c5827f856cca2953b7294a4", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["504acaef364e4626161b372744441bb44866abd4"], "nameRev": "404b6e6bf5050db51c5827f856cca2953b7294a4 tags/v2.5~4", "commitMessage": "Update following pull request\n\nFixes #173\nFixes #182\n", "commitDateTime": "2014-10-02 23:33:18", "authoredDateTime": "2014-10-02 23:32:55", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "pom.xml", "insertions": 4, "deletions": 0, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Deadlock in DateTimeZone/FixedDateTimeZone static initialization", "body": "We've got a [user reporting a deadlock](https://forums.aws.amazon.com/thread.jspa?messageID=566952#566952) while using the AWS SDK for Java. The user is calling into two different parts of the SDK from two different threads. One ends up accessing [DateTimeZone.UTC](https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/DateTimeZone.java#L94) while the other ends up directly creating a new [FixedDateTimeZone](https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/tz/FixedDateTimeZone.java).\n\nThread 1 grabs a lock on DateTimeZone to run its static initialization block. Thread 2 grabs a lock on FixedDateTimeZone to run its static initialization block. FixedDateTimeZone extends DateTimeZone, so the first thing Thread 2 does is try to grab a lock on DateTimeZone to see if it has been initialized yet. Meanwhile, Thread 1 attempts to grab a lock on FixedDateTimeZone to see if it has been initialized yet because the static initializer creates an instance of FixedDateTimeZone to assign to DateTimeZone.UTC. Boom, deadlock.\n\nMinimal repro code:\n\n``` java\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.tz.FixedDateTimeZone;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread one = new Thread() {\n            @Override\n            public void run() {\n                DateTimeZone zone = DateTimeZone.UTC;\n            }\n        };\n\n        Thread two = new Thread() {\n            @Override\n            public void run() {\n                new FixedDateTimeZone(\"GMT\", \"GMT\", 0, 0);\n            }\n        };\n\n        one.start();\n        two.start();\n    }\n}\n```\n\ndeadlocks pretty reliably for me with:\n\n```\n\"Thread-1\" prio=10 tid=0x0a01a800 nid=0xbfb in Object.wait() [0x6db8d000]\n   java.lang.Thread.State: RUNNABLE\n        at Test$2.run(Test.java:16)\n\n\"Thread-0\" prio=10 tid=0x0a019000 nid=0xbfa in Object.wait() [0x6dbde000]\n   java.lang.Thread.State: RUNNABLE\n        at org.joda.time.DateTimeZone.<clinit>(DateTimeZone.java:95)\n        at Test$1.run(Test.java:9)\n```\n\nIs this something that other people have run into? I can certainly work around it by adding no-op references to DateTimeZone before creating any FixedDateTimeZone instances, but that seems awfully fragile (and in particular doesn't protect against something else in my users' processes directly referencing FixedDateTimeZone and locking in the other direction). Any other recommendations? Unfortunately, there doesn't seem to be a straightforward way of fixing this in JodaTime without breaking DateTimeZone.UTC...\n", "url": "https://github.com/JodaOrg/joda-time/issues/171", "user": "david-at-aws", "labels": ["Bug", "Fixed"], "created": "2014-09-02 20:39:49", "closed": "2014-09-08 16:22:41", "commits": {"1ecf8abe9a0a044b1a4da9eed855c49aac73c7d7": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "1ecf8abe9a0a044b1a4da9eed855c49aac73c7d7", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["47c194065d46f3b84fc3642b5613e64b9403c78f"], "nameRev": "1ecf8abe9a0a044b1a4da9eed855c49aac73c7d7 tags/v2.5~8", "commitMessage": "Fix deadlock due to DateTimeZone.UTC\n\nReferencing DateTimeZone and FixedDateTimeZone from two\nthreads at startup could deadlock\nAdd package scoped UTCDateTimeZone class to avoid this\n\nDateTimeZone.UTC has changed implementation type\nIt used to be a FixedDateTimeZone\nNow it is a UTCDateTimeZone\nThis avoids a potential deadlock scenario\nSerialization is unaffected\nThis change will only be observable if you cast the\nUTC constant to FixedDateTimeZone\nFixes #171\n", "commitDateTime": "2014-09-08 17:22:32", "authoredDateTime": "2014-09-08 17:22:32", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 10, "deletions": 1, "lines": 11}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/org/joda/time/UTCDateTimeZone.java", "insertions": 83, "deletions": 0, "lines": 83}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "UTCDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.UTCDateTimeZone", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1ecf8abe9a0a044b1a4da9eed855c49aac73c7d7"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 84, "deletions": 1, "lines": 85, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeZone", "org.joda.time.UTCDateTimeZone"]}, {"title": "Period contructed with end at later offset during DST overlap results in wrong hour value", "body": "Using joda-time 2.3 the behaviour can be reproduced with following code that should create a period containing 15 minutes:\n\n``` java\nDateTimeZone zone = DateTimeZone.forID(\"Europe/Berlin\");\nDateTime start = new DateTime(2013, 10, 27, 2, 0, 0, zone).withLaterOffsetAtOverlap();\nDateTime end = new DateTime(2013, 10, 27, 2, 15, 0, zone).withLaterOffsetAtOverlap();\nPeriod period = new Period(start, end);\nSystem.out.println(period);\n```\n\nThis will print PT1H15M. Thus a period with 1 hour and 15 minutes is created.\n\nUsing\n\n``` java\nDateTime start = new DateTime(2013, 10, 27, 2, 0, 0, zone).withEarlierOffsetAtOverlap();\n```\n\nthe same period is created, which is correct for this start.\n", "url": "https://github.com/JodaOrg/joda-time/issues/156", "user": "MtTracer", "labels": ["Bug", "Fixed"], "created": "2014-07-22 15:36:09", "closed": "2014-07-26 20:13:49", "commits": {"a1b12631a26324acab5348e2b9d51773f382e657": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "a1b12631a26324acab5348e2b9d51773f382e657", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["70ee94062e12002575a2d1d398d315915b646221"], "nameRev": "a1b12631a26324acab5348e2b9d51773f382e657 tags/v2.4~4", "commitMessage": "Fix Period construction during DST overlap\n\nIf one end was within a DST overlap and the other end\nbeyond the overlap then the calculated period was incorrect\nFixes #156\n", "commitDateTime": "2014-07-26 21:13:36", "authoredDateTime": "2014-07-26 21:13:36", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/org/joda/time/chrono/BaseChronology.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/test/java/org/joda/time/TestPeriod_Constructors.java", "insertions": 33, "deletions": 0, "lines": 33}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BaseChronology.get(org.joda.time.ReadablePeriod,long,long)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestPeriod_Constructors.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPeriod_Constructors", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_RI_RI6()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_RI_RI7()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a1b12631a26324acab5348e2b9d51773f382e657"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 1, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BaseChronology.get(org.joda.time.ReadablePeriod,long,long)"]}, {"title": "PeriodFormatter mixes up suffixes during parsing", "body": "I'm using the PeriodFormatter like this:\n\n```\nprivate static final PeriodFormatter PERIOD_FORMATTER = new PeriodFormatterBuilder()\n        .appendWeeks().appendSuffix(\"W\").appendSeparator(\" \")\n        .appendDays().appendSuffix(\"D\").appendSeparator(\" \")\n        .appendHours().appendSuffix(\"h\").appendSeparator(\" \")\n        .appendMinutes().appendSuffix(\"m\").appendSeparator(\" \")\n        .appendSeconds().appendSuffix(\"s\").appendSeparator(\" \")\n        .appendMillis().appendSuffix(\"ms\")\n        .toFormatter();\n\n@Test\npublic void testMilliseconds() {\n    String nullMilliseconds = Period.millis(0).toString(PERIOD_FORMATTER);\n    Assert.assertEquals(\"0ms\", nullMilliseconds);\n    Period period = PERIOD_FORMATTER.parsePeriod(nullMilliseconds);\n    Assert.assertEquals(Period.millis(0), period);\n}\n```\n\nParsing fails with:\njava.lang.IllegalArgumentException: Invalid format: \"0ms\" is malformed at \"s\"\n    at org.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:326)\n    at org.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:304)\n", "url": "https://github.com/JodaOrg/joda-time/issues/154", "user": "deki", "labels": ["Bug", "Hard"], "created": "2014-06-25 09:21:31", "closed": "2014-09-08 15:48:56", "commits": {"7eb5f6043f21431cfc714200e53a738adceb6ecd": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "47c194065d46f3b84fc3642b5613e64b9403c78f": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 75.00027777777778, "commitsDetails": [{"commitHash": "7eb5f6043f21431cfc714200e53a738adceb6ecd", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["6dcf36d38137a1c71522879c7af84bf7b26bfbed"], "nameRev": "7eb5f6043f21431cfc714200e53a738adceb6ecd tags/v2.5~10", "commitMessage": "Handle suffixes/affixes that clash\n\nFor example, m for minutes and ms for milliseconds\nFixes #154, fixes #169\n", "commitDateTime": "2014-09-08 15:16:46", "authoredDateTime": "2014-09-08 15:16:46", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 16, "deletions": 14, "lines": 30}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java", "insertions": 2, "deletions": 3, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestPeriodFormatterBuilder.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}, {"commitHash": "47c194065d46f3b84fc3642b5613e64b9403c78f", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["7eb5f6043f21431cfc714200e53a738adceb6ecd"], "nameRev": "47c194065d46f3b84fc3642b5613e64b9403c78f tags/v2.5~9", "commitMessage": "Handle suffixes/affixes that clash\n\nFor example, m for minutes and ms for milliseconds\nImprove on patch by adjusting memory model issues\nFixes #154, fixes #169\n", "commitDateTime": "2014-09-08 16:49:14", "authoredDateTime": "2014-09-08 15:18:37", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java", "insertions": 26, "deletions": 32, "lines": 58}, {"filePath": "src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java", "insertions": 9, "deletions": 0, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 2}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix.finish(java.util.Set)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.FieldFormatter", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.finish(org.joda.time.format.PeriodFormatterBuilder$FieldFormatter[])", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 1}, {"spoonMethodName": "org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix.matchesOtherAffix(int,java.lang.String,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestPeriodFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestPeriodFormatterBuilder.testFormatPrefixSimple6IgnoringPrefix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "NPE in DateTimeZone.forTimeZone", "body": "I'm getting a NPE when instantiating DateTime object with a java.sql.Timestamp value.  This is happening in our deployment servers but I'm not able to reproduce it locally with tests. Any thoughts?\n\njava.lang.NullPointerException\n        at org.joda.time.DateTimeZone.forTimeZone(DateTimeZone.java:314)\n        at org.joda.time.DateTimeZone.getDefault(DateTimeZone.java:149)\n        at org.joda.time.chrono.ISOChronology.getInstance(ISOChronology.java:86)\n        at org.joda.time.DateTimeUtils.getChronology(DateTimeUtils.java:253)\n        at org.joda.time.convert.AbstractConverter.getChronology(AbstractConverter.java:82)\n        at org.joda.time.base.BaseDateTime.<init>(BaseDateTime.java:170)\n        at org.joda.time.DateTime.<init>(DateTime.java:241)\n        at com.metromile.Jdbc.PostProcessorLogJdbc$PostProcessorLogMapper.mapRow(PostProcessorLogJdbc.java:82)\n", "url": "https://github.com/JodaOrg/joda-time/issues/133", "user": "prokilogrammer", "labels": ["Bug", "Fixed"], "created": "2014-03-03 20:32:57", "closed": "2014-03-20 16:00:53", "commits": {"1ba2af6d66813b45008db6bb9b0a039afdcf6774": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 16.00027777777778, "commitsDetails": [{"commitHash": "1ba2af6d66813b45008db6bb9b0a039afdcf6774", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["38794869c3f3efc568ee37f7ba02639337f755be"], "nameRev": "1ba2af6d66813b45008db6bb9b0a039afdcf6774 tags/v2.4~20", "commitMessage": "Handle weird TimeZone implementations with null ID\n\nCalling DateTimeZone.forTimeZone() would break if the ID was null\nFixes #133\n", "commitDateTime": "2014-03-20 16:00:42", "authoredDateTime": "2014-03-20 16:00:42", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 5, "deletions": 2, "lines": 7}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZone.java", "insertions": 37, "deletions": 1, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "TestDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZone.testConstructor().3", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZone.testFromTimeZoneInvalid()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1ba2af6d66813b45008db6bb9b0a039afdcf6774"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5, "deletions": 2, "lines": 7, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone)"]}, {"title": "Copy&Paste problem in TimeZoneOffset print methods", "body": "When reviewing my other diff, i noticed some odd lines in it. it turns out in TimeZoneOffset, there are \n\n```\n    public void printTo(\n            StringBuffer buf, long instant, Chronology chrono,\n            int displayOffset, DateTimeZone displayZone, Locale locale) {\n```\n\nand\n\n```\n    public void printTo(\n            Writer out, long instant, Chronology chrono,\n            int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n```\n\nwhile one method does\n\n```\n        if (displayOffset == 0 && iMinFields <= 1) {\n```\n\nthe other does\n\n```\n        if (displayOffset == 0 && iMinFields == 1) {\n```\n\nThis looks like an inconsistency / oversight / c&p problem to me.\n\nAs I cannot judge which of them is correct, I cannot fix it myself and send a PR.\n", "url": "https://github.com/JodaOrg/joda-time/issues/122", "user": "CodingFabian", "labels": ["Bug", "Fixed"], "created": "2014-02-12 19:05:05", "closed": "2014-02-13 12:30:54", "commits": {"1929527baf0463a29ec594a2095079421caa54ef": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "f36072e1168bf0ad648678402a7a8366d1d420fc": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "1929527baf0463a29ec594a2095079421caa54ef", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["c3ef36272bddbb08854a4a5939a611668ea68450"], "nameRev": "1929527baf0463a29ec594a2095079421caa54ef tags/v2.4~30", "commitMessage": "Ensure time-zone offset print methods have same code\n\nTesting revealed no difference in behaviour\nFixes #122\n", "commitDateTime": "2014-02-13 10:56:51", "authoredDateTime": "2014-02-13 10:56:51", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java", "insertions": 90, "deletions": 0, "lines": 90}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.printTo(java.io.Writer,long,org.joda.time.Chronology,int,org.joda.time.DateTimeZone,java.util.Locale)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_parse()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min1max1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min1max2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min1max3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min2max2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min2max3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_print_min3max3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_invalidText()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_zeroMinInvalid()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatterBuilder.assertPrint(java.lang.String,org.joda.time.format.DateTimeFormatter,org.joda.time.DateTime)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "f36072e1168bf0ad648678402a7a8366d1d420fc", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["d0514b4c01ee19885a0579f2891dee057091a934"], "nameRev": "f36072e1168bf0ad648678402a7a8366d1d420fc tags/v2.4~28", "commitMessage": "Support Appendable throughout printing\n\nEnsure that Appendable can be used efficiently in printing\nFixes #120\nFixes #121\nFixes #122\n", "commitDateTime": "2014-02-13 12:25:08", "authoredDateTime": "2014-02-13 12:25:08", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormat.java", "insertions": 6, "deletions": 30, "lines": 36}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatter.java", "insertions": 53, "deletions": 57, "lines": 110}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java", "insertions": 36, "deletions": 497, "lines": 533}, {"filePath": "src/main/java/org/joda/time/format/DateTimePrinter.java", "insertions": 1, "deletions": 26, "lines": 27}, {"filePath": "src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java", "insertions": 89, "deletions": 0, "lines": 89}, {"filePath": "src/main/java/org/joda/time/format/FormatUtils.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/org/joda/time/format/InternalPrinter.java", "insertions": 68, "deletions": 0, "lines": 68}, {"filePath": "src/main/java/org/joda/time/format/InternalPrinterDateTimePrinter.java", "insertions": 106, "deletions": 0, "lines": 106}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatStyle.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatter.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["1929527baf0463a29ec594a2095079421caa54ef"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 3, "lines": 6, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 3.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.printTo(java.io.Writer,long,org.joda.time.Chronology,int,org.joda.time.DateTimeZone,java.util.Locale)"]}, {"title": "DayOfMonth and DayOfYear don't return true for Feb 29 in leap year.", "body": "ld = new LocalDate(2008, 2, 29);\nld.year().isLeap();//true\nld.monthOfYear().isLeap();//true\nld.dayOfMonth().isLeap();//should be true, but is false\nld.dayOfYear().isLeap();//should be true, but is false\n", "url": "https://github.com/JodaOrg/joda-time/issues/110", "user": "bouncysteve", "labels": ["Bug", "Fixed"], "created": "2014-01-17 14:24:28", "closed": "2014-01-20 17:57:14", "commits": {"34c0780202dde5d65e346ffe9f02d890352a9c37": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "34c0780202dde5d65e346ffe9f02d890352a9c37", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["5a7bd39f3044bf1c1678d85744c12315e3441967"], "nameRev": "34c0780202dde5d65e346ffe9f02d890352a9c37 tags/v2.4~34", "commitMessage": "Ensure isLeap() returns correct result for day fields\n\nday-of-month and day-of-year should report leap days\nFixes #110\n", "commitDateTime": "2014-01-20 17:56:30", "authoredDateTime": "2014-01-20 17:55:53", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/chrono/BasicChronology.java", "insertions": 11, "deletions": 1, "lines": 12}, {"filePath": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/main/java/org/joda/time/chrono/BasicGJChronology.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/main/java/org/joda/time/chrono/CopticChronology.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "src/main/java/org/joda/time/chrono/EthiopicChronology.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "src/test/java/org/joda/time/chrono/TestCopticChronology.java", "insertions": 20, "deletions": 2, "lines": 22}, {"filePath": "src/test/java/org/joda/time/chrono/TestEthiopicChronology.java", "insertions": 19, "deletions": 1, "lines": 20}, {"filePath": "src/test/java/org/joda/time/chrono/TestGJChronology.java", "insertions": 20, "deletions": 1, "lines": 21}, {"filePath": "src/test/java/org/joda/time/chrono/TestGregorianChronology.java", "insertions": 20, "deletions": 1, "lines": 21}, {"filePath": "src/test/java/org/joda/time/chrono/TestISOChronology.java", "insertions": 20, "deletions": 1, "lines": 21}, {"filePath": "src/test/java/org/joda/time/chrono/TestJulianChronology.java", "insertions": 21, "deletions": 1, "lines": 22}, {"filePath": "src/test/java/org/joda/time/chrono/gj/TestGJDayOfMonthField.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/org/joda/time/chrono/gj/TestGJDayOfYearField.java", "insertions": 6, "deletions": 1, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BasicChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicChronology.isLeapDay(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BasicDayOfMonthDateTimeField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.isLeap(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BasicDayOfYearDateTimeField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicDayOfYearDateTimeField.isLeap(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BasicGJChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BasicGJChronology.isLeapDay(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CopticChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.CopticChronology.isLeapDay(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EthiopicChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.EthiopicChronology.isLeapDay(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestCopticChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestCopticChronology.testLeap_5_13()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestCopticChronology.testLeap_6_13()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestEthiopicChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestEthiopicChronology.testLeap_5_13()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestEthiopicChronology.testLeap_6_13()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestGJChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestGJChronology.testLeap_28feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestGJChronology.testLeap_29feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestGregorianChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestGregorianChronology.testLeap_28feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestGregorianChronology.testLeap_29feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestISOChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestISOChronology.testLeap_28feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestISOChronology.testLeap_29feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestJulianChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestJulianChronology.testLeap_28feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.chrono.TestJulianChronology.testLeap_29feb()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestGJDayOfMonthField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.gj.TestGJDayOfMonthField.isLeap(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestGJDayOfYearField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.gj.TestGJDayOfYearField.isLeap(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["34c0780202dde5d65e346ffe9f02d890352a9c37"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 43, "deletions": 6, "lines": 49, "gitFilesChange": 6}, "spoonStatsSummary": {"TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0, "spoonFilesChanged": 6, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BasicDayOfMonthDateTimeField.isLeap(long)", "org.joda.time.chrono.BasicChronology.isLeapDay(long)", "org.joda.time.chrono.EthiopicChronology.isLeapDay(long)", "org.joda.time.chrono.BasicDayOfYearDateTimeField.isLeap(long)", "org.joda.time.chrono.CopticChronology.isLeapDay(long)", "org.joda.time.chrono.BasicGJChronology.isLeapDay(long)"]}, {"title": "Datetime fails to parse its own output when epoch = Long.MAX_VALUE", "body": "In Joda time 2.2\n\nFollowing code:\n\n<pre>\nDateTime.parse(new DateTime(Long.MAX_VALUE).toString());\n</pre>\n\n\nthrows this exception:\n\n<pre>\nCaused by: org.joda.time.IllegalFieldValueException: Cannot parse \"292278994-08-17T07:12:55.807Z\": Value 292278994 for year must be in the range [-292275054,292278993]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:218)\n    at org.joda.time.chrono.BasicYearDateTimeField.set(BasicYearDateTimeField.java:82)\n    at org.joda.time.format.DateTimeParserBucket$SavedField.set(DateTimeParserBucket.java:483)\n    at org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:366)\n    at org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:854)\n    at org.joda.time.DateTime.parse(DateTime.java:144)\n    at org.joda.time.DateTime.parse(DateTime.java:133)\n</pre>\n", "url": "https://github.com/JodaOrg/joda-time/issues/100", "user": "martin-a", "labels": ["Bug", "Fixed"], "created": "2013-12-16 08:46:43", "closed": "2014-01-19 15:06:41", "commits": {"e46064ee90fca28a92c0f51f10c94b40bc8af2d2": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 34.000277777777775, "commitsDetails": [{"commitHash": "e46064ee90fca28a92c0f51f10c94b40bc8af2d2", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["bd8522f7976a256ffe0f85203fb1e6fe60c22b6b"], "nameRev": "e46064ee90fca28a92c0f51f10c94b40bc8af2d2 tags/v2.4~37", "commitMessage": "DateTime/MutableDateTime constructors taking millis now validate\n\nPreviously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected\nThis ensures that the maximum/minimum year are respected\nFixes #100\n", "commitDateTime": "2014-01-19 15:06:37", "authoredDateTime": "2014-01-19 15:06:37", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/base/BaseDateTime.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Constructors.java", "insertions": 30, "deletions": 0, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseDateTime.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.base.BaseDateTime", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTime_Constructors.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTime_Constructors.testConstructor_long_max()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTime_Constructors.testConstructor_long_min()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e46064ee90fca28a92c0f51f10c94b40bc8af2d2"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 0, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/base"], "changesInPackagesSPOON": ["org.joda.time.base.BaseDateTime"]}, {"title": "Partials with equal fields aren't equal", "body": "Now that Partial can contain all of the different year\\* date-time field types at the same time, the following happens:\n\n``` java\nPartial a = new Partial(new DateTimeFieldType[] { yearOfCentury(), weekyear() }, new int [] { 0, 0 });\n// #<Partial [yearOfCentury=0, weekyear=0]>\nPartial b = new Partial(new DateTimeFieldType[] { weekyear(), yearOfCentury() }, new int [] { 0, 0 });\n// #<Partial [weekyear=0, yearOfCentury=0]>\nassert a.equals(b)\n// AssertionFailed...\n```\n\nProbably should not allow to construct one of those (types array must be in order largest-smallest...).\n", "url": "https://github.com/JodaOrg/joda-time/issues/96", "user": "dm3", "labels": ["Bug", "Fixed"], "created": "2013-12-05 11:31:01", "closed": "2014-05-06 22:28:10", "commits": {"ec4c7b5fe0d7e52ccd43090bf2f8eb651f74b5db": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 152.00027777777777, "commitsDetails": [{"commitHash": "ec4c7b5fe0d7e52ccd43090bf2f8eb651f74b5db", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["6f157ae0dd7d524cf8eeae2a5da0f62080b686a0"], "nameRev": "ec4c7b5fe0d7e52ccd43090bf2f8eb651f74b5db tags/v2.4~13", "commitMessage": "Avoid creating Partials with order weekyear-year\n\nDefine year as greater than weekyear\nFixes #96\nFixes #98\n", "commitDateTime": "2014-05-06 23:27:57", "authoredDateTime": "2014-05-06 23:26:40", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/Partial.java", "insertions": 32, "deletions": 18, "lines": 50}, {"filePath": "src/test/java/org/joda/time/TestPartial_Constructors.java", "insertions": 43, "deletions": 3, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Partial.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Partial", "TOT": 20, "UPD": 1, "INS": 9, "MOV": 7, "DEL": 3}]}, {"spoonFilePath": "TestPartial_Constructors.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPartial_Constructors.testConstructorEx7_TypeArray_intArray()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPartial_Constructors.testConstructorEx8_TypeArray_intArray()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPartial_Constructors.testConstructor_TypeArray_intArray_year_weekyear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPartial_Constructors.testConstructorEx9_TypeArray_intArray()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Partial.with fails with NPE", "body": "Re: #93 \n\nStill fails with (although the reverse is now ok):\n\n``` java\nnew Partial(weekyear(), 1).with(yearOfCentury(), 1);\nnew Partial(year(), 1).with(yearOfCentury(), 1);\nnew Partial(year(), 1).with(yearOfEra(), 1);\nnew Partial(year(), 1).with(weekyearOfCentury(), 1);\n//NullPointerException   org.joda.time.Partial.with (Partial.java:462)\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/95", "user": "dm3", "labels": ["Bug", "Fixed"], "created": "2013-12-03 18:10:18", "closed": "2013-12-04 14:11:49", "commits": {"4058d725e2b886e429233aa02bc45c3acf374471": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "4058d725e2b886e429233aa02bc45c3acf374471", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["9a62b06be5d0df8e833ff8583398cca386608cac"], "nameRev": "4058d725e2b886e429233aa02bc45c3acf374471 tags/v2.4~41", "commitMessage": "Avoid another NPE in Partial.with\n\nFixes #95\n", "commitDateTime": "2013-12-04 14:11:39", "authoredDateTime": "2013-12-04 14:11:39", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/org/joda/time/Partial.java", "insertions": 3, "deletions": 0, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Partial.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["4058d725e2b886e429233aa02bc45c3acf374471"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 0, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)"]}, {"title": "Partial.with fails with NPE", "body": "With the latest master:\n\n``` java\nnew Partial(yearOfCentury(),  1).with(weekyear(), 1);\n// NullPointerException\n// org.joda.time.Partial.with (Partial.java:447)\n```\n\nFails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.\n", "url": "https://github.com/JodaOrg/joda-time/issues/93", "user": "dm3", "labels": ["Bug", "Fixed"], "created": "2013-12-01 09:33:58", "closed": "2013-12-02 19:14:54", "commits": {"8612f9e5b88c1bea933ef9ab1e431f5db3006b48": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "9a62b06be5d0df8e833ff8583398cca386608cac": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "8612f9e5b88c1bea933ef9ab1e431f5db3006b48", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["8d109fe1a999a11b4557536dd96f9210460a5936"], "nameRev": "8612f9e5b88c1bea933ef9ab1e431f5db3006b48 tags/v2.4~43", "commitMessage": "Fix NPE in Partial.with()\n\nAlso ensure unsupported duration fields are compared properly\nFixes #93\n", "commitDateTime": "2013-12-02 19:14:41", "authoredDateTime": "2013-12-02 19:14:41", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/org/joda/time/Partial.java", "insertions": 8, "deletions": 3, "lines": 11}, {"filePath": "src/main/java/org/joda/time/field/UnsupportedDurationField.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/test/java/org/joda/time/TestPartial_Basics.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Partial.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Partial", "TOT": 10, "UPD": 0, "INS": 2, "MOV": 5, "DEL": 3}, {"spoonMethodName": "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "UnsupportedDurationField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.field.UnsupportedDurationField.compareTo(org.joda.time.DurationField)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestPartial_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPartial_Basics.testWith_baseHasNoRange()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPartial_Basics.testWith_argHasNoRange()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPartial_Basics.testWith_baseAndArgHaveNoRange()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "9a62b06be5d0df8e833ff8583398cca386608cac", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["8612f9e5b88c1bea933ef9ab1e431f5db3006b48"], "nameRev": "9a62b06be5d0df8e833ff8583398cca386608cac tags/v2.4~42", "commitMessage": "Fix NPE in Partial.with()\n\nAlso ensure unsupported duration fields are compared properly\nFixes #93\n", "commitDateTime": "2013-12-02 21:11:47", "authoredDateTime": "2013-12-02 21:11:47", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/Partial.java", "insertions": 10, "deletions": 1, "lines": 11}, {"filePath": "src/main/java/org/joda/time/field/UnsupportedDurationField.java", "insertions": 0, "deletions": 3, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Partial.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Partial", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "UnsupportedDurationField.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.field.UnsupportedDurationField.compareTo(org.joda.time.DurationField)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["8612f9e5b88c1bea933ef9ab1e431f5db3006b48"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 11, "deletions": 3, "lines": 14, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 12, "UPD": 0, "INS": 4, "MOV": 5, "DEL": 3, "spoonFilesChanged": 2, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time", "src/main/java/org/joda/time/field"], "changesInPackagesSPOON": ["org.joda.time.Partial", "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)", "org.joda.time.field.UnsupportedDurationField.compareTo(org.joda.time.DurationField)"]}, {"title": "DurationField is incorrect in complex DateTimeField instances", "body": "Each `DateTimeField` has a duration field and a range field. Previously some of the complex cases were wrong, notably around centuries and eras.   For example, `yearOfEra()` returned a range of null when it should be `eras()`. This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField().\n", "url": "https://github.com/JodaOrg/joda-time/issues/92", "user": "jodastephen", "labels": ["Bug", "Fixed"], "created": "2013-11-27 11:27:49", "closed": "2013-11-27 12:50:47", "commits": {"81a818471a9ef5f0e884ae2d319668eff5002738": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "81a818471a9ef5f0e884ae2d319668eff5002738", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["a61b3ff22820c70d36958ac9090f241f99a0dd0b"], "nameRev": "81a818471a9ef5f0e884ae2d319668eff5002738 tags/v2.4~47", "commitMessage": "DurationField is incorrect in complex DateTimeField instances\n\nFixes #92\n", "commitDateTime": "2013-11-27 12:36:05", "authoredDateTime": "2013-11-27 12:21:54", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 10, "deletions": 1, "lines": 11}, {"filePath": "src/main/java/org/joda/time/chrono/BasicChronology.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "src/main/java/org/joda/time/chrono/BuddhistChronology.java", "insertions": 9, "deletions": 3, "lines": 12}, {"filePath": "src/main/java/org/joda/time/chrono/GJChronology.java", "insertions": 51, "deletions": 25, "lines": 76}, {"filePath": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/chrono/ISOChronology.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/chrono/ZonedChronology.java", "insertions": 36, "deletions": 0, "lines": 36}, {"filePath": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java", "insertions": 20, "deletions": 3, "lines": 23}, {"filePath": "src/main/java/org/joda/time/field/DividedDateTimeField.java", "insertions": 37, "deletions": 9, "lines": 46}, {"filePath": "src/main/java/org/joda/time/field/RemainderDateTimeField.java", "insertions": 40, "deletions": 0, "lines": 40}, {"filePath": "src/test/java/org/joda/time/TestDateMidnight_Properties.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/org/joda/time/TestDateTime_Properties.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/org/joda/time/TestMutableDateTime_Properties.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/org/joda/time/chrono/TestBuddhistChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestCopticChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestEthiopicChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestGJChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestGregorianChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestISOChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestIslamicChronology.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "src/test/java/org/joda/time/chrono/TestJulianChronology.java", "insertions": 26, "deletions": 0, "lines": 26}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": ["81a818471a9ef5f0e884ae2d319668eff5002738"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 210, "deletions": 46, "lines": 256, "gitFilesChange": 10}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/field", "src/main/java/org/joda/time/chrono"]}, {"title": "DateTimeUtils.isContiguous() NPE with eras", "body": "It seems that DateTimeFields which return `null` on `getField(idx).getRangeDurationType()` do not play well with `DateTimeUtils.isContiguous`:\n\n``` java\nDateTimeUtils.isContiguous(new Partial(new DateTimeFieldType[] { era(), centuryOfEra()}, new int[] { 1, 1}));\nDateTimeUtils.isContiguous(new Partial(new DateTimeFieldType[] { centuryOfEra(), weekyear()}, new int[] { 1, 1}));\n\n// java.lang.NullPointerException\n//  at org.joda.time.DateTimeUtils.isContiguous(DateTimeUtils.java:371)\n```\n\nHowever, I couldn't reproduce this with DateTimeFieldTypes other than **era** and **centuryOfEra**. Maybe I didn't try hard enough, though.\n", "url": "https://github.com/JodaOrg/joda-time/issues/89", "user": "dm3", "labels": ["Bug", "Fixed"], "created": "2013-11-26 07:31:25", "closed": "2013-11-27 12:50:47", "commits": {"bcb044669b4d1f8d334861ccbd169924d6ef3b54": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "bcb044669b4d1f8d334861ccbd169924d6ef3b54", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["81a818471a9ef5f0e884ae2d319668eff5002738"], "nameRev": "bcb044669b4d1f8d334861ccbd169924d6ef3b54 tags/v2.4~46", "commitMessage": "Fix NPE in DateTimeUtils.isContiguous with weird partials [#89]\n\nFixes #89\n", "commitDateTime": "2013-11-27 12:36:17", "authoredDateTime": "2013-11-27 12:22:25", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/DateTimeUtils.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeUtils.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeUtils.isContiguous(org.joda.time.ReadablePartial)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["bcb044669b4d1f8d334861ccbd169924d6ef3b54"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeUtils.isContiguous(org.joda.time.ReadablePartial)"]}, {"title": "Constructing invalid Partials", "body": "Partials can be constructed by invoking a constructor `Partial(DateTimeFieldType[], int[])` or by merging together a set of partials using `with`, each constructed by calling `Partial(DateTimeFieldType, int)`, e.g.:\n\n``` java\nPartial a = new Partial(new DateTimeFieldType[] { year(), hourOfDay() }, new int[] { 1, 1});\nPartial b = new Partial(year(), 1).with(hourOfDay(), 1);\nassert(a == b);\n```\n\nHowever, the above doesn't work in all cases:\n\n``` java\nnew Partial(new DateTimeFieldType[] { clockhourOfDay(), hourOfDay() }, new int[] { 1, 1}); // throws Types array must not contain duplicate\nnew Partial(clockhourOfDay(), 1).with(hourOfDay(), 1); // #<Partial [clockhourOfDay=1, hourOfDay=1]>\n```\n\nI suppose the Partials should not allow to be constructed in either case. Is that right?\n\nThere's also a related issue (probably stems from the fact that the Partial is invalid):\n\n``` java\nnew Partial(clockhourOfDay(), 1).with(hourOfDay(), 1).isEqual(new Partial(hourOfDay() ,1).with(clockhourOfDay(), 1)) // throws objects must have matching field types\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/88", "user": "dm3", "labels": ["Bug", "Fixed"], "created": "2013-11-25 19:15:46", "closed": "2013-11-27 12:50:47", "commits": {"3ba9ba799b3261b7332a467a88be142c83b298fd": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "3ba9ba799b3261b7332a467a88be142c83b298fd", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["bcb044669b4d1f8d334861ccbd169924d6ef3b54"], "nameRev": "3ba9ba799b3261b7332a467a88be142c83b298fd tags/v2.4~45", "commitMessage": "Prevent creation of invalid partials via Partial.with(DateTimeFieldType,int)\n\nValidation in this method was not as thorough as that in the constructor\nThis allowed invalid partials to be created\nFixes #88\n", "commitDateTime": "2013-11-27 12:36:35", "authoredDateTime": "2013-11-27 12:23:24", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/Partial.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "src/test/java/org/joda/time/TestPartial_Basics.java", "insertions": 9, "deletions": 0, "lines": 9}, {"filePath": "src/test/java/org/joda/time/TestPartial_Constructors.java", "insertions": 9, "deletions": 0, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Partial.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestPartial_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPartial_Basics.testWith3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestPartial_Constructors.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPartial_Constructors.testConstructorEx8_TypeArray_intArray()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3ba9ba799b3261b7332a467a88be142c83b298fd"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 3, "lines": 7, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.Partial.with(org.joda.time.DateTimeFieldType,int)"]}, {"title": "Dates with formats starting with a leading '+' sign before the year part are getting parsed improperly", "body": "I stumbled upon an issue where dates with leading '+' signs in front of year part were getting parsed improperly. I have described the issue in stackoverflow (http://stackoverflow.com/q/19910018/373151). I'll paste the code again here:\n\n```\nSystem.out.println(DateTimeFormat.forPattern(\"yyyyMMdd\").parseDateTime(\"20130101\"));\n// 2013-01-01T00:00:00.000+05:30 (Expected) (case 1)\n\nSystem.out.println(DateTimeFormat.forPattern(\"yyyyMMdd\").parseDateTime(\"+20130101\"));\n// 20130-10-01T00:00:00.000+05:30 (??? Notice that month changed to 10 also) (case 2)\n\nSystem.out.println(DateTimeFormat.forPattern(\"MMyyyydd\").parseDateTime(\"01+201301\"));\n// 20130-01-01T00:00:00.000+05:30 (??? At least month is fine this time) (case 3)\n\nSystem.out.println(DateTimeFormat.forPattern(\"MM-yyyy-dd\").parseDateTime(\"01-+2013-01\"));\n// 2013-01-01T00:00:00.000+05:30 (I expected an error, but this parsed correctly) (case 4)\n```\n\nThe year is getting parsed as 20130 instead of 2013 in cases 2 and 3.\n", "url": "https://github.com/JodaOrg/joda-time/issues/86", "user": "hshankar", "labels": ["Bug", "Fixed"], "created": "2013-11-13 12:53:13", "closed": "2015-10-24 08:27:22", "commits": {"0a201881f01bce85efece778345ebd60cf58ba35": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 709.0002777777778, "commitsDetails": [{"commitHash": "0a201881f01bce85efece778345ebd60cf58ba35", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["4289f5e53527bd20e241d5e92fe55ef0ef20576b"], "nameRev": "0a201881f01bce85efece778345ebd60cf58ba35 tags/v2.9~1", "commitMessage": "Fix basic parsing where additional plus sign\n\nBased on code by Hari Shankar - https://github.com/hshankar\nFixes #86\n", "commitDateTime": "2015-10-24 09:19:15", "authoredDateTime": "2015-10-24 09:17:58", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java", "insertions": 11, "deletions": 10, "lines": 21}, {"filePath": "src/test/java/org/joda/time/format/TestISODateTimeFormatParsing.java", "insertions": 22, "deletions": 0, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFormatterBuilder.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket,java.lang.CharSequence,int)", "TOT": 10, "UPD": 0, "INS": 5, "MOV": 3, "DEL": 2}]}, {"spoonFilePath": "TestISODateTimeFormatParsing.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_dateParser()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_localDateParser()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_dateElementParser()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_date()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_dateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_dateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_ordinalDate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_ordinalDateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_ordinalDateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_weekDate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_weekDateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_weekDateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicDate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicDateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicDateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicOrdinalDate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicOrdinalDateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicOrdinalDateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicWeekDate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicWeekDateTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestISODateTimeFormatParsing.test_basicWeekDateTimeNoMillis()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0a201881f01bce85efece778345ebd60cf58ba35"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 11, "deletions": 10, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 10, "UPD": 0, "INS": 5, "MOV": 3, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket,java.lang.CharSequence,int)"]}, {"title": "Need to correct tz database update URL", "body": "The Readme.txt under tz/src and maybe other web pages indicate the tz database was grabbed from twinsun:\n\nThe data files in this directory were obtained from the public tz database,\nhttp://www.twinsun.com/tz/tz-link.htm, version 2013d.\n\nThe link here is dead/broken.\n\nWhile other pages correctly point to the following address as the place to upgrade tz info, so we might have to update the link there as:\n\nhttp://www.iana.org/time-zones\n\n(At this time the latest is 2013h)\n", "url": "https://github.com/JodaOrg/joda-time/issues/83", "user": "kaiyuan01", "labels": ["Bug", "Fixed"], "created": "2013-10-27 17:16:55", "closed": "2013-11-01 11:59:08", "commits": {"f248cec4ac17197849357a55f286541241b84dd9": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "f248cec4ac17197849357a55f286541241b84dd9", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["ef64bcedb2101e0b1d093394cf4bb392742a27d6"], "nameRev": "f248cec4ac17197849357a55f286541241b84dd9 tags/v2.4~56", "commitMessage": "Fix IANA time zone database links\n\nFixes #83\n", "commitDateTime": "2013-11-01 11:58:04", "authoredDateTime": "2013-11-01 11:57:58", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/org/joda/time/tz/src/Readme.txt", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/site/xdoc/timezones.xml", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/site/xdoc/userguide.xml", "insertions": 3, "deletions": 4, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f248cec4ac17197849357a55f286541241b84dd9"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 3, "lines": 6, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"]}, {"title": "none standard PeriodType without year throws exception", "body": "Hi.\n\nI tried to get a Period only for months and weeks with following code:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()})).normalizedStandard(PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()}));\nreturn p.getMonths();\n```\n\nThis throws following exception:\n\n```\n 10-17 14:35:50.999: E/AndroidRuntime(1350): java.lang.UnsupportedOperationException: Field is not supported\n 10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.PeriodType.setIndexedField(PeriodType.java:690)\n 10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.withYears(Period.java:896) 10-17\n 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.normalizedStandard(Period.java:1630)\n```\n\nEven removing the year component with .withYearsRemoved() throws the same exception:\n\nthis works:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard()).normalizedStandard(PeriodType.standard());\nreturn p.getMonths();\n```\n\nthis fails:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard().withYearsRemoved()).normalizedStandard(PeriodType.standard().withYearsRemoved());\nreturn p.getMonths();\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/79", "user": "Moghedien", "labels": ["Bug", "Fixed"], "created": "2013-10-17 20:36:31", "closed": "2013-11-01 14:07:10", "commits": {"a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 14.000277777777777, "commitsDetails": [{"commitHash": "a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["a38b5e0c620a4a4dc310d35105e3e432c4e91fc3"], "nameRev": "a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815 tags/v2.4~54", "commitMessage": "Fix handling of PeriodType when either years or months missing\n\nFixes #79\n", "commitDateTime": "2013-11-01 14:06:59", "authoredDateTime": "2013-11-01 14:06:59", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/Period.java", "insertions": 14, "deletions": 7, "lines": 21}, {"filePath": "src/test/java/org/joda/time/TestPeriod_Basics.java", "insertions": 43, "deletions": 0, "lines": 43}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Period.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.Period.normalizedStandard(org.joda.time.PeriodType)", "TOT": 23, "UPD": 7, "INS": 8, "MOV": 5, "DEL": 3}]}, {"spoonFilePath": "TestPeriod_Basics.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_years()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_monthsWeeks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Basics.MockPeriod", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14, "deletions": 7, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 23, "UPD": 7, "INS": 8, "MOV": 5, "DEL": 3, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.Period.normalizedStandard(org.joda.time.PeriodType)"]}, {"title": "addDays(0) changes value of MutableDateTime", "body": "Upon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object.\n\nThe code\n\n``` java\nfinal MutableDateTime mdt = new MutableDateTime(2011, 10, 30, 3, 0, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\nSystem.out.println(\"Start date:   \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addHours(-1);\nSystem.out.println(\"addHours(-1): \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addHours(0);\nSystem.out.println(\"addHours(0):  \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addDays(0);\nSystem.out.println(\"addDays(0):   \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n```\n\nprints\n\n```\nStart date:   2011-10-30T03:00:00.000+01:00 (1319940000000)    //OK\naddHours(-1): 2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK\naddHours(0):  2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK, no change in time\naddDays(0):   2011-10-30T02:00:00.000+02:00 (1319932800000)    //error, time has changed by 1 hour\n```\n\nThe methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.\n\nI have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.\n", "url": "https://github.com/JodaOrg/joda-time/issues/77", "user": "berwer", "labels": ["Bug", "Fixed"], "created": "2013-10-16 15:36:22", "closed": "2013-11-27 12:50:47", "commits": {"8d109fe1a999a11b4557536dd96f9210460a5936": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 41.000277777777775, "commitsDetails": [{"commitHash": "8d109fe1a999a11b4557536dd96f9210460a5936", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["3ba9ba799b3261b7332a467a88be142c83b298fd"], "nameRev": "8d109fe1a999a11b4557536dd96f9210460a5936 tags/v2.4~44", "commitMessage": "Adding zero no longer changes the offset during DST overlap\n\nFixes #77\n", "commitDateTime": "2013-11-27 12:36:35", "authoredDateTime": "2013-11-27 12:35:00", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/MutableDateTime.java", "insertions": 31, "deletions": 12, "lines": 43}, {"filePath": "src/test/java/org/joda/time/TestMutableDateTime_Adds.java", "insertions": 136, "deletions": 2, "lines": 138}, {"filePath": "src/test/java/org/joda/time/TestMutableDateTime_Sets.java", "insertions": 46, "deletions": 1, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MutableDateTime.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.MutableDateTime.add(org.joda.time.DurationFieldType,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addYears(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addWeekyears(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addMonths(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addWeeks(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addDays(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addHours(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addMinutes(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addSeconds(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "org.joda.time.MutableDateTime.addMillis(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestMutableDateTime_Adds.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds", "TOT": 4, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAdd_DurationFieldType_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAdd_DurationFieldType_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddYears_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddYears_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMonths_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMonths_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddDays_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddDays_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddWeeks_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddWeeks_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddHours_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddHours_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMinutes_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMinutes_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddSeconds_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddSeconds_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMillis_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Adds.testAddMillis_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestMutableDateTime_Sets.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetMonthOfYear_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetMonthOfYear_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetDayOfMonth_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetDayOfMonth_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetDayOfYear_int_dstOverlapSummer_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMutableDateTime_Sets.testSetDayOfYear_int_dstOverlapWinter_addZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["8d109fe1a999a11b4557536dd96f9210460a5936"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 31, "deletions": 12, "lines": 43, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 20, "UPD": 0, "INS": 10, "MOV": 10, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.MutableDateTime.addDays(int)", "org.joda.time.MutableDateTime.addYears(int)", "org.joda.time.MutableDateTime.addWeekyears(int)", "org.joda.time.MutableDateTime.addWeeks(int)", "org.joda.time.MutableDateTime.add(org.joda.time.DurationFieldType,int)", "org.joda.time.MutableDateTime.addSeconds(int)", "org.joda.time.MutableDateTime.addMillis(int)", "org.joda.time.MutableDateTime.addMinutes(int)", "org.joda.time.MutableDateTime.addMonths(int)", "org.joda.time.MutableDateTime.addHours(int)"]}, {"title": "Unexpected behavior for DateTimeZone.isLocalDateTimeGap", "body": "The time zone is \"America/Rio_Branco\". I tried LocalDateTime 2:30am, 3:30am, 4:30am of June 24th, 2008, and all of them returned true, meaning the local time was set forward for 3 hours. But according to official record, there should be only 1-hour gap.\n", "url": "https://github.com/JodaOrg/joda-time/issues/76", "user": "EnochZ", "labels": ["Bug", "Fixed"], "created": "2013-10-10 22:00:39", "closed": "2014-07-26 22:33:35", "commits": {"b9a9b5737163f5b60643a37aa57893fc248c5439": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 289.0002777777778, "commitsDetails": [{"commitHash": "b9a9b5737163f5b60643a37aa57893fc248c5439", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["a1b12631a26324acab5348e2b9d51773f382e657"], "nameRev": "b9a9b5737163f5b60643a37aa57893fc248c5439 tags/v2.4~3", "commitMessage": "Fixed conversion from Local to UTC\n\nDateTimeZone.getOffsetFromLocal() method\nFixed to handle the last cutover in DST history correctly\nRewrite docs and tests\nFixes #76\n", "commitDateTime": "2014-07-26 23:33:10", "authoredDateTime": "2014-07-26 23:33:10", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 21, "deletions": 12, "lines": 33}, {"filePath": "src/main/java/org/joda/time/chrono/ZonedChronology.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "insertions": 126, "deletions": 92, "lines": 218}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone.getOffsetFromLocal(long)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "ZonedChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.ZonedChronology.localToUTC(long)", "TOT": 6, "UPD": 1, "INS": 3, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "TestDateTimeZoneCutover.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_RioBrancoIsCorrect_Spring()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_RioBranco_Spring()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal_Turk(int,int,int,java.lang.String,int)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,java.lang.String,int,org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,int,int,java.lang.String,int,org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,int,java.lang.String,int,org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,int,int,int,java.lang.String,int,org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Turk()", "TOT": 11, "UPD": 0, "INS": 11, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_NewYork_Spring()", "TOT": 11, "UPD": 0, "INS": 11, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_NewYork_Autumn()", "TOT": 13, "UPD": 0, "INS": 13, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Spring()", "TOT": 11, "UPD": 0, "INS": 11, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn()", "TOT": 16, "UPD": 0, "INS": 16, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Guatemata_Autumn()", "TOT": 18, "UPD": 0, "INS": 18, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn_overlap_mins()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,int,java.lang.String,org.joda.time.DateTimeZone)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,int,int,java.lang.String,org.joda.time.DateTimeZone)", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZoneCutover.doTest_getOffsetFromLocal(int,int,int,int,java.lang.String,org.joda.time.DateTimeZone)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 6, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b9a9b5737163f5b60643a37aa57893fc248c5439"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 25, "deletions": 15, "lines": 40, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 12, "UPD": 1, "INS": 7, "MOV": 2, "DEL": 2, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono", "src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.chrono.ZonedChronology.localToUTC(long)", "org.joda.time.DateTimeZone.getOffsetFromLocal(long)"]}, {"title": "Release notes are nowhere to be found / dead link", "body": "I wanted to browse the release notes for the latest releases, since I missed the last updates. I had a bad time finding the release notes in the first place, and then I found myself going through the commits of https://github.com/JodaOrg/joda-time/blob/master/RELEASE-NOTES.txt. I don't think this is intended.\n- The [main page](https://github.com/JodaOrg/joda-time) contains a [dead link](http://www.joda.org/joda-time/changes-report.html).\n- The [main website](http://www.joda.org/joda-time/) doesn't even bother to mention the release notes exist anywhere (how about the download page?).\n\nRegards,\nBenjamin\n", "url": "https://github.com/JodaOrg/joda-time/issues/66", "user": "BenjaminDebeerst", "labels": ["Bug", "Fixed"], "created": "2013-09-27 10:15:53", "closed": "2013-09-27 15:16:33", "commits": {"970139e65c754536b95a2b706f65ad3484ba68f5": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}, "229c7d01edb902fa093ea36ee5ca2f21409d9a95": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "970139e65c754536b95a2b706f65ad3484ba68f5", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["13d3ea10dea99f1e6bbac06e18da450fe1e9add2"], "nameRev": "970139e65c754536b95a2b706f65ad3484ba68f5 tags/v2.4~68", "commitMessage": "Fix README reference to change notes\n\nSee #66", "commitDateTime": "2013-09-27 08:15:20", "authoredDateTime": "2013-09-27 08:15:20", "commitGitStats": [{"filePath": "README.md", "insertions": 1, "deletions": 2, "lines": 3}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "229c7d01edb902fa093ea36ee5ca2f21409d9a95", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["970139e65c754536b95a2b706f65ad3484ba68f5"], "nameRev": "229c7d01edb902fa093ea36ee5ca2f21409d9a95 tags/v2.4~67", "commitMessage": "Enhance home page link to release notes\n\nFixes #66", "commitDateTime": "2013-09-27 08:16:32", "authoredDateTime": "2013-09-27 08:16:32", "commitGitStats": [{"filePath": "src/site/xdoc/index.xml", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["970139e65c754536b95a2b706f65ad3484ba68f5", "229c7d01edb902fa093ea36ee5ca2f21409d9a95"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "NullPointerException on DateTimeZone.getOffset() when using persistent object", "body": "Hello,\n\nI am using JodaTime v2.3 in combination with a DB4O object database. I have noticed that when retrieving DateTime objects from the database I get NullPointerExceptions when calling: dateTimeObj.getZone().getOffset(long)\n\nHere's a stacktrace:\nCaused by: java.lang.NullPointerException\n    at java.util.Arrays.binarySearch(Arrays.java:827)\n    at org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(DateTimeZoneBuilder.java:1574)\n    at org.joda.time.tz.CachedDateTimeZone.createInfo(CachedDateTimeZone.java:158)\n    at org.joda.time.tz.CachedDateTimeZone.getInfo(CachedDateTimeZone.java:145)\n    at org.joda.time.tz.CachedDateTimeZone.getOffset(CachedDateTimeZone.java:103)\n\nI believe this problem also affects JodaTime v2.2.\n\nBest,\n\nMatthias\n", "url": "https://github.com/JodaOrg/joda-time/issues/65", "user": "mstevens83", "labels": ["Bug", "NotABug"], "created": "2013-09-24 15:26:38", "closed": "2013-10-01 09:18:52", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "ISODateTimeFormat thread safety", "body": "(as per discussion on the joda-interest list)\n\nThe javadoc of ISODateTimeFormat class says it's thread-safe and immutable. The static fields are lazily initialized. However it seems it's not done in a thread-safe manner.\n\nFor example, dt is lazily initialized in\n    public static DateTimeFormatter dateTime() {\n        if (dt == null) {\n            dt = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(tTime())\n                .toFormatter();\n        }\n        return dt;\n    }\n\nWhen there are two threads both inside this method, is it possible that one thread sees an unsafely published non-null dt value due to cache incoherence?\n", "url": "https://github.com/JodaOrg/joda-time/issues/45", "user": "superwanglin", "labels": ["Bug", "Fixed"], "created": "2013-07-22 03:19:05", "closed": "2013-08-07 18:48:52", "commits": {"67778ce6f8a2d794ba876eaa95a3b5ddf720ac0b": {"commitGHEventType": "closed", "commitUser": "jodastephen"}, "91b1ba4ed42ca0b345370ea3cc0ddcdb33781c6d": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 16.00027777777778, "commitsDetails": [{"commitHash": "67778ce6f8a2d794ba876eaa95a3b5ddf720ac0b", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["c384c385083468f2fcb7bd30f56a7952e31eaf9d"], "nameRev": "67778ce6f8a2d794ba876eaa95a3b5ddf720ac0b tags/v2.3~10", "commitMessage": "Better thread-safety in ISODateTimeFormat\n\nFixes #45\n", "commitDateTime": "2013-08-07 19:48:48", "authoredDateTime": "2013-08-07 19:48:48", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/ISODateTimeFormat.java", "insertions": 799, "deletions": 608, "lines": 1407}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "91b1ba4ed42ca0b345370ea3cc0ddcdb33781c6d", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["67778ce6f8a2d794ba876eaa95a3b5ddf720ac0b"], "nameRev": "91b1ba4ed42ca0b345370ea3cc0ddcdb33781c6d tags/v2.3~9", "commitMessage": "Better thread-safety in ISODateTimeFormat\n\nFixes #45\n", "commitDateTime": "2013-08-07 20:25:49", "authoredDateTime": "2013-08-07 20:25:49", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["67778ce6f8a2d794ba876eaa95a3b5ddf720ac0b"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 799, "deletions": 608, "lines": 1407, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"]}, {"title": "Fix chronology cache synchronization", "body": "Fix cache synchronization in BuddhistChronology and GJChronology.\n", "url": "https://github.com/JodaOrg/joda-time/issues/44", "user": "jodastephen", "labels": ["Bug", "Fixed"], "created": "2013-07-20 11:58:30", "closed": "2013-07-20 11:59:15", "commits": {"0f274a6e0450cfd23bae02f80d283dd0e66432a2": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0f274a6e0450cfd23bae02f80d283dd0e66432a2", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["fe915d2cb3cfac7d8f2d2f95970d41a65012e055"], "nameRev": "0f274a6e0450cfd23bae02f80d283dd0e66432a2 tags/v2.3~19", "commitMessage": "Fix chronology cache synchronization\n\nFixes #44\n", "commitDateTime": "2013-07-20 12:59:10", "authoredDateTime": "2013-07-20 12:59:10", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/chrono/BuddhistChronology.java", "insertions": 11, "deletions": 8, "lines": 19}, {"filePath": "src/main/java/org/joda/time/chrono/GJChronology.java", "insertions": 27, "deletions": 29, "lines": 56}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BuddhistChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "GJChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone,org.joda.time.ReadableInstant,int)", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0f274a6e0450cfd23bae02f80d283dd0e66432a2"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 38, "deletions": 37, "lines": 75, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 8, "UPD": 0, "INS": 2, "MOV": 6, "DEL": 0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)", "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone,org.joda.time.ReadableInstant,int)"]}, {"title": "Ensure there is a max/min valid offset", "body": "`DateTimeZone` does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.\n", "url": "https://github.com/JodaOrg/joda-time/issues/43", "user": "jodastephen", "labels": ["Bug", "Fixed"], "created": "2013-07-20 09:23:26", "closed": "2013-07-20 11:08:53", "commits": {"96f586cb8dac7eee62e9be519a3eab125c47bb23": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "96f586cb8dac7eee62e9be519a3eab125c47bb23", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["08a3a0b969b1e5d1d06489a698fe9c9b69e2f2d9"], "nameRev": "96f586cb8dac7eee62e9be519a3eab125c47bb23 tags/v2.3~26", "commitMessage": "Ensure there is a max/min valid offset in DateTimeZone\n\nFixes #43\n", "commitDateTime": "2013-07-20 11:49:21", "authoredDateTime": "2013-07-20 11:42:56", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 14, "deletions": 7, "lines": 21}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZone.java", "insertions": 10, "deletions": 3, "lines": 13}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone.forOffsetHoursMinutes(int,int)", "TOT": 7, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 3}, {"spoonMethodName": "org.joda.time.DateTimeZone", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.DateTimeZone.forOffsetMillis(int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int()", "TOT": 4, "UPD": 1, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDateTimeZone.testForOffsetMillis_int()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["96f586cb8dac7eee62e9be519a3eab125c47bb23"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14, "deletions": 7, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 9, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 3, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeZone.forOffsetHoursMinutes(int,int)", "org.joda.time.DateTimeZone", "org.joda.time.DateTimeZone.forOffsetMillis(int)"]}, {"title": "DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour", "body": "`DateTimeZone.forOffsetHoursMinutes(h,m)` cannot handle negative offset < 1 hour like `-0:30` due to argument range checking. I used `forOffsetMillis()` instead.\n\nThis should probably be mentioned in the documentation or negative minutes be accepted.\n", "url": "https://github.com/JodaOrg/joda-time/issues/42", "user": "eregon", "labels": ["Bug", "Fixed"], "created": "2013-07-18 16:12:52", "closed": "2013-07-20 11:08:53", "commits": {"362ed1787724cda3ded37de2b0aa0f13adf0a66e": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "362ed1787724cda3ded37de2b0aa0f13adf0a66e", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["96f586cb8dac7eee62e9be519a3eab125c47bb23"], "nameRev": "362ed1787724cda3ded37de2b0aa0f13adf0a66e tags/v2.3~25", "commitMessage": "Fix to allow offsets from -00:01 to -00:59\n\nFixes #42\n", "commitDateTime": "2013-07-20 11:49:21", "authoredDateTime": "2013-07-20 11:42:56", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/main/java/org/joda/time/DateTimeZone.java", "insertions": 27, "deletions": 6, "lines": 33}, {"filePath": "src/test/java/org/joda/time/TestDateTimeZone.java", "insertions": 15, "deletions": 10, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.DateTimeZone.forOffsetHoursMinutes(int,int)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "TestDateTimeZone.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int()", "TOT": 21, "UPD": 7, "INS": 6, "MOV": 7, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["362ed1787724cda3ded37de2b0aa0f13adf0a66e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 27, "deletions": 6, "lines": 33, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": ["org.joda.time.DateTimeZone.forOffsetHoursMinutes(int,int)"]}, {"title": "Questionable behaviour of GJChronology when dates pass 1BC", "body": "I expect the following test to pass:\n\n```\nChronology chronology = GJChronology.getInstance();\n\nLocalDate start = new LocalDate(2013, 5, 31, chronology);\nLocalDate expectedEnd = new LocalDate(-1, 5, 31, chronology); // 1 BC\nassertThat(start.minusYears(2013), is(equalTo(expectedEnd)));\nassertThat(start.plus(Period.years(-2013)), is(equalTo(expectedEnd)));\n```\n\nThe error it gives is:\n\n```\norg.joda.time.IllegalFieldValueException: Value 0 for year is not supported\n```\n\nHowever, I never provided \"0\" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?\n", "url": "https://github.com/JodaOrg/joda-time/issues/28", "user": "trejkaz", "labels": ["Bug", "Fixed"], "created": "2013-05-31 00:52:24", "closed": "2013-08-16 13:42:26", "commits": {"28aeba952e838fb12c9b934ce6ef65658e45d7b2": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 77.00027777777778, "commitsDetails": [{"commitHash": "28aeba952e838fb12c9b934ce6ef65658e45d7b2", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["91b1ba4ed42ca0b345370ea3cc0ddcdb33781c6d"], "nameRev": "28aeba952e838fb12c9b934ce6ef65658e45d7b2 tags/v2.3~8", "commitMessage": "Fix GJChronology.plus/minus across cutover and year zero\n\nFixes #28\nWhen subtracting a number of years from a date in the GJChronology there are two considerations\nThe cutover date might be crossed, and year zero might be crossed (there is no year zero in GJ)\nPreviously, each were handled separately, but not together. Now it is fixed\nAs part of this change, the minimum cutover instant was set to 0001-01-01 (Gregorian)\n", "commitDateTime": "2013-08-16 14:41:18", "authoredDateTime": "2013-08-16 14:41:18", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/main/java/org/joda/time/chrono/GJChronology.java", "insertions": 29, "deletions": 0, "lines": 29}, {"filePath": "src/test/java/org/joda/time/chrono/TestAll.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/org/joda/time/chrono/TestGJDate.java", "insertions": 138, "deletions": 0, "lines": 138}], "commitSpoonAstDiffStats": [{"spoonFilePath": "GJChronology.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long,int)", "TOT": 13, "UPD": 0, "INS": 6, "MOV": 6, "DEL": 1}, {"spoonMethodName": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long,long)", "TOT": 13, "UPD": 0, "INS": 6, "MOV": 6, "DEL": 1}, {"spoonMethodName": "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone,org.joda.time.ReadableInstant,int)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestAll.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestAll.suite()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestGJDate.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.chrono.TestGJDate", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["28aeba952e838fb12c9b934ce6ef65658e45d7b2"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 29, "deletions": 0, "lines": 29, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 28, "UPD": 0, "INS": 14, "MOV": 12, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/chrono"], "changesInPackagesSPOON": ["org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long,int)", "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long,long)", "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone,org.joda.time.ReadableInstant,int)"]}, {"title": "Days#daysBetween throw exception for MonthDay with 29 February", "body": "final LocalDate january12012 = new LocalDate(2012, 1,1);\nfinal LocalDate february292012 = new LocalDate(2012, 2, 29);\n// OK\nassertEquals(59, Days.daysBetween(january12012, february292012).getDays());\n\nfinal MonthDay january1 = new MonthDay(1,1);\nfinal MonthDay february29 = new MonthDay(2, 29);\n// FAIL\nassertEquals(59, Days.daysBetween(january1, february29).getDays());\n\norg.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:217)\n    at org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n    at org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\n    at org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:103)\n    at org.joda.time.Days.daysBetween(Days.java:141)\n\nIs there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.\n\nThanks! \n", "url": "https://github.com/JodaOrg/joda-time/issues/22", "user": "cleverbug", "labels": ["Bug", "Fixed"], "created": "2013-05-07 14:19:36", "closed": "2013-06-16 10:28:45", "commits": {"3a413d7844c22dc6ddd50bf5d0d55ff3589e47ac": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 39.000277777777775, "commitsDetails": [{"commitHash": "3a413d7844c22dc6ddd50bf5d0d55ff3589e47ac", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["efce99164f0bbd2c70e7f9d71884a32473e02c6d"], "nameRev": "3a413d7844c22dc6ddd50bf5d0d55ff3589e47ac tags/v2.3~29", "commitMessage": "Days.daysBetween fails for MonthDay\n\nProblems around leap year\nFixes #22\n", "commitDateTime": "2013-06-16 11:28:26", "authoredDateTime": "2013-06-16 11:27:54", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java", "insertions": 4, "deletions": 2, "lines": 6}, {"filePath": "src/test/java/org/joda/time/TestDays.java", "insertions": 35, "deletions": 2, "lines": 37}, {"filePath": "src/test/java/org/joda/time/TestMonths.java", "insertions": 29, "deletions": 2, "lines": 31}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseSingleFieldPeriod.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.base.BaseSingleFieldPeriod.between(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial,org.joda.time.ReadablePeriod)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}, {"spoonMethodName": "org.joda.time.base.BaseSingleFieldPeriod", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestDays.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestDays.testFactory_daysBetween_RPartial()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_YearMonth()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestMonths.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestMonths.testFactory_monthsBetween_RPartial()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMonths.testFactory_monthsBetween_RPartial_YearMonth()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestMonths.testFactory_monthsBetween_RPartial_MonthDay()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3a413d7844c22dc6ddd50bf5d0d55ff3589e47ac"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 2, "lines": 6, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/base"], "changesInPackagesSPOON": ["org.joda.time.base.BaseSingleFieldPeriod.between(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial,org.joda.time.ReadablePeriod)", "org.joda.time.base.BaseSingleFieldPeriod"]}, {"title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)", "body": "There appears to be a bug in the fix to http://sourceforge.net/p/joda-time/bugs/148 (which I also reported).\n\nThe following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999:\n\n``` java\n    public void testParseInto_monthDay_feb29_startOfYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2000, 1, 1, 0, 0, 0, 0, NEWYORK);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2000, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n    }\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/21", "user": "pipelare", "labels": ["Bug", "Fixed"], "created": "2013-05-03 21:03:46", "closed": "2013-07-21 00:13:03", "commits": {"1adb1e69863dcd1ff282692bf1452c422528eeb9": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 78.00027777777778, "commitsDetails": [{"commitHash": "1adb1e69863dcd1ff282692bf1452c422528eeb9", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["6bf5bba0f77f3023dec23a1de6e0a8cef8585f61"], "nameRev": "1adb1e69863dcd1ff282692bf1452c422528eeb9 tags/v2.3~15", "commitMessage": "Fix DateTimeFormatter.parseInto() where it obtains the default year\n\nPreviously, wrong year could be obtained at year start/end in non UTC zones\nNow obtains year using the chronology of the ReadWritableInstant\nFixes #21\n", "commitDateTime": "2013-07-21 01:12:57", "authoredDateTime": "2013-07-21 01:12:57", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatter.java", "insertions": 5, "deletions": 2, "lines": 7}, {"filePath": "src/test/java/org/joda/time/format/TestDateTimeFormatter.java", "insertions": 70, "deletions": 0, "lines": 70}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFormatter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.DateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant,java.lang.String,int)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "TestDateTimeFormatter.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_startOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_OfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork_startOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork_endOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_startOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_endOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_withDefaultYear_feb29_newYork()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_withDefaultYear_feb29_newYork_endOfYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1adb1e69863dcd1ff282692bf1452c422528eeb9"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5, "deletions": 2, "lines": 7, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"], "changesInPackagesSPOON": ["org.joda.time.format.DateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant,java.lang.String,int)"]}, {"title": "Interval equals javadoc is wrong", "body": "currently the [equals](http://joda-time.sourceforge.net/apidocs/org/joda/time/ReadableInterval.html#equals%28java.lang.Object%29) javadoc says \n\nReturns:\n    true if the start and end millis are equal\n\nthis is not correct, it also compares the chronology. I know it mentions it just above, but I think the return comment should be updated as well.\n\nAlso, it would be nice if there was an isEqual method, similar to the one for [AbstractInstant](http://joda-time.sourceforge.net/apidocs/org/joda/time/base/AbstractInstant.html#isEqual%28org.joda.time.ReadableInstant%29)\n\nCurrently the only way I have found to do this check is something like\n\n``` java\nreturn interval1.getStart().isEqual(interval2.getStart()) && interval1.getEnd().isEqual(interval2.getEnd());\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/20", "user": "kingsob-zz", "labels": ["Bug", "Fixed"], "created": "2013-04-29 06:38:26", "closed": "2013-04-29 13:10:52", "commits": {"95b82019c46f45a7b948d8937f2f28067dfcd69f": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "95b82019c46f45a7b948d8937f2f28067dfcd69f", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["0f274a6e0450cfd23bae02f80d283dd0e66432a2"], "nameRev": "95b82019c46f45a7b948d8937f2f28067dfcd69f tags/v2.3~18", "commitMessage": "Add @since tag\n\nSee #20\n", "commitDateTime": "2013-07-20 13:16:12", "authoredDateTime": "2013-07-20 13:16:12", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/base/AbstractInterval.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractInterval.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["95b82019c46f45a7b948d8937f2f28067dfcd69f"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 0, "lines": 1, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/base"]}, {"title": "NPE in DateTimeZoneBuilder", "body": "When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().\n\nThe cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler:\n\n``` java\n   static {\n        cVerbose.set(Boolean.FALSE);\n    }\n```\n\n...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in:\n\n``` java\n   public static boolean verbose() {\n        return cVerbose.get();\n    }\n```\n\nA better approach could be to remove the initialization and test for null:\n\n``` java\npublic static boolean verbose(){\n    Boolean verbose = cVerbose.get();\n    return (verbose != null) ? verbose : false;\n}\n```\n\n---\n\nHere follows a test case:\n\n``` java\n    @Test\n    public void testDateTimeZoneBuilder() throws Exception {\n        getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ1\", true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ2\", true);\n            }\n        });\n        t.start();\n        t.join();\n    }\n\n    private DateTimeZoneBuilder getTestDataTimeZoneBuilder() {\n         return new DateTimeZoneBuilder()\n         .addCutover(1601, 'w', 1, 1, 1, false, 7200000)\n         .setStandardOffset(3600000)\n         .addRecurringSavings(\"\", 3600000, 1601, Integer.MAX_VALUE, 'w', 3, -1, 1, false, 7200000)\n         .addRecurringSavings(\"\", 0, 1601, Integer.MAX_VALUE, 'w', 10, -1, 1, false, 10800000);\n    }\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/18", "user": "lucclaes", "labels": ["Bug", "Fixed"], "created": "2013-04-19 08:28:47", "closed": "2013-04-19 14:48:33", "commits": {"57eb4cbb9044771cd46a9eee0c62016618930226": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "57eb4cbb9044771cd46a9eee0c62016618930226", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["6d5104753470c130336e319a64009c0553b29c96"], "nameRev": "57eb4cbb9044771cd46a9eee0c62016618930226 tags/v2.3~39", "commitMessage": "Fix ZoneInfoCompiler and DateTimeZoneBuilder multi-threading\n\nFixes #18\n", "commitDateTime": "2013-04-19 15:34:57", "authoredDateTime": "2013-04-19 15:34:57", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "pom.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/tz/ZoneInfoCompiler.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "src/test/java/org/joda/time/tz/TestCompiler.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ZoneInfoCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.ZoneInfoCompiler", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "TestCompiler.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.tz.TestCompiler.testDateTimeZoneBuilder()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.tz.TestCompiler.getTestDataTimeZoneBuilder()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["57eb4cbb9044771cd46a9eee0c62016618930226"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5, "deletions": 4, "lines": 9, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/tz"], "changesInPackagesSPOON": ["org.joda.time.tz.ZoneInfoCompiler"]}, {"title": "DateTime.parse doesn't seem to parse YYYYMMDD correctly.", "body": "### Key information\r\n\r\nISO-8601 specifies (at least according to [Wikipedia](https://en.wikipedia.org/wiki/ISO_8601), I don't have access to the actual ISO) that `YYYYMMDD` is a valid way to specify a calendar date.\r\n\r\n- Joda-Time version: 2.10.4\r\n- Result of `TimeZone.getDefault()`: `sun.util.calendar.ZoneInfo[id=\"America/Toronto\",offset=-18000000,dstSavings=3600000,useDaylight=true,transitions=231,lastRule=java.util.SimpleTimeZone[id=America/Toronto,offset=-18000000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=3,startMonth=2,startDay=8,startDayOfWeek=1,startTime=7200000,startTimeMode=0,endMode=3,endMonth=10,endDay=1,endDayOfWeek=1,endTime=7200000,endTimeMode=0]]`\r\n- Result of `DateTimeZone.getDefault()`: `America/Toronto`\r\n\r\n### Problem description\r\n\r\nThe DateTime.parse() method, which I expect to be ISO-8601 compliant, doesn't seem to actually comply to the standard in this one particular case? Passing in `20190101` doesn't parse as January 1st, 2019, but rather January 1st, 20190101.\r\n\r\nI looked at the specification for `ISODateTimeFormat.dateTimeParser()` and I saw that this format is not supported according to the documentation. This popped up as a bug for me, and I feel like the documentation could be more clear, if this is indeed the intentional behaviour?\r\n\r\n### Test case\r\n\r\n```import org.joda.time.DateTime;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class Test {\r\n  @org.junit.Test\r\n  public void TestCase() {\r\n    assertEquals(DateTime.parse(\"20190101\"), DateTime.parse(\"2019-01-01\"));\r\n  }\r\n}\r\n```", "url": "https://github.com/JodaOrg/joda-time/issues/515", "user": "szabado", "labels": ["NotABug", "WontFix"], "created": "2019-09-26 18:08:19", "closed": "2019-10-12 14:41:38", "commits": {}, "ttf": 15.000277777777777, "commitsDetails": []}, {"title": "ISODateTimeFormat.forFields parser doesn't work when using not extended", "body": "### Key information\r\n\r\n- Joda-Time version\r\n2.10.3\r\n- Result of `TimeZone.getDefault()`\r\n`sun.util.calendar.ZoneInfo[id=\"Europe/Stockholm\",offset=3600000,dstSavings=3600000,useDaylight=true,transitions=119,lastRule=java.util.SimpleTimeZone[id=Europe/Stockholm,offset=3600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]`\r\n- Result of `DateTimeZone.getDefault()`\r\nEurope/Stockholm\r\n\r\n### Problem description\r\nISODateTimeFormat.forFields generates a broken parser when using extended = false\r\n\r\n### Test case\r\nJava\r\n```java\r\n\r\nimport org.joda.time.DateTimeFieldType;\r\nimport org.joda.time.Instant;\r\nimport org.joda.time.format.ISODateTimeFormat;\r\n\r\npublic class Test {\r\n\r\n    public static void main(String[] args) {\r\n        java.util.ArrayList<DateTimeFieldType> test = new java.util.ArrayList();\r\n        test.add(DateTimeFieldType.year());\r\n        test.add(DateTimeFieldType.monthOfYear());\r\n        test.add(DateTimeFieldType.dayOfMonth());\r\n\r\n        Instant.parse(\"20050330\", ISODateTimeFormat.forFields(test, false, true));\r\n    }\r\n}\r\n\r\n```\r\nOutput:\r\n```\r\nException in thread \"main\" java.lang.IllegalArgumentException: Invalid format: \"20050330\" is too short\r\n```\r\n\r\nScala\r\n```scala\r\n\"test\" should \"Not break\" in {\r\n    import collection.JavaConverters._\r\n    val form = ISODateTimeFormat\r\n      .forFields(\r\n        Seq(\r\n          DateTimeFieldType.year(),\r\n          DateTimeFieldType.monthOfYear(),\r\n          DateTimeFieldType.dayOfMonth()).asJavaCollection,\r\n        false,\r\n        true)\r\n      .withZoneUTC()\r\n    Instant.parse(\r\n      \"20050320\",\r\n      form\r\n    )\r\n  }\r\n```\r\n\r\n\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/513", "user": "Lanboost", "labels": ["NotABug", "WontFix"], "created": "2019-08-28 12:17:20", "closed": "2019-10-12 14:48:06", "commits": {"adacfb63848c437aa128a1e8de7bbda2dba5f5a4": {"commitGHEventType": "closed", "commitUser": "jodastephen"}}, "ttf": 45.000277777777775, "commitsDetails": [{"commitHash": "adacfb63848c437aa128a1e8de7bbda2dba5f5a4", "commitGHEventType": "closed", "commitUser": "jodastephen", "commitParents": ["b886dfa2e3202e98066a0404a35cc5a344715228"], "nameRev": "adacfb63848c437aa128a1e8de7bbda2dba5f5a4 tags/website8~1", "commitMessage": "Clarify support for parsing\n\nISODateTimeFormat.forFields() often does not support parsing\nFixes #513\n", "commitDateTime": "2019-10-12 15:48:00", "authoredDateTime": "2019-10-12 15:48:00", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/format/ISODateTimeFormat.java", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ISODateTimeFormat.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["adacfb63848c437aa128a1e8de7bbda2dba5f5a4"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 0, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"]}, {"title": "Turkey's DST has some problems", "body": "### Key information\r\n\r\n- Joda-Time version\r\n2.10.1\r\n- Result of `TimeZone.getDefault()`\r\nsun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null]\r\n- Result of `DateTimeZone.getDefault()`\r\nAsia/Shanghai\r\n### Problem description\r\nTurkey's decision to permanently remain on UTC+3\r\nvi {tzdata2018g}/europe: \r\n\r\n`# From Paul Eggert (2017-11-08):`\r\n`# Although Google Translate misfires on that source, it looks like`\r\n`# Turkey reversed last month's decision, and so will stay at +03.`\r\n\r\n`# Zone  NAME            GMTOFF  RULES   FORMAT  [UNTIL]`\r\n`Zone    Europe/Istanbul 1:55:52 -       LMT     1880`\r\n`                       1:56:56 -       IMT     1910 Oct # Istanbul Mean Time?`\r\n`                        2:00    Turkey  EE%sT   1978 Oct 15`\r\n`                        3:00    Turkey  +03/+04 1985 Apr 20`\r\n`                        2:00    Turkey  EE%sT   2007`\r\n`                        2:00    EU      EE%sT   2011 Mar 27  1:00u`\r\n`                        2:00    -       EET     2011 Mar 28  1:00u`\r\n`                        2:00    EU      EE%sT   2014 Mar 30  1:00u`\r\n`                        2:00    -       EET     2014 Mar 31  1:00u`\r\n`                        2:00    EU      EE%sT   2015 Oct 25  1:00u`\r\n`                        2:00    1:00    EEST    2015 Nov  8  1:00u`\r\n`                        2:00    EU      EE%sT   2016 Sep  7`\r\n`                        3:00    -       +03`\r\n`Link    Europe/Istanbul Asia/Istanbul   # Istanbul is in both continents.`\r\n\r\nBut can't get the correct result\r\n\r\n### Test case\r\njava code: \r\n`DateTime date1_sh = new DateTime(2018, 10, 28, 8, 0, 0, 0, DateTimeZone.forID(\"Asia/Shanghai\"));`\r\n`DateTime date2_sh = new DateTime(2018, 10, 28, 9, 0, 0, 0, DateTimeZone.forID(\"Asia/Shanghai\"));`\r\n`System.out.println(\"Asia/Shanghai 1: \" + date1_sh.toString(\"yyyy-MM-dd HH:mm:ss.SSS Z\"));`\r\n`System.out.println(\"Asia/Shanghai 2: \" + date2_sh.toString(\"yyyy-MM-dd HH:mm:ss.SSS Z\"));`\r\n`System.out.println(\"Europe/Istanbul 1: \" + date1_sh.withZone(DateTimeZone.forID(\"Europe/Istanbul\")).toString(\"yyyy-MM-dd HH:mm:ss.SSS Z\"));`\r\n`System.out.println(\"Europe/Istanbul 2: \" + date2_sh.withZone(DateTimeZone.forID(\"Europe/Istanbul\")).toString(\"yyyy-MM-dd HH:mm:ss.SSS Z\"));`\r\n\r\noutput:\r\n`Asia/Shanghai 1: 2018-10-28 08:00:00.000 +0800`\r\n`Asia/Shanghai 2: 2018-10-28 09:00:00.000 +0800`\r\n`Europe/Istanbul 1: 2018-10-28 03:00:00.000 +0300`\r\n`Europe/Istanbul 2: 2018-10-28 03:00:00.000 +0200`", "url": "https://github.com/JodaOrg/joda-time/issues/489", "user": "o0rid0o", "labels": ["Discussion", "NotABug"], "created": "2018-10-31 11:40:21", "closed": "2018-11-01 21:53:38", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "The LocalDateTime(Object instant, DateTimeZone zone) constructor ignores the timezone", "body": "### Key information\r\n\r\n- Joda-Time version:\r\n**2.9.3**\r\n\r\n- Result of `TimeZone.getDefault()`\r\nsun.util.calendar.ZoneInfo[id=\"Europe/Athens\",offset=7200000,dstSavings=3600000,useDaylight=true,transitions=138,lastRule=java.util.SimpleTimeZone[id=Europe/Athens,offset=7200000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\r\n\r\n- Result of `DateTimeZone.getDefault()`\r\n**Europe/Athens**\r\n\r\n### Problem description\r\nThe LocalDateTime(Object instant, DateTimeZone zone) constructor ignores the timezone due to **iChronology = chronology.withUTC();**\r\nThe somewhat analogue LocalDateTime(long instant, DateTimeZone zone) gives the answer considering the TimeZone.\r\n\r\n### Test case\r\n`new LocalDateTime(new LocalDateTime(2012, 1, 1, 0, 0), DateTimeZone.getDefault())`\r\nreturns 2012-01-01**T00**:00:00.000\r\n\r\nwhile....\r\n\r\n`new LocalDateTime(new LocalDateTime(2012, 1, 1, 0, 0).getLocalMillis(), DateTimeZone.getDefault())`\r\nreturns 2012-01-01**T02**:00:00.000", "url": "https://github.com/JodaOrg/joda-time/issues/454", "user": "veverone", "labels": ["NotABug", "WontFix"], "created": "2017-11-24 13:16:43", "closed": "2017-11-24 13:53:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NullPointerException when trying to call getYear() from BasicChronology from an object retrieved after serialization", "body": "I have a LocalDate with a Chronology extending BasicChronology.\r\nI wanted to put it into a Bundle (From Android API) so I serialized it. but after I retrieved the LocalDate object and called getYear(), for some reason the field iYearInfoCache in BasicChronology was null and wasn't regenerated and I got a NullPointerException in the method getYearInfo.", "url": "https://github.com/JodaOrg/joda-time/issues/453", "user": "ahmadzb", "labels": ["NotABug", "WontFix"], "created": "2017-11-14 02:14:46", "closed": "2017-11-23 09:43:52", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "DateTime crasches when save as serializable.", "body": "Version 2.9.9. I tried to keep DateTime in Android as a serializable object and got an error. Obviously, the inner DateTimeZoneBuilder class is not serializable. Please fix it! Thanks!\r\n\r\n```\r\njava.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = org.joda.time.DateTime)\r\n                                                     at android.os.Parcel.writeSerializable(Parcel.java:1394)\r\n                                                     at android.os.Parcel.writeValue(Parcel.java:1341)\r\n                                                     at android.os.Parcel.writeArrayMapInternal(Parcel.java:644)\r\n                                                     at android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1313)\r\n                                                     at android.os.Bundle.writeToParcel(Bundle.java:1034)\r\n                                                     at android.os.Parcel.writeBundle(Parcel.java:669)\r\n                                                     at android.support.v4.app.FragmentState.writeToParcel(Fragment.java:148)\r\n                                                     at android.os.Parcel.writeTypedArray(Parcel.java:1197)\r\n                                                     at android.support.v4.app.FragmentManagerState.writeToParcel(FragmentManager.java:564)\r\n                                                     at android.os.Parcel.writeParcelable(Parcel.java:1363)\r\n                                                     at android.os.Parcel.writeValue(Parcel.java:1268)\r\n                                                     at android.os.Parcel.writeArrayMapInternal(Parcel.java:644)\r\n                                                     at android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1313)\r\n                                                     at android.os.Bundle.writeToParcel(Bundle.java:1034)\r\n                                                     at android.os.Parcel.writeBundle(Parcel.java:669)\r\n                                                     at android.app.ActivityManagerProxy.activityStopped(ActivityManagerNative.java:2919)\r\n                                                     at android.app.ActivityThread$StopInfo.run(ActivityThread.java:3296)\r\n                                                     at android.os.Handler.handleCallback(Handler.java:739)\r\n                                                     at android.os.Handler.dispatchMessage(Handler.java:95)\r\n                                                     at android.os.Looper.loop(Looper.java:135)\r\n                                                     at android.app.ActivityThread.main(ActivityThread.java:5254)\r\n                                                     at java.lang.reflect.Method.invoke(Native Method)\r\n                                                     at java.lang.reflect.Method.invoke(Method.java:372)\r\n                                                     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\r\n                                                     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\r\n                                                  Caused by: java.io.NotSerializableException: org.joda.time.tz.DateTimeZoneBuilder$Recurrence\r\n                                                     at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)\r\n                                                     at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\r\n                                                     at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\r\n                                                     at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\r\n                                                     at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\r\n                                                     at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\r\n                                                     at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\r\n                                                     at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\r\n                                                     at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\r\n                                                     at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\r\n                                                     at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\r\n                                                     at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\r\n                                                     at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\r\n                                                     at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\r\n                                                     at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\r\n                                                     at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\r\n                                                     at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\r\n                                                     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\r\n                                                     at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\r\n                                                     at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\r\n                                                     at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\r\n                                                     at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\r\n```", "url": "https://github.com/JodaOrg/joda-time/issues/448", "user": "m4xp1", "labels": ["NotABug", "WontFix"], "created": "2017-10-24 10:23:28", "closed": "2017-11-13 14:43:29", "commits": {}, "ttf": 20.00027777777778, "commitsDetails": []}, {"title": "DateTimeFormatter behavior when Day-of-Month and day-of-week do not match", "body": "### Key information\r\n\r\n- Joda-Time version: 2.9.7\r\n- Result of `TimeZone.getDefault()`: Europe/Athens\r\n- Result of `DateTimeZone.getDefault()`: Europe/Athens\r\n\r\n### Problem description\r\nI am constructing a `DateTimeFormatter` with pattern \"EEE MMM dd HH:mm:ss YYYY\".\r\nParsing a string whose day field and day of week field do not match, succeeds, **but an exception could be thrown?**\r\n\r\n### Test case\r\n```\r\n@Test\r\n    public void foo() {\r\n\r\n        DateTimeFormatter formatter = DateTimeFormat.forPattern(\"EEE MMM dd HH:mm:ss YYYY\");\r\n\r\n        // this date is malformed. On the 8th it was Sunday, not Wednesay\r\n        DateTime dateTime = formatter.parseDateTime(\"Wed Oct 08 08:39:37 2017\");\r\n        System.out.println(dateTime.getDayOfMonth()); // prints 4 (Wednesday)\r\n    }\r\n```", "url": "https://github.com/JodaOrg/joda-time/issues/447", "user": "minas1", "labels": ["NotABug", "WontFix"], "created": "2017-10-19 11:08:03", "closed": "2017-11-13 14:42:23", "commits": {}, "ttf": 25.00027777777778, "commitsDetails": []}, {"title": "ISO8601", "body": "### Key information\r\n\r\n- Joda-Time 2.9.9\r\n\r\n### Problem description\r\nWrong parsing of ISO8601 in version 2.9.9.\r\n\r\n### Test case\r\n\r\n>  ISODateTimeFormat.dateTime().parseDateTime(\"2017-09-01T15:00:00Z\");\r\n\r\n`java.lang.IllegalArgumentException: Invalid format: \"2017-09-01T15:00:00Z\" is malformed at \"Z\"\r\n\tat org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:945)`\r\n\r\n\r\n>  ISODateTimeFormat.dateTime().parseDateTime(\"2017-09-01T15:00:00.000Z\"); works fine.\r\n\r\nFor example \"2017-09-26T19:25:20Z\" is a valid ISO 8601 (for example https://en.wikipedia.org/wiki/ISO_8601). Why I can not parse it?\r\n\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/443", "user": "svatos-jirka", "labels": ["NotABug", "WontFix"], "created": "2017-09-26 19:54:59", "closed": "2017-10-02 10:17:11", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Days.daysBetween returns unexpected value when you compare two dates where it was applied minusDays(1) to one of them", "body": "### Key information\r\n\r\n- Joda-Time version: **2.9.9**\r\n- Result of `TimeZone.getDefault()`: **Europe/Berlin**\r\n- Result of `DateTimeZone.getDefault()`: **Europe/Berlin**\r\n\r\n### Case\r\nGiven this construction **Days.daysBetween(DateTime.now(),  DateTime.now().minusDays(1)).getValue()** I would expect to receive 1 as a result, but it returns 0\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/442", "user": "jtymoschuk", "labels": ["NotABug", "WontFix"], "created": "2017-09-15 08:19:42", "closed": "2017-09-15 09:40:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MinusMonth issue when result is in the end of February", "body": "Hi Team,\r\n\r\nI'd like to reporting an issue about minusMonths method. I found this when I investigated some unit tests that were failing on certain day of our automated build process.\r\n\r\nSo I write this unit test for simplicity:\r\n\r\n    private static final String YYYY_MM_DD = \"yyyy-MM-dd\";\r\n    \r\n    @Test\r\n    public void test_minus_months() {\r\n \t   DateTime strangeCase1 = DateTime.parse(\"2015-03-30\", DateTimeFormat.forPattern(YYYY_MM_DD));\r\n \t   DateTime strangeCase2 = DateTime.parse(\"2015-03-29\", DateTimeFormat.forPattern(YYYY_MM_DD));\r\n \t   DateTime strangeCase3 = DateTime.parse(\"2015-03-28\", DateTimeFormat.forPattern(YYYY_MM_DD));\r\n \t   DateTime oldTime = DateTime.parse(\"2015-02-28\", DateTimeFormat.forPattern(YYYY_MM_DD));\r\n \t   assertEquals(oldTime, strangeCase1.minusMonths(1));\r\n \t   assertEquals(oldTime, strangeCase2.minusMonths(1));\r\n \t   assertEquals(oldTime, strangeCase3.minusMonths(1));\r\n    }\r\n\r\nAnd this test run successfully, which I believe it shouldn't. Three different days, when one month subtracted from them using minusMonth, resulting in the same day. \r\n\r\nI'm using version 2.9 and when I changed to 2.9.9, this issue still exists.", "url": "https://github.com/JodaOrg/joda-time/issues/441", "user": "Dionsaurus", "labels": ["NotABug", "WontFix"], "created": "2017-08-30 02:46:24", "closed": "2017-09-15 09:42:59", "commits": {}, "ttf": 16.00027777777778, "commitsDetails": []}, {"title": "DateTimeFormatterBuilder bugged when using DateTimeFormatter with Locale", "body": "### Key information\r\n- 2.9.9 (also tested in multiple previous versions and same problem)\r\n\r\n### Problem description\r\nIt seems that using the DateTimeFormatterBuilder will ignore the Locale of any formatter/parser set into it.\r\n\r\n### Test case\r\n\r\nString testDate = \"Juli\";\r\nDateTimeFormatter f = DateTimeFormat.forPattern(\"MMMM\").withLocale(Locale.GERMAN);\r\nDateTime date = f.parseDateTime(testDate);\r\n//This case is parsed correctly with the assigned Locale\r\nSystem.out.println(date);\r\n\r\nDateTimeFormatter formatter = new DateTimeFormatterBuilder().append( f ).toFormatter();\r\nDateTime date1 = formatter.parseDateTime( testDate );\r\n//This case gives an error.. why?\r\nSystem.out.println(date1);\r\n\r\n\r\n\r\nThe reason I want to use the DateTimeFormatterBuilder is because I want to assign multiple parsers to check and avoid trying one by one and catching errors. For example code:\r\nDateTimeParser[] parsers = { \r\nDateTimeFormat.forPattern( \"MMMM\" ).withLocale(Locale.GERMAN).getParser()  };\r\nDateTimeFormatter formatter = new DateTimeFormatterBuilder().append( null, parsers ).toFormatter();\r\n\r\n\r\nEdit:\r\nIn fact seems to happen that any alteration to the DateTimeFormat before the getParser() is ignored.\r\nFor example:\r\n//1) this case works fine and the resulting date will have set year 2017\r\nDateTimeFormatter f = DateTimeFormat.forPattern(\"dd.MM\").withDefaultYear(2017);\r\n\r\n//2) this case will ignore the year and leave it as 2000\r\nDateTimeParser[] parsers = { \r\nDateTimeFormat.forPattern( \"dd.MM\" ).withDefaultYear(Year.now().getValue()).getParser()\t\r\n};\r\nDateTimeFormatter formatter = new DateTimeFormatterBuilder().append( null, parsers ).toFormatter();\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/431", "user": "dannyyw", "labels": ["NotABug", "WontFix"], "created": "2017-06-17 10:38:48", "closed": "2017-07-18 16:18:40", "commits": {}, "ttf": 31.00027777777778, "commitsDetails": []}, {"title": "Wrong seconds format", "body": "### Key information\r\n\r\n- Joda-Time 2.9.7 and 2.9.9\r\n- Result of `TimeZone.getDefault()` : sun.util.calendar.ZoneInfo[id=\"Asia/Ulaanbaatar\",offset=28800000,dstSavings=3600000,useDaylight=true,transitions=93,lastRule=java.util.SimpleTimeZone[id=Asia/Ulaanbaatar,offset=28800000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=7,startTime=7200000,startTimeMode=0,endMode=2,endMonth=8,endDay=-1,endDayOfWeek=7,endTime=0,endTimeMode=0]]\r\n- Result of `DateTimeZone.getDefault()` : Asia/Ulaanbaatar\r\n\r\n### Problem description\r\nwrong seconds format\r\n### Test case\r\n```\r\n\tDateTime now = new DateTime(2017, 2, 27, 17, 50, 31);\r\n\tSystem.out.println(now.toString(\"s\") + \" <-- must 3\\n\" + now.toString(\"ss\")+\" <-- must 31\");\r\n```\r\nreturn mostly\r\n```\r\n31 <-- must 3\r\n31 <-- must 31\r\n```\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/421", "user": "tstsogoo", "labels": ["NotABug", "WontFix"], "created": "2017-03-27 05:22:34", "closed": "2017-03-27 07:39:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "DateTIme construct return current time when parameter is null", "body": "Joda-Time version 2.9.3 \r\n\r\n### Problem description\r\nDateTime constructor \r\npublic DateTime(Object instant) {\r\n        super(instant, (Chronology) null);\r\n}\r\n\r\n when the instant is not null, this return value is correct. \r\n but when the instant is null, return value is current time that I think is a bug\r\n\r\n### Test case\r\n        Date date = DateTime.parse(\"2017-01-01\").toDate();\r\n        System.out.println(date); // Sun Jan 01 00:00:00 CST 2017\r\n\r\n        date = null;\r\n        System.out.println(new DateTime(date)); //2017-03-06T22:43:56.089+08:00\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/417", "user": "linbeisaii", "labels": ["NotABug", "WontFix"], "created": "2017-03-06 14:44:45", "closed": "2017-03-06 14:51:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "AbstractDateTime#getMillisOfDay returns incorrect value on DST days", "body": "### Key information\r\n- Joda-Time version: 2.9.2\r\n- Result of `TimeZone.getDefault()`\r\n> sun.util.calendar.ZoneInfo[id=\"America/Chicago\",offset=-21600000,dstSavings=3600000,useDaylight=true,transitions=235,lastRule=java.util.SimpleTimeZone[id=America/Chicago,offset=-21600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=3,startMonth=2,startDay=8,startDayOfWeek=1,startTime=7200000,startTimeMode=0,endMode=3,endMonth=10,endDay=1,endDayOfWeek=1,endTime=7200000,endTimeMode=0]]\r\n\r\n- Result of `DateTimeZone.getDefault()`\r\nAmerica/Chicago\r\n\r\n### Problem description\r\nWhen getting the milliseconds of the day, it appears that it does not correctly account for the milliseconds of the day when that day is a DST transition date.\r\n\r\nThere is a chance that I am misunderstanding the intended purpose of the org.joda.time.base.AbstractDateTime#getMillisOfDay() method.  My expectation is that the getMillisOfDay would essentially create an interval between the current value within the DateTime and a DateTime that represents the beginning of DateTime that the method is invoked on (in the same time zone, etc), then a duration is calculated between the two.  The follow test case shows that this is not the actual behavior. \r\n\r\n### Test case\r\n```java\r\n        DateTime dstDate = new DateTime(2017, 3, 12, 6, 0);\r\n        DateTime nonDSTDate = new DateTime(2017, 3, 11, 6, 0);\r\n        System.out.println(dstDate); // 2017-03-12T06:00:00.000-05:00\r\n        System.out.println(nonDSTDate); // 2017-03-11T06:00:00.000-06:00\r\n        \r\n        System.out.println(dstDate.getMillisOfDay()); // 21600000\r\n        System.out.println(nonDSTDate.getMillisOfDay()); // 21600000\r\n        \r\n        DateTime dstDateStartOfDay = new DateTime(2017, 3, 12, 0, 0);\r\n        DateTime nonDSTDateStartOfDay = new DateTime(2017, 3, 11, 0, 0);\r\n        System.out.println(new Interval(dstDateStartOfDay, dstDate).toDurationMillis()); // 18000000\r\n        System.out.println(new Interval(nonDSTDateStartOfDay, nonDSTDate).toDurationMillis()); // 21600000\r\n```\r\n\r\nI have inlined comments that show the output, but here is the full output as well:\r\n```plaintext\r\n2017-03-12T06:00:00.000-05:00\r\n2017-03-11T06:00:00.000-06:00\r\n21600000\r\n21600000\r\n18000000\r\n21600000\r\n```\r\n\r\nThe expected output would be that the print out of the dstDate's millis of day would have a different value than the non-dst-date's millis of the day.\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/415", "user": "Singleton06", "labels": ["NotABug", "WontFix"], "created": "2017-02-23 00:23:09", "closed": "2017-02-26 12:24:33", "commits": {"acff94148b2110b95f7aeae6a1bdcafb756061f0": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "acff94148b2110b95f7aeae6a1bdcafb756061f0", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["eef32af393dab7518703c29347128436d563220c"], "nameRev": "acff94148b2110b95f7aeae6a1bdcafb756061f0 tags/v2.9.8~5", "commitMessage": "Clarify fields are on the local time-line\n\nSee #415\n", "commitDateTime": "2017-02-26 12:22:18", "authoredDateTime": "2017-02-26 12:21:03", "commitGitStats": [{"filePath": "src/changes/changes.xml", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/org/joda/time/DateTimeFieldType.java", "insertions": 12, "deletions": 0, "lines": 12}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFieldType.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["acff94148b2110b95f7aeae6a1bdcafb756061f0"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 12, "deletions": 0, "lines": 12, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"]}, {"title": "Problem getting specific date from last year (2016)", "body": "### Key information\r\n\r\n- Joda-Time version : joda-time-2.9.7\r\n- Result of `TimeZone.getDefault()` :sun.util.calendar.ZoneInfo[id=\"Europe/Prague\",offset=3600000,dstSavings=3600000,useDaylight=true,transitions=141,lastRule=java.util.SimpleTimeZone[id=Europe/Prague,offset=3600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\r\n- Result of `DateTimeZone.getDefault()` :Europe/Prague\r\n\r\n### Problem description\r\n\r\nGetting specific date for year 2016 using methods withYear, withWeekOfWeekyear and withDayOfWeek results with date for year 2015\r\n\r\n\r\n### Test case\r\n`public class Main {\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tint weekNumber = 21;\r\n\t\tDateTime dtNow = new DateTime();\r\n\t\tDateTime dt0 = new DateTime().withYear(2014).withWeekOfWeekyear(weekNumber).withDayOfWeek(DateTimeConstants.MONDAY);\r\n\t\tDateTime dt1 = new DateTime().withYear(2015).withWeekOfWeekyear(weekNumber).withDayOfWeek(DateTimeConstants.MONDAY);\r\n\t\tDateTime dt2 = new DateTime().withYear(2016).withWeekOfWeekyear(weekNumber).withDayOfWeek(DateTimeConstants.MONDAY);\r\n\t\tDateTime dt3 = new DateTime().withYear(2017).withWeekOfWeekyear(weekNumber).withDayOfWeek(DateTimeConstants.MONDAY);\r\n\t\tDateTime dt4 = new DateTime().withYear(2018).withWeekOfWeekyear(weekNumber).withDayOfWeek(DateTimeConstants.MONDAY);\r\n\t\t\r\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"dd.MM.yyyy\", Locale.ENGLISH);\r\n\t\tSystem.out.println(\"dtNow (2017) : \" + sdf.format(dtNow.toDate()));\r\n\t\tSystem.out.println(\"dt0   (2014) : \" + sdf.format(dt0.toDate()));\r\n\t\tSystem.out.println(\"dt1   (2015) : \" + sdf.format(dt1.toDate()));\r\n\t\tSystem.out.println(\"dt2   (2016) : \" + sdf.format(dt2.toDate()) + \" expected: 23.05.2016\" );\r\n\t\tSystem.out.println(\"dt3   (2017) : \" + sdf.format(dt3.toDate()));\r\n\t\tSystem.out.println(\"dt4   (2018) : \" + sdf.format(dt4.toDate()));\r\n\t\t\r\n\t}\r\n}`\r\n### Result\r\n\r\ndtNow (2017) : 03.01.2017\r\ndt0   (2014) : 19.05.2014\r\ndt1   (2015) : 18.05.2015\r\n**dt2   (2016) : 18.05.2015 expected: 23.05.2016**\r\ndt3   (2017) : 22.05.2017\r\ndt4   (2018) : 21.05.2018\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/410", "user": "MatejScolopax", "labels": ["NotABug", "WontFix"], "created": "2017-01-03 10:28:31", "closed": "2017-01-03 11:16:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Value set with MutableDateTime.hourOfDay().set() is cleared in corresponding DateTime", "body": "Dear madam / sir,\r\n\r\nI think MutableDateTime has a problem with the hour of the day. I tried the following code:\r\n\r\n    MutableDateTime mref = new MutableDateTime();\r\n    mref.setYear(2016);\r\n    mref.setMonthOfYear(12);\r\n    mref.setDayOfMonth(13);\r\n    mref.hourOfDay().set(4);\r\n    mref.setMinuteOfDay(15);\r\n    mref.setSecondOfMinute(49);\r\n    mref.setMillisOfSecond(345);\r\n    mref.setZone(DateTimeZone.forID(\"CET\"));\r\n    reference = mref.toDateTime();\r\n    System.out.println(String.format(\"Year, month and day: %d-%d-%d\",\r\n        reference.getYear(), reference.getMonthOfYear(), reference.getDayOfMonth()));\r\n    System.out.println(String.format(\"Hour, minute, second and millis: %d:%d:%d.%d\",\r\n        reference.getHourOfDay(), reference.getMinuteOfHour(), reference.getSecondOfMinute(),\r\n        reference.getMillisOfSecond()));\r\n\r\nIt produces:\r\n\r\nYear, month and day: 2016-12-13\r\nHour, minute, second and millis: 0:15:49.345\r\n\r\nThe last line is wrong: I would expect 4:15:49.345. I see also 0 for the hours when I use\r\n    mref.hourOfDay().set(3);\r\n\r\nWith kind regards,\r\n\r\nMartijn Dirkse", "url": "https://github.com/JodaOrg/joda-time/issues/407", "user": "mhdirkse", "labels": ["Discussion", "NotABug"], "created": "2016-12-07 17:24:23", "closed": "2016-12-13 11:13:58", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Duration.getStandard* methods have wrong JavaDoc comments", "body": "### Problem description\r\nThis isn't a run-time problem, so I didn't include any code results. The Duration class has the following methods:\r\n```\r\ngetStandardDays\r\ngetStandardHours\r\ngetStandardMinutes\r\ngetStandardSeconds\r\n```\r\nIn the JavaDoc comments, each of them has the following line:\r\n```\r\n* @return the length of the duration in standard seconds\r\n```\r\nThis comment is only true for the `getStandardSeconds` method. The others should say that they return the length of the durations in their respective units, i.e.\r\n```\r\n* @return the length of the duration in standard hours\r\n```\r\nfor the getStandardHours method.\r\n", "url": "https://github.com/JodaOrg/joda-time/issues/405", "user": "mghoffmann", "labels": ["Fixed", "NotABug"], "created": "2016-11-12 18:45:50", "closed": "2016-12-13 11:09:41", "commits": {}, "ttf": 30.00027777777778, "commitsDetails": []}, {"title": "Prevent formatting of periods that is not conform to the ISO8601 standard", "body": "### Key information\n- Joda-Time version\n  v2.9.4\n- Result of `TimeZone.getDefault()`\n  `libcore.util.ZoneInfo[id=\"America/New_York\",mRawOffset=-18000000,mEarliestRawOffset=-18000000,mUseDst=true,mDstSavings=3600000,transitions=235]`\n- Result of `DateTimeZone.getDefault()`\n  `America/New_York`\n### Problem description\n\nFormatting of ISO8601 periods does not conform to ISO8601 standard.\n\nAccording to the ISO8601 standard, a period can be formatted with **only one of the two following** formats :\n- P[n]Y[n]M[n]DT[n]H[n]M[n]S\n- P[n]W\n\n> Durations are represented by the format P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W\n> [Source](https://en.wikipedia.org/wiki/ISO_8601#Durations)\n\nHence, the format P[n]Y[n]M[n]W[n]DT[n]H[n]M[n]S is not a valid period format according to ISO8601 (weeks cannot be mixed with any other date or time designator)\n\nThe library should check for fields in the Period class and prevent formatting them if they have both a week field and one of the other date or hour fields.\n### Test case\n\nSee [this test file](https://github.com/JodaOrg/joda-time/blob/master/src/test/java/org/joda/time/format/TestISOPeriodFormat.java#L101)\n", "url": "https://github.com/JodaOrg/joda-time/issues/400", "user": "tokou", "labels": ["NotABug", "WontFix"], "created": "2016-10-17 16:34:56", "closed": "2016-10-17 16:38:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Printing the date \"1753-01-01 00:00:00.123\" gets printed incorrectly when the input timestamp is passed and printed using the DateTimeFormatter", "body": "### Key information\n- Joda-Time version : 2.9.4\n- Result of `TimeZone.getDefault()`\n  sun.util.calendar.ZoneInfo[id=\"Asia/Calcutta\",offset=19800000,dstSavings=0,useDaylight=false,transitions=6,lastRule=null]\n- Result of `DateTimeZone.getDefault()`\n  Asia/Kolkata\n### Problem description\n\nPrinting the date \"1753-01-01 00:00:00.123\" gets printed incorrectly when the input timestamp is passed and printed using the DateTimeFormatter\n\nSample code:\npublic static void main( String[] args ) {\n        Timestamp ts = Timestamp.valueOf( \"1753-01-01 00:00:00.123\" );\n        System.out.println(ts);\n        String sts = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\").print( ts.getTime() );\n        System.out.println(sts);\n    }\n\nOutput:\n1753-01-01 00:00:00.123\n1753-01-01 00:23:28.123\n### Test case\n\nInstant: 1753-01-01 00:00:00.123 or something similar\n\nFormatter:\nDateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\")\n\nAPI: print(java.sqlTimestamp)\n", "url": "https://github.com/JodaOrg/joda-time/issues/395", "user": "srikanthvedanthi", "labels": ["NotABug", "WontFix"], "created": "2016-10-12 11:18:40", "closed": "2016-10-20 22:36:35", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "Partial date (containing day/month/year) does not return Era", "body": "The Joda-Time project has been running for many years now, and the codebase is stable.\nJava SE 8 contains a new date and time library that is the successor to Joda-Time.\nAs such Joda-Time is primarily in maintainence mode and there are few things worthy of being raised as an issue.\n\n**As a general rule, you should raise a question at Stack Overflow, not here.**\n\nBefore raising an issue, please check the [FAQs](http://www.joda.org/joda-time/faq.html).\nPlease also search Stack Overflow and the issue history at GitHub.\nIn particular, if the issue is Android specific, you are unlikely to get any assistance here.\nPlease bear in mind that I've worked on Joda-Time in my spare time, unpaid, for over 15 years.\nAs such, issue response time is likely to be slow.\n\nIn the unlikely event you still think you've found an issue, please delete the text above and describe the problem as follows:\n### Key information\n- Joda-Time version\n- Result of `TimeZone.getDefault()`\n- Result of `DateTimeZone.getDefault()`\n### Problem description\n\nIf Partial date contains all the fields day, month & year and if we try to get the associated Era in it then it is not working. The same thing worked with LocalDate.\n### Test case\n\n```\nDateTimeFieldType[] dateTimeFieldTypeArray = new DateTimeFieldType[3];\ndateTimeFieldTypeArray[0] = DateTimeFieldType.year();\ndateTimeFieldTypeArray[1] = DateTimeFieldType.monthOfYear();\ndateTimeFieldTypeArray[2] = DateTimeFieldType.dayOfMonth();\nint[] values = new int[3];\nvalues[0] = 2016;\nvalues[1] = 9;\nvalues[2] = 23;\nPartial partial = new Partial(dateTimeFieldTypeArray, values, GregorianChronology.getInstance());\n\nSystem.out.println(partial.toString(\"dd MM yyyy G\")); // print 23 09 2016 \ufffd, however it should print 23 09 2016 AD\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/393", "user": "ernitingoel", "labels": ["NotABug", "WontFix"], "created": "2016-10-03 13:48:05", "closed": "2016-10-04 09:37:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Fatal Exception on new DateTime(\"2016-04-01\")", "body": "### Key information\n\nversion :2.9.4\n### Problem description\n\nI have an app on google play and I had thousands of sessions without issues. Last night I got this crash: \n\n```\nFatal Exception: org.joda.time.IllegalInstantException: Cannot parse \"2016-04-01\": Illegal instant due to time zone offset transition (Asia/Amman)\n       at org.joda.time.format.DateTimeParserBucket.computeMillis(SourceFile:471)\n       at org.joda.time.format.DateTimeParserBucket.doParseMillis(SourceFile:182)\n       at org.joda.time.format.DateTimeFormatter.parseMillis(SourceFile:826)\n       at org.joda.time.convert.StringConverter.getInstantMillis(SourceFile:65)\n       at org.joda.time.base.BaseDateTime.(SourceFile:173)\n       at org.joda.time.DateTime.(SourceFile:257)\n```\n\nThe line causing the issue is:\n`DateTime rxDate = new DateTime(tile.account.relation_rx.interest_date);`\n", "url": "https://github.com/JodaOrg/joda-time/issues/391", "user": "trr-amsiq", "labels": ["NotABug", "WontFix"], "created": "2016-09-13 07:00:09", "closed": "2016-09-26 11:51:32", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "DateTimeFormatter.parseDateTime() accepts illegal date string", "body": "- Joda-Time version: joda-time-2.8.2.jar\n### Problem description\n\nJUnit test below is self-explanatory. Result of tests is:\n\n```\nTimeZone.getDefault(): sun.util.calendar.ZoneInfo[id=\"Europe/London\",offset=0,dstSavings=3600000,useDaylight=true,transitions=242,lastRule=java.util.SimpleTimeZone[id=Europe/London,offset=0,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\nDateTimeZone.getDefault(): Europe/London\n\njava.lang.AssertionError: Invalid date string 'Sun Jul 04 2016' did not cause IllegalArgumentException; actual parseDateTime() conversion was: Sun Jul 10 2016\n`\n```\n\n```\n    try {\n        System.out.println(\"TimeZone.getDefault(): \" + TimeZone.getDefault());\n        System.out.println(\"DateTimeZone.getDefault(): \" + DateTimeZone.getDefault());\n        String pattern = \"EEE MMM dd yyyy\";\n        String invalidDateString = \"Sun Jul 04 2016\";\n        //  4th July 2016 was a Monday! \n        DateTime x = DateTimeFormat.forPattern(pattern).parseDateTime(invalidDateString);\n        Fail.fail(\"Invalid date string '\" + invalidDateString + \"' did not cause IllegalArgumentException; actual parseDateTime() conversion was: \" + DateTimeFormat.forPattern(pattern).print(x));\n    }\n    catch (Exception e) {\n        assertTrue(\"Unexpected Exception: \", e instanceof IllegalArgumentException);\n    }\n```\n\n```\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/384", "user": "adriangay", "labels": ["NotABug", "WontFix"], "created": "2016-07-06 14:41:56", "closed": "2016-07-20 21:10:10", "commits": {}, "ttf": 14.000277777777777, "commitsDetails": []}, {"title": "Return wrong timestamp when call withTimeAtStartOfDay() for timezone -04:30", "body": "### Key information\n- Joda-Time version\n  2.9.4\n- Result of `TimeZone.getDefault()`\n  libcore.util.ZoneInfo[id=\"America/Caracas\",mRawOffset=-16200000,mEarliestRawOffset=-16200000,mUseDst=false,mDstSavings=0,transitions=3]\n- Result of `DateTimeZone.getDefault()`\n  America/Caracas\n### Problem description\n\nnew Date(DateTime.now().withTimeAtStartOfDay().getMillis())\nreturn: Sat Jun 18 23:30:00 GMT-04:30 2016\nexpected result: Sun Jun 19 00:00:00 GMT-04:30 2016\n", "url": "https://github.com/JodaOrg/joda-time/issues/382", "user": "pongpatr", "labels": ["Discussion", "NotABug"], "created": "2016-06-19 20:06:13", "closed": "2016-07-23 20:37:30", "commits": {}, "ttf": 34.000277777777775, "commitsDetails": []}, {"title": "how i get  QUARTER first day and last day?", "body": "The Joda-Time project has been running for many years now, and the codebase is stable.\nJava SE 8 contains a new date and time library that is the successor to Joda-Time.\nAs such Joda-Time is primarily in maintainence mode and there are few things worthy of being raised as an issue.\n\n**As a general rule, you should raise a question at Stack Overflow, not here.**\n\nBefore raising an issue, please check the [FAQs](http://www.joda.org/joda-time/faq.html).\nPlease also search Stack Overflow and the issue history at GitHub.\nIn particular, if the issue is Android specific, you are unlikely to get any assistance here.\nPlease bear in mind that I've worked on Joda-Time in my spare time, unpaid, for over 15 years.\nAs such, issue response time is likely to be slow.\n\nIn the unlikely event you still think you've found an issue, please delete the text above and describe the problem as follows:\n### Key information\n- Joda-Time version\n- Result of `TimeZone.getDefault()`\n- Result of `DateTimeZone.getDefault()`\n### Problem description\n### Test case\n", "url": "https://github.com/JodaOrg/joda-time/issues/380", "user": "ryanlove", "labels": ["NotABug", "WontFix"], "created": "2016-06-09 02:01:28", "closed": "2016-06-09 08:24:42", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Erroneous String<->DateTime conversion for 2010-week 1-day 4 until 2010-week 1 day 6", "body": "### Key information\n\nJoda-Time version: 2.9.2\nTimeZone.getDefault(): sun.util.calendar.ZoneInfo[id=\"Europe/Paris\",offset=3600000,dstSavings=3600000,useDaylight=true,transitions=184,lastRule=java.util.SimpleTimeZone[id=Europe/Paris,offset=3600000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\nDateTimeZone.getDefault(): Europe/Paris\n### Problem description\n\nDateTimeFormatter seems to make an error converting the year from String to DateTime around the change from 2009 to 2010, for the industrial date format (yyyy-ww-e). Specifically, for days 2010-01-4 up to and including 2010-01-6, it translates the year as 2009 instead of 2010. \n\nAny dates before those dates or after those dates seem to be unaffected.\n### Test case\n\nimport java.util.TimeZone;\n\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class JodaTimeTest {\n\n```\n@BeforeClass\npublic static void init() {\n    System.out.println(\"TimeZone.getDefault(): \" + TimeZone.getDefault());\n    System.out.println(\"DateTimeZone.getDefault(): \" + DateTimeZone.getDefault());\n}\n\n// Succeeds\n@Test\npublic void post2010() {\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-ww-e\");\n    DateTime dt = fmt.parseDateTime(\"2015-05-6\");\n    Assert.assertEquals(\"2015-05-6\", fmt.print(dt));\n}\n\n// Succeeds\n@Test\npublic void in2010() {\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-ww-e\");\n    DateTime dt = fmt.parseDateTime(\"2010-05-6\");\n    Assert.assertEquals(\"2010-05-6\", fmt.print(dt));\n}\n\n// Fails:\n// org.junit.ComparisonFailure: expected:<20[10]-01-4> but was:<20[09]-01-4>\n\n@Test\npublic void transition2009to2010() {\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-ww-e\");\n    DateTime dt = fmt.parseDateTime(\"2010-01-4\");\n    Assert.assertEquals(\"2010-01-4\", fmt.print(dt));\n}\n\n// Succeeds\n@Test\npublic void pre2010() {\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-ww-e\");\n    DateTime dt = fmt.parseDateTime(\"2009-52-1\");\n    Assert.assertEquals(\"2009-52-1\", fmt.print(dt));\n}\n```\n\n}\n", "url": "https://github.com/JodaOrg/joda-time/issues/362", "user": "jvanloov", "labels": ["NotABug"], "created": "2016-02-26 10:08:54", "closed": "2016-02-26 10:30:16", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Edge case DateTime toString method with a Weekly Formatter produces incorrect Output", "body": "### Key information\n- Joda-Time version: 2.9.1\n- Language: Scala\n### Problem description\n\nThe toString method on the DateTime class produces inconsistent results when used with weekly formats. On Specific dates, namely midnight at the beginning of the year.\n### Test case\n\nNOTE: the magic number there represents midnight on 2016-01-01.\ncode to execute: new DateTime(1451606400000L).toString(DateTimeFormat.forPattern(\"yyyy-ww\"))\n\nexpected result: \"2016-01\"\nobserved result: \"2016-53\"\n", "url": "https://github.com/JodaOrg/joda-time/issues/360", "user": "stevorobs3", "labels": ["Discussion", "NotABug"], "created": "2016-02-23 17:02:01", "closed": "2016-02-23 17:12:22", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LocalDate.toString() returns wrong date for dates on or after Feb 1 2016", "body": "new LocalDate().toString(\"yyyy-MM-DD\") returns \"2016-02-32\" when run today (Feb 1 2016), and unfortunately it doesn't get better for later dates - new LocalDate().plusDays(1).toString(\"yyyy-MM-DD\") returns \"2016-02-33\" and new LocalDate().plusDays(100).toString(\"yyyy-MM-DD\") returns \"2016-05-132\"!!!\n\nI am using joda-time 2.9.2 and JDK/JRE 1.8.0_45. \n", "url": "https://github.com/JodaOrg/joda-time/issues/352", "user": "sarismik", "labels": ["NotABug"], "created": "2016-02-01 16:36:36", "closed": "2016-02-01 16:47:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LocalDate, timestamps and conversions", "body": "Hello the team !\n\nI use conversion from and to long timestamps for storing dates in my database.\nHence, I have this issue :\n\n```\nLocalDate.now() //returns 2015-12-17, which is today\nnew LocalDate(LocalDate.now().toDate().getTime()); //returns 2015-12-16, which is yesterday\n```\n\nCan you reproduce this behavior ?\nIs that a bug ?\n\nAt least this is very unexpected.\nConversions elsewhere in my application don't seem to go wrong though.\n", "url": "https://github.com/JodaOrg/joda-time/issues/338", "user": "DanChaltiel", "labels": ["NotABug"], "created": "2015-12-17 22:10:18", "closed": "2016-01-01 01:24:55", "commits": {}, "ttf": 14.000277777777777, "commitsDetails": []}, {"title": "Cancun time zone is incorrect", "body": "America/Cancun time zone is incorrect in Joda Time 2.9.1. It should be -500 EST but is -600 CST. The time zone changed in February 2015. The release notes for 2.9.1 says\"DateTimeZone data updated to version 2015g\" but 2015g has the correct EST time zone.\n\nhttp://www.joda.org/joda-time/timezones.html shows the incorrect CST time zone.\n\nDoing this in Java also shows incorrect CST time zone:\nDateTimeZone.forID(\"America/Cancun\").getShortName(System.currentTimeMillis());\n", "url": "https://github.com/JodaOrg/joda-time/issues/335", "user": "master-elodin", "labels": ["NotABug"], "created": "2015-12-03 16:37:29", "closed": "2015-12-07 23:09:00", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "Joda's DateTime is inconsistency with Calendar", "body": " The following code will get 2 different result which confuse me.  Is this a bug of Joda's DateTime.\n\n```\n    Calendar c = Calendar.getInstance();\n    c.set(1900, 0, 1, 0, 0, 0);\n    c.set(Calendar.MILLISECOND, 0);\n    System.out.println(c.getTimeInMillis() / 1000);\n    System.out.println(c.getTimeZone());\n    DateTime dt = new DateTime(1900, 1, 1, 0, 0, 0);\n    System.out.println(dt.getMillis() / 1000);\n    System.out.println(dt.getChronology());\n```\n\nOutput I get\n\n```\n-2209017600\nsun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null]\n-2209017952\nISOChronology[Asia/Shanghai]\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/334", "user": "zjffdu", "labels": ["NotABug"], "created": "2015-12-01 07:46:00", "closed": "2015-12-07 23:10:59", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "parseDateTime accepts bad input", "body": "The following API calls both give a result, evenso the second date is not valid:\n\ndateTimeCollectionFormatter = new DateTimeFormatterBuilder();\ndateTimeCollectionFormatter.toFormatter().withZone(currentDateTimeZone).parseDateTime(\"Fri, 05 Jun 2015 02:00 am\") \ndateTimeCollectionFormatter.toFormatter().withZone(currentDateTimeZone).parseDateTime(\"Sat, 05 Jun 2015 02:00 am\") \n\nFrom the second date it is not clear which day is meant. It should not result in an error.\n", "url": "https://github.com/JodaOrg/joda-time/issues/329", "user": "JoernSchimmelpfeng", "labels": ["NotABug", "WontFix"], "created": "2015-11-12 10:23:31", "closed": "2015-11-12 10:30:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Mistake in LocalDateTime construction", "body": "I've start use joda-time instead java.util.Date in my project. After this moment some test are failed.\nIn those tests i use date like 01.01.1900. It is a real example in real system.\n\nI'm execute next code:\n\n``` java\njava.util.Date date = new LocalDateTime(1900, 1, 1, 0, 0, 0, 0).toDate();\nlong timestamp = date.getTime();\njava.util.Date newDate = new LocalDateTime(timestamp).toDate();\n```\n\nThis two dates are not equals.\n\nAfter this i start to search the moment when something goes wrong. I found this moment\n\n``` java\n// When i execute \nnew LocalDateTime(-1688270553000L); // it return me 02.07.1916 23:42:32\n//But when i execute \nnew LocalDateTime(-1688270554000L); // it return me 02.07.1916 23:59:59\n```\n\nI have changed only 1 second, but receive big difference. My timezone is GMT +5 (Yekaterinburg)\n", "url": "https://github.com/JodaOrg/joda-time/issues/322", "user": "RasheR666", "labels": ["NotABug"], "created": "2015-10-15 10:20:56", "closed": "2015-10-15 10:51:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Timezone offset is wrong", "body": "Timezone offset for Norway is wrong. During the summer, until October, it should be CEST (+0200), but it is defined as CET (+0100). I imagine the problem also exist for other cities, Zurich, Stockholm, Madrid, Paris, etc. \n", "url": "https://github.com/JodaOrg/joda-time/issues/317", "user": "johanneslagos", "labels": ["NotABug"], "created": "2015-09-21 07:23:07", "closed": "2015-10-13 21:51:13", "commits": {}, "ttf": 22.00027777777778, "commitsDetails": []}, {"title": "Period calculation inconsistent on months with different number of days", "body": "Not sure if this is a bug but looks like there's an inconsistency on calculating the period back and forth.\n\n```\nLocalDate date = new LocalDate(2015, 7, 31); // July 31st, 2015\nPeriod period = new Period(0, 1, 0, 0, 0, 0, 0, 0); // 1 month\nLocalDate minusDate = date.minus(period); // Got June 30th, 2015\nPeriod calcPeriod = new Period(minusDate, date); // 1 month 1 day\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/314", "user": "klyc0k", "labels": ["NotABug", "WontFix"], "created": "2015-09-09 16:03:11", "closed": "2015-09-17 20:17:43", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "Time Zone Wrong?", "body": "final MutableDateTime mdt2 = new MutableDateTime(2011, 10, 30, 2, 0, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\nSystem.out.println(\"Start date:   \" + mdt2 + \" (\" + mdt2.toInstant().getMillis() + \")\");\nfinal MutableDateTime mdt = new MutableDateTime(2011, 10, 30, 3, 0, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\nSystem.out.println(\"Start date:   \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt2.addHours(-1);\nSystem.out.println(\"addHours(-1): \" + mdt2 + \" (\" + mdt2.toInstant().getMillis() + \")\");\n\nThe first output: Start date:   2011-10-30T02:00:00.000+02:00 (1319932800000)\nThe second output: Start date:   2011-10-30T03:00:00.000+01:00 (1319940000000)\nThe third output: addHours(-1): 2011-10-30T02:00:00.000+01:00 (1319936400000)\n\nApparently different zones. Is this supposed to be?\n", "url": "https://github.com/JodaOrg/joda-time/issues/310", "user": "sunjunhqq", "labels": ["NotABug", "WontFix"], "created": "2015-08-21 07:06:55", "closed": "2015-08-29 20:32:31", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "NullPointerException in deserialized CachedDateTimeZone.getInfo", "body": "Attempting to format to string deserialized instances of DateTime (originally obtained from an HBase instance and then shipped around via scalding-cascading-(kryo?)-tez) results in the following stack:\n\n```\nCaused by: java.lang.NullPointerException\n        at org.joda.time.tz.CachedDateTimeZone.getInfo(CachedDateTimeZone.java:143)\n        at org.joda.time.tz.CachedDateTimeZone.getOffset(CachedDateTimeZone.java:103)\n        at org.joda.time.format.DateTimeFormatter.printTo(DateTimeFormatter.java:676)\n        at org.joda.time.format.DateTimeFormatter.printTo(DateTimeFormatter.java:521)\n        at org.joda.time.format.DateTimeFormatter.print(DateTimeFormatter.java:625)\n        at com.transparencyrights.XXXXX$$anonfun$12.apply(XXXXXX.scala:137)\n        at com.transparencyrights.XXXXX$$anonfun$12.apply(XXXXXX.scala:137)\n        at scala.collection.Iterator$$anon$11.next(Iterator.scala:370)\n        at scala.collection.Iterator$class.foreach(Iterator.scala:742)\n        at scala.collection.AbstractIterator.foreach(Iterator.scala:1194)\n        at com.twitter.scalding.FlatMapFunction.operate(Operations.scala:47)\n        at cascading.flow.stream.element.FunctionEachStage.receive(FunctionEachStage.java:100)\n```\n\nUsing joda-time 2.7 through nscala-time 2.0.0\n\nLooking at the code here https://github.com/JodaOrg/joda-time/blob/v2.7/src/main/java/org/joda/time/tz/CachedDateTimeZone.java#L145 it seems that the issue is that the \"iInfoCache\" transient field initialized at https://github.com/JodaOrg/joda-time/blob/v2.7/src/main/java/org/joda/time/tz/CachedDateTimeZone.java#L84 is deserialized as a null. As CachedDateTimeZone lacks a readResolve() method, there is no chance to initialize iInfoCache.\n\nOr is this a duplicate of https://github.com/JodaOrg/joda-time/issues/65, the blame being on the failure from the serialization library to have applied the writeReplace/(serialize a Stub(id))/readResolve protocol ?\n", "url": "https://github.com/JodaOrg/joda-time/issues/307", "user": "cchepelov", "labels": ["Discussion", "NotABug"], "created": "2015-08-07 10:23:36", "closed": "2015-08-11 12:09:42", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "Can't download from maven central due to checksum errors", "body": "I am seeing this in my builds, after i removed joda-time from my local repo and reran.\n\nCould not transfer metadata joda-time:joda-time/maven-metadata.xml from/to central (http://repo1.maven.org/maven2/): Checksum validation failed, expected bed66f1e4d165a744fb45fe60a4e0afbfa12cc78 but is 458b940ded0c9495327658ff0cc1dfb13b3bc324\n\nI verified the checksum of maven-metadata.xml doesn't match the checksum in the repository for sha1:\n\ncurl http://repo1.maven.org/maven2/joda-time/joda-time/maven-metadata.xml > maven-metadata.xml\n$ shasum maven-metadata.xml\n458b940ded0c9495327658ff0cc1dfb13b3bc324  maven-metadata.xml\n\nbut on central: \n$ curl http://repo1.maven.org/maven2/joda-time/joda-time/maven-metadata.xml.sha1\nbed66f1e4d165a744fb45fe60a4e0afbfa12cc78\n", "url": "https://github.com/JodaOrg/joda-time/issues/293", "user": "jmelching", "labels": ["Discussion", "NotABug"], "created": "2015-06-15 14:04:46", "closed": "2015-06-15 14:08:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Midnight is not accepted", "body": "According to ISO 8601 (see attached screenshots from standard), midnight can be represented as [00:00:00] or [24:00:00] but Joda-Time throws an exception on the later format.\n![screen shot 2015-06-15 at 11 23 04](https://cloud.githubusercontent.com/assets/5843038/8156959/1676d6f6-1351-11e5-8d8f-adc6c2463423.png)\n![screen shot 2015-06-15 at 11 23 15](https://cloud.githubusercontent.com/assets/5843038/8156958/167505ec-1351-11e5-830c-535667277569.png)\n\norg.joda.time.IllegalFieldValueException: Cannot parse \"2010-07-02T24:00:00\": Value 24 for hourOfDay must be in the range [0,23]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:234)\n    at org.joda.time.field.PreciseDateTimeField.set(PreciseDateTimeField.java:112)\n    at org.joda.time.format.DateTimeParserBucket$SavedField.set(DateTimeParserBucket.java:568)\n    at org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:447)\n    at org.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:411)\n    at org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:882)\n", "url": "https://github.com/JodaOrg/joda-time/issues/292", "user": "lastcmaster", "labels": ["NotABug", "WontFix"], "created": "2015-06-15 09:26:58", "closed": "2015-06-15 11:02:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "\"missing no-arg constructor for ISOChronology\" (Kryo Serialization error)", "body": "Hi there, \n\neverytime I try to store a `DateTime` with [SnappyDB](https://github.com/nhachicha/SnappyDB) (which uses [Kryo](https://github.com/EsotericSoftware/kryo)) I get the following error: \n\n```\ncom.esotericsoftware.kryo.KryoException: \nClass cannot be created (missing no-arg constructor): org.joda.time.chrono.ISOChronology\nSerialization trace:\niChronology (org.joda.time.DateTime)\n```\n\nI believe, it's not an Android-specific issue, that's why I posted it here.\n\nIs there a workaround for this?\nThanks in advance and keep up the great work!\n\n**Edit:** I just found [these kryo-serializers by magro](https://github.com/magro/kryo-serializers) and will try it out.\n\n**Edit2:** After some trying it works great! SnappyDB just needs to know about the custom serializer by using the integrated Builder or calling this:\n\n```\nmySnappyDb.getKryoInstance().register(DateTime.class, new JodaDateTimeSerializer() );\n```\n\nCan be closed.\n", "url": "https://github.com/JodaOrg/joda-time/issues/290", "user": "an-k", "labels": ["Discussion", "NotABug"], "created": "2015-06-11 08:28:38", "closed": "2015-06-15 13:59:13", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "ISODateTimeFormat.dateTimeParser() does not parse timezone", "body": "If I understand the documentation correctly, ISODateTimeFormat.dateTimeParser() parses an optional timezone. So in this code:\n\n```\n    DateTimeFormatter parser=ISODateTimeFormat.dateTimeParser();\n    DateTime dt=parser.parseDateTime(\"2015-05-08T14:43:00+00:00\");\n    Date d=dt.toDate();\n    int offset=d.getTimezoneOffset();\n```\n\nI'd expect offset to be 0, but it comes out -120, which is my timezone.\n", "url": "https://github.com/JodaOrg/joda-time/issues/277", "user": "bunkenburg", "labels": ["NotABug", "WontFix"], "created": "2015-05-19 14:17:56", "closed": "2015-05-20 20:49:14", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "Redundant check: upper/lowwer case -> equalsIgnoreCase", "body": "Hi! I've been struggling with my own issue using jada-time project and found a redundant check ( imho ) in file <b>DateTimeFormatterBuilder.java<b> in method public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position).\n\nThere is a check for two strings equality, first based on <b>toUpperCase</b> string transformation and if we had no luck, then <b>toLowwerCase</b> transformation, which is unnecessary since if first check gonna fail than the second one wont  success either...\n", "url": "https://github.com/JodaOrg/joda-time/issues/271", "user": "bugsend", "labels": ["NotABug", "WontFix"], "created": "2015-04-29 09:33:45", "closed": "2015-04-29 09:51:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Bug in addSeconds()?", "body": "**Code:**\n\n```\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\n\nimport org.joda.time.DateTime.Property;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\n\n\npublic class joda_datetime2 {\n\n    public static void main(String[] args) {\n        long time = 1174788000000L;\n        int interval = -49680;\n        SimpleDateFormat sdt = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n\n        /* CALENDAR */\n        Calendar c = Calendar.getInstance();\n        c.setTimeInMillis(time);\n        System.out.println(\"CALENDAR1: \" + sdt.format(c.getTime()) + \" - \" + c.getTimeZone());\n        c.set(Calendar.SECOND, c.get(Calendar.SECOND)+interval);\n        System.out.println(\"CALENDAR2: \" + sdt.format(c.getTime()) + \" - \" + c.getTimeZone());\n\n        /* JODA */\n        MutableDateTime mdt = new MutableDateTime(time);\n        System.out.println(\"____JODA1: \" + sdt.format(mdt.toDate()) + \" - \" + mdt.getZone().toTimeZone());\n        mdt.addSeconds(interval);\n        System.out.println(\"____JODA2: \" + sdt.format(mdt.toDate()) + \" - \" + mdt.getZone().toTimeZone());\n    }\n\n}\n```\n\n**Results:**\n\n> CALENDAR1: 2007-03-25T09:00:00.000+07:00 - sun.util.calendar.ZoneInfo[id=\"Asia/Novosibirsk\",offset=21600000,dstSavings=0,useDaylight=false,transitions=68,lastRule=null]\n> CALENDAR2: 2007-03-24T**19**:12:00.000+06:00 - sun.util.calendar.ZoneInfo[id=\"Asia/Novosibirsk\",offset=21600000,dstSavings=0,useDaylight=false,transitions=68,lastRule=null]\n> ____JODA1: 2007-03-25T09:00:00.000+07:00 - sun.util.calendar.ZoneInfo[id=\"Asia/Novosibirsk\",offset=21600000,dstSavings=0,useDaylight=false,transitions=68,lastRule=null]\n> ____JODA2: 2007-03-24T**18**:12:00.000+06:00 - sun.util.calendar.ZoneInfo[id=\"Asia/Novosibirsk\",offset=21600000,dstSavings=0,useDaylight=false,transitions=68,lastRule=null]\n", "url": "https://github.com/JodaOrg/joda-time/issues/266", "user": "bojlxb", "labels": ["Discussion", "NotABug"], "created": "2015-04-14 14:18:23", "closed": "2015-04-25 14:17:14", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "JodaTime contructor gives different results for very old dates (< 1891-10-02)", "body": "Hello.\n\nFor dates older then 1891-10-02 the results are different for:\na) LocalDate.fromCalendarFields(Calendar) and LocalDate.fromDateFields(Date)\nb) new LocalDate(long) and new LocalDate(Date)\n\nDifference starts at 2nd October 1891 and is increasing while going to the past.\n\nLocalDate.fromDateFields(Date) and new LocalDate(Date) should imho return the same LocalDate.\n\nPossible connection with timeZone sensitiveness java.util.Date https://github.com/JodaOrg/joda-time/issues/91\n\nReproduction:\n\n```\n    public static void main(String[] args) {\n        System.out.println(LocalDate.class.getPackage().getImplementationVersion());\n        testDate(new GregorianCalendar(2015, 0, 2));\n        testDate(new GregorianCalendar(1891, 9, 2));\n        testDate(new GregorianCalendar(1891, 9, 1));\n        testDate(new GregorianCalendar(1, 0, 2));\n    }\n\n    private static void testDate(Calendar cal) {\n        System.out.print(\"fromCal: \" + LocalDate.fromCalendarFields(cal));\n        System.out.print(\" fromDate: \" + LocalDate.fromDateFields(cal.getTime()));\n        System.out.print(\" constr. date: \" + new LocalDate(cal.getTimeInMillis()));\n        System.out.print(\" constr. millis: \" + new LocalDate(cal.getTime()));\n        // System.out.print(\" GJCH constr. \" + new LocalDate(cal.getTimeInMillis(), GJChronology.getInstance()));\n\n\n        System.out.print(\" -- \");\n\n        long jodaDateMs = new LocalDate(cal.getTimeInMillis()).toDate().getTime();\n        long dateMs = new Date(cal.getTimeInMillis()).getTime();\n        //      System.out.print(\" JODA from millis: \"+jodaDateMs);\n        //      System.out.print(\" Date from millis: \"+dateMs);\n        System.out.print(\" Diff in hours: \"+(jodaDateMs-dateMs)/1000/60/60);\n        System.out.println();\n    }\n```\n\nOutput:\n\n> 2.7\n> fromCal: 2015-01-02 fromDate: 2015-01-02 constr. date: 2015-01-02 constr. millis: 2015-01-02 --  Diff in hours: 0\n> fromCal: 1891-10-02 fromDate: 1891-10-02 constr. date: 1891-10-02 constr. millis: 1891-10-02 --  Diff in hours: 0\n> fromCal: 1891-10-01 fromDate: 1891-10-01 constr. date: 1891-09-30 constr. millis: 1891-09-30 --  Diff in hours: -24\n> fromCal: 0001-01-02 fromDate: 0001-01-02 constr. date: 0000-12-30 constr. millis: 0000-12-30 --  Diff in hours: -72\n", "url": "https://github.com/JodaOrg/joda-time/issues/264", "user": "rsebestik", "labels": ["Discussion", "NotABug"], "created": "2015-04-09 13:42:49", "closed": "2015-04-25 14:36:38", "commits": {}, "ttf": 16.00027777777778, "commitsDetails": []}, {"title": "Bug with DST in Period", "body": "We found problem when we tried to find hours difference between two dates using CET timezone with DST. Bellow you can see tests, test **twentyFiveHoursDifference_endPlusDay will fail** and twentyFiveHoursDifference_startMinusDay will pass.\n\n``` java\npublic class JodaPeriodTZBugTest {\n\n    private DateTime start = new LocalDateTime(2015, 3, 29, 1, 0).toDateTime(DateTimeZone.forID(\"CET\"));\n    private DateTime end = new LocalDateTime(2015, 3, 29, 3, 0).toDateTime(DateTimeZone.forID(\"CET\"));\n\n    @Test\n    public void oneHourDifference() {\n        assertEquals(1, new Period(start, end).toStandardDuration().toStandardHours().getHours());\n    }\n\n\n    @Test\n    public void twentyFiveHoursDifference_endPlusDay() {\n        assertEquals(25, new Period(start, end.plusDays(1)).toStandardDuration().toStandardHours().getHours());\n    }\n\n    @Test\n    public void twentyFiveHoursDifference_startMinusDay() {\n        assertEquals(25, new Period(start.minusDays(1), end).toStandardDuration().toStandardHours().getHours());\n    }\n\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/261", "user": "mind-blowing", "labels": ["Discussion", "NotABug"], "created": "2015-03-30 13:36:39", "closed": "2015-04-26 11:24:17", "commits": {"6e008a1c643f4dce6cf23cae3587f7d463a0562a": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 26.00027777777778, "commitsDetails": [{"commitHash": "6e008a1c643f4dce6cf23cae3587f7d463a0562a", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["d9d4806d4135046d3f3d1d6e93e0a1f5e1aa3ff4"], "nameRev": "6e008a1c643f4dce6cf23cae3587f7d463a0562a tags/v2.8~5", "commitMessage": "Clarify period addition Javadoc\n\nSee #261\n", "commitDateTime": "2015-04-26 12:25:03", "authoredDateTime": "2015-04-26 12:16:58", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/Period.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Period.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6e008a1c643f4dce6cf23cae3587f7d463a0562a"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 20, "deletions": 0, "lines": 20, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"]}, {"title": "DateTime plusDays calculation is wrong for 100K offset from 1/1/1901", "body": "Calculating Date of Century offset for FX/MM and Lending offset calculations:-\n\n1901/01/01 is the 1st day of the 20th Century. \n\nSo 100,000 days from 1901/01/01 is 2174/10/15. However the plusDays function calculates it as 2174/10/16?\n\n```\n    DateTime startDate = new DateTime(1901,1,1,0,0);\n    DateTime endDate = new DateTime(2174,10,15,0,0);\n    Days d = Days.daysBetween(startDate, endDate);\n    int days = d.getDays() +1 ;  // add 1 to get DOC 100,000 for 15-10-2174\n    System.out.println(days);\n\n    DateTime startDate2 = new DateTime(1901,1,1,12,0);\n    DateTime endDate2 = startDate2.plusDays(100000) ;\n    System.out.println(endDate2.toDate()); // gives Sun Oct 16 12:00:00 BST 2174\n```\n\nUsing Joda-time-2.4 jar \n", "url": "https://github.com/JodaOrg/joda-time/issues/245", "user": "macroba1", "labels": ["NotABug"], "created": "2015-02-24 17:37:59", "closed": "2015-02-24 17:44:03", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "24h time format parsing bug", "body": "Format parser assumes wrong value bounds for 24h time format.\nCurrently bounds are being set to `[1,24]` and should be `[0,23]`.\n\nFor example, using pattern `\"yyyy-MM-dd kk:mm:ss\"` for parsing `2014-04-25 00:57:55` will result in error:\n\n```\norg.joda.time.IllegalFieldValueException: Cannot parse \"2014-04-25 00:57:55\": Value 0 for clockhourOfDay must be in the range [1,24]\n```\n\n(`00:57:55` is a proper time format for 57 minutes past midnight)\n\n(just to be clear - testing version 2.7)\n", "url": "https://github.com/JodaOrg/joda-time/issues/240", "user": "blipinsk", "labels": ["NotABug", "WontFix"], "created": "2015-02-05 15:30:56", "closed": "2015-02-10 15:30:49", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "parsing ISO 8601 defect?", "body": "Using the DateTimeFormatterBuilder.appendTimeZoneOffset method, I can create valid ISO8601 strings like this: \"2004-03-15T12:34:56.789Z\".   However, I can't get any strings containing the \"Z\" character to be parsed.  Is this a known issue? Does it only support the \"+/-hhmm\" syntax?\n", "url": "https://github.com/JodaOrg/joda-time/issues/235", "user": "sbartram", "labels": ["NotABug", "WontFix"], "created": "2015-01-31 00:02:20", "closed": "2015-02-02 14:31:52", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "DateTimeFormat.forPattern(\"yyyyww\") not working properly", "body": "Hi,\n\nI have some troubles with parsing a specific format to a date. When I want to parse \"201401\" with the given format 'yyyyww', I'd expect the library to return the first week of the year 2014. I tried with several other years and weeks which all seem to work fine, but in this special case it returns the 29th of december 2014, which is not correct. Native Java (DateFormat) works as expected.\n\nHere is the example to reproduce:\n\npublic class Test {\n\n```\npublic static void main(String args[]) throws ParseException {\n\n    DateTimeFormatter dtfOut = DateTimeFormat.forPattern(\"yyyyww\");\n    System.out.println(\"Formatted with Joda: \\t\\t\" + dtfOut.parseDateTime(\"201401\").toString());\n\n    DateFormat dfmt = new SimpleDateFormat(\"yyyyww\");\n    System.out.println(\"Formatted with native Java: \\t\" + dfmt.parse(\"201401\").toString());\n\n}\n```\n\n}\n\nOutput:\n\nFormatted with Joda:        2014-12-29T00:00:00.000+01:00   -> not correct\nFormatted with native Java:     Mon Dec 30 00:00:00 CET 2013    -> correct\n\nI'm using the latest version of Joda (2.7)\n", "url": "https://github.com/JodaOrg/joda-time/issues/226", "user": "andreaskuehne", "labels": ["NotABug", "WontFix"], "created": "2015-01-14 09:49:05", "closed": "2015-01-26 20:48:33", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "UTCDateTimeZone class has package private access", "body": "Hi!\n\nWe are using JodaTime in conjunction with SimpleXml for serialization. We cannot define a binding between object and converter in package other than org.joda.time. Would it be ok to make UTCDateTimeZone class public?\n\nBest regards!\nSlawomir\n", "url": "https://github.com/JodaOrg/joda-time/issues/225", "user": "smpawlowski", "labels": ["NotABug", "WontFix"], "created": "2015-01-13 14:52:08", "closed": "2015-01-16 14:36:01", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "DateTimeZone.forID(String) returns wrong dtz for 196 of 582 available IDs", "body": "Here's the unit test I used to find this bug\n\n```\n@Test\npublic void testTZ() {\n    Set<String> tzs = DateTimeZone.getAvailableIDs();\n    for (String tz : tzs) {\n        DateTimeZone dtz = DateTimeZone.forID(tz);\n        if (!tz.equals(dtz.getID())) {\n            java.lang.System.err.println(tz + \" does not equal \" + dtz.getID());\n        } else {\n            java.lang.System.out.println(tz + \" equals \" + dtz.getID());\n        }\n    }\n}\n```\n\nMy current workaround is to use the Java 8 TimeZone class.\n", "url": "https://github.com/JodaOrg/joda-time/issues/224", "user": "er2", "labels": ["NotABug", "WontFix"], "created": "2015-01-08 16:33:16", "closed": "2015-01-08 16:43:50", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "in LocalDate.fromDateFields blocking/waiting in mutli-thread environment", "body": "Hi the following works fine in single thread environment.\nBut when run in mutli-thread, it is blocking and waiting for LocalDate.fromDateFields for each thread....\nand result in very slow response .... Any work around for that ?\n\npublic static String format(Date inDate) {\n                DateTimeFormatter fmt = DateTimeFormat.forPattern(dateFormatStr);\n                LocalDate jodaDate = LocalDate.fromDateFields(inDate);\n                    return jodaDate.toString(fmt);\n}\n", "url": "https://github.com/JodaOrg/joda-time/issues/219", "user": "tcmak1", "labels": ["NotABug", "WontFix"], "created": "2014-12-19 08:56:04", "closed": "2015-01-04 22:48:27", "commits": {}, "ttf": 16.00027777777778, "commitsDetails": []}, {"title": "Android ART issue - java.lang.AbstractMethodError: ", "body": "My app used to work just fine using joda -time.\nIt now crashes with Lollipop (Android 5.0)  or any device using ART ONLY when it is built for prod using proguard.\n\nI can see 2 things:\n- When I try to run the app, I have an a java.lang.AbstractMethodError\n  11-20 22:35:46.492: E/AndroidRuntime(28677): java.lang.AbstractMethodError: abstract method \"long aih.f()\"\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at ais.<init>(SourceFile:46)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at aih.assemble(SourceFile:273)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at org.joda.time.chrono.GregorianChronology.assemble(SourceFile:192)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at org.joda.time.chrono.AssembledChronology.a(SourceFile:323)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at org.joda.time.chrono.AssembledChronology.<init>(SourceFile:102)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at aih.<init>(SourceFile:131)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at ain.<init>(SourceFile:75)\n  11-20 22:35:46.492: E/AndroidRuntime(28677):    at org.joda.time.chrono.GregorianChronology.<init>(SourceFile:148)\n- In the LoCat I see dex2oat warnings during compilation\n  11-21 00:30:43.988: W/dex2oat(9163): Before Android 4.1, method int org.joda.time.chrono.EthiopicChronology.c() would have incorrectly overridden the package-private method in aij\n  11-21 00:30:43.988: W/dex2oat(9163): Before Android 4.1, method int org.joda.time.chrono.EthiopicChronology.d() would have incorrectly overridden the package-private method in aij\n  11-21 00:30:43.988: W/dex2oat(9163): Before Android 4.1, method long org.joda.time.chrono.EthiopicChronology.g(int) would have incorrectly overridden the package-private method in aij\n\nIf you go to \"Verifying App Behavior on the Android Runtime (ART) \" (https://developer.android.com/guide/practices/verifying-apps-art.html)\nThey warn of model change : Object model changes\nDalvik incorrectly allowed subclasses to override package-private methods. ART issues a warning in such cases. That seems to be the case.\n\nHas anyone seen that problem?\nCan anyone help solve this?\n\nThks\n", "url": "https://github.com/JodaOrg/joda-time/issues/207", "user": "hlaurent", "labels": ["NotABug", "WontFix"], "created": "2014-11-20 23:48:39", "closed": "2014-11-26 17:47:25", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "can't set 31 day of month to cotr", "body": "", "url": "https://github.com/JodaOrg/joda-time/issues/200", "user": "andrew--i", "labels": ["NotABug", "WontFix"], "created": "2014-10-31 10:16:03", "closed": "2014-11-20 19:12:25", "commits": {}, "ttf": 20.00027777777778, "commitsDetails": []}, {"title": "AbstractPeriod and BaseSingleFieldPeriod with the same period are not equal", "body": "It seems odd that `Days.ONE.equals(Period.days(1))` is false.\n", "url": "https://github.com/JodaOrg/joda-time/issues/199", "user": "ghost", "labels": ["NotABug", "WontFix"], "created": "2014-10-23 21:23:27", "closed": "2014-10-23 21:36:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ISODateTimeFormat not deserializing it's own serialization", "body": "ISODateTimeFormat cannot deserialize the time zone of it's own serialization. Check out the following class and test code. The test fails.\n\n```\npublic class DateTimeIO {\n    private final DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTime();\n\n    public String serialize(DateTime dateTime) {\n        return dateTime.toString(dateTimeFormatter);\n    }\n    public DateTime deserialize(String dateTimeString) {\n        return dateTimeFormatter.parseDateTime(dateTimeString);\n    }\n}\n\n public class DateTimeIOTest {\n\n    private final DateTimeIO dateTimeIO = new DateTimeIO();\n\n    private final DateTime dateTime = new DateTime(2014, 10, 1, 23, 59, 2, 100, DateTimeZone.forOffsetHours(5));\n\n    @Test\n    public void convertsDateTimeCorrectly() {\n        String dateTimeString = dateTimeIO.serialize(dateTime);\n        DateTime afterDeserialization = dateTimeIO.deserialize(dateTimeString);\n        Assert.assertEquals(\"Time serialization should not change the time\", dateTime, afterDeserialization);\n    }\n}\n\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/197", "user": "kroeber", "labels": ["NotABug", "WontFix"], "created": "2014-10-23 08:51:26", "closed": "2014-10-23 21:35:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Bug: org.joda.time.IllegalFieldValueException: Value 0 for monthOfYear must be in the range [1,12]", "body": "10-02 17:52:25.617: E/AndroidRuntime(24239): org.joda.time.IllegalFieldValueException: Value 0 for monthOfYear must be in the range [1,12]\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:252)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.chrono.BasicChronology.getDateMidnightMillis(BasicChronology.java:612)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.chrono.BasicChronology.getDateTimeMillis(BasicChronology.java:159)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.chrono.GregorianChronology.getDateTimeMillis(GregorianChronology.java:1)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.chrono.AssembledChronology.getDateTimeMillis(AssembledChronology.java:120)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.LocalDate.(LocalDate.java:457)\n10-02 17:52:25.617: E/AndroidRuntime(24239): at org.joda.time.LocalDate.(LocalDate.java:436)\n", "url": "https://github.com/JodaOrg/joda-time/issues/188", "user": "Shahroz16", "labels": ["Discussion", "NotABug"], "created": "2014-10-02 15:30:21", "closed": "2014-10-03 00:09:41", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Source Tarball for version 2.4 does not build", "body": "Twenty-four source files in the Joda-Time 2.4 release import the classes \"org.joda.convert.FromString\" and/or \"org.joda.convert.ToString\", which do not exist.\n\nThe snapshot seems to have been created from a broken build.\n", "url": "https://github.com/JodaOrg/joda-time/issues/184", "user": "SigmaX", "labels": ["NotABug", "WontFix"], "created": "2014-09-20 23:56:57", "closed": "2014-09-21 02:10:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Unable to parse if timezone is in middle of date ", "body": "The parser errors out if the date is \"Tue Sep 16 13:37:51 CDT 2014\" and formatter  pattern is \"EEE MMM dd HH:mm:ss yyyy\". If I use the same pattern it gives proper output\n", "url": "https://github.com/JodaOrg/joda-time/issues/180", "user": "sanjaygoad", "labels": ["Discussion", "NotABug"], "created": "2014-09-18 22:42:10", "closed": "2014-10-03 00:09:16", "commits": {}, "ttf": 14.000277777777777, "commitsDetails": []}, {"title": "Method DateTime#plusWeeks does not always return a copy of the object, in contrast to its JavaDoc statement", "body": "The JavaDoc of the Method DateTime#plusWeeks states that \"Returns a copy of this datetime plus the specified number of weeks.\".\n\nHowever, the implementation of the method is as follows:\nif (weeks == 0) {return this;} ...\n", "url": "https://github.com/JodaOrg/joda-time/issues/174", "user": "hsudbrock", "labels": ["NotABug", "WontFix"], "created": "2014-09-11 12:04:00", "closed": "2014-09-12 23:34:34", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "HourOfDay parsed as zero if formatter made with DateFormatBuilder is used", "body": "```\nval formatter = new DateTimeFormatterBuilder()\n    .appendLiteral(\"added \")\n    .appendMonthOfYearText()\n    .appendLiteral(' ')\n    .appendDayOfMonth(2)\n    .appendLiteral(' ')\n    .appendYear(4, 4)\n    .appendLiteral(\" at \")\n    .appendHourOfDay(2)\n    .appendLiteral(\":\")\n    .appendMinuteOfDay(2)\n    .toFormatter\n    .withZoneUTC()\n\nval s1 = \"added December 11 2014 at 05:45\"\nval s2 = \"added December 11 2014 at 14:45\"\n\nval date1 = DateTime.parse(s1, formatter)\nval date2 = DateTime.parse(s2, formatter)\n\nprintln(date1)\nprintln(date2)\n```\n\nInstead of expected \n\n```\n2014-12-11T05:45:00.000Z\n2014-12-11T14:45:00.000Z\n```\n\nI get \n\n```\n2014-12-11T00:45:00.000Z\n2014-12-11T00:45:00.000Z \n```\n\nAt the same time I can get proper value using\n\n```\nval formatter2 = DateTimeFormat.forPattern(\"'added' MMMM dd yyyy 'at' HH:mm\").withZoneUTC()\n```\n\nor\n\n```\nval formatterTime = DateTimeFormat.forPattern(\"HH:mm\")\nval formatter3 = new DateTimeFormatterBuilder()\n    .appendLiteral(\"added \")\n    .appendMonthOfYearText()\n    .appendLiteral(' ')\n    .appendDayOfMonth(2)\n    .appendLiteral(' ')\n    .appendYear(4, 4)\n    .appendLiteral(\" at \")\n    .append(formatterTime)\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/172", "user": "ov7a", "labels": ["NotABug", "WontFix"], "created": "2014-09-05 08:41:53", "closed": "2014-09-08 16:37:10", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "problem with DateTime.parse - dont recognize pattern", "body": "Hi all,\n\ni'm using a JodaTime 2.4 and, in my project we have a problem:\nAll the time when call the static method DateTime.parse, input new Date().toString() (this'll return a string formated on ISO-8602 definition) and DateTimeFormat.forParse(\"YYYY-MM-dd\"), it has returned  IllegalArgumentsException with description \"malformat pattern\".\n\nCan you tell us, please, if really is a bug or JodaTime do not have a way to receive this pattern ? Following the code line:\n\nDateTime.parse(DateTime.now().toString(),DateTimeFormat.forPattern(\"YYYY/MM/dd\")));\n\nThanks,\n\nDouglas.\n", "url": "https://github.com/JodaOrg/joda-time/issues/170", "user": "douggs", "labels": ["NotABug", "WontFix"], "created": "2014-08-28 21:00:31", "closed": "2014-09-08 16:37:39", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "Wrong DateTimeFormat.forStyle(\"M-\") with polish locale.", "body": "Hi,\n\nI found problem with DateTimeFormatter with polish locale.\n\nDateTimeFormat.forStyle(\"S-\").withLocale(new Locale(\"pl\", \"PL\")) - return \"dd.MM.yy\"\nDateTimeFormat.forStyle(\"M-\").withLocale(new Locale(\"pl\", \"PL\")) - return \"yyyy-MM-dd\" - WRONG FORMAT\n\nFor example, for German locale it returns good format - \"dd.MM.yyyy\". For polish should return same.\n", "url": "https://github.com/JodaOrg/joda-time/issues/167", "user": "paulek", "labels": ["NotABug", "WontFix"], "created": "2014-08-13 13:23:21", "closed": "2014-08-13 23:02:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Constracting a period from two local dates (start/end) and using it to recalculate back the end date gives a wrong result if start date falls on 31st of the month.", "body": "Ran into this problem in the application I support.\nHere is the unit test I wrote that shows the problem:\n    @Test\n    public void testJoda(){\n        LocalDate start = new LocalDate(2014, 7, 31);\n        LocalDate end = new LocalDate(2014, 9, 17);\n        Period p = Period.fieldDifference(start, end);\n        LocalDate recalculatedEnd = start.plus(p);\n        assertEquals(end, recalculatedEnd);\n    }\n", "url": "https://github.com/JodaOrg/joda-time/issues/165", "user": "nagirigo", "labels": ["NotABug", "WontFix"], "created": "2014-08-11 22:01:46", "closed": "2014-08-11 22:09:59", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Islamic date conversions are one day off", "body": "This code outputs 10/09/1435. The expected result is 10/10/1435\n\n``` java\nString date = \"8/6/2014\";\n\nfinal DateTimeZone SAUDI_ARABIA = DateTimeZone.forID( \"Asia/Riyadh\" );\nfinal DateTimeFormatter inputFormat = DateTimeFormat.forPattern( \"MM/dd/yyyy\" ).withZone( SAUDI_ARABIA );\nfinal DateTimeFormatter outputFormat = DateTimeFormat.forPattern( \"MM/dd/yyyy\" ).withZone( SAUDI_ARABIA );\n\nfinal DateTime dateTime = inputFormat.parseDateTime(date);\nDateTime hijriDate = dateTime.withChronology( IslamicChronology.getInstance( SAUDI_ARABIA, IslamicChronology.LEAP_YEAR_16_BASED ) );\n//hijriDate = hijriDate.withFieldAdded( DurationFieldType.days(), 1 ); //FIX!!! Joda time is always off by one day. This fixes it :-P\n\nSystem.out.println( outputFormat.print( hijriDate ) );\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/163", "user": "jessebarnum", "labels": ["NotABug", "WontFix"], "created": "2014-08-08 21:57:48", "closed": "2014-08-11 21:41:40", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Re-parsing the output of ISODateTimeFormat.time() throws IllegalArgumentException", "body": "I'm not sure if this is a bug but, at the very least, `ISODateTimeFormat.time()` is not behaving as I expect. If I create a `DateTimeFormatter` from `ISODateTimeFormat.time()` then serialize a `LocalTime` then try to re-parse the serialized `LocalTime` I get an `IllegalArgumentException`. `ISODateTimeFormat.time()` is serializing in a different format from the one it expects to parse.\n\nIt serializes dates in the format `HH:mm:ss.SSS` but expects strings to be parsed about to be in the format `HH:mm:ss.SSSZ`. \n\nI was expecting the serialization format and the expected parsable format to be the same. Are they intentionally different? Or am I just making an error somewhere?\n\nJUnit4 test case:\n\n``` java\npackage test;\n\nimport org.joda.time.LocalTime;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\nimport org.junit.Test;\n\npublic class ISODateTimeFormatTest {\n\n    @Test\n    public void serializeThenParse() {\n        DateTimeFormatter formatter = ISODateTimeFormat.time().withZoneUTC();\n        LocalTime localTime = new LocalTime(12, 34, 56);\n\n        String serializedLocalTime = formatter.print(localTime);\n\n        // 12:34:56.000\n        System.out.println(serializedLocalTime);\n\n        // This works\n        formatter.parseLocalTime(\"12:34:56.000+00:00\");\n\n        // This throws IllegalArgumentException: Invalid format \"12:34:56.000\" is too short\n        formatter.parseLocalTime(serializedLocalTime);\n    }\n\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/162", "user": "petedmarsh", "labels": ["NotABug", "WontFix"], "created": "2014-08-07 14:56:48", "closed": "2014-08-11 21:44:26", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": " minusMonths is not working correctly", "body": "Hello Team , thanks for your efforts , though to share with you that i have found serious bug in \"minusMonths\" method of JODA Api, it wrongly calculates the days. please feel free to contact should you need any more details. .\n\nThanks a lot for making life easier for java community.\n\nKind Regards\nraky\n\nCalendar calObj = new GregorianCalendar();\ncalObj.setTimeZone(TimeZone.getTimeZone(\"Europe/london\"));\nDate todayDate = calObj.getTime();\nDateTime todayDateObj = new DateTime(todayDate.getTime());\n\nDateTime backDaysObj=todayDateObj.minusDays(9);\nDateTime backMonthObj=backDaysObj.minusMonths(10);\nDateTime backYearObj=backMonthObj.minusYears(10);\n\nassertEquals(\"Age is 9 Days 10 Months 10 Years\", \"-10Years-10Months-9Days\",\n\nWhen the days/months/tears are subtracted and compared again with \"current date\" Joda api does not pass Junit test for all months ie. (I have used JODA Api for age calculation when dob is provided)\n\nJunit test : \nbackDaysObj.minusMonths(1);Actual -10Years-1Months-8Days, expected -10Years-1Months-9Days\nbackDaysObj.minusMonths(2); PASS\n\nbackDaysObj.minusMonths(3);Fail Act-10Years-3Months-9Days Expctd-10Years-3Months-8Days\n\nbackDaysObj.minusMonths(4);PASS\n\nbackDaysObj.minusMonths(5);Fail -10Years-5Months-9Days -10Years-5Months-7Days\nbackDaysObj.minusMonths(6);PASS\nbackDaysObj.minusMonths(7);PASS\nbackDaysObj.minusMonths(8);FAIL -10Years-8Months-9Days -10Years-8Months-8Days\nbackDaysObj.minusMonths(9);PASS\nbackDaysObj.minusMonths(10);Fail -10Years-10Months-9Days -10Years-10Months-8Days\nbackDaysObj.minusMonths(11); PASS\n", "url": "https://github.com/JodaOrg/joda-time/issues/160", "user": "raky35", "labels": ["Discussion", "NotABug"], "created": "2014-08-03 17:18:33", "closed": "2014-10-03 00:19:02", "commits": {}, "ttf": 60.000277777777775, "commitsDetails": []}, {"title": "Interval::isBefore with zero Duration", "body": "```\nDateTime today = new DateTime();\nDateTime tomorrow = new DateTime().plusDays(1);\n\nInterval i1 = new Interval(today, today);\nInterval i2 = new Interval(today, tomorrow);\nInterval i3 = new Interval(tomorrow, tomorrow);\n\nif (i1.isBefore(i2)) System.out.println(\"i1 before i2\"); // \"i1 before i2\"\nif (i2.isBefore(i1)) System.out.println(\"i2 before i1\"); // \"\"\nif (i2.isBefore(i3)) System.out.println(\"i2 before i3\"); // \"i2 before i3\"\n```\n\nAs the start of an Interval is inclusive I would expect neither i1 before i2 nor i2 before i1. In fact, i1 and i2 are concurrent. Am I missing something? \n\nThanks for the great work,\n\nAndreas\n", "url": "https://github.com/JodaOrg/joda-time/issues/158", "user": "acnb", "labels": ["NotABug", "WontFix"], "created": "2014-07-31 08:55:56", "closed": "2014-08-02 06:37:12", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "Today (31 July 2014) is not a valid Date according to JodaTime 2.4", "body": "2014/07/31 06:17:49.434 ERROR \norg.joda.time.IllegalFieldValueException: Value 31 for dayOfMonth must be in the range [1,30]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:236)\n    at org.joda.time.chrono.BasicChronology.getDateMidnightMillis(BasicChronology.java:614)\n    at org.joda.time.chrono.BasicChronology.getDateTimeMillis(BasicChronology.java:177)\n    at org.joda.time.chrono.AssembledChronology.getDateTimeMillis(AssembledChronology.java:133)\n    at org.joda.time.chrono.ZonedChronology.getDateTimeMillis(ZonedChronology.java:118)\n    at org.joda.time.chrono.AssembledChronology.getDateTimeMillis(AssembledChronology.java:133)\n    at org.joda.time.base.BaseDateTime.<init>(BaseDateTime.java:254)\n    at org.joda.time.base.BaseDateTime.<init>(BaseDateTime.java:195)\n    at org.joda.time.DateTime.<init>(DateTime.java:381)\n", "url": "https://github.com/JodaOrg/joda-time/issues/157", "user": "AdrianWilford", "labels": ["NotABug", "WontFix"], "created": "2014-07-31 04:28:16", "closed": "2014-07-31 06:27:50", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "YearMonth + DateTimeFormatter returning \"????\" for year value", "body": "My YearMonth objects are instantiated properly but do not print properly.\nexpected = \"May, 2000\"\nactual = \"May, ????\"\n\nWhat I did:\nIn a class called FilterPanel I have...\n\n<code>\npublic static DateTimeFormatter DATEFORMATTER = new DateTimeFormatterBuilder()\n    .appendPattern(\"MMMM, YYYY\").toFormatter();\n</code>\n\nNote: DATEFORMATTER works as expected in one of my methods using DateTime objects.\n\nIn the code below, the variable \"panel\" is an instance of FilterPanel and the lower_bound is a String \"May, 2000\"; the upper_bound is a String \"January 2009\". 'beg' and 'end' are YearMonth Objects to be used in a loop later.\n\n<code>\n YearMonth beg = new YearMonth(DateTime.parse(panel.getLowerBound(), FilterPanel.DATEFORMATTER));\n</code>\n<code>\nYearMonth end = new YearMonth(DateTime.parse(panel.getUpperBound(), FilterPanel.DATEFORMATTER));\n</code>\n<code>\nSystem.out.println(\"lower_bound = \".concat(panel.getLowerBound()));\n</code>\n<code>\nSystem.out.println(\"lower_bound DateTimeFormatter + DateTime round trip = \".concat(FilterPanel.DATEFORMATTER.parseDateTime(panel.getLowerBound()).toString(FilterPanel.DATEFORMATTER)));\n</code>\n<code>\nSystem.out.println(\"unformatted beg = \".concat(beg.toString()));\n</code>\n<code>\nSystem.out.println(\"beg using \\\"MMMM, YYYY\\\" = \".concat(beg.toString(\"MMMM, YYYY\")));\n</code>\n<code>\nSystem.out.println(\"beg using DateTimeFormatter = \".concat(FilterPanel.DATEFORMATTER.print(beg)));\n</code>\n<code>\nSystem.out.println(\"beg using YearMonth.toString(DateTimeFormatter) = \".concat(beg.toString(FilterPanel.DATEFORMATTER)));\n</code>\n<code>  \nSystem.out.println(\"upper_bound = \".concat(panel.getUpperBound()));\n</code>\n<code>\nSystem.out.println(\"upper_bound DateTimeFormatter + DateTime round trip = \".concat(FilterPanel.DATEFORMATTER.parseDateTime(panel.getUpperBound()).toString(FilterPanel.DATEFORMATTER)));\n</code>\n<code>\nSystem.out.println(\"unformatted end = \".concat(end.toString()));\n</code>\n<code>\nSystem.out.println(\"end using \\\"MMMM, YYYY\\\" = \".concat(end.toString(\"MMMM, YYYY\")));\n</code>\n<code>\nSystem.out.println(\"end using DateTimeFormatter = \".concat(FilterPanel.DATEFORMATTER.print(end)));\n</code>\n<code>\nSystem.out.println(\"end using YearMonth.toString(DateTimeFormatter) = \".concat(end.toString(FilterPanel.DATEFORMATTER)));\n</code>\n\nlower_bound = May, 2000\nlower_bound DateTimeFormatter + DateTime round trip = May, 2000\nunformatted beg = 2000-05\nbeg using \"MMMM, YYYY\" = May, ????\nbeg using DateTimeFormatter = May, ????\nbeg using YearMonth.toString(DateTimeFormatter) = May, ????\nupper_bound = January, 2009\nupper_bound DateTimeFormatter + DateTime round trip = January, 2009\nunformatted end = 2009-01\nend using \"MMMM, YYYY\" = January, ????\nend using DateTimeFormatter = January, ????\nend using YearMonth.toString(DateTimeFormatter) = January, ????\n", "url": "https://github.com/JodaOrg/joda-time/issues/153", "user": "bthayer", "labels": ["NotABug", "WontFix"], "created": "2014-06-20 17:28:44", "closed": "2014-07-01 06:50:24", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "Incorrect parsing of strings with timezone", "body": "new DateTime(Object instant) seems to parse some strings incorrectly.\n\nExample:\n\nnew DateTime(\"1978-01-01T00:00:00+02:00\").toString() yields \"1977-12-31T23:00:00.000+01:00\"\n\nOther dates work as expected\n\nnew DateTime(\"1980-07-08T00:00:00.000+02:00\").toString() yields \"1980-07-08T00:00:00.000+02:00\"\n", "url": "https://github.com/JodaOrg/joda-time/issues/148", "user": "obfuscoder", "labels": ["NotABug", "WontFix"], "created": "2014-05-28 14:41:33", "closed": "2014-05-28 14:48:03", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Period and the Wrong result", "body": "I try to decide the period between two Date (dd-MM-yyyy).\nIn below case, the result is wrong.\n- the first day: 22-04-2014\n- the last day: 10-05-2014\n\nThe result is 4 days. But from 22/04 to 10/05 is 19 days ???????\n\nWho can help me in this case? is it a bug or my code is wrong ?!\n\n--------------------------------------The code ---------------------------------------\n\n```\nString dateStart = \"22-04-2014\";\nString dateStop = \"10-05-2014\";\n\nSimpleDateFormat format = new SimpleDateFormat(\"dd-MM-yyyy\");\n\nDate d1 = null;\nDate d2 = null;\n\ntry {\n    d1 = format.parse(dateStart);\n    d2 = format.parse(dateStop);                \n            LocalDate l1 = LocalDate.fromDateFields(d1);\n            LocalDate l2 = LocalDate.fromDateFields(d2);                \n            Period p = new Period(l1, l2);        \n\n            System.out.println(p.getYears());\n            System.out.println(p.getMonths());\n            System.out.println(p.getDays());\n\n } catch (ParseException e) {\n }\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/145", "user": "phuocthinhdl", "labels": ["NotABug", "WontFix"], "created": "2014-05-10 14:49:14", "closed": "2014-05-12 16:24:02", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Strange results when parsing past dates and converting to java.util.Date", "body": "The following test fails on the last assertion:\n\n``` java\nassertEquals(11, DateTimeFormat.forPattern(\"dd/MM/yyyy\").parseDateTime(\"11/11/1582\").toDate().getDate());\nassertEquals(11, new SimpleDateFormat(\"dd/MM/yyy\").parse(\"11/11/1581\").getDate());\nassertEquals(11, DateTimeFormat.forPattern(\"dd/MM/yyyy\").parseDateTime(\"11/11/1581\").toDate().getDate());\n```\n\nThe strange thing here is that it just fail using dates before the year of 1582, and it is not a parsing issue, but an issue on the method toDate().\n", "url": "https://github.com/JodaOrg/joda-time/issues/135", "user": "flsusp", "labels": ["NotABug", "WontFix"], "created": "2014-03-13 13:54:40", "closed": "2014-03-20 18:03:41", "commits": {}, "ttf": 7.000277777777778, "commitsDetails": []}, {"title": "DateTimeZone short name incorrect for daylight savings", "body": "Hi, I am using version 2.3 and have the following code, which is printing the wrong short name for the timezone with daylight savings:\n\n```\nDateTimeFormatter dtf = DateTimeFormat.forPattern(\"ddMMMYYYY\");\nDateTimeZone zone = DateTimeZone.forID(\"Australia/Melbourne\");\n\nDateTime thisDate = dt1.parseDateTime(\"30Jun2013\");\n// correctly prints \"EST\"\nSystem.out.println(\"\\nZone: \" + zone.getShortName(thisDate.getMillis()));\nthisDate = dt1.parseDateTime(\"30Dec2013\");\n// incorrectly prints \"EST\", should be \"EDT\"\nSystem.out.println(\"\\nZone: \" + zone.getShortName(thisDate.getMillis()));\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/134", "user": "umphy", "labels": ["NotABug", "WontFix"], "created": "2014-03-05 00:22:01", "closed": "2014-03-20 17:53:28", "commits": {}, "ttf": 15.000277777777777, "commitsDetails": []}, {"title": "Years between failing for leap years", "body": "Attached two tests (1st one is passing but not 2nd one) for that issue. It's probably related to #131 \n\n``` java\nimport static org.testng.Assert.assertEquals;\n\nimport org.joda.time.LocalDate;\nimport org.joda.time.Years;\nimport org.testng.annotations.Test;\n\npublic class YearsTest {\n    @Test\n    public void testYears_WillPass() {\n        Years years = Years.yearsBetween(new LocalDate(1996, 2, 28), new LocalDate(2014, 2, 27));\n\n        assertEquals(years.getYears(), 17);\n    }\n\n    @Test\n    public void testYears_WillFail() {\n        Years years = Years.yearsBetween(new LocalDate(1996, 2, 29), new LocalDate(2014, 2, 28));\n\n        assertEquals(years.getYears(), 17);\n    }\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/132", "user": "xabierlaiseca", "labels": ["NotABug", "WontFix"], "created": "2014-02-28 16:59:06", "closed": "2014-03-20 16:57:03", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "Period returns wrong years in case of 29th Feb. (leap year)", "body": "Today one of my Unit-Tests broke. It tests our age validation functionality. \n\n1996 was a leap year so it has a 29th Feb. some who was born will get older on the 1th of Mar. (if no leap year)\n\nExample code:\n\n``` java\nDateTime bithday = new DateTime().minusYears(18).plusDays(1);\nDateTime birthday = new DateTime(1996, 2, 29, 0, 0, 0, 0, now.getZone());\n\nPeriod period = new Period(birthday, now);\n\n//period.getYears() == 18; \n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/131", "user": "HendrikPemoeller", "labels": ["NotABug", "WontFix"], "created": "2014-02-28 11:37:20", "closed": "2014-03-20 16:32:17", "commits": {}, "ttf": 20.00027777777778, "commitsDetails": []}, {"title": "Specific value of timeStamp does not correctly get converted toDateTimeAtStartOfDay", "body": "By using ScalaCheck to write tests on my library using JodaTime, I have encountered some extreme values which makes some JodaTime to behave wrongly\n\nIf you create a LocalDate from -2422054408000L then you convert it  to DateTime using toDateTimeAtStartOfDay you get a DateTime whose minutes is equal to 6 and seconds equal to 32.\n\nIt took me quite a long time to find out what was going wrong with my tests.\n\nI have tested both with 2.2 and 2.3\n", "url": "https://github.com/JodaOrg/joda-time/issues/130", "user": "edmondo1984", "labels": ["NotABug", "WontFix"], "created": "2014-02-24 12:26:54", "closed": "2014-02-28 10:56:35", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "Incorrect parse by DateTimeFormatter constructed by builder", "body": "I had a strange result when parsing some timestamps (in a local timezone) for an application I'm working on. I was able to distill the problem in the following snippit:\n\n```\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Brussels\");  \n\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n\n    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"ddMMMyyyy:HH:mm:ss.SSS\").withLocale(Locale.ENGLISH);\n\n    DateTimeFormatter dtf2 = builder.appendDayOfMonth(2).appendMonthOfYearShortText()\n    .appendYear(4, 4).appendLiteral(\":\").appendHourOfDay(2)\n    .appendLiteral(\":\").appendMinuteOfHour(2).appendLiteral(\":\")\n    .appendSecondOfMinute(2).appendLiteral(\".\").appendFractionOfDay(0,3).toFormatter().withLocale(Locale.ENGLISH);\n\n    String date = \"31MAR2013:19:58:00.000\";\n\n    DateTime first = dtf.parseLocalDateTime(date).toDateTime(zone);\n    System.out.println(first);\n\n    DateTime second = dtf2.parseLocalDateTime(date).toDateTime(zone);\n    System.out.println(second);\n```\n\nThe output is the following:\n                 2013-03-31T19:58:00.000+02:00\n                 2013-03-31T00:58:00.000+01:00\n\nI would expect the second system.out.println (printing the datetime parsed by the formatter built manually) to give the same result. More peculiar: if I remove the appendFractionOfDay , the fraction specification from the pattern, and the fraction from 'date', then the result is identical.\n", "url": "https://github.com/JodaOrg/joda-time/issues/125", "user": "wvc", "labels": ["NotABug", "WontFix"], "created": "2014-02-17 19:20:31", "closed": "2014-03-20 18:16:28", "commits": {}, "ttf": 30.00027777777778, "commitsDetails": []}, {"title": "joda-time give me wrong time zone for Costa Rica", "body": "I live in Panama and I would like to write a java program to works with differents time zones, for example, I would like to know the exact time in Costa Rica, I wrote the following test in java:\n\n```\n    DateTime dt = new DateTime();\n    Date date = dt.toDate();\n    System.out.println(\"Local Time: \" + date);\n\n    DateTime utc = dt.withZoneRetainFields(DateTimeZone.forID(\"Etc/GMT\"));\n    date = utc.toDate();\n    System.out.println(\"Utc Time: \" + date);\n\n    DateTime dtCR = utc.withZoneRetainFields(DateTimeZone.forID(\"America/Costa_Rica\"));\n    Date date3 = dtCR.toDate();\n    System.out.println(\"Costa Rica Time: \" + date3);        \n```\n\nAnd the output is:\nLocal Time: Mon Feb 10 05:59:33 EST 2014\nUtc Time: Mon Feb 10 00:59:33 EST 2014\nCosta Rica Time: Mon Feb 10 06:59:33 EST 2014\n\nbut the time on Costa Rica is wrong, because Costa Rica has a one hour less than Panama, and the output should be: Mon Feb 10 04:59:33 EST 2014\n", "url": "https://github.com/JodaOrg/joda-time/issues/118", "user": "yamir73", "labels": ["NotABug", "WontFix"], "created": "2014-02-10 11:02:24", "closed": "2014-02-10 11:09:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Joda time can't handle large intervals for seconds", "body": "I am getting this error when I use Joda in `clojure` via [clj-time](https://github.com/clj-time/clj-time/). \n\n``` clojure\nuser> (in-seconds (interval (now) (-> (*  3 1000) years from-now)))\nArithmeticException Value cannot fit in an int: 94670812800 org.joda.time.field.FieldUtils.safeToInt (FieldUtils.java:190)\n```\n\nAnd it seems that Joda is assuming seconds field to be an int, so large interval values doesn't work.\n\nrelated bug: https://github.com/clj-time/clj-time/issues/104\n", "url": "https://github.com/JodaOrg/joda-time/issues/117", "user": "trhura", "labels": ["NotABug", "WontFix"], "created": "2014-02-08 04:51:56", "closed": "2014-02-08 21:38:44", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Period field difference in millis on dates on last & first day of month overrun int", "body": "I have been running into an issue with some code to try to detect the timezone of a remote SQL server. The problem appears to happen when the local time is the last day of the month and UTC time is the next calendar day.\n\nThe following test cases showcase the issue:\n\n``` java\npublic class TimeTest {\n    @Test\n    public void timeTest_SuccessCase() {\n        DateTime dtLocal = new DateTime(2014, 1, 31, 15, 59); //Server time\n        DateTime dtUTC = new DateTime(2014, 1, 31, 12, 59, DateTimeZone.UTC); //Assume UTC = server+8 hours (actual code uses DateTime.now(DateTimeZone.UTC))\n\n        LocalDate local = dtLocal.toLocalDate();\n        LocalDate utc = dtUTC.toLocalDate();\n\n        Period p = Period.fieldDifference(utc,local).normalizedStandard(PeriodType.millis());\n    }\n\n    @Test\n    public void timeTest_FailCase() {\n        DateTime dtLocal = new DateTime(2014, 1, 31, 16, 00); //server time\n        DateTime dtUTC = new DateTime(2014, 2, 1, 0, 0, DateTimeZone.UTC); //Assume UTC = server+8 hours (actual code uses DateTime.now(DateTimeZone.UTC))\n\n        LocalDate local = dtLocal.toLocalDate();\n        LocalDate utc = dtUTC.toLocalDate();\n\n        Period p = Period.fieldDifference(utc,local).normalizedStandard(PeriodType.millis()); //Throws a java.lang.ArithmeticException: Value cannot fit in an int: xxx\n    }\n}\n```\n\nAre my assumptions correct or is there an actual bug?\n", "url": "https://github.com/JodaOrg/joda-time/issues/115", "user": "zerodivide1", "labels": ["NotABug", "WontFix"], "created": "2014-02-03 17:18:55", "closed": "2014-07-26 22:53:13", "commits": {}, "ttf": 173.00027777777777, "commitsDetails": []}, {"title": "Joda is not quite ISO-8601 compliant (org.joda.time.format.ISODateTimeFormat.dateTimeParser)", "body": "To quote http://en.wikipedia.org/wiki/ISO_8601 \"There is no limit on the number of decimal places for the decimal fraction.\"\n\nPython style DateTimes have microsecond, not millisecond precision like:\n\n2014-01-17T15:57:22.105710Z\n\nIt would nice if Joda was more tolerant and accepted any number of decimal seconds and rounded the microseconds up to the nearest millisecond.\n\nLogstash is currently using the Joda for its date/time parsing and I have to pre-process all timestamps originating from Python applications to force the fractional seconds to just 3 digits of precision, which is rather annoying.\n", "url": "https://github.com/JodaOrg/joda-time/issues/112", "user": "luis-ortiz", "labels": ["NotABug"], "created": "2014-01-17 16:03:41", "closed": "2014-01-19 14:39:47", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "calling AbstractInstant.isBefore(ReadableInstant) or similar methods returns unexpected on null input.", "body": "Hello,\n\nWhen I call the isBefore method of a DateTime instance with another instance that might be null, I don't expect the current behavior. The current AbstractInstant does not throw a NullPointerException or just returns false (which both would be very common sense solutions), but translates _null_ to _now_ before applying its logic. So when I compare any DateTime before now to null I get _true_ returned.\n\nThe solution would be to \n- either return _false_ on _null_ input (that would be what a SQL function would do, too, or the String.equals() method as a closer related example)\n- or throw a NullPointer exception\n\nThe minimum action would be to warn in the Javadoc about this behavior.\n\nThis affects .isAfter(ReadableInstant) and isEqual(ReadableInstant), too.\n", "url": "https://github.com/JodaOrg/joda-time/issues/108", "user": "SchlauFuchs", "labels": ["NotABug", "WontFix"], "created": "2014-01-09 21:55:47", "closed": "2014-01-19 15:11:15", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "Can't get current islamic date correctly", "body": "i use the following code:\n\nDateTime dtISO = new DateTime(2014, 1, 9, 0, 0, 0, 0);\n        DateTime dtIslamic = dtISO.withChronology(IslamicChronology.getInstance());\n\nday should be 8  but it prints 7\nplease advise\n", "url": "https://github.com/JodaOrg/joda-time/issues/107", "user": "devmsaleh", "labels": ["NotABug"], "created": "2014-01-09 15:06:58", "closed": "2014-01-20 17:10:09", "commits": {}, "ttf": 11.000277777777777, "commitsDetails": []}, {"title": "DateTime does not equal itself after unserialization", "body": "There was a brief discussion [on SO](http://stackoverflow.com/questions/21002385/datetime-does-not-equal-itself-after-unserialization) about this. After serializing and unserializing from/to ISO8601 a DateTime it does not equal the original. More specifically, `.getChronology()` returns don't equal each other, as is illustrated on the accepted answer of that SO question I linked. I presume that is because ISO8601 holds less information than a DateTime. One solution that I imagine is to subclass DateTime and override `equals` and make the chronology comparison more relaxed.\n\nAm I right in presuming that this is intended behavior? Is there a neater workaround?\n", "url": "https://github.com/JodaOrg/joda-time/issues/106", "user": "dmos62", "labels": ["NotABug", "WontFix"], "created": "2014-01-09 11:51:21", "closed": "2014-01-19 15:16:33", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "days not returned during period conversion using Period.dayTime()", "body": "Using version 2.3 \nPeriod p = new Period(instance.getDurationInMillis().longValue(),PeriodType.dayTime()) );\n                    long days = p.getDays();\n                    long hours = p.getHours();\n                    long minutes = p.getMinutes();\n                    long seconds = p.getSeconds();\n\ndays always comes up zero,\nrest are  2923 hours 24 minutes 12 seconds\n", "url": "https://github.com/JodaOrg/joda-time/issues/104", "user": "vadeerhunter", "labels": ["NotABug", "WontFix"], "created": "2014-01-08 18:54:36", "closed": "2014-01-09 04:32:11", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CenturyOfEra DateTime property behaves inconsistently", "body": "Although the maximum value of `centuryOfEra` date-time field tells one thing, actually setting the field to its maximum value fails with exception.\n\nSeems to be an edge case in math in the DividedDateTimeField.\n\n``` java\nDateTime.Property centuryOfEra = new DateTime(\"2294-01-01T00:00:00.000Z\").property(DateTimeFieldType.centuryOfEra());\nint max = centuryOfEra.getMaximumValue();\nassert max == 2922789\ncenturyOfEra.setCopy(2922789);\n// IllegalFieldValueException Value 292278994 for yearOfEra must be in the range [0,292278993]\n//  org.joda.time.field.FieldUtils.verifyValueBounds (FieldUtils.java:234)\n//  org.joda.time.chrono.ISOYearOfEraDateTimeField.set (ISOYearOfEraDateTimeField.java:86)\n//  org.joda.time.field.DividedDateTimeField.set (DividedDateTimeField.java:204)\n//  org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set (ZonedChronology.java:481)\n//  org.joda.time.DateTime$Property.setCopy (DateTime.java:2172)\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/102", "user": "dm3", "labels": ["NotABug", "WontFix"], "created": "2013-12-21 11:05:40", "closed": "2014-01-20 18:04:32", "commits": {}, "ttf": 30.00027777777778, "commitsDetails": []}, {"title": "Bug converting from LocalDate#toDate() in year 1895", "body": "Trying to convert a java.util.Date for 1895-01-01 to LocalDate  and back again and it sets the day one day back instead to 1894-12-31.\n\nIn subsequent years it works fine.  The LocalDate#toDate function appears to do a lot of guessing, so suspect that could be the cause.\n\nI'm working on a CET timezone (UTC+1) if there are some gotchas there.\nI've also tried passing a timezone and a chronology to the LocalDate constructors to no avail.\n\nTestcase to demonstrate what works and what doesn't\n\n``` java\n@Test\n    public void should_convert_01_01_1895_but_this_aint_right() throws Exception {\n        LocalDate start = new LocalDate(1895, 1, 1);\n        Date d1895 = start.toDate();\n        assertThat(new LocalDate(d1895)).isNotEqualTo(start).isEqualTo(new LocalDate(1894, 12, 31));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void should_convert_01_01_1895_works_ok() throws Exception {\n        LocalDate start = new LocalDate(1895, 1, 1);\n        Date d1895 = start.toDateTimeAtStartOfDay(DateTimeZone.getDefault()).toDate();\n        assertThat(new LocalDate(d1895)).isEqualTo(start);\n    }\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/91", "user": "frode-carlsen", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-11-27 06:59:19", "closed": "2013-11-27 12:45:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Parsing a date string with an incorrect day of the week does not throw any errors", "body": "If you parse a string that has an incorrect day of the week , e.g.\n\n``` java\n// July 14, 2012 is a Saturday, but let's call it a Friday\nDateTimeFormat.forPattern(\"EEE MMM dd yyyy\").parseDateTime(\"Fri Jul 14 2012\");\n```\n\nNo parse errors are thrown, but it changes the date to be the 13th, rather than the 14th as in the string to be parsed.\n", "url": "https://github.com/JodaOrg/joda-time/issues/78", "user": "garretthall", "labels": ["NotABug"], "created": "2013-10-16 22:25:59", "closed": "2013-11-01 14:37:49", "commits": {"e02af2cb44051bb085966b884722665669330a4e": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "e02af2cb44051bb085966b884722665669330a4e", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815"], "nameRev": "e02af2cb44051bb085966b884722665669330a4e tags/v2.4~53", "commitMessage": "Better Javadoc for DateTimeFormatter parsing\n\nSee #78\n", "commitDateTime": "2013-11-01 14:36:27", "authoredDateTime": "2013-11-01 14:36:27", "commitGitStats": [{"filePath": "RELEASE-NOTES.txt", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/main/java/org/joda/time/format/DateTimeFormatter.java", "insertions": 9, "deletions": 0, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DateTimeFormatter.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e02af2cb44051bb085966b884722665669330a4e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 9, "deletions": 0, "lines": 9, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time/format"]}, {"title": "appendOptional and Both printing and parsing not supported", "body": "I have problem with DateTimeFormatterBuilder. \nIn Joda 2.1 this code is working without any problem:\n\n```\nDateTimeFormatterBuilder a = new DateTimeFormatterBuilder();\na.append(DateTimeFormat.forPattern(\"HH:mm\"));\na.appendOptional(DateTimeFormat.forPattern(\":ss\").getParser());\na.appendOptional(DateTimeFormat.forPattern(\".SSS\").getParser());\na.append(DateTimeFormat.forPattern(\":ss.SSS\").getPrinter());\nDateTimeFormatter f = a.toFormatter(); \nDateTime c = f.parseDateTime(\"05:04:59\");\nSystem.out.println(f.print(c));\n```\n\nBut it does not work anymore in newer versions. I tried versions 2.2 and 2.3. \na.toFormatter() raises exception:\nBoth printing and parsing not supported\n\nThe problem occurs only when appendOptional method is used.\n\nWhat was changed that it stopped working?\n\nThank you for your help.\n", "url": "https://github.com/JodaOrg/joda-time/issues/75", "user": "jhron", "labels": ["Discussion", "NotABug"], "created": "2013-10-04 12:47:05", "closed": "2013-10-04 13:16:36", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "DateTime API using minus and plus APIs", "body": "Hi!\n\nI am running into an issue that just started this month.  Here is come sample code:\n\nDateTime now = new DateTime();\nnow = now.minusMonths(11);\nnow = now.minusWeeks(3);\nnow = now.plusMonths(11);\nSystem.out.println(Weeks.weeksBetween(now, new DateTime()).getWeeks());\n\nweeksBetween will return 2 instead of 3.  Anyone know why this is occurring?  I am using 2.2 version of the API.\n\nThanks!\n", "url": "https://github.com/JodaOrg/joda-time/issues/74", "user": "Kyle-Thayer", "labels": ["Discussion", "NotABug"], "created": "2013-10-02 16:34:33", "closed": "2013-10-02 22:06:53", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "JodaTime incorrectly converts some time zones on JDK 1.6", "body": "The Joda Time 2.3 incorrectly converts MST TimeZone to DateTimeZone. The following test fails:\n\n``` java\n    @Test\n    public void test() {\n        TimeZone jdkMST = TimeZone.getTimeZone(\"MST\");\n        DateTimeZone mst = DateTimeZone.forTimeZone(jdkMST);\n        DateTimeZone mst2 = DateTimeZone.forID(jdkMST.getID());\n        assertEquals(\"MST\", mst2.getID());\n        assertEquals(\"MST\", mst.getID());\n        assertEquals(mst, mst2);\n    }\n```\n\nThe resulting zone for MST is \"America/Denver\" that has daylight saving, while MST does not have daylight savings. This causes incorrect display of the time, since time zone offset of different.\n\nApparently the offending method is in  DateTimeZone.java:\n\n``` java\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            ......\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            ......\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n```\n\nIt possibly contains some work around for JDK 1.1, but this workaround also applies to JDK 1.6, that contains correct definition of MST time zone. JDK 1.1 work around should be applied only when needed and not to change DateTimeZone when it is not needed.\n", "url": "https://github.com/JodaOrg/joda-time/issues/70", "user": "const", "labels": ["Discussion", "NotABug"], "created": "2013-10-01 11:00:13", "closed": "2013-10-05 00:26:49", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "NullPointerException on DateTimeZone.getOffset() when using persistent object", "body": "Hello,\n\nI am using JodaTime v2.3 in combination with a DB4O object database. I have noticed that when retrieving DateTime objects from the database I get NullPointerExceptions when calling: dateTimeObj.getZone().getOffset(long)\n\nHere's a stacktrace:\nCaused by: java.lang.NullPointerException\n    at java.util.Arrays.binarySearch(Arrays.java:827)\n    at org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(DateTimeZoneBuilder.java:1574)\n    at org.joda.time.tz.CachedDateTimeZone.createInfo(CachedDateTimeZone.java:158)\n    at org.joda.time.tz.CachedDateTimeZone.getInfo(CachedDateTimeZone.java:145)\n    at org.joda.time.tz.CachedDateTimeZone.getOffset(CachedDateTimeZone.java:103)\n\nI believe this problem also affects JodaTime v2.2.\n\nBest,\n\nMatthias\n", "url": "https://github.com/JodaOrg/joda-time/issues/65", "user": "mstevens83", "labels": ["Bug", "NotABug"], "created": "2013-09-24 15:26:38", "closed": "2013-10-01 09:18:52", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": " ReadableInstant extends Comparable and not Comparable<ReadableInstant>, but the implementation behaves as the latter", "body": "Let me start with code (I used `Date` as a comparison, but anything comparable would do, like `String`, `Integer`, ...):\n\n``` java\njava.util.Date normalDate = new java.util.Date();\norg.joda.time.DateTime jodaDate = new new org.joda.time.DateTime();\norg.junit.Assert.assertThat(normalDate, org.hamcrest.Matchers.equalsTo(normalDate));\norg.junit.Assert.assertThat(jodaDate, org.hamcrest.Matchers.equalsTo(jodaDate));\norg.junit.Assert.assertThat(normalDate, org.hamcrest.Matchers.lessThan(normalDate));\norg.junit.Assert.assertThat(jodaDate, org.hamcrest.Matchers.lessThan(jodaDate));\n```\n\nat the 4th `assertThat` (`jodaDate`/`lessThan`) I get weird warning message in Eclipse:\n\n> Type safety: The expression of type `Matcher` needs unchecked conversion to conform to `Matcher<? super DateTime>`\n\nMy guess it is because `ReadableInstant extends Comparable` and not `Comparable<ReadableInstant>`.\n`int compareTo(Object readableInstant);` will throw a `ClassCastException` if it's not instanceof `ReadableInstant` which makes it pointless to implement the raw `Comparable` interface.\n\nThat check can be made by the compiler at compile time. In my opinion it won't break any working code because if someone ever calls it with anything other than `ReadableInstant` instance, they would get an exception anyway, which no-one wants I guess (maybe your unit tests...).\n\nWould it be possible to change the interface extension to the generic one?\nIt will give a warning for anyone who tries to use it against any generic interface which expects `Comparable`, which is pretty annoying if they want \"warning-less\" code. `@SuppressWarnings` is rather pointless, hopefully I'll only have to use it at a few places. (For example `equalsTo` in Hamcrest does not give a warning)\n\n> Migrated from https://sourceforge.net/p/joda-time/bugs/172/\n", "url": "https://github.com/JodaOrg/joda-time/issues/55", "user": "TWiStErRob", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-08-30 23:59:55", "closed": "2013-09-06 14:07:38", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "Monday is listed as fourth day of week in Java Docs", "body": "From: http://joda.sourceforge.net/api-time/org/joda/time/DateTimeConstants.html\n\nEvery one of the day constants mentions that it represents Monday.  For example:\n\nstatic int  THURSDAY \n          Constant (4) representing Monday, the fourth day of the week (ISO)\nstatic int  TUESDAY \n          Constant (2) representing Monday, the second day of the week (ISO)\nstatic int  WEDNESDAY \n          Constant (3) representing Monday, the third day of the week (ISO)\n", "url": "https://github.com/JodaOrg/joda-time/issues/54", "user": "timjstewart", "labels": ["NotABug"], "created": "2013-08-27 19:51:03", "closed": "2013-08-28 10:37:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "DateTimeFormatter parsing issues with patterns \"EEE MMM dd HH:mm:ss yyyy\" and \"EEE MMM dd HH:mm:ss ZZZ yyyy\"", "body": "Hi,\n\nI have seen a weird issue with `DateTimeFormatter` lately, and after some googling without anything similar, I think it might be a bug in the parsing logic of `joda-time` `2.2` and `2.1`.\nFor example, the below code...\n\n```\nString text = \"Tue Aug 11 21:41:19 2013\";\nDateTimeFormatter formatter = DateTimeFormat.forPattern(\"EEE MMM dd HH:mm:ss yyyy\");\nDateTime dateTime = formatter.parseDateTime(text);\nassertThat(formatter.print(dateTime), is(text));\n```\n\n... fails with:\n\n```\njava.lang.AssertionError: \nExpected: is \"Tue Aug 11 21:41:19 2013\"\n    but: was \"Tue Aug 06 21:41:19 2013\"\n```\n\nIf you debug this, you will see that `parseDateTime` somehow transforms 11th of August into the 6th of August.\nBesides the same happens with the pattern: `\"EEE MMM dd HH:mm:ss ZZZ yyyy\"` and strings like: `\"Tue Aug 11 21:41:19 Europe/London 2013\"`.\n\nWould you be able to:\n- confirm it is a new bug and not a known issue?\n- advise about the next steps?\n\nI am happy to try to provide a patch if you point me to the right direction (where is what, etc.).\n\nCheers,\n\nM.\n", "url": "https://github.com/JodaOrg/joda-time/issues/51", "user": "marccarre", "labels": ["NotABug"], "created": "2013-08-16 09:45:36", "closed": "2013-08-16 09:53:38", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Question about year 0000 between JDK and JodaTime", "body": "Hi,\n\nQuick question about the output I'm seeing and I'm not sure it's a bug or not.\n\nWe are using JodaTime to convert our Calendar/Date objects into ISO8601 format to be sent along in a JSON payload. \n\nThings work fine for most normal dates, but our QA team found an interesting issue when they use the year '0000' which is a valid year.\n\nWe are seeing that the JodaTime library seems to lose 2 days during the formatting where the JDK SimpleDateFormatters don't.\n\nIs this a bug? Below is the sample code and output.\n## OUTPUT\n\nJODA: 0000-10-27T12:03:58.000-04:56:02\nJAVA: 0001-10-29T12:00:00.000-0500\n## CODE\n\n``` java\npublic class DateTest {\n\n   // Standard ISO8601 Date format\n   private static final String ISO8601 = \"yyyy-MM-dd'T'hh:mm:ss.SSSZ\";\n\n   /**\n    * Test the difference between JODA and JDK date formats when year is 0000\n    * @param args\n    */\n   public static void main(String[] args) {\n\n      // Set the calendar to known state\n      Calendar c = Calendar.getInstance();\n      c.set(Calendar.YEAR, 0000);\n      c.set(Calendar.DAY_OF_MONTH, 29);\n      c.set(Calendar.MONTH, Calendar.OCTOBER);\n      c.set(Calendar.HOUR_OF_DAY, 12);\n      c.set(Calendar.MINUTE, 0);\n      c.set(Calendar.SECOND, 0);\n      c.set(Calendar.MILLISECOND, 0);\n\n      Date d = c.getTime();\n      doJoda(d);\n      doJava(d);\n\n   }\n\n   /**\n    * Print using JODA TIME\n    * @param d\n    */\n   private static void doJoda(Date d) {\n      System.out.println(\"JODA: \" + new DateTime(d).toString());\n   }\n\n   /**\n    * Print using JDK\n    * @param d\n    */\n   private static void doJava(Date d) {\n      SimpleDateFormat df = new SimpleDateFormat(ISO8601);\n      System.out.println(\"JAVA: \" + df.format(d));\n   }\n}\n\nThanks...\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/50", "user": "tmulle", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-08-07 15:26:59", "closed": "2013-08-07 19:24:48", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "java.io.NotSerializableException after using dateTime.toDate()", "body": "Hi,\n\nIn order to save the current state in an android application, a java.util.Date object is created from a DateTime object using toDate(). However it seems that the resulting Date object is not properly serializable any more.\n\nWe use joda-time 2.2.\n\n``` java\noutState.putSerializable(ARG_SELECTED_DATE, selectedDate.toDate());\n...\nDateTime selectedDate = new DateTime(savedInstanceState.getSerializable(ARG_SELECTED_DATE));\n```\n##### Exception\n\n``` java\njava.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = org.joda.time.DateTime)\nat android.os.Parcel.writeSerializable(Parcel.java:1279)\nat android.os.Parcel.writeValue(Parcel.java:1233)\nat android.os.Parcel.writeMapInternal(Parcel.java:591)\nat android.os.Bundle.writeToParcel(Bundle.java:1627)\nat android.os.Parcel.writeBundle(Parcel.java:605)\nat android.support.v4.app.FragmentState.writeToParcel(Fragment.java:132)\nat android.os.Parcel.writeTypedArray(Parcel.java:1102)\nat android.support.v4.app.FragmentManagerState.writeToParcel(FragmentManager.java:357)\nat android.os.Parcel.writeParcelable(Parcel.java:1254)\nat android.os.Parcel.writeValue(Parcel.java:1173)\nat android.os.Parcel.writeMapInternal(Parcel.java:591)\nat android.os.Bundle.writeToParcel(Bundle.java:1627)\nat android.os.Parcel.writeBundle(Parcel.java:605)\nat android.app.ActivityManagerProxy.activityStopped(ActivityManagerNative.java:2252)\nat android.app.ActivityThread$StopInfo.run(ActivityThread.java:3052)\nat android.os.Handler.handleCallback(Handler.java:725)\nat android.os.Handler.dispatchMessage(Handler.java:92)\nat android.os.Looper.loop(Looper.java:137)\nat android.app.ActivityThread.main(ActivityThread.java:5041)\nat java.lang.reflect.Method.invokeNative(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:511)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:560)\nat dalvik.system.NativeStart.main(Native Method)\nCaused by: java.io.NotSerializableException: org.joda.time.tz.CachedDateTimeZone$Info\nat java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1364)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1671)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat java.io.ObjectOutputStream.writeNewArray(ObjectOutputStream.java:1205)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1662)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:979)\nat java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:368)\nat java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1074)\nat java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1404)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1671)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:979)\nat java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:368)\nat java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1074)\nat java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1404)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1671)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:979)\nat java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:368)\nat java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1074)\nat java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1404)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1671)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:979)\nat java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:368)\nat java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1074)\nat java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1404)\nat java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1671)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1517)\nat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1481)\nat android.os.Parcel.writeSerializable(Parcel.java:1274)\n... 23 more\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/46", "user": "mfehr", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-07-23 09:03:40", "closed": "2013-08-07 19:04:16", "commits": {}, "ttf": 15.000277777777777, "commitsDetails": []}, {"title": "Creating a DateTime from a Julian Day", "body": "I would like to know an appropriate way to create a DateTime from the (astronomical) Julian Day.\n\nDateTimeUtils.fromJulianDay does not seem to work in its own.\n\nMaybe this is my misunderstanding, but\n\n``` java\nnew DateTime(DateTimeUtils.fromJulianDay(0)).getYear() // -4713\n```\n\nshould give -4712 (that is 4713 BC) and not as currently -4713, is it not?\n( from https://en.wikipedia.org/wiki/Julian_day#Calculation )\n", "url": "https://github.com/JodaOrg/joda-time/issues/39", "user": "eregon", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-07-12 15:43:44", "closed": "2013-07-12 18:01:25", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Strange behavior with february when calculate period and espessially the month calculation", "body": "about the february month there is a strange behavior that you can see in the incorect results with jodatime, you can look down here : \n\n```\n        DateTime date4 = new DateTime(2013, 5, 29, 0, 0, 0, 0);\n        DateTime date4PlusNineMonths = new DateTime(2014, 2, 28, 0, 0, 0, 0);\n        Period period4 = new Period(date4, date4PlusNineMonths);\n        //Incorrect result\n        System.out.print(date4.toString(\"dd/MM/YYYY\")+\".plusMonths(9) = \"+ date4.plusMonths(9).toString(\"dd/MM/YYYY\"));\n        System.out.print(period4.getYears() +\"Years/\"+ period4.getMonths() +\"Months/\"+ period4.getWeeks() +\"Weeks/\"+ period4.getDays() +\"Days\");\n```\n\nOutput :\n    29/05/2013.plusMonths(9) = 28/02/2014 //incorrect result should be 01/03/2014\n    0Years/9Months/0Weeks/0Days\n\nThis is an incorrect calculation It should be 0Years/8Months/4Weeks/2Days Isn't it...?\n\nIf it is correct so why when I increase two days more (30 and 31) it always give me the same calculation (0Years/9Months/0Weeks/0Days) we all agree that days are really decreasing or am I dreaming...?\n\nNow maybe I wrong in my use of the joda framework because in the app I develop I do a check everyday on a period to have the precise month separation between two date (toDay and the next date) and if I have 9months and 1day it's too late I need to have 9months and 0days as required in my app =/\n\nIf I wrong how can I achieve this please...?\n", "url": "https://github.com/JodaOrg/joda-time/issues/31", "user": "aky0", "labels": ["NotABug"], "created": "2013-06-11 12:08:38", "closed": "2013-06-16 10:55:47", "commits": {"0cd0ccad045c82711aadf3b37c4188655ad552cf": {"commitGHEventType": "referenced", "commitUser": "jodastephen"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "0cd0ccad045c82711aadf3b37c4188655ad552cf", "commitGHEventType": "referenced", "commitUser": "jodastephen", "commitParents": ["3a413d7844c22dc6ddd50bf5d0d55ff3589e47ac"], "nameRev": "0cd0ccad045c82711aadf3b37c4188655ad552cf tags/v2.3~28", "commitMessage": "Investigate Period calculation at end of month\n\nSee #31\n", "commitDateTime": "2013-06-16 11:56:18", "authoredDateTime": "2013-06-16 11:56:18", "commitGitStats": [{"filePath": "src/main/java/org/joda/time/Period.java", "insertions": 36, "deletions": 3, "lines": 39}, {"filePath": "src/test/java/org/joda/time/TestPeriod_Constructors.java", "insertions": 130, "deletions": 0, "lines": 130}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Period.java", "spoonMethods": []}, {"spoonFilePath": "TestPeriod_Constructors.java", "spoonMethods": [{"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_standardYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_leapYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_exactMonths()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toMar_endOfMonth1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toMar_endOfMonth2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_standardYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_leapYear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_exactMonths()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toMar_endOfMonth1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "org.joda.time.TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toMar_endOfMonth2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0cd0ccad045c82711aadf3b37c4188655ad552cf"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 36, "deletions": 3, "lines": 39, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/org/joda/time"], "changesInPackagesSPOON": []}, {"title": "Parsing hour of halfday with LenientChronology yields wrong value", "body": "Using a LenientChronology when parsing a time using 12-hour format yields a result in which the am/pm are flipped.  On inspection, the issue is in LenientDateTimeField#set(long,int) where the delta between the current and desired value is being calculated.  Because this particular field maps its zero value to 12, this ends up generating an incorrect delta, shifting results by 12 hours.\n\nThis can be reproduced with the following test:\n\n```\npublic void lenientHourOfHalfDay() {\n    Chronology utc= ISOChronology.getInstanceUTC();\n    DateTimeFormatter format= DateTimeFormat.forPattern(\"h:mm a\").withChronology(utc);\n\n    String text= \"3:30 am\";\n    DateTime result= format.parseDateTime(text);\n    DateTime lenientResult= format.withChronology(LenientChronology.getInstance(utc)).parseDateTime(text);\n\n    LocalTime expected= new LocalTime(3, 30);\n\n    // Works, as expected\n    Assert.assertEquals(\"Strict parse result wrong\", expected, result.toLocalTime());\n    // Fails unexpectedly; value shifted by 12 hours\n    Assert.assertEquals(\"Lenient parse result wrong\", expected, lenientResult.withChronology(utc).toLocalTime());\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/30", "user": "userkci", "labels": ["NotABug"], "created": "2013-06-03 23:16:28", "closed": "2013-06-07 21:33:38", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "Period constructor always zero,  print then parse a period gives different period and zero period not equal", "body": "Hi I wanted to let you know that the following code has 3 issues:\n\n```\nPeriod p1 = new Period(5L, PeriodType.hours());\n\nString string = p1.toString();\nSystem.out.println(string);     \n\nPeriod p2 = Period.parse(string);\nSystem.out.println(p2);\n\n//The expected result\nPeriod period=Period.hours(5);\nSystem.out.println(period);\n\nassert p1.equals(p2);\n```\n\nOutputs:\nPT0H\nPT0S\nPT5H\nException in thread \"main\" java.lang.AssertionError \n\n1) It seems that the Period constructor is broken.\n\n2) One would expect that printing a period and then parsing it would give an identical period.\n\n3) One would expect that a zero period in hours should be equal to zero seconds.\n\nRelease Joda Time 2.2\n\n <dependencies>\n     <dependency>\n    <groupId>joda-time</groupId>\n    <artifactId>joda-time</artifactId>\n    <version>2.2</version>\n</dependency>\n", "url": "https://github.com/JodaOrg/joda-time/issues/25", "user": "apps4uco", "labels": ["NeedsInvestigation", "NotABug"], "created": "2013-05-25 16:37:18", "closed": "2013-07-20 11:38:26", "commits": {}, "ttf": 55.000277777777775, "commitsDetails": []}, {"title": "LocalDate.toInterval(DateTimeZone) returns unexpected interval on Day Light Saving cut over day", "body": "Repro:\n\n```\nDateTimeZone = DateTimeZone.forID(\"America/Havana\");\nlong milli = 1352005199998;\nMutableDateTime dt = new MutableDateTime(milli, timeZone);\n// now dt is 2012-11-04T00:59:59.998-04:00\n\nint year = dt.getYear(); // 2012\nint month = dt.getMonthOfYear(); // 11\nint day = dt.getDayOfMonth(); // 4\n\nInterval theDay = new LocalDate(year, month, day).toInterval(timeZone);\n// theDay is 2012-11-04T00:00:00.000-05:00/2012-11-05T00:00:00.000-05:00,\n// which does not include dt.\n\nInterval lastDay = new LocalDate(year, month, day-1).toInterval(timeZone);\n// lastDay is 2012-11-03T00:00:00.000-04:00/2012-11-04T00:00:00.000-05:00\n// i.e. joda thinks that 2012-11-04T00:59:59.998-04:00 is an instance of 2012-11-3\n// instead of 2012-11-04\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/23", "user": "bsdshell", "labels": ["NotABug", "WontFix"], "created": "2013-05-14 18:43:09", "closed": "2014-07-06 22:22:10", "commits": {}, "ttf": 418.0002777777778, "commitsDetails": []}, {"title": "ISODateTimeFormat.dateTimeNoMillis.print(LocalDate) produces strange characters", "body": "Hi.\n\nJoda version 2.1\n\nFor reasons too weird to describe, I tried to format a LocalDate using ISODateTimeFormat.dateTimeNoMillis. The date part comes out fine, as does the subsequent 'T'. However, the time parts are rendered not as 00:00:00, but with some strange characters. It's easy to reproduce. Something like:\n\nISODateTimeFormat.dateTimeNoMillis.print(LocalDate.now())\n\nshould show the problem.\n", "url": "https://github.com/JodaOrg/joda-time/issues/19", "user": "lancewalton", "labels": ["NotABug"], "created": "2013-04-22 22:33:13", "closed": "2013-04-23 06:52:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Leap year incorrectly calculated", "body": "According to Wikipedia, 1900 shouldn't be a leap year.\n\nhttp://en.wikipedia.org/wiki/List_of_leap_years\nhttp://en.wikipedia.org/wiki/Leap_year\n\nAs such, century years must be divisible by 400 before they are classed as leap years.\n\nHere's a unit test.\n\n```\n@Test\npublic void testExcelDateIn1900InMarch() {\n    int days = Days.daysBetween(new DateMidnight(1900, 1, 1),\n            new DateMidnight(1900, 3, 1)).getDays() + 1;\n\n    assertEquals(61, days);\n}\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/16", "user": "softwaremaverick", "labels": ["NotABug"], "created": "2013-04-11 19:00:45", "closed": "2013-04-11 19:44:58", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Timezone displays incorrect for Germany", "body": "joda time displays timezone in numeric format (i.e. \"+2:00\") for Germany locale, but for Franch or US locale timezone displayed in verbose format  (i.e. EET)\nCode snippets to reproduce the issue are displayed below.\n\nThis is utility method to make pattern for conversion. \n\n``` java\n    private static String getDateTimePattern(Locale locale) {\n        StringBuffer dateTimePattern = new StringBuffer();\n        dateTimePattern.append(((SimpleDateFormat) DateFormat.getDateInstance(DateFormat.MEDIUM, locale)).toPattern());\n        dateTimePattern.append(\" \");\n        dateTimePattern.append(((SimpleDateFormat) DateFormat.getTimeInstance(DateFormat.SHORT, locale)).toPattern());\n        dateTimePattern.append(\" \");\n        dateTimePattern.append(\"z\");\n\n        return dateTimePattern.toString();\n    }\n```\n\nSnippet to reproduce in JUnit unit test\n\n``` java\n        Date date = new Date(100000000);\n        Style style = Style.DATETIME;\n        Locale locale = Locale.GERMANY;// !!!\n        TimeZone zone = new SimpleTimeZone(7200000, \"Asia/Amman\", 2, -1, 5, 86400000, 0, 9, -1, 6, 0, 1, 3600000);\n        dtf = DateTimeFormat.forPattern(getDateTimePattern(locale)).withLocale(locale);\n        dtf = dtf.withZone(DateTimeZone.forTimeZone(timezone));\n        DateTime dt = new DateTime(date);\n        assertEquals(\"02.01.1970 05:46 EET\", dt.toString(dtf));\n```\n", "url": "https://github.com/JodaOrg/joda-time/issues/15", "user": "crc83", "labels": ["NotABug"], "created": "2013-04-09 08:50:16", "closed": "2013-04-12 09:01:38", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}]}