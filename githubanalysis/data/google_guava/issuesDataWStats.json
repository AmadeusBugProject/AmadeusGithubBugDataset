{"projectName": "google/guava", "bugLabels": ["type=defect"], "captureTime": "Sat Jul  4 20:29:53 2020", "issues": [{"title": "Resources.getResource() not working on modular project (openjdk 11)? ", "body": "this is a **maven project**, and have one image in **resources directory**:\r\n\r\n```\r\n\u251c\u2500 src\r\n   \u251c\u2500 main\r\n       \u251c\u2500 java\r\n       \u2514\u2500 resources  \r\n          \u2514\u2500imgs\r\n            \u2514\u2500logo.png\r\n```\r\n\r\nI use: \r\n```\r\n        <dependency>\r\n            <groupId>com.google.guava</groupId>\r\n            <artifactId>guava</artifactId>\r\n            <version>29.0-jre</version>\r\n        </dependency>\r\n```\r\n### Code Snippet:\r\n```\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        URL resource = Resources.getResource(Test.class, \"/imgs/logo.png\");\r\n    }\r\n|\r\n```\r\nWill get error, when I **add** `module-info.java`:\r\n```\r\nException in thread \"main\" java.lang.IllegalArgumentException: resource /imgs/logo.png relative to com.ctxx.Test not found.\r\n\tat com.google.common@29.0-jre/com.google.common.base.Preconditions.checkArgument(Preconditions.java:441)\r\n\tat com.google.common@29.0-jre/com.google.common.io.Resources.getResource(Resources.java:208)\r\n\tat OpenJFXAndOpenJDK/com.ctxx.Test.main(Test.java:15)\r\n```\r\nbut when I **delete** `module-info.java` from project, it works well.\r\n\r\n### Code Snippet2:\r\n```\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        URL resource1 = Resources.getResource(\"imgs/logo.png\");\r\n        System.out.println(resource1);\r\n    }\r\n}\r\n\r\n```\r\nwhen I **add** `module-info.java` to project, get error:\r\n```\r\nException in thread \"main\" java.lang.IllegalArgumentException: resource imgs/logo.png not found.\r\n\tat com.google.common@29.0-jre/com.google.common.base.Preconditions.checkArgument(Preconditions.java:217)\r\n\tat com.google.common@29.0-jre/com.google.common.io.Resources.getResource(Resources.java:195)\r\n\tat OpenJFXAndOpenJDK/com.ctxx.Test.main(Test.java:14)\r\n```\r\nbut when I **delete** `module-info.java` from project, it works well.\r\n\r\n", "url": "https://github.com/google/guava/issues/3868", "user": "GG-A", "labels": ["P3", "package=reflect", "platform=java11", "status=working-as-intended", "type=defect"], "created": "2020-04-20 01:40:51", "closed": "2020-04-20 16:41:34", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Reload produces inconsistencies on Enum fields", "body": "Hello,\r\n\r\nWe're using the version 27.1 of this library and it seems that we have an issue related to the data consistency returned by the cache after reloading.\r\n\r\nWe keep a list of AClass in the cache and our problem is that we are getting inconsistent data after reload. The AClass has an Enum field and this value changes randomly.\r\n\r\nWe did debug in both load and reload method and we noticed that inside of these methods we have the correct values, but when we are retrieving the list of object by cache.get( \"key\" ), the state of that Enum field is different for some objects than they were in the reload method.\r\n\r\nYou have below how we configured the cache:\r\n\r\n`\r\n\r\n         CacheBuilder\r\n         .newBuilder()\r\n         .refreshAfterWrite( cacheTimeoutInSeconds, TimeUnit.SECONDS )          \r\n         .maximumSize( NUMBER_OF_CACHE_ENTRIES) \r\n         .build( new CacheLoader<String, List<AClass>>()\r\n         {\r\n            \r\n            @Override\r\n            public List<AClass> load( String key )\r\n            {\r\n               LOG.info( \"Loading search cache\" );\r\n               return loadList();\r\n            }\r\n\r\n            @Override\r\n            public ListenableFuture<List<AClass>> reload( final String key, List<AClass> oldValue )\r\n            {\r\n               ListenableFutureTask<List<AClass>> task = ListenableFutureTask.create(()->loadList());\r\n               executorService.execute( task );\r\n               // Just for debug\r\n               new Thread(() -> {\r\n                  while(!task.isDone());\r\n                  try {\r\n                     task.get().stream()\r\n                             .filter(aClass->\"aspecificId\".equals(aClass.getId()))\r\n                             .findFirst()\r\n                                .ifPresent(aClass -> LOG.info(\"AClass at reload {}\", aClass));\r\n                  } catch (InterruptedException e) {\r\n                     e.printStackTrace();\r\n                  } catch (ExecutionException e) {\r\n                     e.printStackTrace();\r\n                  }\r\n               }).start();\r\n               // end of debug\r\n               return task;\r\n            }\r\n         } );\r\n`\r\nI would much appreciate if you could reply us as soon as possible.\r\n\r\nThanks,\r\nAndrei\r\n", "url": "https://github.com/google/guava/issues/3862", "user": "andreimladin", "labels": ["package=cache", "status=invalid", "type=defect"], "created": "2020-04-15 07:28:03", "closed": "2020-04-20 16:44:36", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Guava cache never update", "body": "Version 19.0 +\r\nThreadPool use **ThreadPoolExecutor.DiscardOldestPolicy()** \r\n\r\nWhen a rejection occurs,the cache is never updated.\r\nBecause **ValueReference** wasn't destroyed\r\n\r\nThe source code:\r\n\r\n### Refresh\r\n```java\r\n void refresh(K key) {\r\n    int hash = hash(checkNotNull(key));\r\n      //segment\r\n    segmentFor(hash).refresh(key, hash, defaultLoader, false);\r\n  }\r\n\r\n```\r\n\r\n```java\r\n@Nullable\r\n    V refresh(K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime) {\r\n      //new LoadingValueReference\r\n      final LoadingValueReference<K, V> loadingValueReference =\r\n          insertLoadingValueReference(key, hash, checkTime);\r\n      if (loadingValueReference == null) {\r\n        return null;\r\n      }\r\n      //async\r\n      ListenableFuture<V> result = loadAsync(key, hash, loadingValueReference, loader);\r\n      if (result.isDone()) {\r\n        try {\r\n          return Uninterruptibles.getUninterruptibly(result);\r\n        } catch (Throwable t) {\r\n          // don't let refresh exceptions propagate; error was already logged\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n```\r\n\r\n```java\r\n@Nullable\r\n    LoadingValueReference<K, V> insertLoadingValueReference(\r\n        final K key, final int hash, boolean checkTime) {\r\n      ReferenceEntry<K, V> e = null;\r\n      lock();\r\n      try {\r\n        long now = map.ticker.read();\r\n        preWriteCleanup(now);\r\n\r\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\r\n        int index = hash & (table.length() - 1);\r\n        ReferenceEntry<K, V> first = table.get(index);\r\n\r\n        // Look for an existing entry.\r\n        for (e = first; e != null; e = e.getNext()) {\r\n          K entryKey = e.getKey();\r\n          if (e.getHash() == hash\r\n              && entryKey != null\r\n              && map.keyEquivalence.equivalent(key, entryKey)) {\r\n            // We found an existing entry.\r\n\r\n            ValueReference<K, V> valueReference = e.getValueReference();\r\n              //\r\n            if (valueReference.isLoading()\r\n                || (checkTime && (now - e.getWriteTime() < map.refreshNanos))) {\r\n              // refresh is a no-op if loading is pending\r\n              // if checkTime, we want to check *after* acquiring the lock if refresh still needs\r\n              // to be scheduled\r\n              return null;\r\n            }\r\n\r\n            // continue returning old value while loading\r\n            ++modCount;\r\n            LoadingValueReference<K, V> loadingValueReference =\r\n                new LoadingValueReference<>(valueReference);\r\n            e.setValueReference(loadingValueReference);\r\n            return loadingValueReference;\r\n          }\r\n        }\r\n\r\n        ++modCount;\r\n        LoadingValueReference<K, V> loadingValueReference = new LoadingValueReference<>();\r\n        e = newEntry(key, hash, first);\r\n        e.setValueReference(loadingValueReference);\r\n        table.set(index, e);\r\n        return loadingValueReference;\r\n      } finally {\r\n        unlock();\r\n        postWriteCleanup();\r\n      }\r\n    }\r\n```\r\n\r\n```java\r\nListenableFuture<V> loadAsync(\r\n        final K key,\r\n        final int hash,\r\n        final LoadingValueReference<K, V> loadingValueReference,\r\n        CacheLoader<? super K, V> loader) {\r\n      final ListenableFuture<V> loadingFuture = loadingValueReference.loadFuture(key, loader);\r\n      loadingFuture.addListener(\r\n          new Runnable() {\r\n            @Override\r\n            public void run() {\r\n              try {\r\n                  //get\r\n                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\r\n              } catch (Throwable t) {\r\n                logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\r\n                loadingValueReference.setException(t);\r\n              }\r\n            }\r\n          },\r\n          directExecutor());\r\n      return loadingFuture;\r\n    }\r\n```\r\n\r\n```java\r\nV getAndRecordStats(\r\n        K key,\r\n        int hash,\r\n        LoadingValueReference<K, V> loadingValueReference,\r\n        ListenableFuture<V> newValue)\r\n        throws ExecutionException {\r\n      V value = null;\r\n      try {\r\n          //while true \uff0cget()\r\n        value = getUninterruptibly(newValue);\r\n        if (value == null) {\r\n          throw new InvalidCacheLoadException(\"CacheLoader returned null for key \" + key + \".\");\r\n        }\r\n        statsCounter.recordLoadSuccess(loadingValueReference.elapsedNanos());\r\n        //lock\r\n          storeLoadedValue(key, hash, loadingValueReference, value);\r\n        return value;\r\n      } finally {\r\n        if (value == null) {\r\n          statsCounter.recordLoadException(loadingValueReference.elapsedNanos());\r\n          removeLoadingValue(key, hash, loadingValueReference);\r\n        }\r\n      }\r\n    }\r\n```\r\n\r\n\r\n### GET\r\n\r\n```java\r\n@Nullable\r\n    V get(Object key, int hash) {\r\n      try {\r\n        if (count != 0) { // read-volatile\r\n          long now = map.ticker.read();\r\n            //\r\n          ReferenceEntry<K, V> e = getLiveEntry(key, hash, now);\r\n          if (e == null) {\r\n            return null;\r\n          }\r\n\r\n          V value = e.getValueReference().get();\r\n          if (value != null) {\r\n            recordRead(e, now);\r\n              //\r\n            return scheduleRefresh(e, e.getKey(), hash, value, now, map.defaultLoader);\r\n          }\r\n          tryDrainReferenceQueues();\r\n        }\r\n        return null;\r\n      } finally {\r\n        postReadCleanup();\r\n      }\r\n    }\r\n\r\n```\r\n\r\n```java\r\nV scheduleRefresh(\r\n        ReferenceEntry<K, V> entry,\r\n        K key,\r\n        int hash,\r\n        V oldValue,\r\n        long now,\r\n        CacheLoader<? super K, V> loader) {\r\n    //\r\n      if (map.refreshes()\r\n          && (now - entry.getWriteTime() > map.refreshNanos)\r\n          && !entry.getValueReference().isLoading()) {\r\n        V newValue = refresh(key, hash, loader, true);\r\n        if (newValue != null) {\r\n          return newValue;\r\n        }\r\n      }\r\n      return oldValue;\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n\r\nTest case:\r\n\r\n```java\r\n/**\r\n *\r\n * @author zhenmin\r\n * @version $Id: GuavaCacheLockTest.java, v 0.1 2019-12-09 3:29 PM zhenmin Exp $$\r\n */\r\npublic class GuavaCacheLockTest {\r\n\r\n    /**\r\n     * \r\n     */\r\n    private ListeningExecutorService executor;\r\n\r\n    /**\r\n     * \r\n     */\r\n    LoadingCache<String, Optional<String>> localCache;\r\n\r\n    /**\r\n     *\r\n     */\r\n    private final Executor threadPool = Executors.newFixedThreadPool(3);\r\n\r\n    /**\r\n     * \r\n     */\r\n    @Before\r\n    public void initCache() {\r\n        executor = MoreExecutors.listeningDecorator(new ThreadPoolExecutor(2,\r\n                2, 0L, TimeUnit.MILLISECONDS,\r\n                new LinkedBlockingQueue<>(20),\r\n                new TestThreadFactory(this.getClass().getName() + \"_DefaultCoordinator\"),\r\n                new ThreadPoolExecutor.DiscardPolicy()));\r\n\r\n        // \r\n        localCache = CacheBuilder.newBuilder().maximumSize(2000).refreshAfterWrite(1, MILLISECONDS).recordStats()\r\n                .build(new CacheLoader<String, Optional<String>>() {\r\n                    @Override\r\n                    public Optional<String> load(final String key) throws Exception {\r\n                        return loadData(key);\r\n                    }\r\n\r\n                    @Override\r\n                    public ListenableFuture<Optional<String>> reload(final String key,\r\n                                                                     Optional<String>\r\n                                                                             oldData)\r\n                            throws Exception {\r\n                        ListenableFutureTask<Optional<String>> task = ListenableFutureTask.create(\r\n                                () -> reloadData(key, oldData));\r\n                        executor.execute(task);\r\n                        return task;\r\n                    }\r\n                });\r\n    }\r\n\r\n\r\n    private Optional<String> loadData(String key) {\r\n        return Optional.of(\"1\");\r\n    }\r\n\r\n    private Optional<String> reloadData(String key, Optional<String> oldData) {\r\n        try {\r\n            //\r\n            TimeUnit.MILLISECONDS.sleep(200);\r\n        } catch (Exception e) {}\r\n        return Optional.of(oldData.get() + 1);\r\n    }\r\n\r\n   \r\n\r\n    /**\r\n     * \r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[11]\r\n     * Optional[111]\r\n     * Optional[1111]\r\n     * Optional[11111]\r\n     * Optional[111111]\r\n     * Optional[1111111]\r\n     * Optional[11111111]\r\n     * Optional[111111111]\r\n     *\r\n     * \r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     * Optional[1]\r\n     *\r\n     * @throws Exception\r\n     */\r\n    @Test\r\n    public void testUnRefresh() throws Exception {\r\n        for (int i = 0; i < 1000; i++) {\r\n            localCache.get(\"\" + i);\r\n        }\r\n        TimeUnit.MILLISECONDS.sleep(5);\r\n        for (int i = 0; i < 1000; i++) {\r\n            localCache.get(\"\" + i);\r\n        }\r\n        TimeUnit.SECONDS.sleep(1);\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(localCache.get(\"888\"));\r\n            TimeUnit.SECONDS.sleep(1);\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass TestThreadFactory implements ThreadFactory {\r\n\r\n    private static final AtomicInteger poolNumber = new AtomicInteger(1);\r\n\r\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\r\n\r\n    private final ThreadGroup group;\r\n\r\n    private final String namePrefix;\r\n\r\n    private final boolean isDaemon;\r\n\r\n    public TestThreadFactory(String name) {\r\n        this(name, false);\r\n    }\r\n\r\n    public TestThreadFactory(String prefix, boolean daemon) {\r\n        SecurityManager s = System.getSecurityManager();\r\n        group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();\r\n        namePrefix = prefix + \"-\" + poolNumber.getAndIncrement() + \"-test-thread-\";\r\n        isDaemon = daemon;\r\n    }\r\n\r\n    @Override\r\n    public Thread newThread(Runnable r) {\r\n        Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);\r\n        t.setDaemon(isDaemon);\r\n        if (t.getPriority() != Thread.NORM_PRIORITY) {\r\n            t.setPriority(Thread.NORM_PRIORITY);\r\n        }\r\n        return t;\r\n    }\r\n}\r\n\r\n````\r\n", "url": "https://github.com/google/guava/issues/3851", "user": "xuzhenmin", "labels": ["package=cache", "status=invalid", "type=defect"], "created": "2020-04-09 13:32:50", "closed": "2020-04-17 16:20:09", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "AbstractFuture and ForkJoinPool are incompatible with SecurityManager", "body": "I was bitten by the issue described in https://stackoverflow.com/a/31052486/6253347 when trying to use Arrow Flight with Java's SecurityManager, since `AbstractFuture` tries to check a property as part of initialization and hence can't be created from an `InnocuousThread` that doesn't have any privileges. The exception looks like this:\r\n\r\n```\r\nCaused by: java.security.AccessControlException: access denied (\"java.util.PropertyPermission\" \"guava.concurrent.generate_cancellation_cause\" \"read\")\r\n\tat java.base/java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)\r\n\tat java.base/java.security.AccessController.checkPermission(AccessController.java:1044)\r\n\tat java.base/java.lang.SecurityManager.checkPermission(SecurityManager.java:408)\r\n\tat java.base/java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:1152)\r\n\tat java.base/java.lang.System.getProperty(System.java:880)\r\n\tat com.google.common.util.concurrent.AbstractFuture.<clinit>(AbstractFuture.java:64)\r\n```\r\n\r\nI can try to put together a small repro if it's useful, but the TL;DR is that I'd like to wrap the call at https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/AbstractFuture.java#L74 in a try/catch, since it will throw if access to system properties is not permitted by the SecurityManager.", "url": "https://github.com/google/guava/issues/3784", "user": "ElliottBrossard", "labels": ["P2", "package=concurrent", "type=defect"], "created": "2020-01-27 23:05:39", "closed": "2020-05-11 19:19:28", "commits": {"e589b5c884a5996f7040ae38bdf02709f9e300da": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "6e0c5b5d50a3e457ae0d787f7c9be7b48c10120b": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 104.00027777777778, "commitsDetails": [{"commitHash": "e589b5c884a5996f7040ae38bdf02709f9e300da", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6e0c5b5d50a3e457ae0d787f7c9be7b48c10120b", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["c6f48dced81bc0dbfb8df3cfcc9475d6b9e0f460"], "nameRev": "6e0c5b5d50a3e457ae0d787f7c9be7b48c10120b tags/v29.0~58", "commitMessage": "Make AbstractFuture compatible with ForkJoinPool by catching exceptions from property retrieval.\n\nFixes #3788, #3784\n\nRELNOTES=Made it safe to load the `AbstractFuture` class from a `ForkJoinPool` thread under a security manager.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=293696683\n", "commitDateTime": "2020-02-06 21:44:28", "authoredDateTime": "2020-02-06 15:54:15", "commitGitStats": [{"filePath": "android/guava/src/com/google/common/util/concurrent/AbstractFuture.java", "insertions": 14, "deletions": 3, "lines": 17}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/AbstractFutureInnocuousThreadTest.java", "insertions": 128, "deletions": 0, "lines": 128}, {"filePath": "guava/src/com/google/common/util/concurrent/AbstractFuture.java", "insertions": 14, "deletions": 3, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractFuture.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "AbstractFutureInnocuousThreadTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureInnocuousThreadTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Guava 28.2 adds DoNotMock Annotation to PeekingIterator which causes Jackson to fail to serialize", "body": "Example code:\r\n\r\n```\r\nIterator<SomeObject> data = new ArrayList<>().iterator();\r\nPeekingIterator<SomeObject> it = Iterators.peekingIterator(data);\r\n\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.writeValue(outputStream, it);\r\n```\r\n\r\nOn Guava 28.1-jre, this works perfectly fine, and it gets serialized to an array of objects.\r\n\r\nOn Guava 28.2-jre, this serializes an empty object `{}`. This is because of the addition of `DoNotMock` in:\r\n\r\nhttps://github.com/google/guava/commit/4eea0f79c27864039a653ec4ca09ef7585e439fc\r\n\r\nThis causes Jackson to report that there exist known annotations on the class, which makes it attempt to serialize the class as a Bean rather than falling back to an Iterator:\r\n\r\nhttps://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java#L367\r\n\r\nI honestly don't know if I should file this as a Guava or a Jackson issue, however, since this issue started when we upgraded to Guava 28.2-jre, it seems like there is potentially some arguable regression in Guava.", "url": "https://github.com/google/guava/issues/3779", "user": "mglazer", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2020-01-22 16:46:08", "closed": "2020-02-07 21:09:28", "commits": {}, "ttf": 16.00027777777778, "commitsDetails": []}, {"title": "Swarmup RateLimiter seems not work for large permitsPerSecond", "body": "I need to limit the bandwidth of the file downloading, and limit the bandwidth to 50MB/s, but the real download bandwidth can only reach 7MB/s.\r\n\r\n```java\r\n@RestController\r\nclass HelloWorldController {\r\n    @GetMapping(\"/\")\r\n    public String sayHello() {\r\n        return \"hello world\";\r\n    }\r\n\r\n    @GetMapping(\"/download\")\r\n    public ResponseEntity<Resource> download() throws FileNotFoundException {\r\n        RateLimiter rateLimiter = GuavaRateLimiter.create(52428800L, 500, TimeUnit.MILLISECONDS)\r\n        FileInputStream in = new FileInputStream(\"/home/hujianxin/Downloads/officesp2010-kb2687455-fullfile-x64-en-us.exe\");\r\n        InputStreamResource resource = new InputStreamResource(new InputStream() {\r\n            @Override\r\n            public int read() throws IOException {\r\n                rateLimiter.acquire();\r\n                return in.read();\r\n            }\r\n\r\n            @Override\r\n            public int read(byte[] b) throws IOException {\r\n                rateLimiter.acquire(b.length);\r\n                return in.read(b);\r\n            }\r\n\r\n            @Override\r\n            public int read(byte[] b, int off, int len) throws IOException {\r\n                rateLimiter.acquire(len);\r\n                return in.read(b, off, len);\r\n            }\r\n        });\r\n        return ResponseEntity.ok().body(resource);\r\n    }\r\n}\r\n```", "url": "https://github.com/google/guava/issues/3770", "user": "hujianxin", "labels": ["P3", "package=concurrent", "status=invalid", "type=defect"], "created": "2020-01-15 02:25:36", "closed": "2020-01-21 20:42:25", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "MutableNetwork.hasEdgeConnecting throw IllegalArgumentException when node are missing", "body": "According to the javadoc, the hasEdgeConnecting method is equivalent to nodes().contains(nodeU) && successors(nodeU).contains(nodeV).\r\nBut, unlike this expression, it throws an exception if the nodes are unknown.\r\nHere is a simple demonstration\r\n```java\r\nimport com.google.common.graph.MutableNetwork;\r\nimport com.google.common.graph.NetworkBuilder;\r\n\r\npublic class Bug {\r\n\tpublic static void main(String[] args) {\r\n\t\tfinal MutableNetwork<String, String> graph = NetworkBuilder.undirected().allowsParallelEdges(false).build();\r\n\t\t// Foolowing line prints false\r\n\t\tSystem.out.println(graph.nodes().contains(\"1\") && graph.successors(\"1\").contains(\"2\"));\r\n\t\t// Next should print false but throws an IllegalArgumentException\r\n\t\tSystem.out.println(graph.hasEdgeConnecting(\"1\", \"2\"));\r\n\t}\r\n}\r\n```\r\nversion guava-28.1-jre", "url": "https://github.com/google/guava/issues/3721", "user": "fathzer", "labels": ["P3", "package=graph", "type=defect"], "created": "2019-11-23 15:29:47", "closed": "2020-01-12 02:54:34", "commits": {"8e0f821430acaa5b77c5c2c05380e3d29f18e410": {"commitGHEventType": "referenced", "commitUser": "nick-someone"}, "2ee7f9da69308c56d5af71267e8b797cedaf31ba": {"commitGHEventType": "referenced", "commitUser": "nick-someone"}}, "ttf": 49.000277777777775, "commitsDetails": [{"commitHash": "8e0f821430acaa5b77c5c2c05380e3d29f18e410", "commitGHEventType": "referenced", "commitUser": "nick-someone", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2ee7f9da69308c56d5af71267e8b797cedaf31ba", "commitGHEventType": "referenced", "commitUser": "nick-someone", "commitParents": ["0b2aacf4fd74b67e919463936209a119b654e3af"], "nameRev": "2ee7f9da69308c56d5af71267e8b797cedaf31ba tags/v28.2~30", "commitMessage": "AbstractNetwork: fix bug in AbstractNetwork.hasEdgeConnecting() causing it to throw if either endpoint was not in the graph.\n\nRELNOTES=Fix bug in AbstractNetwork.hasEdgeConnecting() causing it to throw if either endpoint was not in the graph.  Originally reported as GitHub issue #3721.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=282846559\n", "commitDateTime": "2019-12-02 09:22:31", "authoredDateTime": "2019-11-27 15:46:42", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "android/guava/src/com/google/common/graph/AbstractNetwork.java", "insertions": 4, "deletions": 2, "lines": 6}, {"filePath": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava/src/com/google/common/graph/AbstractNetwork.java", "insertions": 4, "deletions": 2, "lines": 6}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractNetworkTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.graph.AbstractNetworkTest.hasEdgeConnecting_disconnectedNodes()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.graph.AbstractNetworkTest.hasEdgesConnecting_nodesNotInGraph()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractNetwork.java", "spoonMethods": [{"spoonMethodName": "com.google.common.graph.AbstractNetwork.hasEdgeConnecting(com.google.common.graph.EndpointPair)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.graph.AbstractNetwork.hasEdgeConnecting(java.lang.Object,java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2ee7f9da69308c56d5af71267e8b797cedaf31ba"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 8.0, "deletions": 4.0, "lines": 12.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 9.0, "UPD": 1.0, "INS": 3.0, "MOV": 3.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["android/guava/src/com/google/common/graph", "guava/src/com/google/common/graph"], "changesInPackagesSPOON": ["com.google.common.graph.AbstractNetwork.hasEdgeConnecting(com.google.common.graph.EndpointPair)", "com.google.common.graph.AbstractNetwork.hasEdgeConnecting(java.lang.Object,java.lang.Object)"]}, {"title": "MediaType::toString can produce unparsable results", "body": "I've found cases where `MediaType::toString` generates erroneous results.\r\n\r\nOne case is when the `MediaType` instance has a parameter of an empty value. This can happen when calling `withParameter(\"foo\", \"\")`, or parsing `text/plain; foo=\"\"`. When the parameters are later joined, the value is erroneously matched as a token instead of being quoted (as tokens cannot be empty). This will lead the following to throw `IllegalArgumentException`: \r\n```java\r\nMediaType type1 = MediaType.parse(\"text/plain; foo=\\\"\\\"\");\r\nMediaType type2 = MediaType.parse(type1.toString()); // Trying to parse 'text/plain; foo=' will fail\r\n```\r\n I think [this line](https://github.com/google/guava/blob/5a8f19bd3556012ed9e65cd4268a85ddde95733f/guava/src/com/google/common/net/MediaType.java#L1091) should first check if the string is empty before matching against `TOKEN_MATCHER`, or maybe just return the literal `\"\\\"\\\"\"` on that case to avoid the `StringBuilder` allocation.\r\n\r\nAnother case is when parameters are set explicitly using `withParameter[s](...)`, where parameter value[s] contain non-ASCII characters. For example this will also throw `IllegalArgumentException`:\r\n```java\r\nMediaType type1 = MediaType.create(\"text\", \"plain\").withParameter(\"let_me_in!\", \"\\\"\u062c\u0648\u0627\u0641\u0629\\\"\");\r\nMediaType type2 = MediaType.parse(type1.toString()); // The tokenizer will fail to consume QUOTED_TEXT_MATCHER\r\n```\r\nI don't know whether this is the intended behaviour or not but `MediaType::toString` can be used in HTTP header values which shouldn't contain non-ASCII octets. IMHO `normalizeParameterValue(...)` should validate the value against the `ascii()` matcher.", "url": "https://github.com/google/guava/issues/3626", "user": "mizosoft", "labels": ["P2", "package=net", "type=defect"], "created": "2019-09-29 00:48:34", "closed": "2019-10-10 13:48:25", "commits": {"2278123479357836b9090b0e14bca8222c5b0459": {"commitGHEventType": "closed", "commitUser": "cpovirk"}, "b080067280ab22f262880d222c0a75d043962f4f": {"commitGHEventType": "referenced", "commitUser": "nick-someone"}, "5f2c9fde7ae7d392ae9ef416b91ec79cd94bd431": {"commitGHEventType": "referenced", "commitUser": "nick-someone"}}, "ttf": 11.000277777777777, "commitsDetails": [{"commitHash": "2278123479357836b9090b0e14bca8222c5b0459", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["afd127cbc84a70c360c388d192915b8b919e2e42"], "nameRev": "2278123479357836b9090b0e14bca8222c5b0459 tags/v28.2~99", "commitMessage": "Fix 2 bugs in MediaType parameter handling:\n\n1. Make empty parameter values serialize to a quoted string.\n2. Require parameter values to be ASCII.\n\nFixes https://github.com/google/guava/issues/3626\n\nRelnotes:\n  Made `MediaType` serialize empty parameter values to quoted strings.\n  Made `MediaType` reject non-ASCII parameter values.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=272190935\n", "commitDateTime": "2019-10-01 09:52:23", "authoredDateTime": "2019-10-01 05:55:11", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/net/MediaTypeTest.java", "insertions": 76, "deletions": 1, "lines": 77}, {"filePath": "android/guava/src/com/google/common/net/MediaType.java", "insertions": 7, "deletions": 3, "lines": 10}, {"filePath": "guava-gwt/test/com/google/common/net/MediaTypeTest_gwt.java", "insertions": 40, "deletions": 0, "lines": 40}, {"filePath": "guava-tests/test/com/google/common/net/MediaTypeTest.java", "insertions": 76, "deletions": 1, "lines": 77}, {"filePath": "guava/src/com/google/common/net/MediaType.java", "insertions": 7, "deletions": 3, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MediaTypeTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaTypeTest.testToString()", "TOT": 5, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParameters_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParameters_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParameter_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParameter_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParametersIterable_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParametersIterable_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MediaType.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaType.computeToString().2.apply(java.lang.String)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.net.MediaType.normalizeParameterValue(java.lang.String,java.lang.String)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MediaTypeTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParameter_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParameter_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParametersIterable_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParametersIterable_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParameters_nonAsciiParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParameters_nonAsciiParameterValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b080067280ab22f262880d222c0a75d043962f4f", "commitGHEventType": "referenced", "commitUser": "nick-someone", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5f2c9fde7ae7d392ae9ef416b91ec79cd94bd431", "commitGHEventType": "referenced", "commitUser": "nick-someone", "commitParents": ["0e94fb5bb8a6c3a4084854c87335d2e6fa20a97e"], "nameRev": "5f2c9fde7ae7d392ae9ef416b91ec79cd94bd431 tags/v28.2~82", "commitMessage": "Require tokens to be non-empty.\n\nFollowup to CL 272190935.\n\nFixes https://github.com/google/guava/issues/3626 (again :))\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=273763774\n", "commitDateTime": "2019-10-10 09:48:24", "authoredDateTime": "2019-10-09 09:44:07", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/net/MediaTypeTest.java", "insertions": 27, "deletions": 2, "lines": 29}, {"filePath": "android/guava/src/com/google/common/net/MediaType.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-gwt/test/com/google/common/net/MediaTypeTest_gwt.java", "insertions": 19, "deletions": 4, "lines": 23}, {"filePath": "guava-tests/test/com/google/common/net/MediaTypeTest.java", "insertions": 27, "deletions": 2, "lines": 29}, {"filePath": "guava/src/com/google/common/net/MediaType.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MediaTypeTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_nonAsciiParameter()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_nonAsciiParameterValue()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_emptyType()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testCreate_emptySubtype()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest.testWithParameter_emptyParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MediaType.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaType.normalizeToken(java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MediaTypeTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_nonAsciiParameter()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_nonAsciiParameterValue()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_emptySubtype()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testCreate_emptyType()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.net.MediaTypeTest_gwt.testWithParameter_emptyParameter()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2278123479357836b9090b0e14bca8222c5b0459", "5f2c9fde7ae7d392ae9ef416b91ec79cd94bd431"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 16.0, "deletions": 6.0, "lines": 22.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 7.0, "UPD": 0.0, "INS": 5.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["android/guava/src/com/google/common/net", "guava/src/com/google/common/net"], "changesInPackagesSPOON": ["com.google.common.net.MediaType.normalizeParameterValue(java.lang.String,java.lang.String)", "com.google.common.net.MediaType.computeToString().2.apply(java.lang.String)", "com.google.common.net.MediaType.normalizeToken(java.lang.String)"]}, {"title": "cache loader.reload() new value can not be null", "body": " ListenableFuture<V> newValue = loader.reload(key, previousValue);\r\n        if (newValue == null) {\r\n          return Futures.immediateFuture(null);\r\n        }\r\npublic ListenableFuture<V> reload(K key, V oldValue) throws Exception {\r\n    checkNotNull(key);\r\n    checkNotNull(oldValue);\r\n    return Futures.immediateFuture(load(key));\r\n  }\r\n#class: LocalCache  line: 3632      newValue can possible be null?   I do not think so, is it a bug?", "url": "https://github.com/google/guava/issues/3616", "user": "yws-tracy", "labels": ["package=cache", "status=will-not-fix", "type=defect"], "created": "2019-09-22 09:36:39", "closed": "2019-09-23 21:44:20", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "MoreExecutors.java (w/ & w/o Android) calls the AppEngine currentRequestThreadFactory in JDK8", "body": "AppEngine no longer requires CurrentRequestFactory to be called for Java 8.  It causes some apps to fail during local development as those API's aren't injected when running locally.\r\n\r\n```\r\njava.lang.RuntimeException: Couldn't invoke ThreadManager.currentRequestThreadFactory\r\n        at com.google.common.util.concurrent.MoreExecutors.platformThreadFactory(MoreExecutors.java:759)\r\n        at com.google.common.util.concurrent.MoreExecutors.newThread(MoreExecutors.java:799)\r\n        at com.google.common.util.concurrent.MoreExecutors$Application.addDelayedShutdownHook(MoreExecutors.java:203)\r\n        at com.google.common.util.concurrent.MoreExecutors$Application.getExitingScheduledExecutorService(MoreExecutors.java:189)\r\n        at com.google.common.util.concurrent.MoreExecutors$Application.getExitingScheduledExecutorService(MoreExecutors.java:195)\r\n        at com.google.common.util.concurrent.MoreExecutors.getExitingScheduledExecutorService(MoreExecutors.java:146)\r\n        at com.google.cloud.sql.core.CoreSocketFactory.getDefaultExecutor(CoreSocketFactory.java:149)\r\n```\r\n\r\n@ludoch or @eamonnmcmanus will have more context.  This relates to GoogleCloudPlatform/cloud-sql-jdbc-socket-factory#159\r\n\r\nThe API isn't available in GAE Java 11.", "url": "https://github.com/google/guava/issues/3598", "user": "lesv", "labels": ["P2", "package=concurrent", "status=triaged", "type=defect"], "created": "2019-09-08 22:59:02", "closed": "2019-10-02 16:48:51", "commits": {"7bd4b2351c1483f34e7192768b4f3e7a10447c33": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "e3ee00d6769d219c9646a17114fa00e2955b54aa": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 23.00027777777778, "commitsDetails": [{"commitHash": "7bd4b2351c1483f34e7192768b4f3e7a10447c33", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e3ee00d6769d219c9646a17114fa00e2955b54aa", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["67dd062cb9cf27c366eaf51260c1585aff9027fe"], "nameRev": "e3ee00d6769d219c9646a17114fa00e2955b54aa tags/v28.2~92", "commitMessage": "Fix the logic that decides whether to use currentRequestThreadFactory() under App Engine.\n\nWhile there, also support thread renaming under App Engine.\n\nFixes https://github.com/google/guava/issues/3598\nRelevant to https://github.com/google/guava/issues/3606\n(also, the CL in which I experimented with https://github.com/google/guava/issues/3569 before backing it out)\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=272446666\n", "commitDateTime": "2019-10-02 12:48:49", "authoredDateTime": "2019-10-02 08:48:58", "commitGitStats": [{"filePath": "android/guava/src/com/google/common/util/concurrent/Callables.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "android/guava/src/com/google/common/util/concurrent/MoreExecutors.java", "insertions": 11, "deletions": 16, "lines": 27}, {"filePath": "guava-gwt/test/com/google/common/util/concurrent/testModule.gwt.xml", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava/src/com/google/common/util/concurrent/Callables.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "guava/src/com/google/common/util/concurrent/MoreExecutors.java", "insertions": 11, "deletions": 16, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Callables.java", "spoonMethods": []}, {"spoonFilePath": "MoreExecutors.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.MoreExecutors.isAppEngine()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.MoreExecutors.platformThreadFactory()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.Executor,com.google.common.base.Supplier)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.ExecutorService,com.google.common.base.Supplier)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.ScheduledExecutorService,com.google.common.base.Supplier)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e3ee00d6769d219c9646a17114fa00e2955b54aa"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 30.0, "deletions": 38.0, "lines": 68.0, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 2.0, "INS": 0.0, "MOV": 0.0, "DEL": 3.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/util/concurrent", "android/guava/src/com/google/common/util/concurrent"], "changesInPackagesSPOON": ["com.google.common.util.concurrent.MoreExecutors.platformThreadFactory()", "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.ExecutorService,com.google.common.base.Supplier)", "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.ScheduledExecutorService,com.google.common.base.Supplier)", "com.google.common.util.concurrent.MoreExecutors.renamingDecorator(java.util.concurrent.Executor,com.google.common.base.Supplier)", "com.google.common.util.concurrent.MoreExecutors.isAppEngine()"]}, {"title": "Upgrading incompatible issue", "body": "Hi,\r\n\r\nThe following code snippets throw an incompatible issue when I try to upgrade Guava from 19.0 to 28.0.\r\n\r\n```\r\n@Test\r\npublic void find_element_in_iterable () {\r\n    checkArgument(\r\n        Boolean.TRUE,\r\n        \"test string\",\r\n        1,\r\n        2);\r\n}\r\n```\r\n\r\nIt throws an error:\r\n```\r\nreference to checkArgument is ambiguous\r\n[ERROR]   both method checkArgument(boolean,java.lang.String,int,java.lang.Object) in com.google.common.base.Preconditions and method checkArgument(boolean,java.lang.String,int,int) in com.google.common.base.Preconditions match\r\n```\r\n\r\nThanks a lot", "url": "https://github.com/google/guava/issues/3574", "user": "SElab2019", "labels": ["package=base", "status=will-not-fix", "type=defect"], "created": "2019-08-21 20:24:22", "closed": "2019-08-22 12:18:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Reuse of ImmutableSet.Builder with expected size leading to infinite loop on ImmutableSet.contains", "body": "The following snippet produces an infinite loop inside the method ImmutableSet.contains:\r\n\r\n```java\r\nImmutableSet.Builder<Object> builder = ImmutableSet.builderWithExpectedSize(6);\r\nbuilder.add(0);\r\nbuilder.build();\r\nImmutableSet<Object> subject = builder.add(1).add(2).add(3).build();\r\nboolean contains = subject.contains(4);\r\n```\r\n\r\nThis behavior was first observed in guava 25.1-jre and it still happens in version 28.0-jre.\r\n\r\nAnalyzing the source code, I think there is a problem in the implementation of ImmutableSet.RegularSetBuilderImpl.review(). As it decides to reduce the _hashTable_, it does not recompute the _expandTableThreshold_ nor _maxRunBeforeFallback_. From this point, I observed two consequences:\r\n\r\n1. Given a RegularSetBuilderImpl with D distinct elements. \r\nAfter resizing the hashTable to size N, if the (N-D) distinct elements are added, the subsequent build() method would return an instance of ImmutableSet that reproduces the infinite loop on method contains.\r\n2. In the same scenario as above, when the (N+1)th element is added to the builder, the RegularSetBuilderImpl will iterate _maxRunBeforeFallback_ times in a full hashTable, until it falls back to the JdkBackedSetBuilderImpl.\r\n\r\n", "url": "https://github.com/google/guava/issues/3570", "user": "tomasisonfire", "labels": ["P1", "package=collect", "status=fixed", "type=defect"], "created": "2019-08-20 21:47:34", "closed": "2019-08-21 18:48:26", "commits": {"0007cb257b593400097f37cf5fa9c8d5fb598c62": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0007cb257b593400097f37cf5fa9c8d5fb598c62", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["7ab65d08c22fa95adb987d3b3849e5cab60a1c72"], "nameRev": "0007cb257b593400097f37cf5fa9c8d5fb598c62 tags/v28.1~11", "commitMessage": "Fix #3570 by resetting expandTableThreshold and\nmaxRunBeforeFallback after resizing the hashTable.\n\nFixes #3571\n\n[]\n\nRELNOTES=Fixed a bug in `ImmutableSet.Builder` that could lead to infinite loops when building multiple sets from the same builder.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=264648412\n", "commitDateTime": "2019-08-21 14:48:23", "authoredDateTime": "2019-08-21 11:05:47", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/collect/ImmutableSetTest.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableSetTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSetTest.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "guava/src/com/google/common/collect/ImmutableSet.java", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImmutableSetTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSetTest.testReuseBuilderReducingHashTableSizeWithPowerOfTwoTotalElements()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableSetTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSetTest_gwt.testReuseBuilderReducingHashTableSizeWithPowerOfTwoTotalElements()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableSet.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSet.RegularSetBuilderImpl.review()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "listeningDecorator(ScheduledExecutorService) should cancel scheduled tasks when terminating", "body": "I got an email when #3553 was filed about this, but it seems to have been deleted.\r\n\r\nThe spec for `ScheduledExecutorService` added this new requirement when moving from [Java 8](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html#scheduleAtFixedRate-java.lang.Runnable-long-long-java.util.concurrent.TimeUnit-) to [Java 9](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledExecutorService.html#scheduleAtFixedRate-java.lang.Runnable-long-long-java.util.concurrent.TimeUnit-):\r\n\r\n> The sequence of task executions continues indefinitely until one of the following exceptional completions occur:\r\n> ...\r\n> - The executor terminates, _also resulting in task cancellation_.\r\n\r\n(Yes, the old spec says \"Otherwise, the task will only terminate via cancellation _or termination of the executor_.\" But it's not clear that \"task termination\" (presumably meaning \"Is the `Runnable` run again?\") implies \"`Future` cancellation.\" In particular, if termination implied cancellation, I would expect the spec to just say \"Otherwise, the task will only terminate via cancellation [, such as by termination of the executor].\" Anyway, it's mostly academic; the spec now says what is says, and I don't think the old spec _forbids_ that behavior.)", "url": "https://github.com/google/guava/issues/3554", "user": "cpovirk", "labels": ["P3", "package=concurrent", "type=defect"], "created": "2019-08-09 16:24:53", "closed": "2019-08-13 15:23:14", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "TimeLimiter.callWithTimeout  Not working", "body": "While using TimeLimiter.callWithTimeout(Callable<T> callable, Duration timeout). After the given timeout the thread is not interrupted. Please Help on this. \r\n**Sample Implementation:**\r\n```\r\nTimeLimiter stl =  SimpleTimeLimiter.create(callTimeoutPool);\r\n            stl.callWithTimeout(new Callable<Object>() {\r\n                @Override\r\n                public Object call()\r\n                {\r\n//Logic here\r\n                }\r\n            }, callTimeout, TimeUnit.MILLISECONDS);\r\n        }\r\n```", "url": "https://github.com/google/guava/issues/3550", "user": "GowthamKarthick", "labels": ["package=concurrent", "status=invalid", "type=defect"], "created": "2019-08-05 04:56:47", "closed": "2019-08-05 20:17:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Deadlock in HashBiMap#seekByValue", "body": "We experienced an application deadlock in the `seekByValue()` method in the `HashBiMap` class.\r\n\r\nThis is the relevant application stacktrace we've seen:\r\n\r\n    \"Consumer-56\" #229 prio=5 os_prio=0 cpu=62908744.70ms elapsed=865617.45s tid=0x00007fc39c63f800 nid=0x1c6a runnable  [0x00007fc371a9f000]\r\n       java.lang.Thread.State: RUNNABLE\r\n            at com.google.common.collect.HashBiMap.seekByValue(HashBiMap.java:234)\r\n            at com.google.common.collect.HashBiMap.put(HashBiMap.java:274)\r\n            at com.google.common.collect.HashBiMap.put(HashBiMap.java:260)\r\n            at ...\r\n            - locked <0x00000001c7a40130> (a [Ljava.lang.Object;)\r\n            at ...\r\n        at java.lang.Thread.run(java.base@11.0.3/Thread.java:834)\r\n\r\nThe HashBiMap is always executed in a critical section, so the data structures of the map should be ok.\r\nMy lucky guess is that the condition `entry != null` in the loop in `seekByValue()` is not met under certain circumstances and needs to be refined.\r\n\r\nSee the line here\r\nhttps://github.com/google/guava/blob/82988bb2cafb95fd5dde57720024112c20891ac3/guava/src/com/google/common/collect/HashBiMap.java#L233\r\n", "url": "https://github.com/google/guava/issues/3548", "user": "sfuhrm", "labels": ["P3", "package=collect", "status=triaged", "type=defect"], "created": "2019-08-01 10:14:04", "closed": "2019-08-02 07:52:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Avoid using deprecated CharMatcher constants in Guava itself", "body": "They're deprecated for a reason, after all :)\r\n\r\nAttempted search:\r\n\r\n```\r\n$ grep -r 'CharMatcher[.]' */{src,test}/ | grep -v -e CharMatcherTest -e anyOf -e whitespace -e '[.]class' -e '[*]' -e 'noneOf' -e '[.]is[(]' -e inRange -e 'none' -e CharMatcher.java: -e isNot -e ascii -e BenchmarkHelpers -e javaIsoControl\r\nguava/src/com/google/common/net/InternetDomainName.java:      CharMatcher.javaLetterOrDigit().or(DASH_MATCHER);\r\nguava/src/com/google/common/net/InternetDomainName.java:    if (isFinalPart && CharMatcher.digit().matches(part.charAt(0))) {\r\nguava/src/com/google/common/reflect/ClassPath.java:        return CharMatcher.digit().trimLeadingFrom(innerClassName);\r\n```", "url": "https://github.com/google/guava/issues/3544", "user": "cpovirk", "labels": ["P3", "package=general", "status=research", "type=defect"], "created": "2019-07-30 20:10:23", "closed": "2019-11-11 16:31:20", "commits": {}, "ttf": 103.00027777777778, "commitsDetails": []}, {"title": "BaseEncoding#decodingStream decodes invalid Base64 strings successfully", "body": "I have a suspicious behaviour on streaming a Base64 decode. It does not fail an some invalid Base64 strings.\r\n\r\nI've wrote a unit test.\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.StringReader;\r\nimport java.util.Base64;\r\nimport java.util.Random;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\nimport com.google.common.io.BaseEncoding;\r\nimport com.google.common.io.ByteStreams;\r\n\r\npublic class Base64Test {\r\n\r\n    private static final String BASE64_STRING = createTestBase64();\r\n    private static final String NO_BASE64_STRING_1 = BASE64_STRING.substring(0, 500_000) + \"@\" + BASE64_STRING.substring(500_001);\r\n    private static final String NO_BASE64_STRING_2 = BASE64_STRING.substring(0, 500_000) + \"@@\" + BASE64_STRING.substring(500_002);\r\n\r\n    private static String createTestBase64() {\r\n        final byte[] b = new byte[1_000_000];\r\n        new Random().nextBytes(b);\r\n        return Base64.getEncoder().encodeToString(b);\r\n    }\r\n\r\n    @Test\r\n    public void decode_validBase64() {\r\n        Assert.assertEquals(BaseEncoding.base64().decode(BASE64_STRING).length, 1_000_000);\r\n    }\r\n\r\n    @Test\r\n    public void decodingStream_validBase64() throws IOException {\r\n        Assert.assertEquals(ByteStreams.toByteArray(BaseEncoding.base64().decodingStream(new StringReader(BASE64_STRING))).length, 1_000_000);\r\n    }\r\n\r\n    @Test(expected = IllegalArgumentException.class)\r\n    public void decode_invalidBase64_1() {\r\n        BaseEncoding.base64().decode(NO_BASE64_STRING_1);\r\n    }\r\n\r\n    @Test(expected = IllegalArgumentException.class)\r\n    public void decode_invalidBase64_2() {\r\n        BaseEncoding.base64().decode(NO_BASE64_STRING_2);\r\n    }\r\n\r\n    @Test(expected = BaseEncoding.DecodingException.class) // does not fail as expected\r\n    public void decodingStream_invalidBase64_1() throws IOException {\r\n        ByteStreams.exhaust(BaseEncoding.base64().decodingStream(new StringReader(NO_BASE64_STRING_1)));\r\n    }\r\n\r\n    @Test(expected = BaseEncoding.DecodingException.class) // fails as expected\r\n    public void decodingStream_invalidBase64_2() throws IOException {\r\n        ByteStreams.exhaust(BaseEncoding.base64().decodingStream(new StringReader(NO_BASE64_STRING_2)));\r\n    }\r\n}\r\n```\r\n\r\nThe `decode` method fails as expected, but not `decodingStream` with the same invalid Base64 string.\r\nA second invalid Base64 string fails as expected on both methods.\r\n\r\nTested with Guava 23.0 and 28.0-jre.", "url": "https://github.com/google/guava/issues/3542", "user": "sdoeringNew", "labels": ["P2", "package=io", "status=fixed", "type=defect"], "created": "2019-07-30 10:52:54", "closed": "2019-08-05 19:53:12", "commits": {"4e6478d4bec284f047a686b8a16dc2b32628639a": {"commitGHEventType": "referenced", "commitUser": "netdpb"}, "ddd4a49fb760ccccc7903305f68310f4f9a90587": {"commitGHEventType": "referenced", "commitUser": "netdpb"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "4e6478d4bec284f047a686b8a16dc2b32628639a", "commitGHEventType": "referenced", "commitUser": "netdpb", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ddd4a49fb760ccccc7903305f68310f4f9a90587", "commitGHEventType": "referenced", "commitUser": "netdpb", "commitParents": ["a3c9f2cbe27886ef052922dba1cceedbf39cec2d"], "nameRev": "ddd4a49fb760ccccc7903305f68310f4f9a90587 tags/v28.1~18", "commitMessage": "Fix an issue where the InputStream returned by BaseEncoding.decodingStream(Reader) could fail to throw DecodingException while decoding an invalid string.\n\nThis was caused by the default behavior of InputStream.read(byte[], int, int), which swallows any IOException thrown by any call to the single-byte read() method other than the first. To fix it, just override that method with an implementation that does not swallow any exceptions.\n\nFixes https://github.com/google/guava/issues/3542\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=261712883\n", "commitDateTime": "2019-08-16 13:24:21", "authoredDateTime": "2019-08-05 10:21:14", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/io/BaseEncodingTest.java", "insertions": 68, "deletions": 15, "lines": 83}, {"filePath": "android/guava/src/com/google/common/io/BaseEncoding.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "guava-tests/test/com/google/common/io/BaseEncodingTest.java", "insertions": 68, "deletions": 15, "lines": 83}, {"filePath": "guava/src/com/google/common/io/BaseEncoding.java", "insertions": 21, "deletions": 0, "lines": 21}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseEncodingTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.io.BaseEncodingTest.assertFailsToDecode(com.google.common.io.BaseEncoding,java.lang.String,java.lang.String)", "TOT": 18, "UPD": 5, "INS": 1, "MOV": 11, "DEL": 1}, {"spoonMethodName": "com.google.common.io.BaseEncodingTest.AssertFailsToDecodeStrategy", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.io.BaseEncodingTest.AssertFailsToDecodeStrategy.4.assertFailsToDecode(com.google.common.io.BaseEncoding,java.lang.String,java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BaseEncoding.java", "spoonMethods": [{"spoonMethodName": "com.google.common.io.BaseEncoding.StandardBaseEncoding.decodingStream(java.io.Reader).2.read(byte[],int,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ddd4a49fb760ccccc7903305f68310f4f9a90587"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 42.0, "deletions": 0.0, "lines": 42.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/io", "android/guava/src/com/google/common/io"], "changesInPackagesSPOON": ["com.google.common.io.BaseEncoding.StandardBaseEncoding.decodingStream(java.io.Reader).2.read(byte[],int,int)"]}, {"title": "Memory Leak Issue", "body": "JAVA 10, Guava Version => 18.0, I have analysed my application memory consumption and found memory leak over LoadingCache. \r\n\r\nprivate static LoadingCache<Integer, Map<String, String>> userSettingMap = CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.DAYS)\r\n\t\t\t.build(new CacheLoader<>() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic Map<String, String> load(Integer userId) throws Exception {\r\n\t\t\t\t}\r\n\t\t\t});\r\n \r\n![jmx memory analyse snapshot](https://user-images.githubusercontent.com/19775539/59914351-d6d66e00-9437-11e9-8411-97aec3f235e4.png)\r\n", "url": "https://github.com/google/guava/issues/3511", "user": "GAURAVJAYSWAL", "labels": ["package=cache", "status=invalid", "type=defect"], "created": "2019-06-21 09:49:22", "closed": "2019-06-24 14:58:19", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "Invalid OSGi headers in v27.1-jre", "body": "The OSGi headers (`Import-Packages` and `uses` directive of `Export-Packages`) in MANIFEST.MF are referring to a missing package `com.google.common.util.concurrent.internal`.\r\n\r\nI've managed to fix it by manually editing the manifest, but since the package is actually removed, the BND file must be fixed to account for this change.", "url": "https://github.com/google/guava/issues/3400", "user": "hamid-nazari", "labels": ["status=invalid", "type=defect"], "created": "2019-03-10 11:41:31", "closed": "2019-03-18 14:36:26", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "Java8 JaCoCo Coverage missing \u201cnew TypeToken\u201d code inside anonymous class", "body": "So, I wrote a small piece of code to get class object of a generic using Java Reflection and Guava `TypeToken`, but for some reason JaCoCo coverlay \r\nis missing lines inside the `TypeToken`, specifcally here: `      final TypeToken<PHASE> typeTokenPhase = new TypeToken<PHASE (getClass()) {};`\r\n\r\nIn the report, I see `0%` coverage in section: `new TypeToken() {...}`\r\n\r\n\r\n    import java.lang.reflect.Type;\r\n    import com.google.common.reflect.TypeToken;\r\n\r\n    public class MyClass<PHASE> {\r\n\r\n        public Class<PHASE> getPhaseClass() {\r\n          final TypeToken<PHASE> typeTokenPhase = new TypeToken<PHASE     (getClass()) {};\r\n          final Type typePhase = typeTokenPhase.getType();\r\n          Assert.assertEquals(true, typePhase instanceof Class);\r\n          return (Class<PHASE>) typePhase;\r\n        }\r\n    }\r\n\r\nAm I missing anything?\r\n\r\nUsing GoogleGuava-0.23", "url": "https://github.com/google/guava/issues/3336", "user": "abarik1981", "labels": ["status=invalid", "type=defect"], "created": "2018-12-07 10:42:10", "closed": "2018-12-07 18:44:36", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "guava-beta-checker fails to detect @Beta APIs in method references", "body": "`ImmutableMap.copyOf(Iterable<? extends Map.Entry<? extends K,? extends V>> entries)` is marked `@Beta`, but the following snippet gets through the BetaApi check without an error,\r\n\r\n```java\r\nFunction<Iterable<Entry<?, ?>>, ?> f = ImmutableMap::copyOf;\r\nf.apply(Collections.emptyList());\r\n```\r\n\r\nwhereas,\r\n\r\n```java\r\nImmutableMap.copyOf(Collections.emptyList());\r\n```\r\n\r\ngives the expected `@Beta APIs should not be used in library code as they are subject to change`", "url": "https://github.com/google/guava/issues/3335", "user": "c2nes", "labels": ["P2", "package=annotations", "status=fixed", "type=defect"], "created": "2018-12-04 22:20:09", "closed": "2019-10-14 16:07:18", "commits": {}, "ttf": 313.0002777777778, "commitsDetails": []}, {"title": "guava-27.0-jre.jar contains failureaccess class files", "body": "I tried upgrading to guava 27.0 in my project and noticed a new warning at build time:\r\n\r\n```\r\n[WARNING] guava-27.0-jre.jar, failureaccess-1.0.jar define 2 overlapping classes:\r\n[WARNING]   - com.google.common.util.concurrent.internal.InternalFutureFailureAccess\r\n[WARNING]   - com.google.common.util.concurrent.internal.InternalFutures\r\n[WARNING] maven-shade-plugin has detected that some class files are\r\n[WARNING] present in two or more JARs. When this happens, only one\r\n[WARNING] single version of the class is copied to the uber jar.\r\n[WARNING] Usually this is not harmful and you can skip these warnings,\r\n[WARNING] otherwise try to manually exclude artifacts based on\r\n[WARNING] mvn dependency:tree -Ddetail=true and the above output.\r\n[WARNING] See http://maven.apache.org/plugins/maven-shade-plugin/\r\n```\r\n\r\nIndeed, I can see those `.class` files in the `guava-27.0-jre.jar` I downloaded from Maven.  Are those class files supposed to be there?  I ask because it seems like they are supposed to be in the failureaccess jar only, but they were included in the guava jar by mistake.", "url": "https://github.com/google/guava/issues/3302", "user": "michaelhixson", "labels": ["status=fixed", "type=defect"], "created": "2018-10-18 21:26:36", "closed": "2018-11-19 21:45:35", "commits": {"a980611b96ea86b67ccb836687a50d2a9cecf98d": {"commitGHEventType": "referenced", "commitUser": "cgdecker"}}, "ttf": 32.000277777777775, "commitsDetails": [{"commitHash": "a980611b96ea86b67ccb836687a50d2a9cecf98d", "commitGHEventType": "referenced", "commitUser": "cgdecker", "commitParents": ["addd09ad01d7dbe7d5a72a1c5b949c3e08571910"], "nameRev": "a980611b96ea86b67ccb836687a50d2a9cecf98d tags/failureaccess-v1.0.1~9", "commitMessage": "Fix the issue with classes that should only be included in the failureaccess artifact being included in the main Guava jar.\n\nIt appears (thanks to @michaelhixson on https://github.com/google/guava/issues/3302) that the issue is with the maven-bundle-plugin (which does OSGi stuff). Presumably because Guava was declaring that it exports com.google.common.* (and doesn't exclude com.google.common.util.concurrent.internal), it was pulling those class files in from the dependency. It was also pointed out by @talios in that issue that failureaccess doesn't include OSGi metadata to export that package.\n\nThis change should fix both of those issues, but we're going to need to release a failureaccess 1.0.1 and then guava 27.0.1.\n\nRELNOTES=Fixes an issue where classes that should only be included in failureaccess (Guava's one dependency) were also being included in the main Guava jar.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=218884985\n", "commitDateTime": "2018-10-26 16:57:13", "authoredDateTime": "2018-10-26 11:22:49", "commitGitStats": [{"filePath": "android/guava/pom.xml", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "futures/failureaccess/pom.xml", "insertions": 22, "deletions": 1, "lines": 23}, {"filePath": "guava/pom.xml", "insertions": 6, "deletions": 1, "lines": 7}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a980611b96ea86b67ccb836687a50d2a9cecf98d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "SecureDirectoryStream-based recursive file tree deletion doesn't always work in Docker", "body": "I encountered a strange behaviour of `MoreFiles.deleteRecursively()` in a Docker container. It throws a `DirectoryNotEmptyException` at this line: https://github.com/google/guava/blob/34c1616279efe08089960aafd3df486cf8a04820/guava/src/com/google/common/io/MoreFiles.java#L626\r\nIt should never happen unless files are concurrently created in the directory, that shouldn't be the case.\r\n\r\nI copied the logic of this method, leaving only the \"insecure\" path, and the problem disappeared.\r\n", "url": "https://github.com/google/guava/issues/3212", "user": "leventov", "labels": ["P2", "package=io", "status=obsolete", "type=defect"], "created": "2018-07-19 20:55:36", "closed": "2018-07-24 21:23:38", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Iteration over Streams.concat hangs", "body": "`Streams.concat` functions as expected when its arguments are finite streams.\r\nIf we concat two streams: the first is finite and the second is infinite, then obviously we get an infinite stream. But we can iterate over a limited number of elements. This is the scenario where the program hangs.\r\n\r\n```java\r\nimport com.google.common.collect.Streams;\r\n\r\nimport java.util.PrimitiveIterator;\r\nimport java.util.stream.IntStream;\r\n\r\npublic class MyMain {\r\n    public static void main(String[] args) {\r\n\r\n        IntStream stream123 = IntStream.of(1, 2, 3);\r\n        IntStream stream4567 = IntStream.of(4, 5, 6, 7);\r\n        IntStream stream1234567 = Streams.concat(stream123, stream4567);\r\n        printFirstElements(stream1234567, 5);\r\n        // output:\r\n        // 1\r\n        // 2\r\n        // 3\r\n        // 4\r\n        // 5\r\n\r\n\r\n\r\n        IntStream streamInfinite99 = IntStream.generate(() -> 99);\r\n        printFirstElements(streamInfinite99, 3);\r\n        // output:\r\n        // 99\r\n        // 99\r\n        // 99\r\n\r\n        IntStream stream123AndThenInfinite77 = Streams.concat(IntStream.of(1, 2, 3), IntStream.generate(() -> 77));\r\n        printFirstElements(stream123AndThenInfinite77, 5);\r\n        // output:\r\n        // 1\r\n        // 2\r\n        // 3\r\n        // and then program hangs\r\n    }\r\n\r\n    static void printFirstElements(IntStream stream, int count) {\r\n        int counter = 0;\r\n        for (PrimitiveIterator.OfInt iterator = stream.iterator(); iterator.hasNext(); ) {\r\n            Integer next = iterator.next();\r\n            System.out.println(next);\r\n            counter++;\r\n            if (counter == count) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n```", "url": "https://github.com/google/guava/issues/3156", "user": "kleinron", "labels": ["P2", "package=collect", "status=fixed", "status=triaged", "type=defect"], "created": "2018-05-24 08:31:46", "closed": "2019-08-16 17:24:53", "commits": {"9e6e1d02faa4ff07f2c5746a1902ae36cd54335b": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}, "15db5b7f84531a19e7e0ab6f7932208e35b8b068": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}, "e04eb5948b7cdfa401a190bb3fb071a59dfbe5bc": {"commitGHEventType": "closed", "commitUser": "cpovirk"}, "c30df914935008e5a6357e99aa368fb982c74039": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "0763099e769963bd0d93f865a4e7c3a5b320085a": {"commitGHEventType": "referenced", "commitUser": "netdpb"}, "5d20c304e39ca8a920bdfc207a29a75dd0eb8867": {"commitGHEventType": "closed", "commitUser": "netdpb"}}, "ttf": 449.0002777777778, "commitsDetails": [{"commitHash": "9e6e1d02faa4ff07f2c5746a1902ae36cd54335b", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "15db5b7f84531a19e7e0ab6f7932208e35b8b068", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e04eb5948b7cdfa401a190bb3fb071a59dfbe5bc", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["fffd6a33652bdf7c7b3782feebbf73b1edd75dac"], "nameRev": "e04eb5948b7cdfa401a190bb3fb071a59dfbe5bc tags/v26.0~42", "commitMessage": "Fix https://github.com/google/guava/issues/3156 by implementing a proper CollectSpliterators.flatMapTo{Int,Long,Double}.\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=198102330\n", "commitDateTime": "2018-05-29 09:31:02", "authoredDateTime": "2018-05-25 14:22:57", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/collect/StreamsTest_gwt.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "guava-tests/test/com/google/common/collect/StreamsTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/CollectSpliterators.java", "insertions": 252, "deletions": 63, "lines": 315}, {"filePath": "guava/src/com/google/common/collect/Streams.java", "insertions": 68, "deletions": 12, "lines": 80}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "c30df914935008e5a6357e99aa368fb982c74039", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["e04eb5948b7cdfa401a190bb3fb071a59dfbe5bc"], "nameRev": "c30df914935008e5a6357e99aa368fb982c74039 tags/v26.0~41", "commitMessage": "Automated rollback of 9e6e1d02faa4ff07f2c5746a1902ae36cd54335b\n\n*** Reason for rollback ***\n\nAppears to tickle a J2CL bug.\n\n*** Original change description ***\n\nFix https://github.com/google/guava/issues/3156 by implementing a proper CollectSpliterators.flatMapTo{Int,Long,Double}.\n\n***\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=198112871\n", "commitDateTime": "2018-05-29 09:31:02", "authoredDateTime": "2018-05-25 15:30:08", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/collect/StreamsTest_gwt.java", "insertions": 0, "deletions": 20, "lines": 20}, {"filePath": "guava-tests/test/com/google/common/collect/StreamsTest.java", "insertions": 0, "deletions": 24, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/CollectSpliterators.java", "insertions": 63, "deletions": 252, "lines": 315}, {"filePath": "guava/src/com/google/common/collect/Streams.java", "insertions": 12, "deletions": 68, "lines": 80}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "0763099e769963bd0d93f865a4e7c3a5b320085a", "commitGHEventType": "referenced", "commitUser": "netdpb", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5d20c304e39ca8a920bdfc207a29a75dd0eb8867", "commitGHEventType": "closed", "commitUser": "netdpb", "commitParents": ["588ce172f1270a1a5267933fab5486a048e60025"], "nameRev": "5d20c304e39ca8a920bdfc207a29a75dd0eb8867 tags/v28.1~14", "commitMessage": "Fix https://github.com/google/guava/issues/3156 by implementing a proper `CollectSpliterators.flatMapTo{Int,Long,Double}`.\n\nAlso, modify the existing `CollectSpliterators.flatMap` to accept `null` from its `function` by treating it as an empty `Stream`, like `Stream.flatMap` does. Add tests for this behavior.\n\nTo test that the new methods also accept `null` through both their `{Int,Long,Double}Consumer` APIs and their `Consumer` APIs, add `of{Int,Long,Double}` methods to `SpliteratorTester`. They test the given `Spliterator.of{Int,Long,Double}` through both APIs.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=263208125\n", "commitDateTime": "2019-08-16 13:24:21", "authoredDateTime": "2019-08-13 13:54:28", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/collect/CollectSpliteratorsTest_gwt.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "guava-gwt/test/com/google/common/collect/StreamsTest_gwt.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java", "insertions": 162, "deletions": 36, "lines": 198}, {"filePath": "guava-tests/test/com/google/common/collect/CollectSpliteratorsTest.java", "insertions": 47, "deletions": 0, "lines": 47}, {"filePath": "guava-tests/test/com/google/common/collect/StreamsTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/CollectSpliterators.java", "insertions": 317, "deletions": 73, "lines": 390}, {"filePath": "guava/src/com/google/common/collect/Streams.java", "insertions": 69, "deletions": 12, "lines": 81}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["e04eb5948b7cdfa401a190bb3fb071a59dfbe5bc", "c30df914935008e5a6357e99aa368fb982c74039", "5d20c304e39ca8a920bdfc207a29a75dd0eb8867"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 3, "gitStatsSummary": {"insertions": 781.0, "deletions": 480.0, "lines": 1261.0, "gitFilesChange": 2}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"]}, {"title": "InternetDomainName.topPrivateDomain() Fails on Suffix .site", "body": "I have the following code:\r\n\r\n```\r\nprivate static String getDomainName(final String url) throws MalformedURLException {\r\n     final URL u = new URL(url);\r\n    return InternetDomainName.from(u.getHost()).topPrivateDomain().toString();\r\n}\r\n```\r\n\r\nThe String `http://opticafsm.business.site/` is what's passed to `getDomainName()`.\r\n\r\nUnfortunately, it results in the error\r\n\r\n```\r\nCaused by: java.lang.IllegalStateException: Not under a public suffix: opticafsm.business.site\r\n\tat com.google.common.base.Preconditions.checkState(Preconditions.java:177)\r\n\tat com.google.common.net.InternetDomainName.topPrivateDomain(InternetDomainName.java:447)\r\n\tat Links.getDomainName(Links.java:119)\r\n```\r\n\r\nThe version of Guava being used was, original, version 16 which I thought might be causing the issue but, after upgrading to 24.1-jre, the behavior didn't change in any way.\r\n\r\nIt seems that it's not recognizing `.site` as a public suffix in spite of being listed here: https://publicsuffix.org/list/public_suffix_list.dat\r\n\r\n```\r\n// site : 2015-01-15 DotSite Inc.\r\nsite\r\n```\r\n\r\nwhich causes `topPrivateDomain()` to fail, when it's called.", "url": "https://github.com/google/guava/issues/3128", "user": "WammKD", "labels": ["package=net", "status=invalid", "type=defect"], "created": "2018-04-25 19:32:30", "closed": "2018-04-26 17:01:54", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Memoized throwing-suppliers are improperly tested", "body": "[The current test](https://github.com/google/guava/blob/acf29b389bc9ff8701f69d05b30e9d899bc10e35/guava-tests/test/com/google/common/base/SuppliersTest.java#L110) expects to get exceptions thrown again and again. But `Suppliers::memoize` is not called in the \"testMemoizeExceptionThrown\" test.\r\n\r\nThe line 115 should be replaced:\r\n\r\n    private void memoizeExceptionThrownTest(ThrowingSupplier memoizedSupplier) {\r\n\r\nTo:\r\n\r\n    private void memoizeExceptionThrownTest(ThrowingSupplier throwingSupplier) {\r\n      Supplier<Integer> memoizedSupplier = Suppliers.memoize(throwingSupplier);", "url": "https://github.com/google/guava/issues/3122", "user": "ogregoire", "labels": ["P2", "package=base", "status=fixed", "type=defect"], "created": "2018-04-20 13:41:44", "closed": "2018-04-24 13:53:45", "commits": {"7622bb803ff6c0ae1e3d1d1b2311c7ad1be9c6f3": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}, "e214f901e84ca370466c1393c7917f38059bde53": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "7622bb803ff6c0ae1e3d1d1b2311c7ad1be9c6f3", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e214f901e84ca370466c1393c7917f38059bde53", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": ["d61375f7260e138e393822c2d1bda42a88419fc9"], "nameRev": "e214f901e84ca370466c1393c7917f38059bde53 tags/v25.0~9", "commitMessage": "Make SuppliersTest.testMemoizeExceptionThrown() actually memoize the suppliers before testing them.\n\nFixes https://github.com/google/guava/issues/3122\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=193705380\n", "commitDateTime": "2018-04-24 09:53:44", "authoredDateTime": "2018-04-20 12:19:40", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/base/SuppliersTest.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "guava-tests/test/com/google/common/base/SuppliersTest.java", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SuppliersTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.SuppliersTest.memoizeExceptionThrownTest(com.google.common.base.SuppliersTest$ThrowingSupplier)", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e214f901e84ca370466c1393c7917f38059bde53"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "MoreFilesFileTraverserTest: unable to guarantee security of recursive delete", "body": "Reported in https://github.com/google/guava/issues/3086#issuecomment-378523615\r\n\r\nNeeds a fix like https://github.com/google/guava/commit/8f22dbc8ea0c1abdf044846057f6df8201ee9961", "url": "https://github.com/google/guava/issues/3100", "user": "cpovirk", "labels": ["P1", "package=io", "status=fixed", "type=defect"], "created": "2018-04-04 18:20:54", "closed": "2018-04-09 19:30:53", "commits": {"1974d26799780c448ef72c09eee2201dc7812fbb": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}, "a652fa0d6354c78334f5ef9833ad1082333975c0": {"commitGHEventType": "referenced", "commitUser": "ronshapiro"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "1974d26799780c448ef72c09eee2201dc7812fbb", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a652fa0d6354c78334f5ef9833ad1082333975c0", "commitGHEventType": "referenced", "commitUser": "ronshapiro", "commitParents": ["3ad8bffdc73cf604f8d32da450b2cfabe9785c0e"], "nameRev": "a652fa0d6354c78334f5ef9833ad1082333975c0 tags/v25.0~20", "commitMessage": "Fix tests that failed if we couldn't recursively delete securely by using Jimfs and just getting rid of the whole file system each time.\n\nFixes https://github.com/google/guava/issues/3100\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=191677352\n", "commitDateTime": "2018-04-09 15:30:52", "authoredDateTime": "2018-04-04 18:00:24", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/io/MoreFilesFileTraverserTest.java", "insertions": 9, "deletions": 5, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MoreFilesFileTraverserTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.io.MoreFilesFileTraverserTest.setUp()", "TOT": 4, "UPD": 3, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.io.MoreFilesFileTraverserTest.tearDown()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.io.MoreFilesFileTraverserTest.newDir(java.lang.String)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.io.MoreFilesFileTraverserTest.newFile(java.lang.String)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a652fa0d6354c78334f5ef9833ad1082333975c0"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Missing test case for Comparators.emptiesLast", "body": "There are two new utility methods added in a1a83d407f3f19891b7032e151d945363c441780 however only one of them is covered by unit tests. Maybe a synchronization issue between the Google-internal and the public Guava repository?", "url": "https://github.com/google/guava/issues/3088", "user": "ineuwirth", "labels": ["P2", "package=collect", "status=obsolete", "type=defect"], "created": "2018-03-27 21:37:11", "closed": "2019-04-19 17:17:42", "commits": {}, "ttf": 387.0002777777778, "commitsDetails": []}, {"title": "CacheBuilder get return different value every time even the key is the same.", "body": "I use CacheBuilder to cache work in java, but the cache get return me different value even \r\nto get for the same key, I implement ERROR_KEY with hashcode and equal.\r\nERROR_KEY key1 = new ERROR_KEY(\"tableName\", BigDecimal.ONE);\r\nERROR_MSG s1 = cache.get( key1 );\r\nhow to get the same value for the same key?\r\n\r\n```\r\n\tprivate static final LoadingCache<ERROR_KEY, ERROR_MSG> cache = CacheBuilder.newBuilder() //\r\n\t\t\t.expireAfterAccess(Integer.MAX_VALUE, TimeUnit.SECONDS) //\r\n\t\t\t.maximumSize(1000) //\r\n\t\t\t.weakKeys() //\r\n\t\t\t.build(new CacheLoader<ERROR_KEY, ERROR_MSG>() {\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic ERROR_MSG load(ERROR_KEY key) throws Exception {\r\n\t\t\t\t\treturn new ERROR_MSG(key.getTableName(), 1, System.currentTimeMillis());\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\r\nstatic class ERROR_KEY implements Comparable<ERROR_KEY>{\r\n\t\tprivate String tableName;\r\n\t\tprivate BigDecimal seqNo;\r\n\t\tpublic String getTableName() {\r\n\t\t\treturn tableName;\r\n\t\t}\r\n\t\tpublic void setTableName(String tableName) {\r\n\t\t\tthis.tableName = tableName;\r\n\t\t}\r\n\t\tpublic BigDecimal getSeqNo() {\r\n\t\t\treturn seqNo;\r\n\t\t}\r\n\t\tpublic void setSeqNo(BigDecimal seqNo) {\r\n\t\t\tthis.seqNo = seqNo;\r\n\t\t}\r\n\t\t\r\n\t\tpublic ERROR_KEY(String tableName, BigDecimal seqNo) {\r\n\t\t\tsuper();\r\n\t\t\tthis.tableName = tableName;\r\n\t\t\tthis.seqNo = seqNo;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tfinal int prime = 31;\r\n\t\t\tint result = 1;\r\n\t\t\tresult = prime * result + ((seqNo == null) ? 0 : seqNo.hashCode());\r\n\t\t\tresult = prime * result + ((tableName == null) ? 0 : tableName.hashCode());\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (this == obj)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj == null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (getClass() != obj.getClass())\r\n\t\t\t\treturn false;\r\n\t\t\tERROR_KEY other = (ERROR_KEY) obj;\r\n\t\t\tif (seqNo == null) {\r\n\t\t\t\tif (other.seqNo != null)\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (!seqNo.equals(other.seqNo))\r\n\t\t\t\treturn false;\r\n\t\t\tif (tableName == null) {\r\n\t\t\t\tif (other.tableName != null)\r\n\t\t\t\t\treturn false;\r\n\t\t\t} else if (!tableName.equals(other.tableName))\r\n\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(ERROR_KEY o) {\r\n\t\t\treturn Comparator.comparing(ERROR_KEY::getTableName)\r\n\t\t              .thenComparing(ERROR_KEY::getSeqNo)\r\n\t\t              .compare(this, o);\r\n\t\t}\r\n\t}\r\n\r\n\r\n ERROR_KEY key1 = new ERROR_KEY(\"tableName\", BigDecimal.ONE);\r\n ERROR_MSG s1 = cache.get( key1 );\r\n System.out.println(s1);\r\n ERROR_KEY key2 = new ERROR_KEY(\"tableName\", BigDecimal.ONE);\r\n ERROR_MSG s2 = cache.get( key2 );\r\nSystem.out.println(s2);\r\n\r\n```", "url": "https://github.com/google/guava/issues/3053", "user": "passionofvc", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2018-03-05 11:28:16", "closed": "2018-03-05 15:42:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NegativeArraySizeException in collection factory methods", "body": "The immutable collections `ImmutableDoubleArray`, `ImmutableLongArray`, `ImmutableIntArray`, `ImmutableList`, and `ImmutatbleSet` all provide methods called `of`.\r\n\r\nIf an array of length near `Integer.MAX_VALUE` is passed as the last argument, an unexpected `NegativeArraySizeException` is thrown.\r\n\r\nTo reproduce, run this code on a computer with enough RAM:\r\n\r\n```java\r\nimport com.google.common.collect.ImmutableList;\r\n\r\npublic class NegArrSize {\r\n   public static void main(String[] args) {\r\n     Object[] array = new Object[Integer.MAX_VALUE - 11];\r\n     ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, array);\r\n   }\r\n}\r\n```\r\n\r\nThe program throws `NegativeArraySizeException`.\r\n\r\nThe problem is that these methods do an unchecked addition to compute the size of an array that will be allocated. The methods work for most argument array sizes, but it would be helpful to document and check the restriction on the argument.\r\n", "url": "https://github.com/google/guava/issues/3026", "user": "panacekcz", "labels": ["P1", "package=collect", "status=fixed", "type=defect"], "created": "2018-01-08 10:25:48", "closed": "2018-01-24 20:09:15", "commits": {"9f0269fd0a43458850b5d3989bf5033d35d8679f": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 16.00027777777778, "commitsDetails": [{"commitHash": "9f0269fd0a43458850b5d3989bf5033d35d8679f", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["bf1931b9d9a68e3ef7c3c1ba1c5377aaac06bb9d"], "nameRev": "9f0269fd0a43458850b5d3989bf5033d35d8679f tags/v24.0~6", "commitMessage": "Restrict length of varargs array in immutable collection factory methods\n\nThis PR documents the restriction that immutable collection factory methods with varargs pose on the length of the last argument, and adds a check for this precondition to prevent NegativeArraySizeException from being thrown.\n\nFixes #3027\nFixes #3026\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=183115996\n", "commitDateTime": "2018-01-24 15:07:39", "authoredDateTime": "2018-01-24 11:35:04", "commitGitStats": [{"filePath": "android/guava/src/com/google/common/collect/ImmutableList.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "android/guava/src/com/google/common/collect/ImmutableSet.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "android/guava/src/com/google/common/primitives/ImmutableDoubleArray.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "android/guava/src/com/google/common/primitives/ImmutableIntArray.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "android/guava/src/com/google/common/primitives/ImmutableLongArray.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "guava/src/com/google/common/collect/ImmutableList.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "guava/src/com/google/common/collect/ImmutableSet.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava/src/com/google/common/primitives/ImmutableDoubleArray.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "guava/src/com/google/common/primitives/ImmutableIntArray.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "guava/src/com/google/common/primitives/ImmutableLongArray.java", "insertions": 8, "deletions": 1, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImmutableList.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableList.of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableSet.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSet.of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableDoubleArray.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.ImmutableDoubleArray.of(double,double[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableIntArray.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.ImmutableIntArray.of(int,int[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableLongArray.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.ImmutableLongArray.of(long,long[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Consider tweaking the `Comparators#{emptiesFirst,emptiesLast}` method signatures", "body": "Guava 22.0 introduced [`Comparators#emptiesFirst(Comparator<T>)`](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/Comparators.html#emptiesFirst-java.util.Comparator-) and [`Comparators#emptiesLast(Comparator<T>)`](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/Comparators.html#emptiesLast-java.util.Comparator-). Since these methods are still in `@Beta`, can their signatures be updated to accept a `Comparator<? super T>`, just like `#least` and `#greatest`, as well as various methods defined in `java.util.Comparators`?\r\n\r\nRationale: as it stands my compiler complains when I write `emptiesFirst(naturalOrder())`:\r\n\r\n> The method `emptiesFirst(Comparator<T>)` in the type `Comparators` is not applicable for the arguments (`Comparator<Comparable<? super Comparable<? super T>>>`).\r\n\r\nThe workaround is to provide an explicit type parameter to either `emptiesFirst` or `naturalOrder`, but if the signatures are updated as suggested above that won't be necessary.", "url": "https://github.com/google/guava/issues/3022", "user": "Stephan202", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2018-01-01 22:15:31", "closed": "2018-01-03 15:40:33", "commits": {"ae70a5c3968a49cc122f106ac44e3a14c4896801": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "ae70a5c3968a49cc122f106ac44e3a14c4896801", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["a33e717b645e1d15357e7a8c4df37d798214d897"], "nameRev": "ae70a5c3968a49cc122f106ac44e3a14c4896801 tags/v24.0~56", "commitMessage": "Make \"emptiesFirst(naturalOrder())\" infer the type more reliably.\n\nFixes #3022.\n\n[]\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=180665310\n", "commitDateTime": "2018-01-03 07:30:02", "authoredDateTime": "2018-01-03 06:47:37", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/collect/ComparatorsTest.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "guava/src/com/google/common/collect/Comparators.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ComparatorsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ComparatorsTest.testEmptiesFirst()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Comparators.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ae70a5c3968a49cc122f106ac44e3a14c4896801"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": []}, {"title": "ConcurrentHashMultiset#createEntrySet() is public", "body": "`ConcurrentHashMultiset#createEntrySet()` has public visibility, although it seems like an internal method, not meant to be in public API. \r\n\r\nWhole `ConcurrentHashMultiset` is not in `@Beta`, so I'm not sure if simply changing visibility to package-private is what you really want, hence no PR from my side.", "url": "https://github.com/google/guava/issues/3003", "user": "Xaerxess", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2017-12-05 10:26:54", "closed": "2018-01-08 22:14:19", "commits": {}, "ttf": 34.000277777777775, "commitsDetails": []}, {"title": "MediaType parse bug", "body": "Hi all,\r\n\r\nI am facing something I'm calling a bug with the method parse from the class MediaType.\r\nThe method raises an exception if I parse the string \"application/toto\" what is correct.\r\nThe method don't raise any exception if I parse the string \"application/pdf\" what is also correct.\r\nHowever, the method don't raise any exception if I parse the string \"application/p\" what is not a mime type.\r\n\r\nDid I miss something?\r\n\r\nYours sincerely,\r\nJulien BAUMGARTEN", "url": "https://github.com/google/guava/issues/2994", "user": "Kawabaumga", "labels": ["package=net", "status=invalid", "type=defect"], "created": "2017-11-15 09:43:42", "closed": "2017-11-15 15:41:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Contended cache access causes deadlock", "body": "I'm also observing some strange behaviour with guava caches under contention. According to @ben-manes, this is unrelated to #2863. Motivation for opening this issue: https://github.com/google/guava/issues/2863#issuecomment-338578756\r\n\r\nWhile I was doing some JMH benchmarks I noticed that benchmarks that were using guava caches stalled completely and/or had very erratic performance during thread contention. Benchmark iterations very often stalled for seconds, minutes or sometimes seemingly indefinitely. It turned out that the cache was the culprit in all cases.\r\n\r\nThe issue is _very_ easy to trigger. I published a sample project on https://github.com/hibox-systems/guava-cache-test that demonstrates the issue. In my environment it works fine with 1, 2 and 3 threads. Using 4 threads or more always stalls the benchmark at some point. I have tried the benchmark with all published guava versions that are compatible with the sample code, i.e. guava 11.0 and newer. Tested with these JVM versions on Ubuntu 16.04 with a Intel Core i7-3770 CPU:\r\n- OpenJDK 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11\r\n- Oracle 1.8.0_151-b12\r\n- Oracle 9.0.1+11\r\n\r\nFWIW, I tried replacing the guava caches in the benchmarks with caffeine caches, and all kinds of stalling and erratic performance went away.", "url": "https://github.com/google/guava/issues/2976", "user": "slovdahl", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2017-10-24 11:02:21", "closed": "2018-01-24 23:20:55", "commits": {}, "ttf": 92.00027777777778, "commitsDetails": []}, {"title": "ServiceManager.awaitHealthy method is not working when run jetty embed.", "body": "**app: guava\r\nversion: 20.0**\r\n\r\n**code 1:**\r\n```\r\npublic class EmbedMonitoredServices {\r\n\r\n    // ------------------------------------------------------------------------\r\n\r\n    private static final Logger logger = LoggerFactory.getLogger(EmbedMonitoredServices.class);\r\n\r\n    private static final Set<Service> monitoredServices = Sets.newHashSet();\r\n\r\n    private static ServiceManager monitoredServiceManager;\r\n\r\n    private static MonitoredWebService monitoredWebService;\r\n\r\n    // ------------------------------------------------------------------------\r\n\r\n    private static MonitoredWebService getMonitoredWebService() {\r\n        if (monitoredWebService == null) {\r\n            monitoredWebService = new MonitoredWebService();\r\n        }\r\n        return monitoredWebService;\r\n    }\r\n\r\n    private static ServiceManager getMonitoredServiceManager() {\r\n        if (monitoredServiceManager == null) {\r\n            monitoredServices.add(getMonitoredWebService());\r\n            monitoredServiceManager = new ServiceManager(monitoredServices);\r\n        }\r\n        return monitoredServiceManager;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    \r\n    public static ServiceManager manage() {\r\n        return getMonitoredServiceManager();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n\r\n    public static class MonitoredWebService extends AbstractService {\r\n\r\n        // --------------------------------------------------------------------\r\n\r\n        private static final String CONTEXT_PATH = \"/scout-web-monitor\";\r\n\r\n        private static final String PACKAGE_PATH = EnvironmentContents.PROJECT_HOME + \"/lib/ext/scout-web-monitor-1.0.0.war\";\r\n\r\n        private static Server server;\r\n\r\n        // --------------------------------------------------------------------\r\n\r\n        @Override\r\n        protected void doStart() {\r\n            server = new Server(8080);\r\n            MBeanContainer mbContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\r\n            server.addBean(mbContainer);\r\n            WebAppContext webapp = new WebAppContext();\r\n            webapp.setContextPath(CONTEXT_PATH);\r\n            webapp.setWar(PACKAGE_PATH);\r\n            webapp.addAliasCheck(new AllowSymLinkAliasChecker());\r\n            webapp.addLifeCycleListener(new LifeCycle.Listener() {\r\n\r\n                @Override\r\n                public void lifeCycleStarting(LifeCycle event) {\r\n                    LoggingUtils.info(logger, manage().servicesByState());\r\n                }\r\n\r\n                @Override\r\n                public void lifeCycleStarted(LifeCycle event) {\r\n                    LoggingUtils.info(logger, manage().servicesByState());\r\n                    notifyStarted();\r\n                    LoggingUtils.info(logger, manage().servicesByState());\r\n                }\r\n\r\n                @Override\r\n                public void lifeCycleFailure(LifeCycle event, Throwable cause) {\r\n                    notifyFailed(LoggingUtils.error(logger, cause));\r\n                }\r\n\r\n                @Override\r\n                public void lifeCycleStopping(LifeCycle event) {}\r\n\r\n                @Override\r\n                public void lifeCycleStopped(LifeCycle event) {\r\n                    notifyStopped();\r\n                }\r\n\r\n            });\r\n            server.setHandler(webapp);\r\n            try {\r\n                server.start();\r\n                // erver.dumpStdErr();\r\n                server.join();\r\n            } catch (Exception e) {\r\n                throw LoggingUtils.error(logger, e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        protected void doStop() {\r\n            try {\r\n                server.stop();\r\n            } catch (Exception e) {\r\n                throw LoggingUtils.error(logger, e);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n**code 2:**\r\n```\r\npublic static void startMonitoredService(PrintStream stdout, NmapProfile profile) throws Exception {\r\n        showLogo(stdout);\r\n        Environments.initializeLogback();\r\n        LoggingUtils.info(logger, \"Start Monitored Service.\");\r\n        EmbedMonitoredServices.manage().startAsync().awaitHealthy();\r\n        LoggingUtils.info(logger, \"Monitored Service started.\");\r\n        LoggingUtils.info(logger, \"Monitored Service started.\");\r\n}\r\n```\r\n\r\n**print:**\r\n```\r\n[INFO] Start Monitored Service.\r\n[INFO] Logging initialized @5375ms\r\n[INFO] jetty-9.2.22.v20170606\r\n[INFO] {NEW=[MonitoredWebService [STARTING]]}\r\n[INFO] jetty-9.2.22.v20170606\r\n[WARN] ServletContext@o.e.j.s.ServletContextHandler@542e560f{/,null,STARTING} has uncovered http methods for path: /\r\n[INFO] Started ServerConnector@8c11eee{HTTP/1.1}{0.0.0.0:61614}\r\n[INFO] Started @6749ms\r\n[INFO] {NEW=[MonitoredWebService [STARTING]]}\r\n[INFO] {NEW=[MonitoredWebService [RUNNING]]}\r\n[INFO] Started ServerConnector@32a068d1{HTTP/1.1}{0.0.0.0:8080}\r\n[INFO] Started @7163ms\r\n```", "url": "https://github.com/google/guava/issues/2964", "user": "deathknight0718", "labels": ["package=concurrent", "status=invalid", "type=defect"], "created": "2017-10-10 18:13:31", "closed": "2017-10-11 16:53:50", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Inconsistant null checks in ImmutableSortedMap", "body": "When creating `ImmutableSortedMap` instances the documentation for methods `copyOf` and `copyOfSorted` state: \r\n\r\n> \"NullPointerException - if any key or value in map is null\"\r\n\r\nHowever this behavior is not consistent an it is possible to create a map with null values.\r\n\r\nGiven a `HashMap` of stings with `map:{a:null}` all the `copOf` methods throw as expected, with a `map:{a:null, b:two}` then none of the `copyOf` methods throw.\r\n\r\nGiven a `SortedMap` of strings with `map:{a:null}` and a natural order `copyOf` and `copyOfSorted` all throw as expected; with a `map:{a:null, b:two}` then `copyOf(Map)` and `copyOfSorted(SortedMap)` throw; `copyOf(Iterable)`, `copyOf(Iterable, Comparator)`, `copyOf(Map, Comparator)` do not throw; with a `map:{a:one, b:null}`\r\n`copyOf` and `copyOfSorted` all throw as expected.\r\n\r\nFrom what I can tell this behavior is only present for maps with two elements and only when the `null` is the first value of the first key. The `of` and `builder` methods are not effected an throw as expected.\r\n\r\n", "url": "https://github.com/google/guava/issues/2962", "user": "johnsoneal", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2017-10-09 16:49:18", "closed": "2017-10-10 17:50:27", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "ClassPath.getTopLevelClasses() returns empty list (Again)", "body": "Hello,\r\n\r\nThis is continue of #2152 the problem still exists, but this time on java 9.\r\n\r\n```log\r\njava version \"9\"\r\nJava(TM) SE Runtime Environment (build 9+181)\r\nJava HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)\r\n```\r\nI've tested with 22.0, 23.0, 23.1\r\n\r\n", "url": "https://github.com/google/guava/issues/2959", "user": "UnAfraid", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2017-10-05 16:19:29", "closed": "2017-10-11 15:08:10", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Guava 23 `edgeValueOrDefault` missing edge returns non-default value", "body": "In Guava 23...\r\n\r\nAssume `nodeA` exists but  #`nodeU` does not exist. Execute:\r\n\r\n`graph.edgeValueOrDefault(nodeA, nodeU, 5)`\r\n\r\nThe result is `null`. I would expect the result to be `5`, given that there is no edge between `nodeA` and non-existent `nodeU`. Guava 22 an earlier have the expected behavior.\r\n\r\nI see that Guava 23 now returns an `Optional` for `edgeValue`, so the statement can easily be converted to `graph.edgeValue(nodeA, nodeU, 5).orElse(5)`, however if this is the intended behavior of the `edgeValueOrDefault` method for this situation, it deserves some additional explanation in the Javadoc. Or simply deprecate this method and recommend people transition to `edgeValue().orElse()`.", "url": "https://github.com/google/guava/issues/2924", "user": "rocketraman", "labels": ["package=graph", "type=defect"], "created": "2017-08-23 17:43:55", "closed": "2017-10-05 15:49:11", "commits": {"a8f4ebc429d01150d3e35980373cb8c9c123aeaa": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "361eba8e4078a4c80f9be0c9194a7e3c0473aa6d": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 42.000277777777775, "commitsDetails": [{"commitHash": "a8f4ebc429d01150d3e35980373cb8c9c123aeaa", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["11d3683ddba029aad2c9da7769c528cbe99d6fd3"], "nameRev": "a8f4ebc429d01150d3e35980373cb8c9c123aeaa tags/v23.2~22", "commitMessage": "ValueGraph: fix implementation of edgeValueOrDefault().\nAlso fixed tests to guard against similar future regressions.\n\n(This fixes a regression that was introduced when we temporarily replaced this method with edgeValueOrNull() ([] and then failed to restore the original semantics when we restored the original method ([]  Oops.)\n\nRef: GitHub issue #2924\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=171145586\n", "commitDateTime": "2017-10-05 06:46:05", "authoredDateTime": "2017-10-05 06:38:22", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/graph/ValueGraphTest.java", "insertions": 8, "deletions": 6, "lines": 14}, {"filePath": "android/guava/src/com/google/common/graph/ConfigurableValueGraph.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "guava/src/com/google/common/graph/ConfigurableValueGraph.java", "insertions": 2, "deletions": 3, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ValueGraphTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.graph.ValueGraphTest.edgeValue_missing()", "TOT": 15, "UPD": 3, "INS": 6, "MOV": 0, "DEL": 6}]}, {"spoonFilePath": "ConfigurableValueGraph.java", "spoonMethods": [{"spoonMethodName": "com.google.common.graph.ConfigurableValueGraph.edgeValueOrDefault(java.lang.Object,java.lang.Object,java.lang.Object)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "361eba8e4078a4c80f9be0c9194a7e3c0473aa6d", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["1f697f51921ec3cf42fb8a37cc148e744bff20ca"], "nameRev": "361eba8e4078a4c80f9be0c9194a7e3c0473aa6d tags/v23.2~8", "commitMessage": "ValueGraphTest.java: add a few checks to make sure that we're properly exercising both null and non-null default values.\n\nThis addresses the most recent suggestion in GitHub issue #2924.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=171818169\n", "commitDateTime": "2017-10-11 07:50:41", "authoredDateTime": "2017-10-11 07:17:00", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/graph/ValueGraphTest.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "insertions": 19, "deletions": 0, "lines": 19}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ValueGraphTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.graph.ValueGraphTest.directedGraph()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.graph.ValueGraphTest.undirectedGraph()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.graph.ValueGraphTest.edgeValue_missing()", "TOT": 9, "UPD": 0, "INS": 9, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.graph.ValueGraphTest.validateGraphState()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a8f4ebc429d01150d3e35980373cb8c9c123aeaa", "361eba8e4078a4c80f9be0c9194a7e3c0473aa6d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 6, "lines": 10, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["android/guava/src/com/google/common/graph", "guava/src/com/google/common/graph"], "changesInPackagesSPOON": ["com.google.common.graph.ConfigurableValueGraph.edgeValueOrDefault(java.lang.Object,java.lang.Object,java.lang.Object)"]}, {"title": "Throwables#lazyStackTrace throws UnsupportedOperationException on AIX 5.3", "body": "The mechanism which detects whether to fallback on the non-lazy stack trace implementation seems to be broken on AIX 5.3 with IBMs JDK `jdk-6.0.0.645-aix-powerpc`. When iterating through the list returned by the method on such a system I get the following exception + trace\r\n\r\n> Caused by: java.lang.UnsupportedOperationException: You cannot access stack trace depth this way in this implementation\r\n        at sun.misc.SharedSecrets$1.getStackTraceDepth(SharedSecrets.java:172)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)\r\n        at java.lang.reflect.Method.invoke(Method.java:611)\r\n        at com.google.common.base.Throwables.invokeAccessibleNonThrowingMethod(Throwables.java:292)\r\n        at com.google.common.base.Throwables.access$200(Throwables.java:48)\r\n        at com.google.common.base.Throwables$1.size(Throwables.java:284)\r\n        at java.util.AbstractList$SimpleListIterator.hasNext(AbstractList.java:51)\r\n        at com.google.common.collect.Iterators$PeekingImpl.hasNext(Iterators.java:1171)\r\n        at com.delphix.logger.Logger.getLogger(Logger.java:96)\r\n        at com.delphix.session.impl.common.SessionManager.<clinit>(SessionManager.java:23)\r\n        at java.lang.J9VMInternals.initializeImpl(Native Method)\r\n        at java.lang.J9VMInternals.initialize(J9VMInternals.java:199)\r\n        ... 21 more\r\n\r\nExplicitly using `new Throwable().getStackTrace` resolved the problem.", "url": "https://github.com/google/guava/issues/2887", "user": "kyle-cackett", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2017-07-28 19:40:43", "closed": "2018-01-29 20:20:50", "commits": {}, "ttf": 185.00027777777777, "commitsDetails": []}, {"title": "cache.cleanUp() doesn't work, and cache.invalidateAll() is ok.", "body": "I met a case in using GuavaCache.\r\n\r\nI Create GuavaCache like this:\r\n\r\nCache<String, Object> cache = CacheBuilder.newBuilder()\r\n        .maximumSize(guavaCache.size())\r\n        .expireAfterWrite(600, TimeUnit.SECONDS)\r\n        .build();\r\n\r\nWhen use this cache, I have several cache nesting, a method with cache call another method with cache, then when I want to invalidate the cache manually.\r\ncache.cleanUp() doesn't work, and cache.invalidateAll() is ok.\r\n\r\nCan someone provide an explanation?\r\nThanks.", "url": "https://github.com/google/guava/issues/2780", "user": "pumadong", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2017-04-10 09:06:38", "closed": "2017-05-01 19:36:37", "commits": {}, "ttf": 21.00027777777778, "commitsDetails": []}, {"title": "Absent#equals bugs after serializing / deserializing", "body": "After serializing / deserializing Absent instances won't be the same (e.g. in an Apache Spark context with Kryo serialization).\r\n\r\nTherefore the implementation below contains a bug. Why not just check if the two instances have the same class definition?\r\n\r\n```\r\n@Override public boolean equals(@Nullable Object object) {\r\n  return object == this;\r\n}\r\n```", "url": "https://github.com/google/guava/issues/2779", "user": "cbismuth", "labels": ["package=base", "status=will-not-fix", "type=defect"], "created": "2017-04-05 12:55:34", "closed": "2017-09-13 23:57:12", "commits": {}, "ttf": 161.00027777777777, "commitsDetails": []}, {"title": "LocalManualCache deadlock in guava 21", "body": "Unit test testCache works with guava 20, locks up in 21 (LocalCache.java,line 2392):\r\n\r\n    @Test\r\n    public void testCache()\r\n    {\r\n        String key = \"test\";\r\n        int count  = 1000;\r\n        Cache<String, String> cache = CacheBuilder.newBuilder().expireAfterAccess(500000, TimeUnit.MILLISECONDS).maximumSize(1000).build();\r\n\r\n        IntStream.range(0, count).parallel().forEach((n) -> {\r\n            String val = cache.asMap().computeIfAbsent(key, k->\"testv\" + n);\r\n            logger.info(\"Val=\" + val);\r\n\r\n        });\r\n    }\r\n    @Test\r\n    public void testConcurrentMap()\r\n    {\r\n        String key = \"test\";\r\n        int count  = 1000;\r\n        Map<String, String> cache = new ConcurrentHashMap<>();\r\n\r\n        IntStream.range(0, count).parallel().forEach((n) -> {\r\n            String val = cache.computeIfAbsent(key, k->\"testv\" + n);\r\n            logger.info(\"Val:\", val );\r\n\r\n        });\r\n    }\r\n", "url": "https://github.com/google/guava/issues/2743", "user": "epavlov1", "labels": ["package=cache", "type=defect"], "created": "2017-02-17 00:53:01", "closed": "2017-03-28 16:39:09", "commits": {"7bde6040bf36313a5e2567fa0eaf7cefb46d4bdc": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 39.000277777777775, "commitsDetails": [{"commitHash": "7bde6040bf36313a5e2567fa0eaf7cefb46d4bdc", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["32c885b3cc561f64dae7efed3d5fee516ad359fa"], "nameRev": "7bde6040bf36313a5e2567fa0eaf7cefb46d4bdc tags/v22.0-rc1~95", "commitMessage": "Fix LocalCache.compute deadlock issue, also added unittests.\n\nhttps://github.com/google/guava/issues/2743\n\nwe need to hold the lock when calling compute, the rest of the calls\nlike removeEntry need to hold the lock too.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=150363160\n", "commitDateTime": "2017-03-16 14:31:59", "authoredDateTime": "2017-03-16 13:46:21", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java", "insertions": 85, "deletions": 0, "lines": 85}, {"filePath": "guava/src/com/google/common/cache/LocalCache.java", "insertions": 6, "deletions": 15, "lines": 21}], "commitSpoonAstDiffStats": [{"spoonFilePath": "LocalCacheMapComputeTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.cache.LocalCacheMapComputeTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LocalCache.java", "spoonMethods": [{"spoonMethodName": "com.google.common.cache.LocalCache.Segment.compute(java.lang.Object,int,java.util.function.BiFunction)", "TOT": 11, "UPD": 0, "INS": 3, "MOV": 7, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7bde6040bf36313a5e2567fa0eaf7cefb46d4bdc"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6, "deletions": 15, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 11, "UPD": 0, "INS": 3, "MOV": 7, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/cache"], "changesInPackagesSPOON": ["com.google.common.cache.LocalCache.Segment.compute(java.lang.Object,int,java.util.function.BiFunction)"]}, {"title": "remove() in MinMaxPriorityQueue<Double> not removing the correct object", "body": "A MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\r\n\r\n> [5.6, 6.0, 5.7, 5.9]\r\nTry to remove 5.7 :\r\n[5.6, 6.0, 5.7]\r\n\r\nObtained from :\r\n\r\n> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.remove(6.2);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(6.3);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.remove(5.8);\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.4);\r\n\t\t\tvalues.remove(5.4);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.remove(6.1);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(5.4);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.remove(5.5);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(5.8);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(5.7);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.9);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(6.1);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.9);\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tSystem.out.println(values);\r\n\t\t\tSystem.out.println(\"Try to remove 5.7 :\");\r\n\t\t\tvalues.remove(5.7);\r\n\t\t\tSystem.out.println(values);", "url": "https://github.com/google/guava/issues/2658", "user": "forestier", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2016-11-24 11:53:19", "closed": "2016-11-30 17:35:11", "commits": {"2ef955163b3d43e7849c1929ef4e5d714b93da96": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "2ef955163b3d43e7849c1929ef4e5d714b93da96", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["16e3f26fd31ced35fa8a71ab2b1091ce9157a90f"], "nameRev": "2ef955163b3d43e7849c1929ef4e5d714b93da96 tags/v21.0-rc1~27", "commitMessage": "Fix two bugs in MinMaxPriorityQueue (introduced in [] First is a bug in removeAt(int) that sometimes causes the wrong element to be removed. Second is a bug that sometimes causes certain elements to be iterated over more than once if elements were removed during iteration.\n\nReported externally at https://github.com/google/guava/issues/2658\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=140382230\n", "commitDateTime": "2016-11-28 11:48:09", "authoredDateTime": "2016-11-28 11:38:37", "commitGitStats": [{"filePath": "cycle_whitelist.txt", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava-gwt/test/com/google/common/collect/MinMaxPriorityQueueTest_gwt.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java", "insertions": 78, "deletions": 3, "lines": 81}, {"filePath": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "insertions": 14, "deletions": 4, "lines": 18}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MinMaxPriorityQueueTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest_gwt.testRandomAddsAndRemoves()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest_gwt.testRandomRemoves()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest_gwt.testRemoveRegression()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MinMaxPriorityQueueTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.runIterator(java.util.List,int).1", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.runIterator(java.util.List,int).1.verify(java.util.List)", "TOT": 5, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.runIterator(java.util.List,int).1.newTargetIterator()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testCreation_comparator()", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testCreation_expectedSize_comparator()", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testCreation_comparator_maximumSize()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testCreation_comparator_withContents()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testCreation_allOptions()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.suite()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testRemoveRegression()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testRandomRemoves()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest.testRandomAddsAndRemoves()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueueTest", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MinMaxPriorityQueue.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueue.Heap.getCorrectLastElement(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueue.removeAt(int)", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.MinMaxPriorityQueue.QueueIterator.remove()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2ef955163b3d43e7849c1929ef4e5d714b93da96"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14, "deletions": 4, "lines": 18, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5, "UPD": 2, "INS": 2, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": ["com.google.common.collect.MinMaxPriorityQueue.removeAt(int)", "com.google.common.collect.MinMaxPriorityQueue.QueueIterator.remove()", "com.google.common.collect.MinMaxPriorityQueue.Heap.getCorrectLastElement(java.lang.Object)"]}, {"title": "symlink cycles create failures in ClassPath scan", "body": "Starting in at least r19, https://google.github.io/guava/releases/19.0/api/docs/com/google/common/reflect/ClassPath.html will eagerly traverse circular symlinks during the ClassPath scan.\r\n\r\nDepending on the host platform and JVM settings, this can lead to OutOfMemoryError, StackOverflowError, or (depending on the depth limits in underlying file system) inconsistent resource listings.\r\n\r\nThe symlink cycle doesn't have to occur in the actual class path.  ClassPath  eagerly scans the Class-Path attribute in the manifests of any encountered jars.  So relative paths encountered there, or an empty Class-Path attribute value, causes recursive scans of arbitrary file system paths.\r\n\r\nI do have a failing test case and candidate fix prepared.  I can submit a pull request for that, but wanted to file a bug report first, since the \"correct\" behavior is a little ambiguous in this case.", "url": "https://github.com/google/guava/issues/2648", "user": "jct-amzn", "labels": ["P3", "package=reflect", "status=fixed", "type=defect"], "created": "2016-11-17 20:00:21", "closed": "2019-07-30 20:58:40", "commits": {}, "ttf": 985.0002777777778, "commitsDetails": []}, {"title": "Cache size doesn't update after some key expired?", "body": "Hello\uff0cI write a test code\uff1a\n\n```\ncache<String, Integer> cache =\n            CacheBuilder.newBuilder()\n                    .expireAfterAccess(10, TimeUnit.SECONDS).build();\ncache.put(\"test\", 1);\n\nThread.sleep(5000);\n// output 1:1\nSystem.out.println(cache.size() + \": \" + cache.getIfPresent(\"test\"));\n\nThread.sleep(10000);\n// output 1:null\nSystem.out.println(cache.size() + \": \" + cache.getIfPresent(\"test\"));\n```\n\nThe cache doesn't update its size after the key expired, it's a bug or others?\n\nThanks & Regards.\n", "url": "https://github.com/google/guava/issues/2598", "user": "ihaolin", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2016-10-08 00:21:31", "closed": "2016-10-08 00:41:33", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FluentIterable#isEmpty is misleading", "body": "Javadoc at FluentIterable#isEmpty() says:\n\"Determines whether this fluent iterable is empty.\"\n\nHowever, in reality it checks whether underlying iterator is exhausted yet and never checks for emptiness. Either the method  behaviour or the javadoc is misleading.\n", "url": "https://github.com/google/guava/issues/2566", "user": "shestakov-m-a", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2016-09-14 12:11:27", "closed": "2016-09-27 19:47:47", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "LoadingCache returning values that \"expired\" when setting expireAfterWrite to 0 for testing", "body": "Seems caused by \nLocalCache.java\n\n  boolean isExpired(ReferenceEntry<K, V> entry, long now) {\n    checkNotNull(entry);\n    if (expiresAfterAccess()\n        && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {\n      return true;\n    }\n    if (expiresAfterWrite()\n        && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {\n      return true;\n    }\n    return false;\n  }\n\nSince expireAfterWrite = 0\n\nBut method\nexpiresAfterWrite() is implemented like\nboolean expiresAfterWrite() {\n    return expireAfterWriteNanos > 0;\n  }\n\nIt never performs the time check\n", "url": "https://github.com/google/guava/issues/2513", "user": "kringol", "labels": ["package=cache", "status=duplicate", "type=defect"], "created": "2016-06-29 09:29:01", "closed": "2019-07-24 23:35:03", "commits": {}, "ttf": 1120.0002777777777, "commitsDetails": []}, {"title": "DoubleMath incorrectly rounds 0.99999999999999994 to 2 with rounding mode UP or CEILING", "body": "**Failure cases:**\n_1) Positive_\nValues rounded incorrectly: `0.99999999999999984` to `0.99999999999999994`\nRounding modes: CEILING or UP\nExpected: `1`\nActual: `2`\n\n_2) Negative_\nValues rounded incorrectly:`-0.99999999999999984` to `-0.99999999999999994`\nRounding modes: FLOOR or UP\nExpected: `-1`\nActual: `-2`\n\n**Remarks:**\nThe reason is that values between 0 and 1 have higher fraction precision than values between 1 and 2. The code adds 1.0 to the value x, and double arithmetic uses HALF_EVEN rounding by default. This leads to unexpected results for edge cases when HALF_EVEN triggers rounding UP to 2.\n\n**Proposed FIX:**\nThe FIX is to cast the double value `x` to a long before the addition of `1.0`:\nCurrent:`x + 1.0`\nFixed: `(long)x + 1.0`\n\n**Pull Request:**\nSee pull request [#2511](https://github.com/google/guava/pull/2511)\n", "url": "https://github.com/google/guava/issues/2509", "user": "terzerm", "labels": ["package=math", "status=fixed", "type=defect"], "created": "2016-06-27 14:18:14", "closed": "2016-06-30 19:37:42", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "Links to JSR 305 in Javadoc are broken", "body": "For example [Javadoc for package `base`](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/package-summary.html) link to [`@ParametersAreNonnullByDefault`](http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/ParametersAreNonnullByDefault.html?is-external=true) results in 404.\n\nAffects all links to JSR 305 annotations.\n\nAs far as I can tell JSR 305 is not maintained anymore. Maybe the easiest solution would be to not link to the JSR 305 annotations in the Javadoc.\n", "url": "https://github.com/google/guava/issues/2479", "user": "arend-von-reinersdorff", "labels": ["type=api-docs", "type=defect"], "created": "2016-05-13 16:27:12", "closed": "2016-11-03 19:47:35", "commits": {"73e382fa877f80994817a136b0adcc4365ccd904": {"commitGHEventType": "referenced", "commitUser": "cgdecker"}, "c34433a6d6062ffb23eb3878355024ae08517495": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 174.00027777777777, "commitsDetails": [{"commitHash": "73e382fa877f80994817a136b0adcc4365ccd904", "commitGHEventType": "referenced", "commitUser": "cgdecker", "commitParents": ["d4593835188550859a05537676d01944fa2eab01"], "nameRev": "73e382fa877f80994817a136b0adcc4365ccd904 tags/v21.0-rc1~68", "commitMessage": "Release Java 8 changes to Guava.\n\n(Note: This will break the public Guava GWT tests. We'll come back to fix them.)\n\nFixes https://github.com/google/guava/issues/2585, https://github.com/google/guava/issues/2479, https://github.com/google/guava/issues/2029, and probably various other issues :)\n\nAlso relevant: https://github.com/google/guava/issues/2591\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=138100073\n", "commitDateTime": "2016-11-03 15:39:41", "authoredDateTime": "2016-11-03 12:04:47", "commitGitStats": [{"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableBiMap.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableCollection.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableList.java", "insertions": 14, "deletions": 1, "lines": 15}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMap.java", "insertions": 39, "deletions": 0, "lines": 39}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSet.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedMap.java", "insertions": 35, "deletions": 1, "lines": 36}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "guava-gwt/test/com/google/common/base/OptionalTest_gwt.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-gwt/test/com/google/common/collect/CollectSpliteratorsTest_gwt.java", "insertions": 35, "deletions": 0, "lines": 35}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableBiMapTest_gwt.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableListMultimapTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableListTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableMapTest_gwt.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableMultisetTest_gwt.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableSetMultimapTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableSetTest_gwt.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableSortedMapTest_gwt.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableSortedSetTest_gwt.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava-gwt/test/com/google/common/collect/ImmutableTableTest_gwt.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "guava-gwt/test/com/google/common/collect/LinkedHashMultimapTest_gwt.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava-gwt/test/com/google/common/collect/MoreCollectorsTest_gwt.java", "insertions": 70, "deletions": 0, "lines": 70}, {"filePath": "guava-gwt/test/com/google/common/collect/testModule.gwt.xml", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-gwt/test/com/google/common/collect/testing/Testing.gwt.xml", "insertions": 30, "deletions": 26, "lines": 56}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/ListTestSuiteBuilder.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java", "insertions": 22, "deletions": 0, "lines": 22}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java", "insertions": 190, "deletions": 0, "lines": 190}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java", "insertions": 96, "deletions": 3, "lines": 99}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java", "insertions": 47, "deletions": 0, "lines": 47}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java", "insertions": 98, "deletions": 1, "lines": 99}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/google/MultimapForEachTester.java", "insertions": 48, "deletions": 0, "lines": 48}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java", "insertions": 52, "deletions": 0, "lines": 52}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java", "insertions": 53, "deletions": 0, "lines": 53}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java", "insertions": 103, "deletions": 0, "lines": 103}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionSpliteratorTester.java", "insertions": 95, "deletions": 0, "lines": 95}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionStreamTester.java", "insertions": 61, "deletions": 0, "lines": 61}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/ListReplaceAllTester.java", "insertions": 65, "deletions": 0, "lines": 65}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java", "insertions": 165, "deletions": 0, "lines": 165}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java", "insertions": 181, "deletions": 0, "lines": 181}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java", "insertions": 210, "deletions": 0, "lines": 210}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java", "insertions": 79, "deletions": 0, "lines": 79}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java", "insertions": 108, "deletions": 0, "lines": 108}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java", "insertions": 197, "deletions": 0, "lines": 197}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java", "insertions": 122, "deletions": 0, "lines": 122}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java", "insertions": 102, "deletions": 0, "lines": 102}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java", "insertions": 125, "deletions": 0, "lines": 125}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java", "insertions": 148, "deletions": 0, "lines": 148}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java", "insertions": 108, "deletions": 0, "lines": 108}, {"filePath": "guava-testlib/src/com/google/common/testing/CollectorTester.java", "insertions": 176, "deletions": 0, "lines": 176}, {"filePath": "guava-testlib/src/com/google/common/testing/TearDown.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-testlib/test/com/google/common/collect/testing/OpenJdk6MapTests.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "guava-tests/benchmark/com/google/common/collect/IteratorBenchmark.java", "insertions": 29, "deletions": 0, "lines": 29}, {"filePath": "guava-tests/benchmark/com/google/common/collect/StreamsBenchmark.java", "insertions": 111, "deletions": 0, "lines": 111}, {"filePath": "guava-tests/pom.xml", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "guava-tests/test/com/google/common/base/OptionalTest.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava-tests/test/com/google/common/cache/LocalCacheTest.java", "insertions": 48, "deletions": 12, "lines": 60}, {"filePath": "guava-tests/test/com/google/common/collect/CollectSpliteratorsTest.java", "insertions": 67, "deletions": 0, "lines": 67}, {"filePath": "guava-tests/test/com/google/common/collect/FluentIterableTest.java", "insertions": 22, "deletions": 0, "lines": 22}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableBiMapTest.java", "insertions": 30, "deletions": 0, "lines": 30}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableListMultimapTest.java", "insertions": 22, "deletions": 0, "lines": 22}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableListTest.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableMapTest.java", "insertions": 46, "deletions": 0, "lines": 46}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableMultisetTest.java", "insertions": 72, "deletions": 0, "lines": 72}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSetMultimapTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSetTest.java", "insertions": 59, "deletions": 0, "lines": 59}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSortedMapTest.java", "insertions": 53, "deletions": 0, "lines": 53}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSortedMultisetTest.java", "insertions": 27, "deletions": 0, "lines": 27}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableSortedSetTest.java", "insertions": 73, "deletions": 0, "lines": 73}, {"filePath": "guava-tests/test/com/google/common/collect/ImmutableTableTest.java", "insertions": 23, "deletions": 0, "lines": 23}, {"filePath": "guava-tests/test/com/google/common/collect/LinkedHashMultimapTest.java", "insertions": 56, "deletions": 0, "lines": 56}, {"filePath": "guava-tests/test/com/google/common/collect/MoreCollectorsTest.java", "insertions": 102, "deletions": 0, "lines": 102}, {"filePath": "guava-tests/test/com/google/common/collect/StreamsTest.java", "insertions": 264, "deletions": 0, "lines": 264}, {"filePath": "guava-tests/test/com/google/common/collect/SynchronizedBiMapTest.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava-tests/test/com/google/common/collect/SynchronizedNavigableSetTest.java", "insertions": 49, "deletions": 43, "lines": 92}, {"filePath": "guava-tests/test/com/google/common/collect/SynchronizedQueueTest.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "guava-tests/test/com/google/common/collect/SynchronizedSetTest.java", "insertions": 14, "deletions": 14, "lines": 28}, {"filePath": "guava-tests/test/com/google/common/collect/TreeTraverserTest.java", "insertions": 23, "deletions": 21, "lines": 44}, {"filePath": "guava-tests/test/com/google/common/io/MoreFilesTest.java", "insertions": 643, "deletions": 0, "lines": 643}, {"filePath": "guava-tests/test/com/google/common/io/SourceSinkFactories.java", "insertions": 179, "deletions": 0, "lines": 179}, {"filePath": "guava-tests/test/com/google/common/math/StatsTest.java", "insertions": 38, "deletions": 0, "lines": 38}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "guava/pom.xml", "insertions": 4, "deletions": 2, "lines": 6}, {"filePath": "guava/src/com/google/common/base/Equivalence.java", "insertions": 13, "deletions": 1, "lines": 14}, {"filePath": "guava/src/com/google/common/base/Function.java", "insertions": 11, "deletions": 27, "lines": 38}, {"filePath": "guava/src/com/google/common/base/Optional.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "guava/src/com/google/common/base/Platform.java", "insertions": 16, "deletions": 5, "lines": 21}, {"filePath": "guava/src/com/google/common/base/Predicate.java", "insertions": 18, "deletions": 17, "lines": 35}, {"filePath": "guava/src/com/google/common/base/Supplier.java", "insertions": 12, "deletions": 18, "lines": 30}, {"filePath": "guava/src/com/google/common/cache/LocalCache.java", "insertions": 167, "deletions": 6, "lines": 173}, {"filePath": "guava/src/com/google/common/collect/AbstractBiMap.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/AbstractMapBasedMultimap.java", "insertions": 41, "deletions": 0, "lines": 41}, {"filePath": "guava/src/com/google/common/collect/AbstractMapBasedMultiset.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "guava/src/com/google/common/collect/AbstractMultimap.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "guava/src/com/google/common/collect/AbstractRangeSet.java", "insertions": 0, "deletions": 24, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/AbstractTable.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "guava/src/com/google/common/collect/ArrayTable.java", "insertions": 17, "deletions": 1, "lines": 18}, {"filePath": "guava/src/com/google/common/collect/BinaryTreeTraverser.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "guava/src/com/google/common/collect/CollectCollectors.java", "insertions": 101, "deletions": 0, "lines": 101}, {"filePath": "guava/src/com/google/common/collect/CollectSpliterators.java", "insertions": 288, "deletions": 0, "lines": 288}, {"filePath": "guava/src/com/google/common/collect/Collections2.java", "insertions": 43, "deletions": 4, "lines": 47}, {"filePath": "guava/src/com/google/common/collect/FluentIterable.java", "insertions": 35, "deletions": 33, "lines": 68}, {"filePath": "guava/src/com/google/common/collect/ForwardingNavigableMap.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "guava/src/com/google/common/collect/HashBiMap.java", "insertions": 79, "deletions": 50, "lines": 129}, {"filePath": "guava/src/com/google/common/collect/ImmutableBiMap.java", "insertions": 31, "deletions": 1, "lines": 32}, {"filePath": "guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java", "insertions": 63, "deletions": 0, "lines": 63}, {"filePath": "guava/src/com/google/common/collect/ImmutableCollection.java", "insertions": 36, "deletions": 0, "lines": 36}, {"filePath": "guava/src/com/google/common/collect/ImmutableEnumMap.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava/src/com/google/common/collect/ImmutableEnumSet.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava/src/com/google/common/collect/ImmutableList.java", "insertions": 62, "deletions": 0, "lines": 62}, {"filePath": "guava/src/com/google/common/collect/ImmutableListMultimap.java", "insertions": 49, "deletions": 0, "lines": 49}, {"filePath": "guava/src/com/google/common/collect/ImmutableMap.java", "insertions": 187, "deletions": 1, "lines": 188}, {"filePath": "guava/src/com/google/common/collect/ImmutableMapEntrySet.java", "insertions": 18, "deletions": 0, "lines": 18}, {"filePath": "guava/src/com/google/common/collect/ImmutableMapKeySet.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava/src/com/google/common/collect/ImmutableMapValues.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava/src/com/google/common/collect/ImmutableMultimap.java", "insertions": 31, "deletions": 4, "lines": 35}, {"filePath": "guava/src/com/google/common/collect/ImmutableMultiset.java", "insertions": 42, "deletions": 1, "lines": 43}, {"filePath": "guava/src/com/google/common/collect/ImmutableSet.java", "insertions": 42, "deletions": 0, "lines": 42}, {"filePath": "guava/src/com/google/common/collect/ImmutableSetMultimap.java", "insertions": 46, "deletions": 0, "lines": 46}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedAsList.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedMap.java", "insertions": 85, "deletions": 0, "lines": 85}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java", "insertions": 34, "deletions": 0, "lines": 34}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedMultiset.java", "insertions": 46, "deletions": 0, "lines": 46}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedSet.java", "insertions": 53, "deletions": 0, "lines": 53}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava/src/com/google/common/collect/ImmutableTable.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "guava/src/com/google/common/collect/Iterables.java", "insertions": 80, "deletions": 57, "lines": 137}, {"filePath": "guava/src/com/google/common/collect/LinkedHashMultimap.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "guava/src/com/google/common/collect/LinkedListMultimap.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava/src/com/google/common/collect/Lists.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "guava/src/com/google/common/collect/Maps.java", "insertions": 105, "deletions": 5, "lines": 110}, {"filePath": "guava/src/com/google/common/collect/MoreCollectors.java", "insertions": 170, "deletions": 0, "lines": 170}, {"filePath": "guava/src/com/google/common/collect/Multimap.java", "insertions": 18, "deletions": 0, "lines": 18}, {"filePath": "guava/src/com/google/common/collect/Multimaps.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "guava/src/com/google/common/collect/Multiset.java", "insertions": 48, "deletions": 3, "lines": 51}, {"filePath": "guava/src/com/google/common/collect/Multisets.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava/src/com/google/common/collect/MutableClassToInstanceMap.java", "insertions": 12, "deletions": 1, "lines": 13}, {"filePath": "guava/src/com/google/common/collect/Ordering.java", "insertions": 5, "deletions": 5, "lines": 10}, {"filePath": "guava/src/com/google/common/collect/RangeSet.java", "insertions": 19, "deletions": 3, "lines": 22}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableAsList.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableBiMap.java", "insertions": 23, "deletions": 0, "lines": 23}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableList.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableMap.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableSet.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java", "insertions": 9, "deletions": 0, "lines": 9}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableSortedSet.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableTable.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "guava/src/com/google/common/collect/Sets.java", "insertions": 31, "deletions": 0, "lines": 31}, {"filePath": "guava/src/com/google/common/collect/SingletonImmutableBiMap.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/SingletonImmutableList.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/SingletonImmutableSet.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "guava/src/com/google/common/collect/StandardTable.java", "insertions": 26, "deletions": 1, "lines": 27}, {"filePath": "guava/src/com/google/common/collect/Streams.java", "insertions": 496, "deletions": 0, "lines": 496}, {"filePath": "guava/src/com/google/common/collect/Synchronized.java", "insertions": 143, "deletions": 0, "lines": 143}, {"filePath": "guava/src/com/google/common/collect/Tables.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "guava/src/com/google/common/collect/TopKSelector.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava/src/com/google/common/collect/TreeTraverser.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "{guava-tests/test => guava/src}/com/google/common/io/AndroidIncompatible.java", "insertions": 3, "deletions": 8, "lines": 11}, {"filePath": "guava/src/com/google/common/io/InsecureRecursiveDeleteException.java", "insertions": 47, "deletions": 0, "lines": 47}, {"filePath": "guava/src/com/google/common/io/MoreFiles.java", "insertions": 738, "deletions": 0, "lines": 738}, {"filePath": "guava/src/com/google/common/io/RecursiveDeleteOption.java", "insertions": 49, "deletions": 0, "lines": 49}, {"filePath": "guava/src/com/google/common/util/concurrent/AsyncFunction.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava/src/com/google/common/util/concurrent/AtomicLongMap.java", "insertions": 121, "deletions": 223, "lines": 344}, {"filePath": "guava/src/com/google/common/util/concurrent/Monitor.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "pom.xml", "insertions": 24, "deletions": 34, "lines": 58}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}, {"commitHash": "c34433a6d6062ffb23eb3878355024ae08517495", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["a70ab0168d75db566d7e974220a0d0b17e514cf8"], "nameRev": "c34433a6d6062ffb23eb3878355024ae08517495 tags/v21.0-rc1~63", "commitMessage": "Fix links to javadoc.io for Maven Javadoc Plugin\n\nFixes #2479\n\nFixes #2628\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=138184010\n", "commitDateTime": "2016-11-04 06:55:11", "authoredDateTime": "2016-11-04 06:35:32", "commitGitStats": [{"filePath": "guava/pom.xml", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["73e382fa877f80994817a136b0adcc4365ccd904"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4707, "deletions": 507, "lines": 5214, "gitFilesChange": 94}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect", "guava-testlib/src/com/google/common/testing", "guava-gwt/src-super/com/google/common/collect/super/com/google/common", "guava-tests/benchmark/com/google/common/collect", "guava/src/com/google/common/base", "guava/src/com/google/common/cache", "guava/src/com/google/common/io", "guava/src/com/google/common/util/concurrent", "{guava-tests/test => guava/src}/com/google/common/io", "guava-tests/test/com/google/common/io"]}, {"title": "Locking Problem with Lazy Striped ReadWriteLocks", "body": "We're seeing a behaviour of a Striped.lazyReadWriteLock that seem to break the documented behaviour that for the same key the same lock will be returned. Is there something obvious we're missing or misunderstood about the lazy Striped Locks? When using eager Locks, everything works as expected.\n\nThe following test reproduces the behaviour.\n\n```\npublic class MyTest {\n\n    private final Striped<ReadWriteLock> stripedLock = Striped.lazyWeakReadWriteLock(64);\n    private final AtomicBoolean writeLocked = new AtomicBoolean(false);\n    private final Set<String> someSet = new HashSet<>();\n    private final Random random = new Random();\n\n    private final String key = \"anyKey\";\n\n    @Test\n    public void test() throws Exception {\n        final ExecutorService executorService = Executors.newCachedThreadPool();\n        final AtomicBoolean testFailed = new AtomicBoolean(false);\n\n        for (int i = 0; i < 1000000; i++) {\n            someSet.add(\"\" + i);\n        }\n\n        for (int i = 0; i < 10; i++) {\n\n            executorService.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        while (!testFailed.get()) {\n                            if (random.nextBoolean()) {\n                                writeLockedMethod();\n                            } else {\n                                readLockedMethod();\n                            }\n                        }\n                    } catch (AssertionError e) {\n                        e.printStackTrace();\n                        testFailed.set(true);\n                    }\n                }\n            });\n        }\n\n        while (!testFailed.get()) {\n            Thread.sleep(1000);\n        }\n        fail();\n    }\n\n    private void readLockedMethod() {\n        final Lock readLock = stripedLock.get(key).readLock();\n        readLock.lock();\n        assertFalse(writeLocked.get());\n        try {\n            someSet.contains(\"\" + random.nextInt(1000000)); //Just do something.\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    private void writeLockedMethod() {\n        final Lock writeLock = stripedLock.get(key).writeLock();\n        writeLock.lock();\n        //Since the atomic boolean is set inside the write lock, for the same key, this should never be true.\n        assertFalse(Thread.currentThread().getName(),writeLocked.get());\n        writeLocked.getAndSet(true);\n        try {\n            someSet.contains(\"\" + random.nextInt(1000000)); //Just do something.\n        } finally {\n            writeLocked.getAndSet(false);\n            writeLock.unlock();\n        }\n    }\n}\n```\n", "url": "https://github.com/google/guava/issues/2477", "user": "dobermai", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2016-05-12 17:29:59", "closed": "2017-10-16 19:40:04", "commits": {}, "ttf": 522.0002777777778, "commitsDetails": []}, {"title": "Work around Samsung 5.0.x Atomic*FieldUpdater bug in AggregateFutureState and InterruptibleTask", "body": "We already do in `AbstractFuture`.\n", "url": "https://github.com/google/guava/issues/2463", "user": "cpovirk", "labels": ["package=concurrent", "platform=android", "status=fixed", "type=defect"], "created": "2016-04-19 16:11:23", "closed": "2016-04-20 15:58:01", "commits": {"80dad6bf149f9b8d66e4db4436034cf6b7018398": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "80dad6bf149f9b8d66e4db4436034cf6b7018398", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["717146e3910cf4e5243defa3760c456c4dc16ecb"], "nameRev": "80dad6bf149f9b8d66e4db4436034cf6b7018398 tags/v20.0-rc1~359", "commitMessage": "Support reflection-less atomic updates in AggregateFutureState and InterruptibleTask as in AbstractFuture.\n\nFixes https://github.com/google/guava/issues/2463\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=120337540\n", "commitDateTime": "2016-04-20 08:11:48", "authoredDateTime": "2016-04-20 08:05:56", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/util/concurrent/AggregateFutureStateFallbackAtomicHelperTest.java", "insertions": 136, "deletions": 0, "lines": 136}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "guava/src/com/google/common/util/concurrent/AggregateFutureState.java", "insertions": 79, "deletions": 11, "lines": 90}, {"filePath": "guava/src/com/google/common/util/concurrent/InterruptibleTask.java", "insertions": 56, "deletions": 4, "lines": 60}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AggregateFutureStateFallbackAtomicHelperTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureStateFallbackAtomicHelperTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FuturesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.setUp()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.tearDown()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AggregateFutureState.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState", "TOT": 11, "UPD": 4, "INS": 2, "MOV": 4, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.decrementRemainingAndGet()", "TOT": 6, "UPD": 2, "INS": 1, "MOV": 3, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.getOrInitSeenExceptions()", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.AtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.SafeAtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.SynchronizedAtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFutureState.SafeAtomicHelper.decrementAndGetRemainingCount(com.google.common.util.concurrent.AggregateFutureState)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "InterruptibleTask.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask", "TOT": 7, "UPD": 1, "INS": 3, "MOV": 3, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.run()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.AtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.SafeAtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.SynchronizedAtomicHelper", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["80dad6bf149f9b8d66e4db4436034cf6b7018398"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 135, "deletions": 15, "lines": 150, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 36, "UPD": 11, "INS": 13, "MOV": 11, "DEL": 1, "spoonFilesChanged": 2, "spoonMethodsChanged": 12}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/util/concurrent"], "changesInPackagesSPOON": ["com.google.common.util.concurrent.AggregateFutureState.getOrInitSeenExceptions()", "com.google.common.util.concurrent.AggregateFutureState.AtomicHelper", "com.google.common.util.concurrent.InterruptibleTask.SafeAtomicHelper", "com.google.common.util.concurrent.AggregateFutureState.SafeAtomicHelper", "com.google.common.util.concurrent.InterruptibleTask.run()", "com.google.common.util.concurrent.AggregateFutureState.SafeAtomicHelper.decrementAndGetRemainingCount(com.google.common.util.concurrent.AggregateFutureState)", "com.google.common.util.concurrent.AggregateFutureState.decrementRemainingAndGet()", "com.google.common.util.concurrent.InterruptibleTask.SynchronizedAtomicHelper", "com.google.common.util.concurrent.AggregateFutureState.SynchronizedAtomicHelper", "com.google.common.util.concurrent.AggregateFutureState", "com.google.common.util.concurrent.InterruptibleTask", "com.google.common.util.concurrent.InterruptibleTask.AtomicHelper"]}, {"title": "Map tests assert on .toString even when CollectionFeature.NON_STANDARD_TOSTRING is specified", "body": "See a unit test demonstrating the issue here: https://github.com/gpanther/fastutil-guava-tests/blob/master/src/test/java/net/greypanther/guava/tests/tests/CustomToStringTest.java\n\nIt shows a HashMap subclass which overrides toString and as a result fails tests, even if CollectionFeature.NON_STANDARD_TOSTRING passed to MapTestSuiteBuilder.\n\nI believe that methods like https://github.com/google/guava/blob/2cd4d629a2b6f1a462643b248e0972f44c5133b7/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java#L45 should be marked with `@CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)`.\n", "url": "https://github.com/google/guava/issues/2418", "user": "cdman", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2016-03-12 17:06:08", "closed": "2016-03-18 18:12:39", "commits": {"6bd4a49baaefd36e1f7c8c4d28a82d688b15a0fc": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "6bd4a49baaefd36e1f7c8c4d28a82d688b15a0fc", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["00ad4b03340a6b58134e5f6f5c46c0eb775a3895"], "nameRev": "6bd4a49baaefd36e1f7c8c4d28a82d688b15a0fc tags/v20.0-rc1~410", "commitMessage": "Skip Map+Multimap toString() tests if NON_STANDARD_TOSTRING is specified.\n\nFixes https://github.com/google/guava/issues/2418\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=117563335\n", "commitDateTime": "2016-03-18 14:06:14", "authoredDateTime": "2016-03-18 10:56:33", "commitGitStats": [{"filePath": "guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MultimapToStringTester.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.testing.google.MultimapToStringTester.testToStringEmpty()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.google.MultimapToStringTester.testToStringSingleton()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.google.MultimapToStringTester.testToStringWithNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.google.MultimapToStringTester.testToStringWithNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.google.MultimapToStringTester.testToStringMatchesAsMap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MapToStringTester.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.testing.testers.MapToStringTester.testToString_size0()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.testers.MapToStringTester.testToString_size1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.testers.MapToStringTester.testToStringWithNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.testers.MapToStringTester.testToStringWithNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.testing.testers.MapToStringTester.testToString_formatting()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6bd4a49baaefd36e1f7c8c4d28a82d688b15a0fc"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Incoherent miss count in cache stats", "body": "Sometimes, after a lot of concurrent GET on a guava cache with the same key, the miss count may not be coherent.\n\nMy current understanding of the cache behavior is that threads performing concurrent GET for an un-cached key will all be blocked but one, the one performing the load, until the latter returns and then each thread gets the value. This will increment the miss count by the number of threads that were blocked. Any subsequent GET for the same key by one of these threads should hit the cache (no eviction assumed here) and so miss counter should not be incremented anymore.\n\nAssuming this behavior, I've developped the following test to emphasize the wrong counts I've observed. \n\n[See test gist](https://gist.github.com/rrevol/8ab557eeb3b9f1185256)\n", "url": "https://github.com/google/guava/issues/2389", "user": "rrevol", "labels": ["P4", "package=cache", "type=defect"], "created": "2016-02-10 14:27:30", "closed": "2019-07-24 23:47:40", "commits": {}, "ttf": 1260.0002777777777, "commitsDetails": []}, {"title": "Override removeIf() and replaceAll() in our ConcurrentMap implementations", "body": "A recent concurrency-interest thread suggests that we should override `removeIf` in our Java 8 branch:\n- http://cs.oswego.edu/pipermail/concurrency-interest/2016-February/014900.html\n- http://stackoverflow.com/q/29876083/28465\n- http://stackoverflow.com/q/3768554/28465\n- http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8078645\n\nDoes that sound like something we should do?\n\nImplementations that might need an update:\n\n```\n$ extends java.util.concurrent.ConcurrentMap | grep com.google.common\njava:com.google.common.cache.LocalCache\njava:com.google.common.collect.ComputingConcurrentHashMap\njava:com.google.common.collect.ComputingConcurrentHashMap.ComputingSerializationProxy\njava:com.google.common.collect.ForwardingConcurrentMap\njava:com.google.common.collect.ForwardingConcurrentMapTest.TestMap\njava:com.google.common.collect.MapMaker.ComputingMapAdapter\njava:com.google.common.collect.MapMakerInternalMap\njava:com.google.common.collect.MapMakerInternalMap.AbstractSerializationProxy\njava:com.google.common.collect.MapMakerInternalMap.SerializationProxy\njava:com.google.common.collect.MapMaker.NullComputingConcurrentMap\njava:com.google.common.collect.MapMaker.NullConcurrentMap\njava:com.google.common.labs.concurrent.ConcurrentEnumMap\n```\n", "url": "https://github.com/google/guava/issues/2382", "user": "cpovirk", "labels": ["package=collect", "platform=java8", "type=defect"], "created": "2016-02-05 17:30:15", "closed": "2016-09-11 14:35:07", "commits": {}, "ttf": 218.00027777777777, "commitsDetails": []}, {"title": "Consider replacing unicode character in Range.toString()", "body": "`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\n\nConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\n", "url": "https://github.com/google/guava/issues/2376", "user": "cowwoc", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2016-01-30 01:21:57", "closed": "2016-02-17 14:58:12", "commits": {"c6e21a35f3113a7a952a9615a0e92dcf1dd4bfb3": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 18.00027777777778, "commitsDetails": [{"commitHash": "c6e21a35f3113a7a952a9615a0e92dcf1dd4bfb3", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["31c5a404b250f692d864fb36fb419988c4bc7ee4"], "nameRev": "c6e21a35f3113a7a952a9615a0e92dcf1dd4bfb3 tags/v20.0-rc1~496", "commitMessage": "Change Range.toString() to use printable ASCII chars (..) instead of \\u2025 (\u2025)\n\nSee https://github.com/google/guava/issues/2376\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=114820315\n", "commitDateTime": "2016-02-17 09:52:04", "authoredDateTime": "2016-02-16 19:30:38", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/collect/RangeTest.java", "insertions": 12, "deletions": 12, "lines": 24}, {"filePath": "guava/src/com/google/common/collect/Range.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/collect/RangeMap.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/collect/RangeSet.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "RangeTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.RangeTest.testOpen()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testClosed()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testOpenClosed()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testClosedOpen()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testSingleton()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testEmpty1()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testEmpty2()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testLessThan()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testGreaterThan()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testAtLeast()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testAtMost()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.RangeTest.testAll()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Range.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.Range.toString(com.google.common.collect.Cut,com.google.common.collect.Cut)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "RangeMap.java", "spoonMethods": []}, {"spoonFilePath": "RangeSet.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["c6e21a35f3113a7a952a9615a0e92dcf1dd4bfb3"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 3, "lines": 6, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": ["com.google.common.collect.Range.toString(com.google.common.collect.Cut,com.google.common.collect.Cut)"]}, {"title": "Map::replaceAll breaks HashBiMap::inverse", "body": "Hi, I just tried updating a HashBiMap using replaceAll and a second HashBiMap, but kept getting the error \"java.lang.IllegalArgumentException: value already present: null\".\nAfter checking my own code, I set up a minimal code example to see what was going wrong.\nIt seems like calling replaceAll on an inverse of a HashBiMap doesn't work.\n\nThe println lines are just there to show you that it should work as in the line where I combine the two maps.\n\n```\nfinal int upperBound = 2;\nfinal HashBiMap<Integer, Integer> b2a = HashBiMap.create();\nIntStream.range(0, upperBound).forEach(i -> b2a.put(i, 100 + i));\nSystem.out.println(\"b2a\" + b2a);\nfinal HashBiMap<Integer, Integer> b2c = HashBiMap.create();\nIntStream.range(0, upperBound).forEach(i -> b2c.put(i, 200 + i));\nSystem.out.println(\"b2c\" + b2c);\nfinal BiMap<Integer, Integer> a2b = b2a.inverse();\nSystem.out.println(\"a2b\" + a2b);\nSystem.out.println(\"a2c\" + Maps.asMap(a2b.keySet(), k -> b2c.get(a2b.get(k))));\na2b.replaceAll((a, b) -> b2c.get(b));\nSystem.out.println(\"a2b'\" + a2b);\n```\n\nIt is interesting to note, that putAll for a copy of the combined map works.\n", "url": "https://github.com/google/guava/issues/2367", "user": "muued", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2016-01-22 17:35:27", "closed": "2016-02-04 20:13:12", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "Implement Stopwatch.toString() under GWT", "body": "Not a high priority. I just feel a little bad that users there would get something like \"com.google.common.base.Stopwatch@0xdeadbeef\".\n", "url": "https://github.com/google/guava/issues/2365", "user": "cpovirk", "labels": ["package=base", "platform=gwt", "status=fixed", "type=defect"], "created": "2016-01-21 22:26:42", "closed": "2016-04-01 17:02:58", "commits": {"c995616f2409e2b20e890e415d6dd3d38d5bc1fe": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 70.00027777777778, "commitsDetails": [{"commitHash": "c995616f2409e2b20e890e415d6dd3d38d5bc1fe", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["5b608043b9d56a4427a2d8c1583f6f3c5a4e1023"], "nameRev": "c995616f2409e2b20e890e415d6dd3d38d5bc1fe tags/v20.0-rc1~387", "commitMessage": "Implement Stopwatch.toString() under GWT.\n\nFixes #2437\nFixes #2365\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=118680962\n", "commitDateTime": "2016-04-01 09:28:39", "authoredDateTime": "2016-03-31 08:13:28", "commitGitStats": [{"filePath": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/base/StopwatchTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "guava/src/com/google/common/base/Platform.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava/src/com/google/common/base/Stopwatch.java", "insertions": 2, "deletions": 5, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Platform.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.Platform.formatCompact4Digits(double)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StopwatchTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.StopwatchTest_gwt.testToString()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StopwatchTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.StopwatchTest", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.base.StopwatchTest.testToString()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "Stopwatch.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.Stopwatch.toString()", "TOT": 7, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 2}, {"spoonMethodName": "com.google.common.base.Stopwatch", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug: Cache.weakKeys() doesn't work.", "body": "I am expecting the cache to evict keys after System.gc(). This requires:\n- cache.getIfPresent(v) works\n- cache is cleared after System.gc()\n\nBut unfortunately it couldn't satisfy both conditions.\n\nHere is how I created the cache:\n\n```\n        Cache cache = CacheBuilder.newBuilder()\n                .weakKeys().build();\n```\n- Eviction works when the key is created and not assigned to a variable\n\n```\n        cache.put(Math.random(), \"a\");\n        System.out.println(\"cache: \" + cache.asMap());\n        System.gc();\n        System.out.println(\"cache: \" + cache.asMap());\n```\n\nThis showed the correct output:\n\n```\ncache: {0.7254227566649404=a}\ncache: {}\n```\n- Eviction doesn't work if the the key is assigned to a local variable:\n\n```\n        Cache cache = CacheBuilder.newBuilder()\n                .weakKeys().build();\n        {\n        Double r = Math.random();\n        cache.put(r, \"a\");\n        }\n        System.out.println(\"cache: \" + cache.asMap());\n        System.gc();\n        System.out.println(\"cache: \" + cache.asMap());\n```\n\nThis showed the wrong output:\n\n```\ncache: {0.006581944795823524=a}\ncache: {0.006581944795823524=a}        //  <=== notice here, the value is still in cache.\n```\n- Eviction works with primitive, but cache doesn't work\n\n```\n        double r = Math.random();\n        cache.put(r, \"a\");\n        System.out.println(\"cache: \" + cache.asMap());\n        System.out.println(\"v: \" + cache.getIfPresent(r));\n        System.gc();\n        System.out.println(\"cache: \" + cache.asMap());\n```\n\nThis showed the wrong output:\n\n```\ncache: {0.3569447241229746=a}\nv: null                     // <===  autoboxed Double at different time will give different segment hashes.\ncache: {}\n```\n\nSo, with Cache.weakKeys(), we don't have eviction on System.gc(), or cache with keys that don't have a match.\n", "url": "https://github.com/google/guava/issues/2352", "user": "yuhanz", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2016-01-06 01:13:08", "closed": "2016-01-06 01:23:16", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Test suites incorrectly call TestSetGenerator.order", "body": "The [javadoc for TestContainerGenerator.order](https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java#L66) states:\n\n> This method runs only when CollectionFeature#KNOWN_ORDER is specified when creating the test suite. It should never run when testing containers such as HashSet, which have a non-deterministic iteration order.\n\nHowever, 74 tests (out of 450) fail with the code below which (as described by the documentation) expects TestContainerGenerator.order not to be called and throws an UnsupportedOperationException for it:\n\n``` java\npublic final class JavaUtilCollectionsTests {\n  public static Test suite() {\n    TestSuite suite = new TestSuite(\"HashSet\");\n    suite.addTest(SetTestSuiteBuilder.<Integer>using(new TestSetGenerator<Integer>() {\n      @Override\n      public SampleElements<Integer> samples() {\n        return new SampleElements<Integer>(-7, 0, Integer.MIN_VALUE, 42, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public Integer[] createArray(int length) {\n        return new Integer[length];\n      }\n\n      @Override\n      public Iterable<Integer> order(List<Integer> insertionOrder) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public Set<Integer> create(Object... elements) {\n        List<Integer> values =\n            Arrays.stream(elements).map(o -> (Integer) o).collect(Collectors.toList());\n        return new HashSet<>(values);\n      }\n    }).named(\"HashSet\")\n        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE,\n            CollectionFeature.ALLOWS_NULL_VALUES, CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)\n        .createTestSuite());\n    return suite;\n  }\n}\n```\n\nThe expected result would be for all the tests to pass.\n", "url": "https://github.com/google/guava/issues/2349", "user": "cdman", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2016-01-05 16:23:02", "closed": "2016-03-18 19:01:01", "commits": {"c925b98f0dadbf1fe836fe70251ba294ef8f6c81": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 73.00027777777778, "commitsDetails": [{"commitHash": "c925b98f0dadbf1fe836fe70251ba294ef8f6c81", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["6bd4a49baaefd36e1f7c8c4d28a82d688b15a0fc"], "nameRev": "c925b98f0dadbf1fe836fe70251ba294ef8f6c81 tags/v20.0-rc1~409", "commitMessage": "Document that order() is called even without KNOWN_ORDER.\n\nFixes https://github.com/google/guava/issues/2349\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=117569479\n", "commitDateTime": "2016-03-18 15:00:40", "authoredDateTime": "2016-03-18 11:48:08", "commitGitStats": [{"filePath": "guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java", "insertions": 5, "deletions": 5, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "TestContainerGenerator.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["c925b98f0dadbf1fe836fe70251ba294ef8f6c81"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "ImmutableSortedMap.copyOf and ImmutableSortedSet.copyOf are inconsistent", "body": "`ImmutableSortedMap.copyOf` has an overload with the following signature:\n\n```\ncopyOf(Map<? extends K,? extends V> map, Comparator<? super K> comparator);\n```\n\nbut similar methods on `ImmutableSortedSet` are declared like so:\n\n```\ncopyOf(Comparator<? super E> comparator, Collection<? extends E> elements)\ncopyOf(Comparator<? super E> comparator, Iterable<? extends E> elements)\ncopyOf(Comparator<? super E> comparator, Iterator<? extends E> elements)\n```\n\nThe placement of the `Comparator` argument is inconsistent. I suggest one version is deprecated, and overloads with the arguments swapped over are added.\n", "url": "https://github.com/google/guava/issues/2256", "user": "ghost", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2015-12-18 11:32:21", "closed": "2016-01-19 20:36:20", "commits": {}, "ttf": 32.000277777777775, "commitsDetails": []}, {"title": "Nesting Futures.transform() eats StackOverflowError and causes the Future to hang forever", "body": "Hey!\nI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \n\n``` java\n  static final int REPS = 10000;\n  @Test\n  public void hangs() throws InterruptedException, TimeoutException {\n    SettableFuture<Integer> settableFuture = SettableFuture.create();\n    ListenableFuture<Integer> chained = settableFuture;\n    for (int i = 0; i < REPS; ++i) {\n      chained = Futures.transform(chained, Functions.<Integer>identity());\n    }\n    settableFuture.set(0);\n\n    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\n  }\n```\n\nBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\n\nMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\n", "url": "https://github.com/google/guava/issues/2254", "user": "marcinkosiba", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2015-12-15 15:26:17", "closed": "2016-01-28 13:56:56", "commits": {"52b5ee640da780e0fd2502ec995436fcdc93e03e": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "fd3c30f0efd09435c010f5fab52495554242ab52": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "cf1478062f646ec0d7e1d96f8ab52e7194b50ce8": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 43.000277777777775, "commitsDetails": [{"commitHash": "52b5ee640da780e0fd2502ec995436fcdc93e03e", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["88e42e657a32f9aaf0fa705d40a164431133d342"], "nameRev": "52b5ee640da780e0fd2502ec995436fcdc93e03e tags/v20.0-rc1~552", "commitMessage": "Don't silently swallow Errors.\nhttps://github.com/google/guava/issues/2254\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=113152082\n", "commitDateTime": "2016-01-28 07:30:20", "authoredDateTime": "2016-01-27 05:31:45", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java", "insertions": 540, "deletions": 0, "lines": 540}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "insertions": 495, "deletions": 0, "lines": 495}, {"filePath": "guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java", "insertions": 53, "deletions": 25, "lines": 78}, {"filePath": "guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java", "insertions": 112, "deletions": 33, "lines": 145}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "fd3c30f0efd09435c010f5fab52495554242ab52", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["cfd409b2d0b6ed0ee35589d8471a44689eddccc4"], "nameRev": "fd3c30f0efd09435c010f5fab52495554242ab52 tags/v20.0-rc1~98", "commitMessage": "Make it more difficult to get StackOverflowErrors from hooking chains of futures together with setFuture\n\nThere are two ways such an SOE can occur given a chain of AbstractFutures strung together with setFuture\n1 when the 'innermost' future completes, the sequence of directExecutor listeners will all execute inline, recursively\n2 when the 'outermost' future is cancelled, AbstractFuture.cancel() propagates cancellation to the future that has been assigned to it via setFuture since this is 'inline' we can run out of stack\n\nThe first one can be solved by modifying the way we execute listeners and detecting this case explicitly\n\nThe second one would technically allow for the same solution but a number of users depend on their cancel methods actually getting called so we need to limit this solution to TrustedFuture subclasses and mark TrustedFuture.cancel final.  I can break this change into a separate CL but i thought it might be easier to review altogether, let me know.\n\nThis of course doesn't solve every way you could get such a StackOverflowError, just a few potentially common ones.\n\n(This may help with problems like https://github.com/google/guava/issues/2254)\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=131312174\n", "commitDateTime": "2016-08-25 12:07:39", "authoredDateTime": "2016-08-25 11:33:31", "commitGitStats": [{"filePath": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java", "insertions": 7, "deletions": 5, "lines": 12}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java", "insertions": 44, "deletions": 16, "lines": 60}, {"filePath": "guava/src/com/google/common/util/concurrent/AbstractFuture.java", "insertions": 134, "deletions": 69, "lines": 203}, {"filePath": "guava/src/com/google/common/util/concurrent/AggregateFuture.java", "insertions": 14, "deletions": 25, "lines": 39}, {"filePath": "guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractFuture.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.completeWithFuture(com.google.common.util.concurrent.ListenableFuture,java.lang.Object)", "TOT": 7, "UPD": 3, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.clearWaiters()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.clearListeners()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.complete()", "TOT": 29, "UPD": 10, "INS": 0, "MOV": 13, "DEL": 6}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.setFuture(com.google.common.util.concurrent.ListenableFuture)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.SetFuture.run()", "TOT": 8, "UPD": 1, "INS": 3, "MOV": 3, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.cancel(boolean)", "TOT": 27, "UPD": 0, "INS": 12, "MOV": 9, "DEL": 6}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.set(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.setException(java.lang.Throwable)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.TrustedFuture.cancel(boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.SetFuture", "TOT": 5, "UPD": 0, "INS": 5, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.complete(com.google.common.util.concurrent.AbstractFuture)", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.clearListeners(com.google.common.util.concurrent.AbstractFuture$Listener)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFuture.getFutureValue(com.google.common.util.concurrent.ListenableFuture)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractFutureTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testSetFutureCancelBash()", "TOT": 15, "UPD": 4, "INS": 5, "MOV": 2, "DEL": 4}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testSetFutureCancelBash().23.call()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testSetFutureCancelBash().24.call()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testSetFutureCancelBash().27.call()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testSetFuture_stackOverflow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractFutureTest.testCancel_stackOverflow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AggregateFuture.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AggregateFuture.cancel(boolean)", "TOT": 7, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFuture.afterDone()", "TOT": 9, "UPD": 0, "INS": 3, "MOV": 5, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.AggregateFuture.RunningState.handleOneInputDone(int,java.util.concurrent.Future)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "TrustedListenableFutureTask.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.afterDone()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "cf1478062f646ec0d7e1d96f8ab52e7194b50ce8", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["71703b40b42c96dd1fef03a760e2e648db11f792"], "nameRev": "cf1478062f646ec0d7e1d96f8ab52e7194b50ce8 tags/v23.1~96", "commitMessage": "Fix interruption leak in submitAsync and whenAllComplete().callAsync().\n\nThere are two bugs in the handling of TrustedListenableFutureTask:\n\n1. Returning an future that was cancelled with interruption calls setFuture(), which then calls interruptTask() on the output future - this then calls InterruptibleTask.interruptTask(), which happily interrupts the thread that directExecutor.execute() was called on.\n\n2. The thread that InterruptibleTask runs on is referenced forever, and CombinedFuture nulls out its reference to InterruptibleTask in afterDone() - which is called after interruptTask. This means that if the setFuture() path is taken, then cancel(true) is called, the thread that called the callable will be interrupted, even after InterruptTask.run() has returned.\n\nIf we've ever seen spurious InterruptedExceptions in production, this could be a cause - whenAllComplete().callAsync(callable, executor).cancel(true) can interrupt whatever thread callable was called on, even long after call() returns. If that thread is part of a pool (which it probably always would be), then this would interrupt whatever unlucky task happened to be running on that pool thread later.\n\nThis CL adds earlier nulling out of the InterruptibleTask in TrustedListenableFutureTask, as well as makes InterruptibleTask robust to having interruptTask called after runInterruptibly has returned. To avoid tasks interrupting themselves when they call setFuture of an interrupted and cancelled future, a new method allows subclasses to end the interruption window early - this should also somewhat reduce the race of directExecutor() listeners being interrupted.\n\nAdditionally, by splitting CombinedFuture.setValue() into 2 methods, this CL fixes the equivalent of https://github.com/google/guava/issues/2254 for Futures.whenAllSucceed/whenAllComplete.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=162649353\n", "commitDateTime": "2017-07-20 12:47:32", "authoredDateTime": "2017-07-20 12:20:56", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "android/guava/src/com/google/common/util/concurrent/CombinedFuture.java", "insertions": 42, "deletions": 27, "lines": 69}, {"filePath": "android/guava/src/com/google/common/util/concurrent/InterruptibleTask.java", "insertions": 51, "deletions": 19, "lines": 70}, {"filePath": "android/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java", "insertions": 37, "deletions": 29, "lines": 66}, {"filePath": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/InterruptibleTask.java", "insertions": 21, "deletions": 8, "lines": 29}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "guava/src/com/google/common/util/concurrent/CombinedFuture.java", "insertions": 42, "deletions": 27, "lines": 69}, {"filePath": "guava/src/com/google/common/util/concurrent/InterruptibleTask.java", "insertions": 51, "deletions": 19, "lines": 70}, {"filePath": "guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java", "insertions": 37, "deletions": 29, "lines": 66}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FuturesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testMakeChecked_listenersRunOnCancel()", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testMakeChecked_listenersRunOnFailure()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testMakeChecked_listenersRunOnceCompleted()", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_wildcard()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.doTestSuccessfulAsList_resultCancelledRacingInputDone()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.asyncIdentity()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_wildcard().52", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_asyncResult().53", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_asyncError().54", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_cancelledNotInterrupted().55", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_interrupted().56", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllSucceed().57", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.pseudoTimedGetUninterruptibly(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.doTestSuccessfulAsList_resultCancelledRacingInputDone().59", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testMakeChecked_propagatesFailedMappers()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.asyncIdentity().64", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.pseudoTimedGetUninterruptibly(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit).58", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testMakeChecked_propagatesFailedMappers().60", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_asyncError().54.call()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.doTestSuccessfulAsList_resultCancelledRacingInputDone().59.run()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testSubmitAsync_asyncCallable_returnsInterruptedFuture()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.FuturesTest.testWhenAllComplete_noLeakInterruption()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CombinedFuture.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.wasInterrupted()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.runInterruptibly()", "TOT": 9, "UPD": 3, "INS": 0, "MOV": 4, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask.setValue()", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.setValue()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.setValue()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask.setValue(com.google.common.util.concurrent.ListenableFuture)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.runInterruptibly()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.setValue(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.setValue(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.afterRanInterruptibly(java.lang.Object,java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "InterruptibleTask.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask", "TOT": 7, "UPD": 4, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.wasInterrupted()", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.runInterruptibly()", "TOT": 4, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.interruptTask()", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.run()", "TOT": 17, "UPD": 0, "INS": 11, "MOV": 4, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.DoNothingRunnable", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.InterruptibleTask.isDone()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TrustedListenableFutureTask.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.runInterruptibly()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.wasInterrupted()", "TOT": 4, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.runInterruptibly()", "TOT": 7, "UPD": 2, "INS": 1, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.wasInterrupted()", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.run()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.afterRanInterruptibly(java.lang.Object,java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.isDone()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["52b5ee640da780e0fd2502ec995436fcdc93e03e", "fd3c30f0efd09435c010f5fab52495554242ab52", "cf1478062f646ec0d7e1d96f8ab52e7194b50ce8"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 3, "gitStatsSummary": {"insertions": 602, "deletions": 316, "lines": 918, "gitFilesChange": 12}, "spoonStatsSummary": {"TOT": 215.0, "UPD": 46.0, "INS": 72.0, "MOV": 66.0, "DEL": 31.0, "spoonFilesChanged": 5, "spoonMethodsChanged": 47}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/util/concurrent", "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google", "android/guava/src/com/google/common/util/concurrent"], "changesInPackagesSPOON": ["com.google.common.util.concurrent.AbstractFuture.SetFuture", "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.setValue()", "com.google.common.util.concurrent.TrustedListenableFutureTask.run()", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.afterRanInterruptibly(java.lang.Object,java.lang.Throwable)", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.wasInterrupted()", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask", "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.runInterruptibly()", "com.google.common.util.concurrent.AbstractFuture.clearListeners()", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.isDone()", "com.google.common.util.concurrent.InterruptibleTask.DoNothingRunnable", "com.google.common.util.concurrent.InterruptibleTask.isDone()", "com.google.common.util.concurrent.InterruptibleTask.interruptTask()", "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask", "com.google.common.util.concurrent.InterruptibleTask", "com.google.common.util.concurrent.InterruptibleTask.run()", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask", "com.google.common.util.concurrent.AbstractFuture.cancel(boolean)", "com.google.common.util.concurrent.AbstractFuture.set(java.lang.Object)", "com.google.common.util.concurrent.AbstractFuture.clearListeners(com.google.common.util.concurrent.AbstractFuture$Listener)", "com.google.common.util.concurrent.AggregateFuture.RunningState.handleOneInputDone(int,java.util.concurrent.Future)", "com.google.common.util.concurrent.TrustedListenableFutureTask.afterDone()", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.wasInterrupted()", "com.google.common.util.concurrent.AbstractFuture.clearWaiters()", "com.google.common.util.concurrent.AbstractFuture.getFutureValue(com.google.common.util.concurrent.ListenableFuture)", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.setValue()", "com.google.common.util.concurrent.AggregateFuture.afterDone()", "com.google.common.util.concurrent.AbstractFuture.completeWithFuture(com.google.common.util.concurrent.ListenableFuture,java.lang.Object)", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.runInterruptibly()", "com.google.common.util.concurrent.AbstractFuture.TrustedFuture.cancel(boolean)", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.afterRanInterruptibly(java.lang.Object,java.lang.Throwable)", "com.google.common.util.concurrent.InterruptibleTask.wasInterrupted()", "com.google.common.util.concurrent.InterruptibleTask.runInterruptibly()", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.setValue(java.lang.Object)", "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask", "com.google.common.util.concurrent.AggregateFuture.cancel(boolean)", "com.google.common.util.concurrent.AbstractFuture.setException(java.lang.Throwable)", "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask.setValue(com.google.common.util.concurrent.ListenableFuture)", "com.google.common.util.concurrent.CombinedFuture.CombinedFutureInterruptibleTask.runInterruptibly()", "com.google.common.util.concurrent.AbstractFuture.SetFuture.run()", "com.google.common.util.concurrent.AbstractFuture.complete(com.google.common.util.concurrent.AbstractFuture)", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleTask.wasInterrupted()", "com.google.common.util.concurrent.CombinedFuture.AsyncCallableInterruptibleTask.setValue()", "com.google.common.util.concurrent.AbstractFuture.complete()", "com.google.common.util.concurrent.AbstractFuture.setFuture(com.google.common.util.concurrent.ListenableFuture)", "com.google.common.util.concurrent.TrustedListenableFutureTask.TrustedFutureInterruptibleAsyncTask.runInterruptibly()", "com.google.common.util.concurrent.CombinedFuture.CallableInterruptibleTask.setValue(java.lang.Object)"]}, {"title": "X.tryParse inconsitencies", "body": "The `tryParse` methods should behave similarly: \n\n```\nDoubles.tryParse(null)  -> null\nFloats.tryParse(null)   -> null\nLongs.tryParse(null)    -> NPE\nInts.tryParse(null)     -> NPE\n```\n\nFor a method like this I would prefer the null result since otherwise I would use the Java parseInt. But if they all should throw NPE I think that should be clearer in the JavaDoc (even if you normally do not document @NotNull parameters).\n", "url": "https://github.com/google/guava/issues/2238", "user": "osundblad", "labels": ["package=primitives", "status=invalid", "type=defect"], "created": "2015-11-27 20:45:40", "closed": "2016-01-15 19:36:27", "commits": {"9b826b4b45ecca5a77e94fc82581ca0600a29aa8": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "6fef0b0dba5dfa40fe30cdd6fbcc9d3908801e23": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 48.000277777777775, "commitsDetails": [{"commitHash": "9b826b4b45ecca5a77e94fc82581ca0600a29aa8", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["3ddefd829e9fc0ed033613cd7d74427e6397c745"], "nameRev": "9b826b4b45ecca5a77e94fc82581ca0600a29aa8 tags/v20.0-rc1~571", "commitMessage": "Add tests for https://github.com/google/guava/issues/2238\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=112410294\n", "commitDateTime": "2016-01-19 11:04:48", "authoredDateTime": "2016-01-18 08:08:43", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/primitives/IntsTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-gwt/test/com/google/common/primitives/LongsTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/primitives/DoublesTest.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-tests/test/com/google/common/primitives/FloatsTest.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "guava-tests/test/com/google/common/primitives/IntsTest.java", "insertions": 9, "deletions": 0, "lines": 9}, {"filePath": "guava-tests/test/com/google/common/primitives/LongsTest.java", "insertions": 9, "deletions": 0, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "IntsTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.IntsTest_gwt.testTryParse_withNullGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LongsTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.LongsTest_gwt.testTryParse_withNullGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DoublesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.DoublesTest.testTryParse_withNullNoGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FloatsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.FloatsTest.testTryParse_withNullNoGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "IntsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.IntsTest.testTryParse_withNullGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LongsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.LongsTest.testTryParse_withNullGwt()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "6fef0b0dba5dfa40fe30cdd6fbcc9d3908801e23", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["9b826b4b45ecca5a77e94fc82581ca0600a29aa8"], "nameRev": "6fef0b0dba5dfa40fe30cdd6fbcc9d3908801e23 tags/v20.0-rc1~570", "commitMessage": "Fix the tests in primitives for tryParse not to generate their own NPEs.\n\nhttps://github.com/google/guava/issues/2238\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=112600511\n", "commitDateTime": "2016-01-20 14:38:38", "authoredDateTime": "2016-01-20 11:21:15", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/primitives/DoublesTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/primitives/FloatsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/primitives/IntsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/primitives/LongsTest.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DoublesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.DoublesTest.testTryParse_withNullNoGwt()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FloatsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.FloatsTest.testTryParse_withNullNoGwt()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "IntsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.IntsTest.testTryParse_withNullGwt()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LongsTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.primitives.LongsTest.testTryParse_withNullGwt()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["9b826b4b45ecca5a77e94fc82581ca0600a29aa8", "6fef0b0dba5dfa40fe30cdd6fbcc9d3908801e23"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Very small values breaks com.google.common.util.concurrent.RateLimiter", "body": "### Problem:\n\nVery small double values break the RateLimiter resulting in it allowing many more permits than it should. The tests below are similar to the ones in com.google.common.util.concurrent.RateLimiterTest but do not use a stopwatch. \n### Test Case 1: Create with limit of Double.MIN_VALUE\n\n```\n    RateLimiter r = RateLimiter.create(Double.MIN_VALUE);\n    assertTrue(\"Unable to acquire initial permit\", r.tryAcquire());\n    assertFalse(\"Capable of acquiring an additional permit\", r.tryAcquire());\n    Thread.sleep(5000);\n    assertFalse(\"Capable of acquiring an additional permit after sleeping\", r.tryAcquire());\n```\n\n> Fails the second assertion (\"Capable of acquiring an additional permit\")\n### Test Case 2: Create with limit of .0001\n\n```\n    RateLimiter r = RateLimiter.create(.0001);\n    assertTrue(\"Unable to acquire initial permit\", r.tryAcquire());\n    assertFalse(\"Capable of acquiring an additional permit\", r.tryAcquire());\n    Thread.sleep(5000);\n    assertFalse(\"Capable of acquiring an additional permit after sleeping\", r.tryAcquire());\n```\n\n> Succeeds\n### Test Case 3: Create with limit of 1E-13\n\n```\n    RateLimiter r = RateLimiter.create(0.0000000000001);\n    assertTrue(\"Unable to acquire initial permit\", r.tryAcquire());\n    assertFalse(\"Capable of acquiring an additional permit\", r.tryAcquire());\n    Thread.sleep(5000);\n    assertFalse(\"Capable of acquiring an additional permit after sleeping\", r.tryAcquire());\n```\n\n> Fails the second assertion (\"Capable of acquiring an additional permit\")\n", "url": "https://github.com/google/guava/issues/2231", "user": "dominicbertolino", "labels": ["package=concurrent", "type=defect"], "created": "2015-11-18 19:59:32", "closed": "2017-01-31 19:41:36", "commits": {}, "ttf": 439.0002777777778, "commitsDetails": []}, {"title": "First put is not evicted", "body": "Hi,\n\nThe following test fails on the last line.\nFirst item is not evicted.\nIt fails for version 18 and 19 rc2.\n\n```\n         Cache c = CacheBuilder.newBuilder()\n                .concurrencyLevel(4)\n                .maximumSize(1000)\n                .expireAfterAccess(10000L, TimeUnit.SECONDS)\n                .build();\n\n        for (int i = 0; i < 1000;  ++i) {\n            c.put(i, \"v\" + i);\n        }\n        assertNotNull(c.getIfPresent(0));\n        for (int i = 1000; i < 1003;  ++i) {\n            c.put(i, \"v \" + i);\n        }\n        assertNull(c.getIfPresent(1));\n        assertNull(c.getIfPresent(2));\n        c.cleanUp();\n        assertNull(\"BB \" + c.getIfPresent(0), c.getIfPresent(0));\n```\n", "url": "https://github.com/google/guava/issues/2229", "user": "yaitskov", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2015-11-16 10:41:05", "closed": "2015-11-17 18:05:07", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "why Cache.getIfPresent(Object key) is not Java Generic?", "body": "Hi folks\n\nas we can see the methods of Cache interface, most of them are generic except `getIfPresent(Object key)`:\n\n``` java\npublic interface Cache<K, V> {\n...\n  @Nullable\n  V getIfPresent(Object key);\n\n  V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;\n...\n  void put(K key, V value);\n...\n```\n\nis it intended? why not `V getIfPresent(K key)` to be consistent?\n\nthanks\n", "url": "https://github.com/google/guava/issues/2227", "user": "missedone", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2015-11-16 06:11:31", "closed": "2015-11-16 19:55:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ContiguousSet.intersection doesn't handle singleton results.", "body": "Let a < x < b:\n- [x].intersection([x]) should return [x], returns [],\n- [x].intersection([a..b]) should return [x], returns [],\n- [a..b].intersection([x]) should return [x], returns [],\n- [a..x].intersection([x..b]) should return [x], returns [].\n\nI'll create a PR in a minute.\n", "url": "https://github.com/google/guava/issues/2196", "user": "perceptron8", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2015-10-21 15:21:57", "closed": "2015-10-23 16:52:48", "commits": {"44a2592b04490ad26d2bc874f9dbd4c1146cc5de": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "44a2592b04490ad26d2bc874f9dbd4c1146cc5de", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["c071822d399b5c0e066790067d575c6a56740762"], "nameRev": "44a2592b04490ad26d2bc874f9dbd4c1146cc5de tags/v20.0-rc1~714", "commitMessage": "Fix RegularContiguousSet.intersection to handle singleton results.\n\nPull request from perceptron8 <perceptron8@gmail.com>\nhttps://github.com/google/guava/pull/2197\n\nFixes https://github.com/google/guava/issues/2196\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=106153276\n", "commitDateTime": "2015-10-23 12:52:39", "authoredDateTime": "2015-10-23 09:28:10", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/collect/ContiguousSetTest.java", "insertions": 37, "deletions": 29, "lines": 66}, {"filePath": "guava/src/com/google/common/collect/RegularContiguousSet.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ContiguousSetTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ContiguousSetTest.testHeadSet()", "TOT": 6, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.ContiguousSetTest.testTailSet()", "TOT": 6, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.ContiguousSetTest.testSubSet()", "TOT": 12, "UPD": 4, "INS": 4, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.ContiguousSetTest.testIntersection()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.ContiguousSetTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "RegularContiguousSet.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.RegularContiguousSet.intersection(com.google.common.collect.ContiguousSet)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["44a2592b04490ad26d2bc874f9dbd4c1146cc5de"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": ["com.google.common.collect.RegularContiguousSet.intersection(com.google.common.collect.ContiguousSet)"]}, {"title": "19rc2 regression: Using ImmutableMutlimap and annotation processors fails compile on jdk6", "body": "The following test case fails on jdk6u45 (trigger a jdk6 bug probably fixed in jdk7). It happens as soon as an annotation processor is present in the classpath (not only auto-value).\n\n``` java\npackage test;\nimport com.google.common.collect.ImmutableMultimap;\npublic final class Test {{\n    ImmutableMultimap.class.toString();\n}}\n```\n\n``` xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>guava-19rc2-regression</groupId>\n    <artifactId>immutablemultimap</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <dependencies>\n        <dependency>\n            <groupId>com.google.guava</groupId>\n            <artifactId>guava</artifactId>\n            <version>19.0-rc2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.auto.value</groupId>\n            <artifactId>auto-value</artifactId>\n            <version>1.1</version>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.6</source>\n                        <target>1.6</target>\n                        <compilerArgs combine.self=\"append\">\n                            <arg>-verbose</arg>\n                        </compilerArgs>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n    </build>\n</project>\n```\n", "url": "https://github.com/google/guava/issues/2173", "user": "jbgi", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2015-09-29 13:07:53", "closed": "2015-09-29 16:26:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Serialized instances of ArrayListMultimap under guava 18 cannot be deserialized under version 19", "body": "More information and code here:\nhttps://github.com/martinm1000/g18vs19\n", "url": "https://github.com/google/guava/issues/2168", "user": "martinm1000", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2015-09-21 15:35:33", "closed": "2015-09-21 15:39:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ClassPath.getTopLevelClasses() returns empty list.", "body": "**Summary**\nClassPath.getTopLevelClasses() returns empty list when the path of the classloader contains special characters.\n\n**How to reproduce this error**\n1. Create a packeage with three classes\n2. Create the following unit test\n\n``` java\n    @Test\n    public void testMain() throws Exception {\n        ClassLoader loader = this.getClass().getClassLoader();\n        ClassPath p = ClassPath.from(loader);\n        ImmutableSet<ClassPath.ClassInfo> list = p.getTopLevelClasses(\"testpackage\");\n        Assert.assertEquals(3, list.size());\n    }\n```\n1. Copy the whole project to a folder with special characters in its name (like % for example) and execute it.\n2. The test will fail. If you copy the project to a folder without special characters in its path the test will pass.\n", "url": "https://github.com/google/guava/issues/2152", "user": "jcoeltjen", "labels": ["package=reflect", "status=triaged", "type=defect"], "created": "2015-09-10 10:12:07", "closed": "2017-01-30 22:46:31", "commits": {"896c51abd32e136621c13d56b6130d0a72f4957a": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 508.0002777777778, "commitsDetails": [{"commitHash": "896c51abd32e136621c13d56b6130d0a72f4957a", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["65ffec58dcbb7547109896d5d96ae0581dca4cc8"], "nameRev": "896c51abd32e136621c13d56b6130d0a72f4957a tags/v22.0-rc1~184", "commitMessage": "To fix external bug https://github.com/google/guava/issues/2152.\n\nThis code follows the article emcmanus mentioned:\nhttps://community.oracle.com/blogs/kohsuke/2007/04/25/how-convert-javaneturl-javaiofile\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=144362958\n", "commitDateTime": "2017-01-12 13:50:02", "authoredDateTime": "2017-01-12 13:19:22", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/reflect/ClassPathTest.java", "insertions": 92, "deletions": 20, "lines": 112}, {"filePath": "guava/src/com/google/common/reflect/ClassPath.java", "insertions": 15, "deletions": 2, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ClassPathTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_URLClassLoader_noParent()", "TOT": 7, "UPD": 1, "INS": 0, "MOV": 6, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_duplicateUri_parentWins()", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_notURLClassLoader_noParent()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_notURLClassLoader_withParent()", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_notURLClassLoader_withParentAndGrandParent()", "TOT": 7, "UPD": 1, "INS": 0, "MOV": 6, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_notURLClassLoader_withGrandParent()", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_URLClassLoader_withParent()", "TOT": 31, "UPD": 11, "INS": 1, "MOV": 18, "DEL": 1}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testScan_classPathCycle()", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_URLClassLoader_pathWithSpace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testClassPathEntries_URLClassLoader_pathWithEscapedSpace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testToFile()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testToFile_AndroidIncompatible()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.testJarFileWithSpaces()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.makeJarUrlWithName(java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.reflect.ClassPathTest.JarFileFinder", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ClassPath.java", "spoonMethods": [{"spoonMethodName": "com.google.common.reflect.ClassPath.Scanner.getClassPathFromManifest(java.io.File,java.util.jar.Manifest)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.reflect.ClassPath.Scanner.getClassPathEntries(java.lang.ClassLoader)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.reflect.ClassPath.toFile(java.net.URL)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["896c51abd32e136621c13d56b6130d0a72f4957a"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 15, "deletions": 2, "lines": 17, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/reflect"], "changesInPackagesSPOON": ["com.google.common.reflect.ClassPath.toFile(java.net.URL)", "com.google.common.reflect.ClassPath.Scanner.getClassPathFromManifest(java.io.File,java.util.jar.Manifest)", "com.google.common.reflect.ClassPath.Scanner.getClassPathEntries(java.lang.ClassLoader)"]}, {"title": "ImmutableSet is not producing consistent hash while using HashFunction", "body": "`com.google.common.collect.ImmutableSet` is not producing consistent hash while using `com.google.common.hash.HashFunction`. If we wrap `HashSet` with `ImmutableSet` it works.\nPlease refer to `HashFunctionTest` below:\n\n```\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.common.hash.Hashing;\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class HashFunctionTest {\n\n    private HashFunction hashFunction;\n\n    @Before\n    public void setUp() throws Exception {\n        hashFunction = Hashing.goodFastHash(128);\n    }\n\n    @Test // failed\n    public void testImmutableSet() throws Exception {\n        ImmutableSet<Integer> set1 = ImmutableSet.of(1, 2);\n        ImmutableSet<Integer> set2 = ImmutableSet.of(2, 1);\n        assertEquals(set1, set2);\n\n        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));\n        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));\n        assertEquals(hash1, hash2);\n    }\n\n\n    @Test // failed\n    public void testImmutableSetBuilder() throws Exception {\n        ImmutableSet.Builder<Integer> builder1 = ImmutableSet.builder();\n        builder1.add(1);\n        builder1.add(2);\n\n        ImmutableSet.Builder<Integer> builder2 = ImmutableSet.builder();\n        builder2.add(2);\n        builder2.add(1);\n\n        ImmutableSet<Integer> set1 = builder1.build();\n        ImmutableSet<Integer> set2 = builder2.build();\n        assertEquals(set1, set2);\n\n        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));\n        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));\n        assertEquals(hash1, hash2);\n    }\n\n    @Test // passed\n    public void testSet() throws Exception {\n        HashSet<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        HashSet<Integer> set2 = new HashSet<>();\n        set2.add(2);\n        set2.add(1);\n        assertEquals(set1, set2);\n\n        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));\n        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));\n        assertEquals(hash1, hash2);\n    }\n\n    @Test // passed\n    public void testSetAndImmutableSet() throws Exception {\n        HashSet<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        HashSet<Integer> set2 = new HashSet<>();\n        set2.add(2);\n        set2.add(1);\n        assertEquals(set1, set2);\n\n        ImmutableSet<Integer> immutableSet1 = ImmutableSet.copyOf(set1);\n        ImmutableSet<Integer> immutableSet2 = ImmutableSet.copyOf(set2);\n\n        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));\n        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));\n        assertEquals(hash1, hash2);\n    }\n\n    @Test // passed\n    public void testSetAndImmutableSetBuilder() throws Exception {\n        HashSet<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        HashSet<Integer> set2 = new HashSet<>();\n        set2.add(2);\n        set2.add(1);\n        assertEquals(set1, set2);\n\n        ImmutableSet<Integer> immutableSet1 = ImmutableSet.<Integer>builder().addAll(set1).build();\n        ImmutableSet<Integer> immutableSet2 = ImmutableSet.<Integer>builder().addAll(set2).build();\n\n        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));\n        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));\n        assertEquals(hash1, hash2);\n    }\n}\n```\n", "url": "https://github.com/google/guava/issues/2151", "user": "bbednarek", "labels": ["package=collect", "package=hash", "status=working-as-intended", "type=defect"], "created": "2015-09-09 01:20:53", "closed": "2015-09-09 01:59:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "GWT can't compile ImmutableMap in 19.0-rc1", "body": "My project is using GWT 2.7.0 and Guava 18.0. When switching from 18.0 to 19.0-rc1 and making no other changes, I get the following error during GWT compilation:\n\n```\n   Tracing compile failure path for type 'com.google.common.collect.ImmutableMapEntrySet'\n      [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMapEntrySet.java'\n         [ERROR] Line 35: Weak cannot be resolved to a type\n         [ERROR] Line 20: The import com.google.j2objc cannot be resolved\n   [ERROR] Hint: Check that the type name 'com.google.common.collect.ImmutableMapEntrySet' is really what you meant\n   [ERROR] Hint: Check that your classpath includes all required source roots\n```\n", "url": "https://github.com/google/guava/issues/2142", "user": "ekuefler", "labels": ["package=collect", "platform=gwt", "status=invalid", "type=defect"], "created": "2015-08-26 07:14:53", "closed": "2015-09-18 20:20:20", "commits": {}, "ttf": 23.00027777777778, "commitsDetails": []}, {"title": "19rc1 regression in sliced bytesource: offset + length may overflow for large length values", "body": "An algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \nThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\n\nI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\n", "url": "https://github.com/google/guava/issues/2127", "user": "jbgi", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2015-08-11 09:00:32", "closed": "2015-08-12 18:03:26", "commits": {"0f4bd484fc6e1b779da9a4178c336f278e81d746": {"commitGHEventType": "closed", "commitUser": "cgdecker"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "0f4bd484fc6e1b779da9a4178c336f278e81d746", "commitGHEventType": "closed", "commitUser": "cgdecker", "commitParents": ["cadd7237e484818b55be97883cc5d83f0f0bd6a7"], "nameRev": "0f4bd484fc6e1b779da9a4178c336f278e81d746 tags/v19.0-rc2~4^2~28", "commitMessage": "Fix ByteArrayByteSource.slice to handle the case where offset + length > Long.MAX_VALUE.\n\nFixes https://github.com/google/guava/issues/2127\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=100485800\n", "commitDateTime": "2015-08-12 13:18:02", "authoredDateTime": "2015-05-07 10:02:32", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/io/ByteSourceTester.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "guava/src/com/google/common/io/ByteSource.java", "insertions": 4, "deletions": 3, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ByteSourceTester.java", "spoonMethods": [{"spoonMethodName": "com.google.common.io.ByteSourceTester.testSlice_longMaxValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ByteSource.java", "spoonMethods": [{"spoonMethodName": "com.google.common.io.ByteSource.ByteArrayByteSource.slice(long,long)", "TOT": 11, "UPD": 1, "INS": 3, "MOV": 5, "DEL": 2}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0f4bd484fc6e1b779da9a4178c336f278e81d746"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 3, "lines": 7, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 11, "UPD": 1, "INS": 3, "MOV": 5, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/io"], "changesInPackagesSPOON": ["com.google.common.io.ByteSource.ByteArrayByteSource.slice(long,long)"]}, {"title": "java.lang.NoSuchMethodError: com.google.common.util.concurrent.Futures.withFallback", "body": "![jar](https://cloud.githubusercontent.com/assets/7439619/8873965/a6db4cee-3229-11e5-9d75-20f2c128e269.png)\nI am using Guava v 17.0 dependency in Maven and Cassandra connection is established successfully.\nBut when I run same JAR on Hadoop 2.0.0-CDH4.3.1, It throws me error \n\njava.lang.NoSuchMethodError: com.google.common.util.concurrent.Futures.withFallback(Lcom/google/common/util/concurrent/ListenableFuture;Lcom/google/common/util/concurrent/FutureFallback;Ljava/util/concurrent/Executor;)Lcom/google/common/util/concurrent/ListenableFuture;\n\nWhen I look at the Guava v17.0 JAR I cant find Futures.withFallback static method. \nIs it related to Hadoop's version compatibility with Guava as Cassandra got connected when not running on Hadoop.\n", "url": "https://github.com/google/guava/issues/2116", "user": "umesh9794", "labels": ["status=invalid", "type=defect"], "created": "2015-07-24 11:55:19", "closed": "2015-07-30 18:14:41", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "Cache.asMap().size() may return a negative value", "body": "My multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\n\n``` java\n(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\n(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\n(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\n```\n\nThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\n\n```\njava.lang.NegativeArraySizeException\nat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\nat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\nat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\nat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat java.lang.Thread.run(Thread.java:745)\n```\n", "url": "https://github.com/google/guava/issues/2108", "user": "ben-manes", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2015-07-15 07:40:36", "closed": "2015-07-30 19:49:13", "commits": {"648c0fe661f328a2cb1785c85e70d9e4fbdf01ba": {"commitGHEventType": "referenced", "commitUser": "lowasser"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "648c0fe661f328a2cb1785c85e70d9e4fbdf01ba", "commitGHEventType": "referenced", "commitUser": "lowasser", "commitParents": ["f49015a77c5eb39587687a6c529280fecd33ceef"], "nameRev": "648c0fe661f328a2cb1785c85e70d9e4fbdf01ba tags/v19.0-rc2~4^2~58", "commitMessage": "Noninvasive patch for negative results from size().  See https://github.com/google/guava/issues/2108 for more details.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=99503151\n", "commitDateTime": "2015-08-03 15:34:18", "authoredDateTime": "2015-07-30 12:41:37", "commitGitStats": [{"filePath": "guava/src/com/google/common/cache/LocalCache.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "LocalCache.java", "spoonMethods": [{"spoonMethodName": "com.google.common.cache.LocalCache.longSize()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["648c0fe661f328a2cb1785c85e70d9e4fbdf01ba"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/cache"], "changesInPackagesSPOON": ["com.google.common.cache.LocalCache.longSize()"]}, {"title": "Documentation: Broken link", "body": "https://github.com/google/guava/wiki/ImmutableCollectionsExplained#why refers to https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures (link text: analysis), which doen't exist anymore.\n\nThe old equivalent https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why? also points to that same broken link.\n", "url": "https://github.com/google/guava/issues/2104", "user": "JensRantil", "labels": ["package=general", "status=fixed", "type=defect", "type=documentation"], "created": "2015-07-13 11:46:09", "closed": "2015-09-18 20:19:06", "commits": {}, "ttf": 67.00027777777778, "commitsDetails": []}, {"title": "Wrong RemovalCause published on cache.invaldateAll()", "body": "When the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\n\nDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\n\n> The key and/or value may be null if they were already garbage collected.\n\nTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\n\n``` java\n@Test\npublic void clear_expireAfterAccess() {\n  FakeTicker ticker = new FakeTicker();\n  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\n  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\n      ArgumentCaptor.forClass(RemovalNotification.class);\n  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.MINUTES)\n      .removalListener(listener)\n      .ticker(ticker)\n      .build();\n  cache.put(1, 1);\n  ticker.advance(10, TimeUnit.MINUTES);\n  cache.invalidateAll();\n\n  verify(listener).onRemoval(captor.capture());\n  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\n}\n```\n\nThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \n\nUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\n", "url": "https://github.com/google/guava/issues/2101", "user": "ben-manes", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2015-07-08 08:04:36", "closed": "2015-11-30 22:26:14", "commits": {"0a686a644ca5cefb9e7bf4a38b34bf4ede9e75aa": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 145.00027777777777, "commitsDetails": [{"commitHash": "0a686a644ca5cefb9e7bf4a38b34bf4ede9e75aa", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["69a42c5e6fcdba03e1445a8eb9acad7177c6a714"], "nameRev": "0a686a644ca5cefb9e7bf4a38b34bf4ede9e75aa tags/v20.0-rc1~656", "commitMessage": "Ensure the correct removal notification is published.\n\nFixes #2101.\n\nPull request #2122.\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=109009756\n", "commitDateTime": "2015-11-30 17:14:11", "authoredDateTime": "2015-11-30 13:30:59", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/cache/CacheExpirationTest.java", "insertions": 18, "deletions": 0, "lines": 18}, {"filePath": "guava/src/com/google/common/cache/LocalCache.java", "insertions": 43, "deletions": 34, "lines": 77}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CacheExpirationTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.cache.CacheExpirationTest.testExpiration_invalidateAll()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LocalCache.java", "spoonMethods": [{"spoonMethodName": "com.google.common.cache.LocalCache.Segment.enqueueNotification(java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference,com.google.common.cache.RemovalCause)", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.storeLoadedValue(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,java.lang.Object)", "TOT": 6, "UPD": 1, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.put(java.lang.Object,int,java.lang.Object,boolean)", "TOT": 4, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.loadAsync(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.cache.CacheLoader).1.run()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.enqueueNotification(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.RemovalCause)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 1}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.removeCollectedEntry(com.google.common.cache.LocalCache$ReferenceEntry)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.enqueueNotification(java.lang.Object,int,java.lang.Object,int,com.google.common.cache.RemovalCause)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.removeValueFromChain(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,int,java.lang.Object,com.google.common.cache.LocalCache$ValueReference,com.google.common.cache.RemovalCause)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.removeEntry(com.google.common.cache.LocalCache$ReferenceEntry,int,com.google.common.cache.RemovalCause)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.clear()", "TOT": 12, "UPD": 0, "INS": 10, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.replace(java.lang.Object,int,java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.remove(java.lang.Object,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.remove(java.lang.Object,int,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.reclaimKey(com.google.common.cache.LocalCache$ReferenceEntry,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.replace(java.lang.Object,int,java.lang.Object,java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.reclaimValue(java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.lockedGetOrLoad(java.lang.Object,int,com.google.common.cache.CacheLoader)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.cache.LocalCache.Segment.removeValueFromChain(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference,com.google.common.cache.RemovalCause)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "EventBus.handleException() fails to log exception thrown", "body": "In Guava 18.0, `EventBus.handleException()` incorrectly logs `exception.getCause()` instead of the underlying `exception`:\n\n```\n  logger.log(Level.SEVERE, \"Could not dispatch event: \" \n      + context.getSubscriber() + \" to \" + context.getSubscriberMethod(),\n      exception.getCause());\n```\n\nThis means any `@Subscribe` method which throws an exception fails to log the most important information of all: the actual exception thrown. (If the exception happened to be wrapping another exception, Guava will log the wrapped exception, but that's usually not the case.)\n\nI believe this should be:\n\n```\n  logger.log(Level.SEVERE, \"Could not dispatch event: \" \n      + context.getSubscriber() + \" to \" + context.getSubscriberMethod(),\n      exception);\n```\n\nTo reproduce, try the following. I would expect the log message to include `This message should appear in the logs`, but it doesn't.\n\n```\n% cat GuavaBug.java \nimport com.google.common.eventbus.EventBus;\nimport com.google.common.eventbus.Subscribe;\n\npublic class GuavaBug {\n  private static class Event { }\n\n  @Subscribe\n  public void handleEvent(Event event) {\n    throw new RuntimeException(\"This message should appear in the logs\");\n  }\n\n  public static void main(String[] args) {\n    EventBus eventBus = new EventBus();\n    GuavaBug guavaBug = new GuavaBug();\n    eventBus.register(guavaBug);\n    eventBus.post(new Event());\n  }\n}\n\n% javac -cp guava-18.0.jar GuavaBug.java\n% java -cp guava-18.0.jar:. GuavaBug\nJun 24, 2015 2:30:42 PM com.google.common.eventbus.EventBus$LoggingSubscriberExceptionHandler handleException\nSEVERE: Could not dispatch event: GuavaBug@7de26db8 to public void GuavaBug.handleEvent(GuavaBug$Event)\n```\n", "url": "https://github.com/google/guava/issues/2093", "user": "bhamiltoncx", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2015-06-24 21:32:01", "closed": "2015-09-25 20:24:27", "commits": {}, "ttf": 92.00027777777778, "commitsDetails": []}, {"title": "Guava-testlib 18 uses Truth APIs that are deleted in 0.25+ releases of Truth", "body": "Guava 18 uses Truth, but truth is not API stable, so using it in an intermediary library like Guava-testlib is problematic - it forces that fragility onto non-guava consumers of our testlibs.\n\nFor Guava 19, we should remove use of Truth within the testlib, since it's a convenience for us, but only marginally helpful to users of guava-testlib.\n\nFor Guava 18, it is broken for anyone who attempts to upgrade to a version of Truth past 0.24. We should consider rolling an 18.0.1 of guava-testlib to rectify this, so that existing users are not hampered.\n", "url": "https://github.com/google/guava/issues/2073", "user": "cgruber", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2015-06-09 22:14:57", "closed": "2015-06-23 04:39:23", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "Deadlock when stopping an AbstractScheduledService and Exception thrown from CustomScheduler.getNextSchedule()", "body": "(Source attached below which demonstrates the issue).\nI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \nThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\n\nI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\n\n``` java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\n        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\n        System.out.println(\"starting service\");\n        service.startAsync();\n        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\n        System.out.println(\"Stopping service\");\n        service.stopAsync();\n        System.out.println(\"Bye\");\n      }\n}\n```\n\n``` java\npublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\n    private long blockTime;\n\n    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\n        this.blockTime = blockTime;\n    }\n\n    @Override\n    protected void runOneIteration() throws Exception {\n        System.out.println(\"runOneIteration()\");\n    }\n\n    @Override\n    protected Scheduler scheduler() {\n        return new CustomScheduler() {\n            @Override\n            protected Schedule getNextSchedule() throws Exception {\n                System.out.println(\"getNextSchedule()...\");\n                Thread.sleep(blockTime);\n                if (state() == State.STOPPING) {\n                    System.out.println(\"getNextSchedule() - not running anymore so don't return scheduler\");\n                    throw new Exception(\"not running anymore so don't return scheduler\");\n                }\n                System.out.println(\"...getNextSchedule()\");\n                return new Schedule(0, TimeUnit.NANOSECONDS);\n            }\n        };\n    }\n\n    @Override\n    protected void startUp() throws Exception {\n        System.out.println(\"startUp()\");\n    }\n\n    @Override\n    protected void shutDown() throws Exception {\n        System.out.println(\"shutDown()\");\n    }\n}\n```\n\n``` java\npublic class ServiceStateMonitor {\n    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\n        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\n    }\n\n    private class PrintOutNewStateServiceListener extends Service.Listener {\n        @Override\n        public void starting() {\n            System.out.println(\"SERVICE LISTENER : Starting\");\n        }\n\n        @Override\n        public void running() {\n            System.out.println(\"SERVICE LISTENER : Running\");\n        }\n\n        @Override\n        public void stopping(final Service.State from) {\n            System.out.println(\"SERVICE LISTENER : Stopping\");\n        }\n\n        @Override\n        public void terminated(final Service.State from) {\n            System.out.println(\"SERVICE LISTENER : Terminated\");\n        }\n\n        @Override\n        public void failed(final Service.State from, final Throwable failure) {\n            System.out.println(\"SERVICE LISTENER : Failed\");\n        }\n    }\n}\n```\n\nThe Standard Ouput from running the main()\n\n```\nstarting service\nSERVICE LISTENER : Starting\nstartUp()\ngetNextSchedule()...\n...getNextSchedule()\nSERVICE LISTENER : Running\nrunOneIteration()\ngetNextSchedule()...\nStopping service\ngetNextSchedule() - not running anymore so don't return scheduler\n```\n\nnotice that there is no \"shutDown()\" or \"Bye\" output line.\n", "url": "https://github.com/google/guava/issues/2072", "user": "stevo58008", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2015-06-09 13:52:31", "closed": "2015-06-16 19:44:59", "commits": {"6315a434ab54c804c0a9d89434f14803ace52b64": {"commitGHEventType": "referenced", "commitUser": "lukesandberg"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "6315a434ab54c804c0a9d89434f14803ace52b64", "commitGHEventType": "referenced", "commitUser": "lukesandberg", "commitParents": ["a6ce7b511bff96f39c56e598143557dcff08db86"], "nameRev": "6315a434ab54c804c0a9d89434f14803ace52b64 tags/v19.0-rc1~45", "commitMessage": "Fix a lock ordering deadlock in CustomScheduler reported in https://github.com/google/guava/issues/2072\n\nThe issue is that CustomScheduler uses a lock to atomically reschedule after each iteration, unfortunately this lock has inconsistent ordering with respect to the lock used by AbstractService.  In particular for a RUNNING service the following can ocurr\n\nT1:\nservice.stopAsync()\n  -> AbstractService.stopAsync() [ ACQUIRE AbstractService.monitor]\n     -> AbstractService.doStop()\n        -> CustomScheduler.cancel() [ ACQUIRE CustomScheduler.lock]\n\nT2:\nCustomScheduler.reschedule() [ ACQUIRE CustomScheduler.lock]\n   (getNextSchedule throws an exception)\n  -> AbstractService.notifyFailed [ACQUIRE AbstractService.monitor]\n\nBoom deadlock!\n\nIt looks like i introduced this deadlock in https://github.com/google/guava/commit/2c0727049d7e7cbbe1febf5bcf6b7a4b1860dea5 though it is possible it wasn't an issue at the time since the AbstractService implementation was different\n\nThe fix was to simply move the call to notifyFailed outside the lock.\n\nI have similar concerns about the other lock in this class, but i believe it actually is safe (though we should probably remove it anyway, as per an ancient TODO)\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=96113737\n", "commitDateTime": "2015-06-16 13:44:08", "authoredDateTime": "2015-06-16 09:20:29", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "guava/src/com/google/common/util/concurrent/AbstractScheduledService.java", "insertions": 18, "deletions": 3, "lines": 21}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractScheduledServiceTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractScheduledServiceTest.SchedulerTest.testBig()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractScheduledServiceTest.SchedulerTest.testBig().7", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractScheduledServiceTest.SchedulerTest.testBig().7.scheduler()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.AbstractScheduledServiceTest.SchedulerTest.testCustomScheduler_deadlock()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractScheduledService.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.ReschedulableCallable.reschedule()", "TOT": 9, "UPD": 0, "INS": 5, "MOV": 2, "DEL": 2}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6315a434ab54c804c0a9d89434f14803ace52b64"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 18, "deletions": 3, "lines": 21, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 9, "UPD": 0, "INS": 5, "MOV": 2, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/util/concurrent"], "changesInPackagesSPOON": ["com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.ReschedulableCallable.reschedule()"]}, {"title": "ImmutableSortedMultiset::naturalOrder has wrong generic type", "body": "Please fix the `ImmutableSortedMultiset::naturalOrder` generic type so that classes that are subclasses of classes implementing `Comparable` can be used.\n\nHere is a snippet showing the issue:\n\n```\npublic class ImmutableSortedCollectionsComparison {\n  public static void main(String[] args) {\n    ImmutableSortedSet     <MySubComparable> sortedSet      = ImmutableSortedSet     .<MySubComparable>naturalOrder().build();\n    ImmutableSortedMultiset<MySubComparable> sortedMultiset = ImmutableSortedMultiset.<MySubComparable>naturalOrder().build();\n  }\n}\nclass MyComparable implements Comparable<MyComparable> {\n  @Override public int compareTo(MyComparable o) { return 1; }\n}\nclass MySubComparable extends MyComparable { }\n```\n\nThe line of the `ImmutableSortedSet` will compile nicely, but the one of the `ImmutableSortedMultiset` won't.\n\nHere's the faulty signature of `ImmutableSortedMultiset::naturalOrder`:\n\n```\npublic static <E extends Comparable<E>> ImmutableSortedMultiset.Builder<E> naturalOrder()\n```\n\nAnd here is the expected signature:\n\n```\npublic static <E extends Comparable<?>> ImmutableSortedMultiset.Builder<E> naturalOrder()\n```\n\nWhich will then be similar to the working `ImmutableSortedSet::naturalOrder`:\n\n```\npublic static <E extends Comparable<?>> ImmutableSortedSet.Builder<E> naturalOrder()\n```\n", "url": "https://github.com/google/guava/issues/2016", "user": "ogregoire", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2015-03-27 13:35:52", "closed": "2015-07-30 19:10:05", "commits": {}, "ttf": 125.00027777777778, "commitsDetails": []}, {"title": "Iterators.concat is not gc friendly", "body": "I ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\n\n(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\n\nHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\n", "url": "https://github.com/google/guava/issues/2008", "user": "devinrsmith", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2015-03-19 22:53:23", "closed": "2015-04-07 17:54:59", "commits": {"5394f635d552aae319c5a58d6a9a332ccbcd0dd8": {"commitGHEventType": "referenced", "commitUser": "lowasser"}}, "ttf": 18.00027777777778, "commitsDetails": [{"commitHash": "5394f635d552aae319c5a58d6a9a332ccbcd0dd8", "commitGHEventType": "referenced", "commitUser": "lowasser", "commitParents": ["156e3b8926e89f21086bb38961dff121d55f1470"], "nameRev": "5394f635d552aae319c5a58d6a9a332ccbcd0dd8 tags/v19.0-rc1~154", "commitMessage": "Address https://github.com/google/guava/issues/2008 by discarding references to iterators in Iterators.concat after they have been iterated over.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=90525172\n", "commitDateTime": "2015-04-14 16:28:40", "authoredDateTime": "2015-04-07 10:51:26", "commitGitStats": [{"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java", "insertions": 0, "deletions": 16, "lines": 16}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java", "insertions": 16, "deletions": 4, "lines": 20}, {"filePath": "guava/src/com/google/common/collect/ConsumingQueueIterator.java", "insertions": 46, "deletions": 0, "lines": 46}, {"filePath": "guava/src/com/google/common/collect/Iterables.java", "insertions": 0, "deletions": 16, "lines": 16}, {"filePath": "guava/src/com/google/common/collect/Iterators.java", "insertions": 16, "deletions": 4, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Iterables.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.Iterables.consumingIterable(java.lang.Iterable).12.iterator()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.Iterables.ConsumingQueueIterator", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "Iterators.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator,java.util.Iterator)", "TOT": 5, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator,java.util.Iterator,java.util.Iterator)", "TOT": 6, "UPD": 0, "INS": 5, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.Iterators.concat(java.util.Iterator[])", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "ConsumingQueueIterator.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ConsumingQueueIterator", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5394f635d552aae319c5a58d6a9a332ccbcd0dd8"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 78, "deletions": 40, "lines": 118, "gitFilesChange": 5}, "spoonStatsSummary": {"TOT": 21, "UPD": 1, "INS": 15, "MOV": 0, "DEL": 5, "spoonFilesChanged": 3, "spoonMethodsChanged": 7}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect", "guava-gwt/src-super/com/google/common/collect/super/com/google/common"], "changesInPackagesSPOON": ["com.google.common.collect.Iterators.concat(java.util.Iterator[])", "com.google.common.collect.Iterables.ConsumingQueueIterator", "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator,java.util.Iterator)", "com.google.common.collect.ConsumingQueueIterator", "com.google.common.collect.Iterables.consumingIterable(java.lang.Iterable).12.iterator()", "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator)", "com.google.common.collect.Iterators.concat(java.util.Iterator,java.util.Iterator,java.util.Iterator,java.util.Iterator)"]}, {"title": "New ClassPathTest methods fail in open-source build", "body": "Is this #1926 again? @cgdecker @fluentfuture @lukesandberg \n\nI won't paste the full failure log, but:\n\n```\ntestGetAllClasses(com.google.common.reflect.ClassPathTest): Not true that <[com.google.common.reflect.TypeToken$TypeSet, com.google.common.reflect.ClassPath$ResourceInfo, com.google.common.reflect.Types$ParameterizedTypeImpl, com.google.common.reflect.TypeToken$TypeCollector, com.google.common.reflect.TypeResolver$1, com.google.common.reflect.Types$TypeVariableInvocationHandler, com.google.common.reflect.Types$GenericArrayTypeImpl, com.google.common.reflect.Invokable$ConstructorInvokable, com.google.common.reflect.Invokable, com.google.common.reflect.ClassPath, com.google.common.reflect.Types$ClassOwnership$1, com.google.common.reflect.TypeToken$TypeFilter$1, com.google.common.reflect.TypeToken$TypeFilter$2, com.google.common.reflect.Types$ClassOwnership$3, com.google.common.reflect.ImmutableTypeToInstanceMap$1, com.google.common.reflect.Types$ClassOwnership$2, com.google.common.reflect.ImmutableTypeToInstanceMap$Builder, com.google.common.reflect.ClassPath$Scanner, com.google.common.reflect.TypeToken$InterfaceSet, com.google.common.reflect.TypeToken$SimpleTypeToken, com.google.common.reflect.TypeToken$ClassSet, com.google.common.reflect.Types$JavaVersion$2, com.google.common.reflect.TypeResolver$WildcardCapturer, com.google.common.reflect.Types$JavaVersion$1, com.google.common.reflect.Reflection, com.google.common.reflect.MutableTypeToInstanceMap$1, com.google.common.reflect.Types$JavaVersion$4, com.google.common.reflect.TypeToken$InterfaceSet$1, com.google.common.reflect.Types$JavaVersion$3, com.google.common.reflect.TypeToInstanceMap, com.google.common.reflect.AbstractInvocationHandler, com.google.common.reflect.Types, com.google.common.reflect.TypeResolver$TypeTable, com.google.common.reflect.MutableTypeToInstanceMap, com.google.common.reflect.Parameter, com.google.common.reflect.ClassPath$1, com.google.common.reflect.TypeToken$TypeFilter, com.google.common.reflect.TypeToken, com.google.common.reflect.Types$ClassOwnership, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$2, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$1, com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector, com.google.common.reflect.TypeToken$Bounds, com.google.common.reflect.ClassPath$ClassInfo, com.google.common.reflect.Invokable$MethodInvokable, com.google.common.reflect.package-info, com.google.common.reflect.Element, com.google.common.reflect.Types$TypeVariableImpl, com.google.common.reflect.TypeResolver$TypeTable$1, com.google.common.reflect.Types$NativeTypeVariableEquals, com.google.common.reflect.TypeVisitor, com.google.common.reflect.TypeCapture, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry, com.google.common.reflect.TypeToken$3, com.google.common.reflect.TypeToken$4, com.google.common.reflect.TypeToken$1, com.google.common.reflect.Types$WildcardTypeImpl, com.google.common.reflect.TypeToken$2, com.google.common.reflect.TypeParameter, com.google.common.reflect.ImmutableTypeToInstanceMap, com.google.common.reflect.Types$JavaVersion, com.google.common.reflect.TypeResolver, com.google.common.reflect.TypeToken$TypeCollector$1, com.google.common.reflect.Types$2, com.google.common.reflect.Types$1, com.google.common.reflect.Types$ClassOwnership$1LocalClass, com.google.common.reflect.TypeResolver$TypeMappingIntrospector, com.google.common.reflect.TypeToken$TypeCollector$2, com.google.common.reflect.TypeToken$TypeCollector$3, com.google.common.reflect.TypeToken$TypeCollector$4, com.google.common.reflect.TypeResolver$TypeVariableKey]> contains all of <[com.google.common.reflect.ClassPathTest$1, com.google.common.reflect.ClassPathTest$1LocalClass, com.google.common.reflect.ClassPath, com.google.common.reflect.ClassPathTest]>. It is missing <[com.google.common.reflect.ClassPathTest$1, com.google.common.reflect.ClassPathTest$1LocalClass, com.google.common.reflect.ClassPathTest]>\ntestGetTopLevelClasses(com.google.common.reflect.ClassPathTest): Not true that <[com.google.common.reflect.ImmutableTypeToInstanceMap, com.google.common.reflect.TypeParameter, com.google.common.reflect.TypeResolver, com.google.common.reflect.Reflection, com.google.common.reflect.package-info, com.google.common.reflect.Element, com.google.common.reflect.TypeVisitor, com.google.common.reflect.TypeCapture, com.google.common.reflect.TypeToInstanceMap, com.google.common.reflect.AbstractInvocationHandler, com.google.common.reflect.Types, com.google.common.reflect.Invokable, com.google.common.reflect.MutableTypeToInstanceMap, com.google.common.reflect.ClassPath, com.google.common.reflect.Parameter, com.google.common.reflect.TypeToken]> contains all of <[com.google.common.reflect.ClassPath, com.google.common.reflect.ClassPathTest]>. It is missing <[com.google.common.reflect.ClassPathTest]>\ntestGetTopLevelClassesRecursive(com.google.common.reflect.ClassPathTest): Not true that <[interface com.google.common.reflect.package-info, class com.google.common.reflect.ImmutableTypeToInstanceMap, interface com.google.common.reflect.TypeToInstanceMap, class com.google.common.reflect.TypeCapture, class com.google.common.reflect.Reflection, class com.google.common.reflect.Element, class com.google.common.reflect.TypeParameter, class com.google.common.reflect.ClassPath, class com.google.common.reflect.Parameter, class com.google.common.reflect.TypeResolver, class com.google.common.reflect.TypeToken, class com.google.common.reflect.AbstractInvocationHandler, class com.google.common.reflect.MutableTypeToInstanceMap, class com.google.common.reflect.Types, class com.google.common.reflect.Invokable, class com.google.common.reflect.TypeVisitor]> contains all of <[class com.google.common.reflect.ClassPathTest, class com.google.common.reflect.subpackage.ClassInSubPackage]>. It is missing <[class com.google.common.reflect.ClassPathTest, class com.google.common.reflect.subpackage.ClassInSubPackage]>\ntestGetTopLevelClasses_diamond(com.google.common.reflect.ClassPathTest): failed to find class com.google.common.reflect.ClassPathTest\n```\n\nThe bottom line seems to be things like:\n\n```\nIt is missing <[com.google.common.reflect.ClassPathTest]>\n```\n", "url": "https://github.com/google/guava/issues/1981", "user": "cpovirk", "labels": ["package=reflect", "type=defect"], "created": "2015-02-23 15:08:52", "closed": "2017-10-09 16:47:21", "commits": {}, "ttf": 959.0002777777778, "commitsDetails": []}, {"title": "Possible deadlock in ImmutableList ", "body": "ImmutableList contains following code since version 15.0\n\n private static final ImmutableList<Object> EMPTY =\n      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\n", "url": "https://github.com/google/guava/issues/1977", "user": "kronar", "labels": ["package=general", "status=fixed", "type=defect"], "created": "2015-02-19 15:54:48", "closed": "2015-06-23 04:42:58", "commits": {"f3099c7e01df0f240615eea996ec0c973a47aa11": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "83923892da4dc396e497c956f00cb4c577d941ec": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 123.00027777777778, "commitsDetails": [{"commitHash": "f3099c7e01df0f240615eea996ec0c973a47aa11", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["1839378a0dc48379f018597adb0cbcadc3225d34"], "nameRev": "f3099c7e01df0f240615eea996ec0c973a47aa11 tags/v19.0-rc1~210", "commitMessage": "Move EMPTY to RegularImmutableList.\nThis was requested in https://github.com/google/guava/issues/1977 to avoid circular static-init dependencies.\nI fear that we have other such problems. We should consider adding a test for them.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=88131198\n", "commitDateTime": "2015-03-16 14:35:04", "authoredDateTime": "2015-03-09 10:49:03", "commitGitStats": [{"filePath": "guava/src/com/google/common/collect/ImmutableList.java", "insertions": 3, "deletions": 6, "lines": 9}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableList.java", "insertions": 4, "deletions": 1, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImmutableList.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableList", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "RegularImmutableList.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.RegularImmutableList", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "83923892da4dc396e497c956f00cb4c577d941ec", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["91b5db6570568265aec0a4636023c0e0925661ba"], "nameRev": "83923892da4dc396e497c956f00cb4c577d941ec tags/v20.0-rc1~738", "commitMessage": "Remove more possible static-init deadlocks (https://github.com/google/guava/issues/1977).\n\n- ImmutableSortedMultiset: I couldn't figure out a way for this to actually deadlock, but I figure it's best for it to follow the pattern of the others.\n- ImmutableSortedSet: This might be able to deadlock if one thread creates a RegularImmutableMap (which then calls into RegularImmutableSortedSet and then ImmutableSet) while another initializes ImmutableSortedSet (which then calls into RegularImmutableSortedSet).\n- ImmutableTable: This might be able to deadlock if one thread GWT-deserializes a SparseImmutableTable (which then calls into ImmutableTable) while another initializes ImmutableTable (which calls into SparseImmutableTable).\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=104995935\n", "commitDateTime": "2015-10-08 17:35:29", "authoredDateTime": "2015-10-08 14:03:55", "commitGitStats": [{"filePath": "guava/src/com/google/common/collect/ImmutableSortedMultiset.java", "insertions": 3, "deletions": 8, "lines": 11}, {"filePath": "guava/src/com/google/common/collect/ImmutableSortedSet.java", "insertions": 3, "deletions": 9, "lines": 12}, {"filePath": "guava/src/com/google/common/collect/ImmutableTable.java", "insertions": 1, "deletions": 7, "lines": 8}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "guava/src/com/google/common/collect/RegularImmutableSortedSet.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "guava/src/com/google/common/collect/SparseImmutableTable.java", "insertions": 3, "deletions": 0, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImmutableSortedMultiset.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSortedMultiset", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.ImmutableSortedMultiset.emptyMultiset(java.util.Comparator)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.ImmutableSortedMultiset.of()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableSortedSet.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableSortedSet", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "com.google.common.collect.ImmutableSortedSet.emptySet(java.util.Comparator)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.ImmutableSortedSet.of()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImmutableTable.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.ImmutableTable", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "com.google.common.collect.ImmutableTable.of()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "RegularImmutableSortedMultiset.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.RegularImmutableSortedMultiset", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "RegularImmutableSortedSet.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.RegularImmutableSortedSet", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SparseImmutableTable.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.SparseImmutableTable", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f3099c7e01df0f240615eea996ec0c973a47aa11", "83923892da4dc396e497c956f00cb4c577d941ec"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 22, "deletions": 31, "lines": 53, "gitFilesChange": 8}, "spoonStatsSummary": {"TOT": 19, "UPD": 0, "INS": 9, "MOV": 2, "DEL": 8, "spoonFilesChanged": 8, "spoonMethodsChanged": 13}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": ["com.google.common.collect.RegularImmutableList", "com.google.common.collect.ImmutableSortedSet.emptySet(java.util.Comparator)", "com.google.common.collect.ImmutableSortedSet", "com.google.common.collect.ImmutableSortedMultiset.of()", "com.google.common.collect.RegularImmutableSortedMultiset", "com.google.common.collect.ImmutableTable", "com.google.common.collect.ImmutableTable.of()", "com.google.common.collect.ImmutableList", "com.google.common.collect.RegularImmutableSortedSet", "com.google.common.collect.ImmutableSortedMultiset", "com.google.common.collect.SparseImmutableTable", "com.google.common.collect.ImmutableSortedMultiset.emptyMultiset(java.util.Comparator)", "com.google.common.collect.ImmutableSortedSet.of()"]}, {"title": "Test failure in ClassPathTest under JDK8", "body": "Now that the JDK8 compilation issue is fixed, one test appears to be failing (at least under Oracle JDK 1.8.0_05). The failing test is `ClassPathTest.testGetResources`. It's throwing a NPE at the `assertNotNull(resource.url())` line for two particular resources, because the `ClassLoader` for those resources returns `null` when asked for the resource's URL.\n\nThe resources in question are `source_tips` and `version.rc`, both loaded by `sun.misc.Launcher$ExtClassLoader`, which loads from jars in `jre/lib/ext/`.\n\n`source_tips` appears to be a file that's in the root of multiple jars in `ext`: `sunec.jar`, `sunjce_provider.jar` and `sunpkcs11.jar`. I'm actually not clear on how (if at all) the class loader is supposed to distinguish between the multiple files with the same name that are in different jars (on second thought, I guess this is just the first or maybe last wins thing that causes issues with multiple jars defining some of the same classes on the classpath, but it doesn't seem like something that should cause the ClassLoader to just refuse to return a URL for the name).\n\n`version.rc`, on the other hand, only seems to appear in one jar: `jfxrt.jar`.\n\nThis may be some kind of bug or oddity with the `ClassLoader` implementation itself, I'm not sure. I couldn't trace down into exactly what's going on in there with a debugger.\n", "url": "https://github.com/google/guava/issues/1926", "user": "cgdecker", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-12-18 17:52:53", "closed": "2014-12-19 19:52:19", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "Range type parameter bound to Serializable", "body": "Given that `Range` is serializable, shouldn't its type parameter `C` be bound to `Serializable` too?\n\n``` java\nRange<C extends Comparable & Serializable>\n```\n", "url": "https://github.com/google/guava/issues/1912", "user": "paolofulgoni", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-12-10 10:23:18", "closed": "2014-12-10 14:46:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName.topPrivateDomain() fails for s3.amazonaws.com", "body": "The expected output is `amazonaws.com`, but an `IllegalStateException` is thrown.\n", "url": "https://github.com/google/guava/issues/1890", "user": "prb", "labels": ["package=net", "status=working-as-intended", "type=defect"], "created": "2014-11-14 19:06:56", "closed": "2014-11-14 19:27:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "BloomFilter why create use long,but readFrom use int?", "body": "creat method:\n![qq 20141105153403](https://cloud.githubusercontent.com/assets/9320176/4914158/8b15dc10-64be-11e4-9d48-9870e165b74f.png)\n\nreadFrom method\n![qq 20141105153422](https://cloud.githubusercontent.com/assets/9320176/4914159/8b19cd98-64be-11e4-8d1c-d576887a6d23.png)\n\nis there right?\n", "url": "https://github.com/google/guava/issues/1880", "user": "haochun", "labels": ["package=hash", "status=working-as-intended", "type=defect"], "created": "2014-11-05 07:37:21", "closed": "2014-11-05 17:01:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "how can i replace BloomFilter  writeTo method ?", "body": "BloomFilter has writeTo method,that i can serialize it to file.but,i found it is slow and the serialized file is to big.i want use Kryo to serialize.but,when i use Kryo,it happed exception.So,how can i replace it?\n", "url": "https://github.com/google/guava/issues/1879", "user": "haochun", "labels": ["package=hash", "type=defect"], "created": "2014-11-05 05:19:45", "closed": "2014-11-05 17:03:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName.isValid is not RFC1123 compliant", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1872) created by **manderson23** on 2014-10-27 at 10:59 PM_\n\n---\n\nInternetDomainName.isValid returns false for the parameter \"8server\".\n\nRFC1123 suggests that names should be able to start with a digit. See https://groups.google.com/forum/#!topic/guava-discuss/8Sycya7Fkok on guava-discuss for a discussion of the issue. \n\nI also asked for clarification on Server Fault at http://serverfault.com/questions/638260/is-it-valid-for-a-hostname-to-start-with-a-digit\n\nMy final suggestion on the mailing list for solving this was as follows:\n\n\"What about if the final part starts with a digit actually checking if the complete name is an IP address e.g. calling InetAddreses.isInetAddress? The discussion section in RFC 1123 does suggest a full syntactic check to prevent a dotted decimal number getting through.\"\n\nbut there was no response.\n", "url": "https://github.com/google/guava/issues/1872", "user": "gissuebot", "labels": ["package=net", "type=defect"], "created": "2014-10-31 18:02:06", "closed": "2019-06-05 10:43:16", "commits": {}, "ttf": 1677.0002777777777, "commitsDetails": []}, {"title": "Maps.unmodifiableNavigableMap not covariant in V", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1870) created by **thecoop1984** on 2014-10-23 at 08:42 AM_\n\n---\n\nMaps.unmodifiableNavigableMap is declared as follows:\n\n&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, V> map);\n\nthis could be changed to \n\n&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V> map);\n\nas there are no methods in NavigableMap that take a V as a method parameter. This would also be consistent with the declarations of Collections.unmodifiableSortedMap and ImmutableSortedMap.copyOfSorted.\n", "url": "https://github.com/google/guava/issues/1870", "user": "gissuebot", "labels": ["package=collect", "status=triaged", "type=defect"], "created": "2014-10-31 18:02:02", "closed": "2016-12-06 20:42:45", "commits": {}, "ttf": 767.0002777777778, "commitsDetails": []}, {"title": "CountingOutputStream allegedly declares @Nullable out (wrapped), but will NPE", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1869) created by **anth...@whitford.com** on 2014-10-22 at 01:01 AM_\n\n---\n\nThe constructor suggests that outputsteam may be null:\n\npublic CountingOutputStream(@\ufeffNullable OutputStream out)\n\nBut then any write/close operation will NPE:\n\n@\ufeffOverride public void write(byte[] b, int off, int len) throws IOException {\n&nbsp;&nbsp;&nbsp;&nbsp;out.write(b, off, len);\n&nbsp;&nbsp;&nbsp;&nbsp;count += len;\n}\n\nEither the @\ufeffNullable annotation should be removed, or the write/close methods should only pass-through when out is non-null.\n", "url": "https://github.com/google/guava/issues/1869", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 18:02:00", "closed": "2014-11-01 02:31:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NullPointerException in RegularImmutableList.equals() after Deserialization", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1861) created by **gomarkus** on 2014-10-02 at 11:55 AM_\n\n---\n\nField \"array\" of class \"RegularImmutableList\" is marked as transient. So it gets null after deserialization. Method \"equals(Object)\" tries to access the array and a NullPointerException is thrown.\n", "url": "https://github.com/google/guava/issues/1861", "user": "gissuebot", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2014-10-31 18:01:43", "closed": "2014-11-01 02:29:56", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "In Guava 18, MapMaker.makeComputingMap scope has changed, but it's referenced from Guice 4 Beta4", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1847) created by **cl...@magicalspirits.net** on 2014-09-13 at 02:40 PM_\n\n---\n\njava.lang.IllegalAccessError: tried to access method com.google.common.collect.MapMaker.makeComputingMap(Lcom/google/common/base/Function;)Ljava/util/concurrent/ConcurrentMap; from class com.google.inject.internal.Annotations$AnnotationChecker\nat com.google.inject.internal.Annotations$AnnotationChecker.(Annotations.java:104)\nat com.google.inject.internal.Annotations.(Annotations.java:122)\nat com.google.inject.spi.InjectionPoint.(InjectionPoint.java:94)\nat com.google.inject.spi.InjectionPoint$InjectableField.toInjectionPoint(InjectionPoint.java:440)\nat com.google.inject.spi.InjectionPoint.getInjectionPoints(InjectionPoint.java:725)\nat com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:358)\nat com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:377)\nat com.google.inject.internal.BindingBuilder.toInstance(BindingBuilder.java:84)\n\nI know the method is marked as deprecated, but changing it's scope has resulted in other libraries with dependencies on it that haven't been updated; including Guice.\n", "url": "https://github.com/google/guava/issues/1847", "user": "gissuebot", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2014-10-31 18:01:13", "closed": "2015-04-10 21:03:46", "commits": {}, "ttf": 161.00027777777777, "commitsDetails": []}, {"title": "InetAddresses#ipStringToBytes() fails to parse ipv6 with scope", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1844) created by **kofemann** on 2014-09-04 at 08:23 PM_\n\n---\n\nDear Guava team,\n\nthe InetAddresses#ipStringToBytes() fails to parse ipv6 with scope:\n\nInetAddresses.isInetAddress(\"fe80:0:0:0:230:48ff:fed3:e52%2\"))\n\nwill always returns false.\n\nFor example code:\n\nInetAddress addr = InetAddress.getByName(\"fe80:0:0:0:230:48ff:fed3:e52%2\");\nString addrString = addr.getHostAddress();\n\nif (isInetAddress(addrString)) {\n&nbsp;&nbsp;&nbsp;.....\n}\n\nwill never work. This is true as well, when IPv6 address taken by querying network interfaces.\n\nA possible fix (with corresponding unit test):\n\nhttps://code.google.com/r/kofemann-inetaddress/source/detail?r=9bad198f9108d14afb6fa66b064ede0dad6e076d\n\nThanks,\n&nbsp;&nbsp;&nbsp;kofemann\n", "url": "https://github.com/google/guava/issues/1844", "user": "gissuebot", "labels": ["package=net", "status=duplicate", "type=defect"], "created": "2014-10-31 18:01:07", "closed": "2014-11-01 02:27:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "EventBus.LoggingSubscriberExceptionHandler drops an exception", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1840) created by **stefan.liebig** on 2014-09-03 at 06:14 AM_\n\n---\n\nThe handleException() method on the LoggingSubscriberExceptionHandler is called with exception.getCause(). This is fine - it returns the target exception of the InvocationTargetException.\nHowever, the handleException() method logs this failure with exception.getCause() which than skips one exception.\n\nA simple workaround is to provide an own SubscriberExceptionHandler.\n\nGuava version 18.\n", "url": "https://github.com/google/guava/issues/1840", "user": "gissuebot", "labels": ["P2", "package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 18:00:58", "closed": "2019-08-16 15:44:58", "commits": {}, "ttf": 1749.0002777777777, "commitsDetails": []}, {"title": "18.0-rc1is unusable because Truth dep is SNAPSHOT", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1830) created by **leventov.ru** on 2014-08-11 at 06:42 AM_\n\n---\n\nGuava-testlib depends on truth:1.0-SNAPSHOT, which couldn't be downloaded from maven central.\n", "url": "https://github.com/google/guava/issues/1830", "user": "gissuebot", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2014-10-31 18:00:37", "closed": "2014-11-01 02:25:27", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Not under a public suffix: s3.amazonaws.com", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1829) created by **maxim.zemlyanoy** on 2014-08-07 at 11:13 AM_\n\n---\n\nGetting exception \"Not under a public suffix: s3.amazonaws.com\".\nBut domain is ok. \n", "url": "https://github.com/google/guava/issues/1829", "user": "gissuebot", "labels": ["package=net", "status=working-as-intended", "type=defect"], "created": "2014-10-31 18:00:35", "closed": "2014-11-01 02:24:00", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Booleans is marked as @GwtCompatible but imports java.util.BitSet which is not emulated by GWT", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1824) created by **jens.nehlmeier** on 2014-08-01 at 06:18 PM_\n\n---\n\nThe summary pretty much sums it up. \n\nActually Booleans does only use BitSet in JavaDoc @\ufefflink references and not in code, however the import is enough for GWT to fail during compilation. Using full qualified @\ufefflink references should probably fix the problem.\n\n[java]    [ERROR] Errors in 'jar:file:/..../guava-gwt.jar!/com/google/common/primitives/Booleans.java'\n[java]    [ERROR] Line 29: The import java.util.BitSet cannot be resolved\n[java]    [ERROR] Aborting compile due to errors in some input files\n", "url": "https://github.com/google/guava/issues/1824", "user": "gissuebot", "labels": ["package=primitives", "platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 18:00:25", "closed": "2015-06-23 04:44:13", "commits": {}, "ttf": 234.00027777777777, "commitsDetails": []}, {"title": "Class name repeated in output of resolveType()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1822) created by **archie.cobbs** on 2014-07-30 at 09:42 PM_\n\n---\n\nTest program:\n\n&nbsp;&nbsp;import com.google.common.reflect.TypeToken;\n\n&nbsp;&nbsp;public class Outer {\n\n```\npublic abstract static class Inner<T extends Inner<T>> {\n}\n\npublic void foo(Iterable<? extends Inner<?>> arg) {\n}\n\npublic static void main(String[] args) throws Exception {\n    System.out.println(\n      TypeToken.of(Outer.class.getMethod(\"foo\", Iterable.class)\n      .getGenericParameterTypes()[0]));\n}\n```\n\n&nbsp;&nbsp;}\n\nExpected output:\n\n&nbsp;&nbsp;java.lang.Iterable<? extends Outer$Inner<?>>\n\nActual output:\n\n&nbsp;&nbsp;java.lang.Iterable<? extends Outer.Outer$Inner<?>>\n", "url": "https://github.com/google/guava/issues/1822", "user": "gissuebot", "labels": ["package=reflect", "type=defect"], "created": "2014-10-31 18:00:20", "closed": "2019-09-13 20:37:17", "commits": {}, "ttf": 1778.0002777777777, "commitsDetails": []}, {"title": "NullPointerTester should not require @Nullable on the param of an equals() override", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1819) created by **ogregoire** on 2014-07-29 at 03:35 PM_\n\n---\n\nWhen I call the following, the test case fails (see full test case in attachment).\n\n&nbsp;&nbsp;new ClassSanityTester().testNulls(MyObject.class);\n\nI get the following error: No exception thrown for parameter at index 0 from MyObjectTest$MyObject.public boolean MyObjectTest$MyObject.equals(java.lang.Object)[null] for class MyObjectTest$MyObject\n\nClearly, this indicates that it expects a call to \"equals(Object)\" to throw a NullPointerException. That method should never throw an exception but rather return true or false. The test seems to skip this assertion and I'm surprised this hasn't been reported earlier. \n\nPlease make it so ClassSanityTester#testNulls(Class) doesn't fail when equals is behaving correctly (see the test case where testEquals(MyObject.class succeeds).\n\nOn a side note, the text returned should be adapted as it mentions three times MyObjectTest$MyObject. That's 2 too many, and it renders the whole error message nearly not understandable.\n", "url": "https://github.com/google/guava/issues/1819", "user": "gissuebot", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2014-10-31 18:00:14", "closed": "2016-08-23 19:00:15", "commits": {"af1dabf1b37fd74bfe074ad6d7a7fe8da5a61d12": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 662.0002777777778, "commitsDetails": [{"commitHash": "af1dabf1b37fd74bfe074ad6d7a7fe8da5a61d12", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["484e083653bef124948c449edc56195323b8d00a"], "nameRev": "af1dabf1b37fd74bfe074ad6d7a7fe8da5a61d12 tags/v20.0-rc1~105", "commitMessage": "NullPointerTester should not require @Nullable on the param of an equals() override\n\nThis is currently being worked around with things like:\n\nnew NullPointerTester()\n    .ignore(AutoValue_MyValueType.class.getMethod(\"equals\", Object.class))\n    ...\n\nThe work-arounds prevent AutoValue from being treated as a pure implementation-generating processor.\n\nFixes #1819\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=131074329\n", "commitDateTime": "2016-08-23 11:59:44", "authoredDateTime": "2016-08-23 11:00:39", "commitGitStats": [{"filePath": "guava-testlib/src/com/google/common/testing/NullPointerTester.java", "insertions": 31, "deletions": 1, "lines": 32}, {"filePath": "guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java", "insertions": 18, "deletions": 0, "lines": 18}], "commitSpoonAstDiffStats": [{"spoonFilePath": "NullPointerTester.java", "spoonMethods": [{"spoonMethodName": "com.google.common.testing.NullPointerTester.isEquals(java.lang.reflect.Member)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.testing.NullPointerTester.isIgnored(java.lang.reflect.Member)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "NullPointerTesterTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.testing.NullPointerTesterTest.OverridesEquals", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.testing.NullPointerTesterTest.DoesNotOverrideEquals", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.testing.NullPointerTesterTest.testEqualsMethod()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["af1dabf1b37fd74bfe074ad6d7a7fe8da5a61d12"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "com.google.common.io.Closeables implementation pointless", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1816) created by **Michael.Bergens** on 2014-07-25 at 09:42 AM_\n\n---\n\nThis class could be useful if it wasn't so useless. \n\nThe method close(Closeable, boolean) - why there is a CHECKED exception declared in the method signature? If I wanted to catch and use this exception, I wouldn't use this method. The whole point of it is closing a closeable without caring about exception. The method should be public void closeAll(Closeable... values), no checked exception in the method signature!\n\nAnd why there are separate methods for another two Closeable subclasses?? They are doing the same thing, just change the signature to the one above and you'll have just one useful method in place of 0.5 useful and 2.5 useless.\n", "url": "https://github.com/google/guava/issues/1816", "user": "gissuebot", "labels": ["package=io", "status=working-as-intended", "type=defect"], "created": "2014-10-31 18:00:07", "closed": "2014-11-01 02:22:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName parsing fails for URLs with dash at begin or end of subdomain", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1808) created by **gosimek** on 2014-07-18 at 08:30 AM_\n\n---\n\nEx.: \"www.-navarro-.tumblr.com\", \"www.-chlebni-lawenda-b.mojabudowa.pl\"\n\nCaused by: java.lang.IllegalArgumentException (\"Not a valid domain name: '-navarro-.tumblr.com'\") ? at line -1\ncom.google.common.base.Preconditions ? in checkArgument at line 119\ncom.google.common.net.InternetDomainName ? in &lt;init> at line 154\ncom.google.common.net.InternetDomainName ? in from at line 225\n", "url": "https://github.com/google/guava/issues/1808", "user": "gissuebot", "labels": ["package=net", "status=duplicate", "type=defect"], "created": "2014-10-31 17:59:50", "closed": "2014-11-01 02:21:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ExceptionInInitializerError", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1806) created by **smrtprjcts** on 2014-07-17 at 10:44 AM_\n\n---\n\nHi,\n\nI've got this:\njava.lang.ExceptionInInitializerError\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Splitter.&lt;init>(SourceFile:110)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Splitter.on(SourceFile:174)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.BaseApplication.count(SourceFile:900)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.CheckNewApps.doInBackground(SourceFile:106)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.CheckNewApps.doInBackground(SourceFile:1)\n&nbsp;&nbsp;&nbsp;&nbsp;at android.os.AsyncTask$2.call(AsyncTask.java:288)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n&nbsp;&nbsp;&nbsp;&nbsp;at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:811)\nCaused by: java.lang.UnsupportedOperationException\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.CharMatcher.a(SourceFile:775)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.CharMatcher.&lt;clinit>(SourceFile:212)\n&nbsp;&nbsp;&nbsp;&nbsp;... 11 more\n\nThis is the code:\n&nbsp;public int count(String string, String substring) {\n&nbsp;&nbsp;&nbsp;int count=0;\n&nbsp;&nbsp;&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;count = Iterables.size(Splitter.on(substring).split(string)) - 1;\n&nbsp;&nbsp;&nbsp;} catch (Exception e){\n...\n&nbsp;&nbsp;&nbsp;}\n\nYes, count = ... is the line 900?\n\nHow can it be? It comes from Galaxy S3 4.4.4\nThanks\n", "url": "https://github.com/google/guava/issues/1806", "user": "gissuebot", "labels": ["package=base", "type=defect"], "created": "2014-10-31 17:59:46", "closed": "2019-05-06 20:46:38", "commits": {}, "ttf": 1648.0002777777777, "commitsDetails": []}, {"title": "Double.POSITIVE_INFINITY seems to poison the com.google.common.util.concurrent.RateLimiter", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1791) created by **jroesler** on 2014-06-25 at 02:02 PM_\n\n---\n\nOnce a RateLimiter is configured with permitsPerSecond == Double.POSITIVE_INFINITY, it can never deliver a non-infinite rate. Tested on Guava 17.0.\n\nTest case:\n\npublic static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RateLimiter rateLimiter = RateLimiter.create(Double.POSITIVE_INFINITY);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final double permitsPerSecond = 1.0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rateLimiter.setRate(permitsPerSecond);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final long l = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final int totalPermits = 60;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final int permitsEachTime = 1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < totalPermits; i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rateLimiter.acquire(permitsEachTime);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(i + \",\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final double seconds = 1.0 \\* (System.currentTimeMillis() - l) / 1000;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(seconds);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((totalPermits / permitsPerSecond));\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\nThe behavior should be that it prints out the numbers about once a second and then prints the two \"seconds\" metrics roughly in agreement, like \n0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,\n59.0\n60.0\n\nWhen the rate limiter is initialized with a non-infinite value (like 10.0), we see the desired behavior.\n\nWhat the code above actually produces is:\n0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,\n0.002\n60.0\n\nshowing that the limiter is still issuing permits at an infinite rate.\n\nThe culprit seems to be this code:\nin com.google.common.util.concurrent.RateLimiter.Bursty#doSetRate\n&nbsp;&nbsp;&nbsp;&nbsp;storedPermits = (oldMaxPermits == 0.0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? 0.0 // initial state\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: storedPermits \\* maxPermits / oldMaxPermits;\nonce the rate has been set to infinity, we also have an infinite number of stored permits, as well as an infinite number of oldMaxPermits. This division yields NaN, which then goes on to ensure that com.google.common.util.concurrent.RateLimiter#reserveNextTicket will return 0 micros to wait.\n\nIt seems you may want to look at the whole rateLimiter with infinity in mind. Infinity is a reasonable value to configure a rate limiter with, so I think you should continue to accept it, but there may be other places where the math requires special handling of Infinity.\n\nLet me know if I can help.\n\nThanks,\n-John\n", "url": "https://github.com/google/guava/issues/1791", "user": "gissuebot", "labels": ["package=concurrent", "status=triaged", "type=defect"], "created": "2014-10-31 17:59:14", "closed": "2018-07-20 14:24:47", "commits": {}, "ttf": 1357.0002777777777, "commitsDetails": []}, {"title": "ImmutableSortedMap.copyOf incorrectly reports \"Multiple entries with the same key\"", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1784) created by **ardjan.zwartjes** on 2014-06-18 at 08:40 AM_\n\n---\n\nI ran into the following bug:\nI try to create an ImmutableSortedMap from an ImmutableMap. I use Functions.forMap(map) to create an Ordering\nthat orders the keys of the ImmutableMap based on the value they point to. When the ImmutableMap holds multiple keys that point to an equal value (according to the comparator) I would expect the order for those keys in the resulting ImmutableSortedMap to be undetermined. \n\nInstead an IllegalArgumentException is thrown from com.google.common.collect.ImmutableMap.checkNoConflict(ImmutableMap.java:150) with the message \"Multiple entries with same key\". This result is demonstrated with the attached file (I used Guava 17.0 for this test). This problem is caused by the call to checkNoConflict on line 300 of ImmutableSortedMap.java That line determines two subsequent entries for which the comparator returns 0 to be conflicting, while (in my opinion) the ordering is only undetermined. I feel that the conflict check should be made by calling:\nentries[i-1].getKey().equals(entries[i].getKey())\n\nI hope you agree with my conclusion and that this can be fixed. Thanks in advance.\n", "url": "https://github.com/google/guava/issues/1784", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:59:00", "closed": "2014-11-01 02:17:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "optimalNumOfHashFunctions() May not Return what you Expect", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1781) created by **justatheory** on 2014-06-13 at 08:25 PM_\n\n---\n\nWas experimenting with JavaScript code when I noticed this.  If you call\n\n```\noptimalNumOfHashFunctions(319, 3072)\n```\n\nIt returns 6. A quick JavaScript version returned 7. The reason is because the division acts only on integers and returns an integer. In JavaScript everything is a float. That is, in Java, `3072 / 319`&nbsp;returns 9, but in JavaScript it returns 9.63. Maybe it was intentional to have an implicitly truncated value, but I'm guessing not. The fix would be something like:\n\n--- a/guava/src/com/google/common/hash/BloomFilter.java\n+++ b/guava/src/com/google/common/hash/BloomFilter.java\n@@ -363,7 +363,7 @@ public final class BloomFilter&lt;T> implements Predicate&lt;T>, Serializable {\n&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;@\ufeffVisibleForTesting\n&nbsp;&nbsp;&nbsp;static int optimalNumOfHashFunctions(long n, long m) {\n-    return Math.max(1, (int) Math.round(m / n \\* Math.log(2)));\n-    return Math.max(1, (int) Math.round((float)m / n \\* Math.log(2)));\n  &nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;/**\n", "url": "https://github.com/google/guava/issues/1781", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:58:54", "closed": "2015-07-27 20:42:27", "commits": {}, "ttf": 269.0002777777778, "commitsDetails": []}, {"title": "Event is dispatched twice under JDK8", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1776) created by **sim.herter** on 2014-06-05 at 08:43 AM_\n\n---\n\nCreated a new test case to show the bug: see https://code.google.com/r/simherter-guava/source/detail?r=d578416aff9946fbdd00b350b3620b107bab6a13\n", "url": "https://github.com/google/guava/issues/1776", "user": "gissuebot", "labels": ["package=eventbus", "status=duplicate", "type=defect"], "created": "2014-10-31 17:58:43", "closed": "2014-11-01 02:16:37", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "register without \"public\" modifier doesn't work", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1766) created by **davidpc82** on 2014-05-27 at 12:10 PM_\n\n---\n\nIt works:\n\n```\n@Subscribe\npublic void onEvent(Event e) {\n    ...\n}\n```\n\nIt doesn't Work:\n\n```\n@Subscribe\nvoid onEvent(Event e) {\n    ...\n}\n```\n\nEnvironment:\nWindows 7 amd64\nNetbeans 8\nMaven 3.10\njdk1.7.0_51 x64\nGuava 17.0\n", "url": "https://github.com/google/guava/issues/1766", "user": "gissuebot", "labels": ["package=eventbus", "status=duplicate", "type=defect"], "created": "2014-10-31 17:58:22", "closed": "2014-11-01 02:26:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LocalCache weight eviction does not work when maxSegmentWeight is >= int.MAX_VALUE", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1761) created by **DanGLow** on 2014-05-22 at 05:18 PM_\n\n---\n\nHi,\n\nThis bug was originally discovered here: https://github.com/elasticsearch/elasticsearch/issues/6268, but I have traced it down into an issue with an overflowing int and long comparison in LocalCache.java eviction logic. The following is the eviction code at https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/LocalCache.java#L2665\n\n@\ufeffGuardedBy(\"Segment.this\")\nvoid evictEntries() {\n&nbsp;&nbsp;if (!map.evictsBySize()) {\n&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;drainRecencyQueue();\n&nbsp;&nbsp;while (totalWeight > maxSegmentWeight) {\n&nbsp;&nbsp;&nbsp;&nbsp;ReferenceEntry&lt;K, V> e = getNextEvictable();\n&nbsp;&nbsp;&nbsp;&nbsp;if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n}\n\n'totalWeight' is defined as an int, while 'maxSegmentWeight' is a long. If 'maxSegmentWeight' is set to any value int.MAX_VALUE or greater, then this check\n\n&nbsp;&nbsp;while (totalWeight > maxSegmentWeight) {\n\nwill never be true, since 'totalWeight' will overflow, and the eviction code will never run.\n", "url": "https://github.com/google/guava/issues/1761", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:58:12", "closed": "2014-11-01 02:15:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "com.google.common.collect.testing.SafeTreeMapTest: Java heap space when doing \"mvn install\"", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1757) created by **bpan.mit** on 2014-05-16 at 05:53 PM_\n\n---\n\nI tried to install guava, but when I did \"mvn install\", I saw this:\n\nRunning com.google.common.testing.anotherpackage.ForwardingWrapperTesterTest\nTests run: 19, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.165 sec\nRunning com.google.common.testing.ArbitraryInstancesTest\nMay 16, 2014 10:47:09 AM com.google.common.testing.ArbitraryInstances get\nWARNING: Exception while invoking default constructor.\njava.lang.RuntimeException\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstancesTest$WithExceptionalConstructor.&lt;init>(ArbitraryInstancesTest.java:429)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstances.get(ArbitraryInstances.java:359)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstancesTest.testGet_class(ArbitraryInstancesTest.java:293)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runTest(TestCase.java:168)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runBare(TestCase.java:134)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult$1.protect(TestResult.java:110)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.runProtected(TestResult.java:128)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.run(TestResult.java:113)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.run(TestCase.java:124)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.proxy.$Proxy0.invoke(Unknown Source)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)\nTests run: 25, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.03 sec\nRunning com.google.common.testing.ClassSanityTesterTest\nTests run: 71, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.069 sec\nRunning com.google.common.testing.EqualsTesterTest\nTests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 sec\nRunning com.google.common.testing.EquivalenceTesterTest\nTests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.007 sec\nRunning com.google.common.testing.FakeTickerTest\nTests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.028 sec\nRunning com.google.common.testing.FreshValueGeneratorTest\nTests run: 60, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.135 sec\nRunning com.google.common.testing.GcFinalizationTest\nTests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.31 sec\nRunning com.google.common.testing.NullPointerTesterTest\nTests run: 60, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.148 sec\nRunning com.google.common.testing.RelationshipTesterTest\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec\nRunning com.google.common.testing.SerializableTesterTest\nTests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 sec\nRunning com.google.common.testing.TearDownStackTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 sec\nRunning com.google.common.testing.TestLogHandlerTest\nTests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec\nRunning com.google.common.util.concurrent.testing.TestingExecutorsTest\nTests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.045 sec\n\nResults :\n\nFailed tests: \n&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with natural comparator [collection size: zero] keys [collection size: zero] descending [collection size: zero]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw\n...\nveral] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw\n&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true\n&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true\n&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true\n&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw\n&nbsp;&nbsp;testAddAll_unsupportedSomePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(somePresent) should throw\n&nbsp;&nbsp;testAdd_unsupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw\n&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true\n&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true\n&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true\n&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw\n&nbsp;&nbsp;testAddAll_unsupportedSomePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(somePresent) should throw\n&nbsp;&nbsp;testAdd_unsupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw\n&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true\n&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true\n&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true\n&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true\n\nTests in error: \n&nbsp;&nbsp;com.google.common.collect.testing.SafeTreeMapTest: Java heap space\n\nTests run: 60963, Failures: 612, Errors: 1, Skipped: 0\n\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Guava Maven Parent ................................ SUCCESS [  0.270 s]\n[INFO] Guava: Google Core Libraries for Java ............. SUCCESS [ 12.746 s]\n[INFO] Guava Testing Library ............................. FAILURE [03:39 min]\n[INFO] Guava Unit Tests .................................. SKIPPED\n[INFO] Guava GWT compatible libs ......................... SKIPPED\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 03:52 min\n[INFO] Finished at: 2014-05-16T10:47:09-08:00\n[INFO] Final Memory: 18M/265M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-testlib: There are test failures.\n[ERROR] \n[ERROR] Please refer to /Users/bpan/git/guava-libraries/guava-testlib/target/surefire-reports for the individual test results.\n[ERROR] -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn &lt;goals> -rf :guava-testlib\n\nI found changing MAVEN_OPTS=\"-Xms256m -Xmx5512m\" to adjust java heap size does not work. \n\nDoes anybody know a way to resolve this issue?\n\nThank you.\n", "url": "https://github.com/google/guava/issues/1757", "user": "gissuebot", "labels": ["status=obsolete", "type=defect"], "created": "2014-10-31 17:58:03", "closed": "2019-10-17 18:11:47", "commits": {}, "ttf": 1812.0002777777777, "commitsDetails": []}, {"title": "Impossible-looking race in AbstractScheduledServiceTest.testDefaultExecutorIsShutdownWhenServiceFails", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1751) created by **cpovirk@google.com** on 2014-05-12 at 06:30 PM_\n\n---\n\nI saw this failure once at internal CL 66812931 (test ID 6c02838a-8b9d-4ff3-ab06-89ecb4a8f01b -- this is a non-mint client, but the only change (to RateLimiterTest) ought to have affected only another test suite). For all I know, there's some bug in the JVM or java.util.concurrent, but I could believe that there's a race in ListenerCallQueue or another Guava class that we missed.\n\njunit.framework.AssertionFailedError\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.fail(Assert.java:48)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.assertTrue(Assert.java:20)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.assertTrue(Assert.java:27)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractScheduledServiceTest.testDefaultExecutorIsShutdownWhenServiceFails(AbstractScheduledServiceTest.java:217)\n", "url": "https://github.com/google/guava/issues/1751", "user": "gissuebot", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2014-10-31 17:57:50", "closed": "2014-11-01 02:23:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Lists.partition(List<T> list, int size) is returning wrong List<List<T>> size", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1733) created by **sripati.misra** on 2014-04-21 at 04:40 PM_\n\n---\n\nI have gone through the issue - 451.  Here more discussion is going on \"distribute\". Whatever I found the defect quite similar, But result is different. The Lists.partition(List&lt;T> list, int size) is returning wrong size of List&lt;List&lt;T>>. \n\nIf the size of \"List&lt;T> list\" is 12 in the first parameter and in second parameter \"int size\" is 4. So it should return List&lt;List&lt;T>> size 3 rather than 4.\n", "url": "https://github.com/google/guava/issues/1733", "user": "gissuebot", "labels": ["package=collect", "status=obsolete", "type=defect"], "created": "2014-10-31 17:57:12", "closed": "2014-11-01 02:11:33", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CharMatcher.ASCII.matchesAllOf sometimes is wrong.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1720) created by **eric.itzhak** on 2014-04-10 at 07:34 AM_\n\n---\n\nAfter alot of tries, I've realized that if I check the same string in different runs, sometimes the method\n\nCharMatcher.ASCII.matchesAllOf(string);\n\nwill return the wrong answer, about 97% of the time it returns false, but every once in a while it returns as true,\nI do not know how to reproduce it, that seems to happen in random times\n", "url": "https://github.com/google/guava/issues/1720", "user": "gissuebot", "labels": ["package=base", "status=invalid", "type=defect"], "created": "2014-10-31 17:56:45", "closed": "2014-11-01 02:09:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Possible hang in ServiceManagerTest", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1715) created by **cpovirk@google.com** on 2014-04-07 at 05:42 PM_\n\n---\n\nOne time, when running the tests of the JDK5 backport[*] -- no, I don't know if the JDK5-ness (e.g., ArrayDeque -> LinkedList) is relevant -- ServiceManagerTest appeared to hang. jstack output is attached. I don't know if there were any exceptions or other hints of a cause. (Certainly our Maven test output always has exceptions in it; I didn't see if any looked related, and I've since overwritten the output files :) The interesting part of the stacks is below.\n\nThe test worked fine the next time I ran it, and it worked fine when I made the equivalent internal change and ran 10x against the normal internal JDK with the normal tools.\n\nI could believe that we hit a crazy VM bug or something, but in case there's anything actually wrong in ServiceManager or its test, I figured I'd file this bug.\n\n&nbsp;&nbsp;at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)\n&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)\n&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:994)\n&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1303)\n&nbsp;&nbsp;at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:236)\n&nbsp;&nbsp;at com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly(Uninterruptibles.java:55)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManagerTest$4.failure(ServiceManagerTest.java:365)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState$5.call(ServiceManager.java:689)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState$5.call(ServiceManager.java:687)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.run(ListenerCallQueue.java:118)\n&nbsp;&nbsp;at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.execute(ListenerCallQueue.java:86)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState.executeListeners(ServiceManager.java:700)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState.transitionService(ServiceManager.java:671)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceListener.failed(ServiceManager.java:774)\n&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService$9.call(AbstractService.java:484)\n&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService$9.call(AbstractService.java:482)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.run(ListenerCallQueue.java:118)\n&nbsp;&nbsp;at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.execute(ListenerCallQueue.java:86)\n&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService.executeListeners(AbstractService.java:433)\n&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService.startAsync(AbstractService.java:180)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager.startAsync(ServiceManager.java:287)\n&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManagerTest.testListenerDeadlock(ServiceManagerTest.java:371)\n\n[*] at https://github.com/google/guava/commit/566894361b48cec7d391127fe4b0f9547b4549c6\n", "url": "https://github.com/google/guava/issues/1715", "user": "gissuebot", "labels": ["package=concurrent", "type=defect"], "created": "2014-10-31 17:56:35", "closed": "2015-05-17 19:53:03", "commits": {}, "ttf": 198.00027777777777, "commitsDetails": []}, {"title": "BitArray in the BloomFilterStrategies's bitSize may be out of range", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1702) created by **magiciankid** on 2014-03-21 at 10:20 AM_\n\n---\n\nmethod named bitSize() return int :  \nif data.length==Integer.MAX_VALUE  \ndata.length \\* 64 will out of int's  range\n", "url": "https://github.com/google/guava/issues/1702", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:56:07", "closed": "2014-11-01 02:06:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Preconditions.format possible NullPointerException", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1701) created by **soe...@glorien.com** on 2014-03-20 at 06:43 PM_\n\n---\n\nWithin Preconditions.java you defined \"args\" as Nullable but in line 416 (...new StringBuilder(template.length() + 16 \\* args.length);) a NullPointerException can be thrown!\n\nI would expect at least the Nullable-Annotation should be removed (even for the calling methods, like checkNotNull) or it should be null-safe.\n", "url": "https://github.com/google/guava/issues/1701", "user": "gissuebot", "labels": ["package=base", "type=defect"], "created": "2014-10-31 17:56:05", "closed": "2018-01-02 15:24:56", "commits": {}, "ttf": 1158.0002777777777, "commitsDetails": []}, {"title": "RegularContiguousSet.contains() may throw NullPointerException", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1698) created by **Aaron.Greenhouse** on 2014-03-14 at 12:58 PM_\n\n---\n\nThe method contains() in com.google.common.collect.Range contains a call to Preconditions.checkNotNull() for the formal parameter:\n\n&nbsp;&nbsp;public boolean contains(C value) { \n&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(value);\n&nbsp;&nbsp;&nbsp;&nbsp;// let this throw CCE if there is some trickery going on\n&nbsp;&nbsp;&nbsp;&nbsp;return lowerBound.isLessThan(value) && !upperBound.isLessThan(value);\n&nbsp;&nbsp;}\n\nThat is, this method will throw a NullPointerException if value is null.\n\nThe method contains() in com.google.common.collect.RegularContiguousSet is implemented using Range.contains():\n\n&nbsp;&nbsp;@\ufeffOverride public boolean contains(Object object) {\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return range.contains((C) object);\n&nbsp;&nbsp;&nbsp;&nbsp;} catch (ClassCastException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n\nThere is no null check here, so if RegularContiguousSet.contains() is called with a null value, it will pass that value to Range.contains() and a NullPointerException will result.  This is erroneous because RegularContiguousSet.contains() overrides ImmutableCollection.contains() whose \"object\" parameter is explicitly annotated as @\ufeffNullable.  That is, the method should be able to handle a test against null:\n\n&nbsp;&nbsp;@\ufeffOverride\n&nbsp;&nbsp;public boolean contains(@\ufeffNullable Object object) {\n&nbsp;&nbsp;&nbsp;&nbsp;return object != null && Iterators.contains(iterator(), object);\n&nbsp;&nbsp;}\n\nRegularContiguousSet.contains() should be fixed to check for null:\n\n&nbsp;@\ufeffOverride public boolean contains(Object object) {\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (object == null) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return range.contains((C) object);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;} catch (ClassCastException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n", "url": "https://github.com/google/guava/issues/1698", "user": "gissuebot", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2014-10-31 17:55:59", "closed": "2014-11-01 02:06:38", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "GWT 2.6.0 The method divide(int, int, RoundingMode) is undefined for the type IntMath", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1684) created by **wokier** on 2014-02-27 at 01:08 PM_\n\n---\n\nHi\n\nI have this log as an error in devMode, but that does not prevent the application to run correctly.\nIt is just an annoying log.\n\nThe methd is marked as @\ufeffGwtIncompatible in 11.0.2 but not in 12.0 and further versions\n", "url": "https://github.com/google/guava/issues/1684", "user": "gissuebot", "labels": ["platform=gwt", "status=obsolete", "type=defect"], "created": "2014-10-31 17:55:30", "closed": "2014-11-01 02:04:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Iterables.consumingIterable().toString() probably should not consume all the elements", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1681) created by **kevinb@google.com** on 2014-02-24 at 06:34 PM_\n\n---\n\nIterables.consumingIterable().toString() probably should not consume all the elements\n\nThe method is questionable to begin with, but.....\n", "url": "https://github.com/google/guava/issues/1681", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:55:23", "closed": "2014-11-01 02:03:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CacheBuilder#removalListener(RemovalListener) lacks information about deferred invoking RemovalListener", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1680) created by **xaerxess** on 2014-02-24 at 02:58 PM_\n\n---\n\n[http://stackoverflow.com/questions/21986551/guava-cachebuilder-doesnt-call-removal-listener In this Stackoverflow question] user pointed out that RemovalListener isn't called on removal entry. That behavior is not explicitely documented, as CacheBuilder#removalListener(RemovalListener) documentation says:\n\n> Specifies a listener instance that caches should notify each time an entry\n> is removed for any reason. Each cache created by _this builder will invoke\n> this listener as part of the routine maintenance described in the class\n> documentation above_.\n\nThe \"documentation above\" says:\n\n> Caches built with CacheBuilder do not perform cleanup and evict values\n> \"automatically,\" or instantly after a value expires, or anything of the sort.\n> Instead, it performs small amounts of maintenance during write operations,\n> _or during occasional read operations if writes are rare_.\n\nI think user can expect RemovalListener to be called on actual removal.\n\nInternally, the cleanup is (not) made by postReadCleanup():\n\n```\n/**\n * Performs routine cleanup following a read. Normally cleanup happens during writes. If cleanup\n * is not observed after a sufficient number of reads, try cleaning up from the read thread.\n */\nvoid postReadCleanup() {\n  if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {\n    cleanUp();\n  }\n}\n```\n\nso \"occasionally\" means every 64 reads, if no write or cleanup occured meanwhile. This is some kind of optimization, so I'd like to request either:\n\n&nbsp;\\- adding a clarification in CacheBuilder#removalListener(RemovalListener),\n&nbsp;\\- changing postReadCleanup() to just do cleanUp() (it should probably be benchmarked),\n&nbsp;\\- adding something like CacheBuilder#doNotDeferRemovalListener() which would bypass DRAIN_THRESHOLD check in postReadCleanup().\n\nI've checked LoadingCache tests and it looks like the third option (which is a win-win IMO) would not break any tests, while second option breaks testDrainRecencyQueueOn{Read,Write}.\n", "url": "https://github.com/google/guava/issues/1680", "user": "gissuebot", "labels": ["P3", "package=cache", "status=invalid", "type=defect"], "created": "2014-10-31 17:55:21", "closed": "2019-10-02 16:42:27", "commits": {}, "ttf": 1796.0002777777777, "commitsDetails": []}, {"title": "Joiner.join with skipNulls() gives NPE when 3th arg is null", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1672) created by **joeri.le...@9to5.be** on 2014-02-17 at 05:26 PM_\n\n---\n\nConsider this scenario:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Joiner.on('&').skipNulls().join(\"one\", null)); // prints \"one\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Joiner.on('&').skipNulls().join(\"one\", \"two\", \"three\", null)); // prints \"one&two&three\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Joiner.on('&').skipNulls().join(\"one\", \"two\", null)); // NullPointerException\n\nThe last line will result in a NullPointerException because the 3th argument is interpreted as a varargs list which cannot be null.\n", "url": "https://github.com/google/guava/issues/1672", "user": "gissuebot", "labels": ["package=base", "status=duplicate", "type=defect"], "created": "2014-10-31 17:55:04", "closed": "2014-11-01 02:02:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "AbstractPackageSanityTests equals test fails for AutoValue classes with Set members", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1665) created by **pettermahlen** on 2014-02-11 at 08:31 AM_\n\n---\n\nFor an @\ufeffAutoValue that has a field that is a parameterised set is tested by AbstractPackageSanityTests, for some types, the tests seem to generate incorrect equality groups.  For example, this class:\n\n@\ufeffAutoValue\npublic abstract class EqualsBreaker {\n&nbsp;&nbsp;EqualsBreaker() {}\n\n&nbsp;&nbsp;public static EqualsBreaker create(Set&lt;HostAndPort> hosts) {\n&nbsp;&nbsp;&nbsp;&nbsp;return new AutoValue_EqualsBreaker(ImmutableSet.copyOf(hosts));\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;public abstract Set&lt;HostAndPort> hosts();\n}\n\nLeads to a failure like this: \n\nCaused by: junit.framework.AssertionFailedError: com.spotify.hermes.cache.AutoValue_CachedResponse([2]) must not be Object#equals to com.spotify.hermes.cache.AutoValue_CachedResponse(Set@1)\n\nThe following changes make this work as expected:\n- changing to Set&lt;String>\n- changing to List&lt;HostAndPort>\n\nI originally had another @\ufeffAutoValue class as Set type parameter, but changed to HostAndPort to pick something that was 'not almost primitive' and that I was very sure wouldn't have any issues with its equals method.\n\nExplicitly testing the class using EqualsTester and hand-coded equality groups works as expected, so I'm pretty sure the issue is in how AbstractPackageSanityTests generates equality groups for sets.\n", "url": "https://github.com/google/guava/issues/1665", "user": "gissuebot", "labels": ["package=testing", "status=fixed", "type=defect"], "created": "2014-10-31 17:54:50", "closed": "2014-11-01 02:09:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bloom filter negative expectedFpp and premature saturation of filter", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1656) created by **spie...@addthis.com** on 2014-02-05 at 04:07 PM_\n\n---\n\nHi folks,\n\nWe've observed that for very large bloom filters the expected false positive probability returns a negative value and the observed false positive probability exceeds the desired false positive probability  during conditions when the number of performed insertions is relatively small as compared to the number of expected insertions.\n\nI've been able to reproduce this behavior in the attached SSCCE. The bloom filter is constructed with an expected 150M insertions and a desired fpp of 0.0001. After 75M insertions the expected false positive probability is a negative value. The observed false positive probability is around 0.0002. Informally we have been able to reproduce the negative expected false positive probability with larger  desired false positive probabilities by increasing the expected number of insertions.\n", "url": "https://github.com/google/guava/issues/1656", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:54:30", "closed": "2014-11-01 02:07:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Sets$SetView#contains(Object object) - not working as expected", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1655) created by **knitelius** on 2014-02-03 at 10:39 AM_\n\n---\n\nI would have expected the SetView#contains(Object object) method to check if the given object is currently present and 'visible' in the view.\n\nAnd not as currently implemented checking whether or not the List is part of the view. \n", "url": "https://github.com/google/guava/issues/1655", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:54:28", "closed": "2014-11-01 02:00:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName.topPrivateDomain() Fails on Suffix .kp", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1654) created by **kalspaugh** on 2014-01-30 at 07:00 PM_\n\n---\n\nWhen calling topPrivateDomain() on a domain that ends in .kp (North Korea) I get an IllegalStateException stating that the domain is \"Not under a public suffix\".  The result of isPublicSuffix() on a domain ending with .kp returns false.\n\n.kp is on the public suffix list and should return true.\n", "url": "https://github.com/google/guava/issues/1654", "user": "gissuebot", "labels": ["package=net", "status=fixed", "type=defect"], "created": "2014-10-31 17:54:26", "closed": "2014-11-01 02:07:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Stop using FilterOutputStream", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1651) created by **ch...@digitalascent.com** on 2014-01-30 at 04:22 PM_\n\n---\n\nA review of the HashingOutputStream source reveals a couple of corner cases that can result in erroneous results or silently-swallowed exceptions:\n\n1) The hashcode of the streamed content is available independent of the stream state (open/flushed/closed).  In the case where the stream is wrapped (directly or indirectly) with a BufferedOutputStream (or any other stream that buffers the content), the HashingOutputStream won't yet have seen anything that is buffered, resulting in the hash() method calculating a likely incorrect hashcode (the hash would be technically correct, but not what the user expected as it isn't based on the full input).\n\nThis can be addressed by not allowing the hashcode to be available until after close() is called, throwing an exception if accessed otherwise (this uncovered a number of subtle errors when we implemented it):\n\n```\npublic HashCode getHashCode()\n{\n    checkState( hashCode != null, \"Attempted to retrieve hashCode without having closed the stream first\" );\n    return hashCode;\n}\n\n@Override\npublic void close() throws IOException\n{\n    hashCode = hasher.hash();\n    super.close();\n}\n```\n\n2) HashingOutputStream inherits from FilterOutputStream, which implements close() as:\n\n```\npublic void close() throws IOException {\n    try {\n      flush();\n    } catch (IOException ignored) {\n    }\n    out.close();\n}\n```\n\nThe call to flush() is appropriate here - but the swallowing of any exception is not.  In the case of buffered streams, there may be content left to be flushed - and the underlying stream may throw an exception processing that content (network issue, disk full, ...).\n\nThis is the same issue that resulted in Closeables.closeQuietly being deprecated (https://github.com/google/guava/issues/1118\n\nIMO, java.io.FilterOutputStream is not safe to use in it's current state - we've banished it from our code base, in favor of an alternate superclass that behaves correctly (and also clarifies the overriding / delegation of write() calls).\n", "url": "https://github.com/google/guava/issues/1651", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:54:20", "closed": "2014-11-01 02:06:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "gwt+guava compilation error:[ERROR] Line 761: MAX_SIZE cannot be resolved or is not a field", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1639) created by **Alexander.Luya** on 2014-01-22 at 01:08 AM_\n\n---\n\nWhen compiling guava 16.0+gwt 2.6 RC4,I got this error:\n\nCompiling module com.dsc.athena.Athena\n&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'jar:file:/home/alex/workspace/DSC-Lib/lib/guava-gwt-16.0.jar!/com/google/common/base/super/com/google/common/base/CharMatcher.java'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 761: MAX_SIZE cannot be resolved or is not a field\n", "url": "https://github.com/google/guava/issues/1639", "user": "gissuebot", "labels": ["package=base", "platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:53:55", "closed": "2014-11-01 02:00:17", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Question about lazy evaluation of inverse in ImmutableSetMultimap", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1638) created by **shtratos** on 2014-01-18 at 10:43 AM_\n\n---\n\nHello,\n\nHere [1] inverse field is lazily calculated and ImmutableSetMultimap is advertised as thread-safe, but inverse is not marked as volatile.\nIs it intentional?\n\nI guess it doesn't matter since in the worst case the inverse value will be calculated several times and will produce the same result.\n\n[1] https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableSetMultimap.java#L363\n", "url": "https://github.com/google/guava/issues/1638", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:53:53", "closed": "2014-11-01 02:14:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LocalCache.Values should not be a Set", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1636) created by **me...@rewor.cz** on 2014-01-17 at 09:02 AM_\n\n---\n\nAs Cache is basically a map, it can contain same values for different keys. \nUsing Set for Cache.asMap().values() is always wrong: it will either discard duplicate values or break semantics of Set.\n\nMy now not-working use (it should remove all values, now removes only one):\n[cache].asMap().values().removeAll(ImmutableList.of([value]));\n\nIt worked up to r13. Offending changeset: 60b819dc1291788a3dce17cd95d8f4a7d0a8b9bf.\n", "url": "https://github.com/google/guava/issues/1636", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:53:49", "closed": "2014-11-01 01:57:23", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "JDK and Guava TypeVariable implementations are no longer compatible under 1.7.0_51-b13", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1635) created by **magiciankid** on 2014-01-17 at 01:02 AM_\n\n---\n\ncom.google.common.reflect.TypeResolverTest\ncom.google.common.reflect.TypeTokenResolutionTest\ncom.google.common.reflect.TypeTokenTest\ncom.google.common.reflect.TypesTest\n\njava -version\n\njava version \"1.7.0_51\"\nJava(TM) SE Runtime Environment (build 1.7.0_51-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)\n\nplease fix it \uff1a\uff09\n", "url": "https://github.com/google/guava/issues/1635", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:53:47", "closed": "2014-11-01 02:00:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Eviction by maximumWeight does not seems to work  ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1629) created by **b.lerer** on 2014-01-05 at 09:36 PM_\n\n---\n\nIt seems that the cache expire entries before the maximumWeight has been reached.\n\nYou can run the following unit test to reproduce the problem.\n\nimport java.util.concurrent.ExecutionException;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.cache.RemovalListener;\nimport com.google.common.cache.RemovalNotification;\nimport com.google.common.cache.Weigher;\n\npublic class TestCache {\n\n```\n@Test\npublic void testMaximumWeight() throws ExecutionException {\n\n    final String s = \"12345678901234567890123456789012345678901234567890\";\n\n    LoadingCache<String, String> cache = CacheBuilder.newBuilder()\n                                                     .maximumWeight(100)\n                                                     .weigher(new Weigher<String, String>() {\n\n                                                         @Override\n                                                         public int weigh(String key, String value) {\n\n                                                             System.out.println(\"weigth:\" + value.length());\n\n                                                             return value.length();\n                                                         }\n                                                     })\n                                                     .removalListener(new RemovalListener<String, String>() {\n\n                                                         @Override\n                                                         public    void\n                                                                 onRemoval(RemovalNotification<String, String> notification) {\n\n                                                             System.out.println(\"removing (\"\n                                                                     + notification.getKey() + \", \"\n                                                                     + notification.getValue() + \") \"\n                                                                     + notification.getCause());\n                                                         }\n\n                                                     })\n                                                     .build(new CacheLoader<String, String>() {\n\n                                                         @Override\n                                                         public String load(String arg0) throws Exception {\n                                                             return s;\n                                                         }\n\n                                                     });\n\n    Assert.assertEquals(s, cache.get(\"A\"));\n    Assert.assertNotNull(\"the entry should still be here as the maximum weight has not been reached.\",\n                         cache.getIfPresent(\"A\"));\n}\n```\n\n}\n", "url": "https://github.com/google/guava/issues/1629", "user": "gissuebot", "labels": ["package=cache", "status=duplicate", "type=defect"], "created": "2014-10-31 17:53:34", "closed": "2014-11-01 01:55:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Behavior of Multiset.difference ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1626) created by **magiciankid** on 2014-01-02 at 04:51 AM_\n\n---\n\ntestcase as follows\uff1a\n&nbsp;&nbsp;&nbsp;&nbsp;Multiset&lt;String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n&nbsp;&nbsp;&nbsp;&nbsp;Multiset&lt;String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"c\"));\n&nbsp;&nbsp;&nbsp;&nbsp;ASSERT.that(Multisets.difference(ms1, ms2)).has().exactly(\"a\", \"b\");           // success\n&nbsp;&nbsp;&nbsp;&nbsp;ASSERT.that(Multisets.difference(ms1, ms2)).has().exactly(\"a\", \"b\", \"c\");   //  failure\n&nbsp;&nbsp;&nbsp;&nbsp;fail();\n\nthe //failure result was expected , isn't  it? \n\nit seems Multisets.difference just take care of the element in the multiset1, but ignore the element absent in multiset2 \u3002\n", "url": "https://github.com/google/guava/issues/1626", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:53:28", "closed": "2014-11-01 01:55:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LongMath.checkedPow() mishandles negative numbers with large magnitude", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1624) created by **jihokim** on 2013-12-27 at 11:08 PM_\n\n---\n\nIn v15, LongMath.checkPow(Long.MIN_VALUE,2)==0.  Instead, it should throw an ArithmeticException per specification.  The problem occurs more generally when the base is negative and the result overflows.\n\nLongMath's checkPow() implementation should have the similar check as IntMath:\n\n// from LongMath.checkedPow()\ncheckNoOverflow(b <= FLOOR_SQRT_MAX_LONG); \n\n// from IntMath.checkedPow()\ncheckNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT); \n", "url": "https://github.com/google/guava/issues/1624", "user": "gissuebot", "labels": ["package=math", "status=fixed", "type=defect"], "created": "2014-10-31 17:53:24", "closed": "2015-10-08 21:02:29", "commits": {}, "ttf": 342.0002777777778, "commitsDetails": []}, {"title": "Avoid overflow in RateLimiter#tryAcquire(int, long, TimeUnit)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1622) created by **stephan202** on 2013-12-25 at 01:18 PM_\n\n---\n\nScenario: I'm using RateLimiter to perform a certain operation every \"interval\" milliseconds for a total of \"duration\" milliseconds. If \"duration\" is 0, then the operation must be repeated indefinitely.\n\nThus I wrote something akin to the following:\n\n```\nfinal double permitsPerSecond = MILLISECONDS.convert(1, SECONDS) / (double) interval;\nfinal Stopwatch sw = Stopwatch.createStarted();\nfinal RateLimiter rl = RateLimiter.create(permitsPerSecond);\nlong timeout;\ndo { \n    doOperation();\n    timeout = (duration < 1) ? Long.MAX_VALUE : duration - sw.elapsed(MILLISECONDS);\n} while (timeout >= 0 && rl.tryAcquire(timeout, MILLISECONDS));\n```\n\nTurns out, this doesn't work: when #tryAcquire is passed Long.MAX_VALUE, internally an overflow happens. The following would fix this:\n\n```\ndiff --git a/guava/src/com/google/common/util/concurrent/RateLimiter.java b/guava/src/com/google/common/util/concurrent/RateLimiter.java\nindex a929b8a..33e574b 100644\n--- a/guava/src/com/google/common/util/concurrent/RateLimiter.java\n+++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java\n@@ -467,7 +467,7 @@ public abstract class RateLimiter {\n     long microsToWait;\n     synchronized (mutex) {\n       long nowMicros = readSafeMicros();\n-      if (nextFreeTicketMicros > nowMicros + timeoutMicros) {\n+      if (nextFreeTicketMicros - timeoutMicros > nowMicros) {\n         return false;\n       } else {\n         microsToWait = reserveNextTicket(permits, nowMicros);\n```\n\nBonus question: should #tryAcquire accept negative timeouts?\n", "url": "https://github.com/google/guava/issues/1622", "user": "gissuebot", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2014-10-31 17:53:19", "closed": "2014-11-01 02:12:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Lists.transform() throws a NoSuchElementException if an IndexOutOfBoundsException is raised", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1606) created by **amanteaux** on 2013-12-09 at 05:51 PM_\n\n---\n\nWhile a list transformation through Lists.transform(), if the transform function raises an IndexOutOfBoundsException, then a NoSuchElementException is thrown.\nThe main problem is that the IndexOutOfBoundsException will never appear in the NoSuchElementException stack trace, so the error source is hard to find.\n\nThe problem seems to only occur with IndexOutOfBoundsException. If a plain RuntimeException is thrown inside the transform function, the RuntimeException will correctly by thrown again by Lists.transform().\n\nThe problem is present at least in Guava 14 and 15.\n", "url": "https://github.com/google/guava/issues/1606", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:52:46", "closed": "2014-11-01 01:54:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FluentIterable.toArray() should probably accept a Class<? super E>", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1603) created by **kevinb@google.com** on 2013-12-05 at 04:39 PM_\n\n---\n\nThe following ought to compile, no?\n\nNumber[] na = FluentIterable.from(Arrays.asList(1)).toArray(Number.class);\n\nI'm not sure why it doesn't, unless we just forgot. I think if we add a &lt;T super E> and accept Class&lt;T> everything should work.\n", "url": "https://github.com/google/guava/issues/1603", "user": "gissuebot", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:52:39", "closed": "2015-10-15 19:31:31", "commits": {}, "ttf": 349.0002777777778, "commitsDetails": []}, {"title": "Iterables.removeIfFromRandomAccessList(..) not working with Lists prohibiting duplicates", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\n\n---\n\nThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\n\n\"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare.\" (java.util.List, JavaDoc).\n\nWhen a list prohibits duplicates, \ncom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \nleads to exceptions, because an element temporarily may be contained muiltple times in the list. \nThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\n\nSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\n", "url": "https://github.com/google/guava/issues/1596", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:52:25", "closed": "2015-10-22 18:04:21", "commits": {"1a1b97ee1f065d0bc52c91eeeb6407bfaa6cbea1": {"commitGHEventType": "referenced", "commitUser": "cgdecker"}}, "ttf": 356.0002777777778, "commitsDetails": [{"commitHash": "1a1b97ee1f065d0bc52c91eeeb6407bfaa6cbea1", "commitGHEventType": "referenced", "commitUser": "cgdecker", "commitParents": ["bde81523d94478e145583eb5b1687c8aad280a1b"], "nameRev": "1a1b97ee1f065d0bc52c91eeeb6407bfaa6cbea1 tags/v20.0-rc1~718", "commitMessage": "Fix Iterables.removeIfFromRandomAccessList to handle Lists for which set() throws IAE (for example, if the list disallows duplicate elements).\n\nFixes Guava issue #1596\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=105826920\n", "commitDateTime": "2015-10-20 09:48:16", "authoredDateTime": "2015-10-19 21:13:28", "commitGitStats": [{"filePath": "guava-gwt/test/com/google/common/collect/IterablesTest_gwt.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "guava-tests/test/com/google/common/collect/IterablesTest.java", "insertions": 33, "deletions": 0, "lines": 33}, {"filePath": "guava/src/com/google/common/collect/Iterables.java", "insertions": 7, "deletions": 2, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "IterablesTest_gwt.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.IterablesTest_gwt.testRemoveIf_randomAccess_notPermittingDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "IterablesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_transformedList()", "TOT": 7, "UPD": 5, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.create(java.lang.String[])", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_noRandomAccess()", "TOT": 8, "UPD": 4, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.create(java.lang.String[]).19", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testConsumingIterable_queue_iterator().20", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_noRandomAccess().17", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_noRandomAccess().18", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_transformedList().14", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_transformedList().16", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_transformedList().15", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.IterablesTest.testRemoveIf_randomAccess_notPermittingDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Iterables.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.Iterables.removeIfFromRandomAccessList(java.util.List,com.google.common.base.Predicate)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1a1b97ee1f065d0bc52c91eeeb6407bfaa6cbea1"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7, "deletions": 2, "lines": 9, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect"], "changesInPackagesSPOON": ["com.google.common.collect.Iterables.removeIfFromRandomAccessList(java.util.List,com.google.common.base.Predicate)"]}, {"title": "TypeToken.equals() is incorrect for some array type combinations", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1590) created by **chris.th...@bronto.com** on 2013-11-25 at 08:17 PM_\n\n---\n\nThe following sample code displays the issue,\n\nTypeToken<?> b0 = new TypeToken&lt;byte[]>() {};\nTypeToken<?> b1 = TypeToken.of(byte[].class);\n\nSystem.out.println(b0.equals(b1));\nSystem.out.println(b0.isAssignableFrom(b1));\nSystem.out.println(b1.isAssignableFrom(b0));\n\nI would expect all of these comparisons to return true, but the first instead prints false. In the first case (b0) the byte[] type is represented internally as an instance of GenericArrayTypeImpl. The equals() on GenericArrayTypeImpl will only attempt a comparison to other GenericArrayType subclasses. I believe this equals method should also handle comparison to non-generic array types when appropriate.\n", "url": "https://github.com/google/guava/issues/1590", "user": "gissuebot", "labels": ["package=reflect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:52:12", "closed": "2015-04-10 20:21:27", "commits": {}, "ttf": 161.00027777777777, "commitsDetails": []}, {"title": "SetView size is 1 when the contents are the null set", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1588) created by **ben...@basistech.com** on 2013-11-22 at 12:43 PM_\n\n---\n\nIf I use Sets.difference to subtract two sets such that the difference is empty, the resulting SetView seems wrong to me. \n\nIt returns 1 for size()\ntoString  renders \"[null]\"\niterator().hasNext() returns true\niterator().next() return null\n", "url": "https://github.com/google/guava/issues/1588", "user": "gissuebot", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2014-10-31 17:52:08", "closed": "2014-11-01 01:50:31", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "AbstractMultimap.replaceValues(Iterable) throws Exception when trying to replace a collection with itself.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1584) created by **causis** on 2013-11-19 at 07:48 PM_\n\n---\n\nWhen calling replaceValues on a Multimap using the same collection being replaced as a parameter, the method throws a ConcurrentModificationException. This is because AbstractMultimap.replaceValues takes the collection being replaced, clears it, and then iterates over the parameter to fill it. It should check if the parameter and the old collection are the same instance, and if that happens, it shouldn't do anything.\nHere's a test to reproduce the problem:\n\n```\npublic void testMultimap() {\n    SortedSetMultimap<Long, Long> multimap = TreeMultimap.create();\n    multimap.put(1L, 2L);\n\n    multimap.replaceValues(1L, multimap.get(1L));\n}\n```\n\nIn case this use isn't allowed, it should throw a more declarative Exception and explain this on the method's javadoc.\n", "url": "https://github.com/google/guava/issues/1584", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:51:59", "closed": "2015-10-23 15:52:01", "commits": {}, "ttf": 356.0002777777778, "commitsDetails": []}, {"title": "Running tests in a non-US locale might fail", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\n\n---\n\nFailed tests: \n&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\n&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\n&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\n&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\n&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\n&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\n&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\n&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\n&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\n&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\n&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\n&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\n\n@@\n\nInstead of:\n\nString.format(\"%.4g %s\", value, abbreviate(unit));\n\nyou might want to use:\n\nString.format(Locale.ROOT, \"%.4g %s\", value, abbreviate(unit));\n\n@@\n\nYou might want to check the entire codebase for usages of String.format without an explicit Locale.\n", "url": "https://github.com/google/guava/issues/1567", "user": "gissuebot", "labels": ["package=general", "status=fixed", "type=defect"], "created": "2014-10-31 17:51:23", "closed": "2015-01-14 19:02:55", "commits": {"651774d3734a0f72dd7bccab9e57bd9579cfff0e": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 75.00027777777778, "commitsDetails": [{"commitHash": "651774d3734a0f72dd7bccab9e57bd9579cfff0e", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["a94c53e0ebafa03384d174aad024fa74430640f5"], "nameRev": "651774d3734a0f72dd7bccab9e57bd9579cfff0e tags/v19.0-rc1~329", "commitMessage": "Pass a Locale to String.format calls.\nThen, run Guava tests in locale hi-IN to catch future dependencies on the default locale.\nFinally, as a convenience in debugging problems, write Maven logs in UTF-8 rather than ASCII. (This is likely already the case in \"normal\" Maven runs, but our guava_moe_test target was stuck on ASCII.)\n\nThis CL covers all the String.format calls in Guava, fixing <https://github.com/google/guava/issues/1567>. There are many other calls in internal com.google.common code. We may want to consider additional testing and avoidance strategies, e.g., a RootLocale.format convenience method and an error-prone check for no-Locale calls.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=83859950\n", "commitDateTime": "2015-01-14 13:33:25", "authoredDateTime": "2015-01-13 10:48:56", "commitGitStats": [{"filePath": "guava-testlib/src/com/google/common/collect/testing/Platform.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java", "insertions": 7, "deletions": 6, "lines": 13}, {"filePath": "guava-testlib/src/com/google/common/collect/testing/testers/Platform.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "guava-testlib/src/com/google/common/testing/GcFinalization.java", "insertions": 10, "deletions": 6, "lines": 16}, {"filePath": "guava-testlib/test/com/google/common/collect/testing/features/FeatureEnumTest.java", "insertions": 17, "deletions": 12, "lines": 29}, {"filePath": "guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java", "insertions": 14, "deletions": 9, "lines": 23}, {"filePath": "guava-tests/pom.xml", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/collect/FauxveridesTest.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "guava-tests/test/com/google/common/hash/HashingTest.java", "insertions": 9, "deletions": 8, "lines": 17}, {"filePath": "guava-tests/test/com/google/common/primitives/CharsTest.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/GeneratedMonitorTest.java", "insertions": 8, "deletions": 6, "lines": 14}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/RateLimiterTest.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/ServiceTest.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/ThreadFactoryBuilderTest.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "guava/src/com/google/common/base/Stopwatch.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "guava/src/com/google/common/cache/CacheBuilderSpec.java", "insertions": 9, "deletions": 4, "lines": 13}, {"filePath": "guava/src/com/google/common/eventbus/EventBus.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava/src/com/google/common/net/InetAddresses.java", "insertions": 9, "deletions": 6, "lines": 15}, {"filePath": "guava/src/com/google/common/util/concurrent/RateLimiter.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java", "insertions": 3, "deletions": 1, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": ["651774d3734a0f72dd7bccab9e57bd9579cfff0e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 58, "deletions": 30, "lines": 88, "gitFilesChange": 11}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava-testlib/src/com/google/common/collect/testing/testers", "guava/src/com/google/common/util/concurrent", "guava/src/com/google/common/cache", "guava/src/com/google/common/net", "guava/src/com/google/common/base", "guava-testlib/src/com/google/common/collect/testing/features", "guava-testlib/src/com/google/common/testing", "guava/src/com/google/common/eventbus", "guava-testlib/src/com/google/common/collect/testing"]}, {"title": "Serialization & Deserilization of bloom filter not working...", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1564) created by **saravanan77** on 2013-10-30 at 05:30 AM_\n\n---\n\n// Serialize\nObjectOutputStream objectWriter = new ObjectOutputStream(new FileOutputStream(\"bloomfilter.obj\"));\nobjectWriter.writeObject(bloomFilter);\nobjectWriter.flush();\nobjectWriter.close();\n\n// Deserialize\nObjectInputStream readerObject = new ObjectInputStream(new FileInputStream(inputFile+\".obj\"));\nBloomFilter&lt;String> bloomFilterAfterDes = (BloomFilter&lt;String>) readerObject.readObject();\nreaderObject.close();\n\nbloomFilterAfterDes.mightContains call returns false even when the element available in bloomFilterAfterDes but bloomFilter instance returns proper value.\n", "url": "https://github.com/google/guava/issues/1564", "user": "gissuebot", "labels": ["package=hash", "status=invalid", "type=defect"], "created": "2014-10-31 17:51:17", "closed": "2014-11-01 01:46:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Inconsistency between Ints and Longs in tryParse", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1563) created by **Maaartinus** on 2013-10-28 at 05:41 AM_\n\n---\n\nAs requested in\nhttps://mail.google.com/mail/ca/u/0/#label/8-java%2Fguava/141e7f32e0596002\nI'm filing this as bug.\n\nCurrently, Ints.tryParse accepts non-ASCII digits, while Long.tryParse does not. This is both undocumented and inconsistent. The questions are\n- Should non-ascii digits be accepted?\n- If so, should even mixed numbers like DEVANAGARI_DIGIT_ONE + \"\" + BENGALI_DIGIT_TWO be accepted?\n\nNote also that currently the fastest way to parse an Integer is via Longs.tryParse (this doesn't necessarily mean that accepting non-ASCII must cause a slowdown).\n\nhttps://microbenchmarks.appspot.com/runs/f32a811c-aeb5-40ac-ae48-07b60256838f\n", "url": "https://github.com/google/guava/issues/1563", "user": "gissuebot", "labels": ["package=primitives", "status=research", "type=defect"], "created": "2014-10-31 17:51:15", "closed": "2016-12-28 17:44:54", "commits": {}, "ttf": 788.0002777777778, "commitsDetails": []}, {"title": "Iterables.toArray broken in case of concurrent modifications", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\n\n---\n\nIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\n\nThe documentation says \"return a newly-allocated array into which all the elements of the iterable have been copied\", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\n\nIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\n\nThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\n", "url": "https://github.com/google/guava/issues/1558", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:51:04", "closed": "2015-10-09 18:46:38", "commits": {"0cdfef602bc04513efe9a7a4c2821d71f9dcf00d": {"commitGHEventType": "referenced", "commitUser": "lowasser"}}, "ttf": 343.0002777777778, "commitsDetails": [{"commitHash": "0cdfef602bc04513efe9a7a4c2821d71f9dcf00d", "commitGHEventType": "referenced", "commitUser": "lowasser", "commitParents": ["80b78c8ba68e32963e1684787a10b7f78c91e81a"], "nameRev": "0cdfef602bc04513efe9a7a4c2821d71f9dcf00d tags/v20.0-rc1~734", "commitMessage": "Rewrite Iterables.toArray to work correctly in the presence of concurrent modification (https://github.com/google/guava/issues/1558).\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=105071914\n", "commitDateTime": "2015-10-12 09:39:24", "authoredDateTime": "2015-10-09 11:06:04", "commitGitStats": [{"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "guava/src/com/google/common/collect/Iterables.java", "insertions": 4, "deletions": 6, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Iterables.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.Iterables.toCollection(java.lang.Iterable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.Iterables.toArray(java.lang.Iterable,java.lang.Object[])", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.Iterables.toArray(java.lang.Iterable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.collect.Iterables.toArray(java.lang.Iterable,java.lang.Class)", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 3}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0cdfef602bc04513efe9a7a4c2821d71f9dcf00d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7, "deletions": 9, "lines": 16, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 10, "UPD": 3, "INS": 1, "MOV": 3, "DEL": 3, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/collect", "guava-gwt/src-super/com/google/common/collect/super/com/google/common"], "changesInPackagesSPOON": ["com.google.common.collect.Iterables.toCollection(java.lang.Iterable)", "com.google.common.collect.Iterables.toArray(java.lang.Iterable)", "com.google.common.collect.Iterables.toArray(java.lang.Iterable,java.lang.Object[])", "com.google.common.collect.Iterables.toArray(java.lang.Iterable,java.lang.Class)"]}, {"title": "Serialization for ImmutableMap (and probably others) class fails with circular graphs.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1554) created by **jihokim** on 2013-10-11 at 05:47 PM_\n\n---\n\nA ClassCastException is thrown when there is a circularity in the object graph involving an ImmutableMap.\n\nFrom experimentation, it looks like the order in which objects are serialized matters.  The ClassCastException may not occur if a different object in the object graph cycle is (de)serialized \"first\".\n\nAlso, from the looks of it, other collection classes suffer the same fault where the static inner SerializedForm does not extend the appropriate interface/classes.  The attached file shows the problem in ImmutableBiMap:\n\nException in thread \"main\" java.lang.ClassCastException: cannot assign instance of com.google.common.collect.ImmutableBiMap$SerializedForm to field ImmutableMapSerialization.map of type com.google.common.collect.ImmutableMap in instance of ImmutableMapSerialization\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectStreamClass$FieldReflector.setObjFieldValues(ObjectStreamClass.java:2063)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectStreamClass.setObjFieldValues(ObjectStreamClass.java:1241)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1970)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1888)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1771)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1347)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1685)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1341)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1964)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1888)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1771)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1347)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectInputStream.readObject(ObjectInputStream.java:369)\n&nbsp;&nbsp;&nbsp;&nbsp;at ImmutableMapSerialization.main(ImmutableMapSerialization.java:31)\n", "url": "https://github.com/google/guava/issues/1554", "user": "gissuebot", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:50:56", "closed": "2015-10-08 19:46:39", "commits": {}, "ttf": 342.0002777777778, "commitsDetails": []}, {"title": "Possible classloader leak caused by Striped64", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1553) created by **patric.rufflar** on 2013-10-09 at 01:47 PM_\n\n---\n\nIt seems that web applications which are using guava cache might face a memory leak.\nAfter several redeployments, the application container crashes or stalls with an OutOfMemoryError.\n\nWhen looking at the corresponding heap dump in these cases it seems that something is keeping the web application classloaders alive.\nThe only GC root to the classloader is the following path:\n## Class Name                                                     | Shallow Heap | Retained Heap\n\n&lt;classloader> class com.google.common.cache.Striped64$HashCode |            8 |            64\n|- &lt;class> com.google.common.cache.Striped64$HashCode          |           16 |            16\n|  '- value java.lang.ThreadLocal$ThreadLocalMap$Entry         |           32 |            48\n|     '- [9] java.lang.ThreadLocal$ThreadLocalMap$Entry[32]    |          144 |           880\n|        '- table java.lang.ThreadLocal$ThreadLocalMap         |           24 |           904\n## |           '- threadLocals com.caucho.env.thread2.ResinThread2|          136 |         1.296\n\n(ResinThread2 is just extending java.lang.Thread, so in fact, the GC roots are originating from java.lang.Thread.threadLocals)\n\nAs you can see, com.google.common.cache.Striped64$HashCode is still referenced by a ThreadLocal.\nThis ThreadLocal and its initial value (which is the Striped64$HashCode instance) is created here:\n\nhttps://github.com/google/guava/blob/d6da7d86a2cab91bb3d33d983ccf5b07de14cc20/guava/src/com/google/common/cache/Striped64.java#L144\n\nHowever, neither the static ThreadLocal (respectively its actual subclass ThreadHashCode) nor its value is cleared at any time later.\nAs a result, as long as the Thread (which created the ThreadLocal) is alive, will keep its classloader alive.\nFor regular applications this might often not be an issue, however, for application servers which reuses/shares Threads across web applications this will cause classloader leaks.\n", "url": "https://github.com/google/guava/issues/1553", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:50:54", "closed": "2014-11-01 02:23:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Duplicated EventHandler Registration on the Generic method", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1549) created by **dreamershl** on 2013-10-04 at 08:04 AM_\n\n---\n\nabstract class baseclass&lt;T>\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public abstract void onChange1(configclass p);\n\n```\npublic abstract void onChange2(T p);\n```\n\n}\n\nclass childclassforeventbus extends baseclass&lt;configclass> \n{\n&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffOverride\n&nbsp;&nbsp;&nbsp;&nbsp;public void onChange1(configclass p)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n```\n@Override  @Subscribe\npublic void onChange2(configclass p)\n{\n}\n```\n\n}\n\nIf register a generice event handler, it will automatically register 2 handlers, the actual handler and raw type handler, \"onChange2(configclass)\" & \"onChange2(Object)\". \n\nShould enhance the \"findAllHandlers\" to bypass the raw type handler. Otherwise, the generic handler will be called twice!\n", "url": "https://github.com/google/guava/issues/1549", "user": "gissuebot", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 17:50:45", "closed": "2014-11-01 02:16:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CycleDetectingLockFactory not able to detect deadlock for a case.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1538) created by **nitin.taur** on 2013-09-17 at 09:56 AM_\n\n---\n\nAttached is the source for deadlock creation. I created lock as following and excepted exception to be thrown or at least some console output:\n\nLock _lock = CycleDetectingLockFactory.newInstance(Policies.THROW).newReentrantLock(DeadLock.class.getName()+INTEGER.incrementAndGet());\n", "url": "https://github.com/google/guava/issues/1538", "user": "gissuebot", "labels": ["package=concurrent", "status=duplicate", "type=defect"], "created": "2014-10-31 17:50:22", "closed": "2016-04-26 14:15:35", "commits": {}, "ttf": 542.0002777777778, "commitsDetails": []}, {"title": "Guava 15 cannot be deployed in an environment using CDI 1.0 such as JEE6", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1527) created by **thomas.lorblanches** on 2013-09-11 at 12:49 PM_\n\n---\n\nI had no problem previously with Guava 14.0.1, but with the new Guava 15.0 my application cannot be deployed anymore on JBoss AS 7.1.1.\nMaybe this is linked to issue #\ufeff1433 ?\n\nHere is the stacktrace:\n\n14:44:39,174 ERROR [org.jboss.msc.service.fail](MSC service thread 1-4) MSC00001: Failed to start service jboss.deployment.unit.\n\"ResourceIT.war\".WeldService: org.jboss.msc.service.StartException in service jboss.deployment.unit.\"ResourceIT.war\".WeldService:\n&nbsp;com.google.common.collect.ComputationException: java.lang.ArrayIndexOutOfBoundsException: 3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.as.weld.services.WeldService.start(WeldService.java:83)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1811) [jboss-msc-1.0.2.GA.jar:1.0.2\n.GA]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.msc.service.ServiceControllerImpl$StartTask.run(ServiceControllerImpl.java:1746) [jboss-msc-1.0.2.GA.jar:1.0.2.GA]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_21]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_21]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:722) [rt.jar:1.7.0_21]\nCaused by: com.google.common.collect.ComputationException: java.lang.ArrayIndexOutOfBoundsException: 3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingMapAdapter.get(ComputingConcurrentHashMap.java:397)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer.loadClass(ClassTransformer.java:149)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.&lt;init>(WeldClassImpl.java:139)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.of(WeldClassImpl.java:118)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:49)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:40)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference.compute(ComputingConcurrentHashMap.java:355)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.compute(ComputingConcurrentHashMap.java:184)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.getOrCompute(ComputingConcurrentHashMap.java:153)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap.getOrCompute(ComputingConcurrentHashMap.java:69)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingMapAdapter.get(ComputingConcurrentHashMap.java:393)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer.loadClass(ClassTransformer.java:149)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.&lt;init>(WeldClassImpl.java:139)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.of(WeldClassImpl.java:118)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:49)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:40)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference.compute(ComputingConcurrentHashMap.java:355)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.compute(ComputingConcurrentHashMap.java:184)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.getOrCompute(ComputingConcurrentHashMap.java:153)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap.getOrCompute(ComputingConcurrentHashMap.java:69)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingMapAdapter.get(ComputingConcurrentHashMap.java:393)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer.loadClass(ClassTransformer.java:149)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.bootstrap.BeanDeployer.addClass(BeanDeployer.java:86)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.bootstrap.BeanDeployer.addClasses(BeanDeployer.java:115)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.bootstrap.BeanDeployment.createBeans(BeanDeployment.java:171)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.bootstrap.WeldBootstrap.deployBeans(WeldBootstrap.java:336)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.as.weld.WeldContainer.start(WeldContainer.java:82)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.as.weld.services.WeldService.start(WeldService.java:76)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... 5 more\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldConstructorImpl.&lt;init>(WeldConstructorImpl.java:103)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldConstructorImpl.of(WeldConstructorImpl.java:66)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.&lt;init>(WeldClassImpl.java:205)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.introspector.jlr.WeldClassImpl.of(WeldClassImpl.java:118)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:49)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at org.jboss.weld.resources.ClassTransformer$TransformTypeToWeldClass.apply(ClassTransformer.java:40)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference.compute(ComputingConcurrentHashMap.java:355)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.compute(ComputingConcurrentHashMap.java:184)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment.getOrCompute(ComputingConcurrentHashMap.java:153)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap.getOrCompute(ComputingConcurrentHashMap.java:69)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComputingConcurrentHashMap$ComputingMapAdapter.get(ComputingConcurrentHashMap.java:393)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... 32 more\n", "url": "https://github.com/google/guava/issues/1527", "user": "gissuebot", "labels": ["package=general", "status=fixed", "type=defect"], "created": "2014-10-31 17:49:59", "closed": "2014-11-01 02:24:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Preconditions.checkNotNull(T reference [ ... ]) should be: checkNotNull(@Nullable T reference [ ... ])", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1524) created by **ceefour666** on 2013-09-06 at 09:27 AM_\n\n---\n\nPreconditions.checkNotNull triggers null reference warnings in Eclipse IDE,\nwhich is understandable because the \"reference\" method argument may be null,\nhowever as of 14.0.1 it's not yet marked as @\ufeffNullable in Preconditions.checkNotNull.\n", "url": "https://github.com/google/guava/issues/1524", "user": "gissuebot", "labels": ["package=base", "status=duplicate", "type=defect"], "created": "2014-10-31 17:49:53", "closed": "2014-11-01 01:40:18", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ByteStreams.join no longer supports infinite-length inputs in Guava 15", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1516) created by **g...@maginatics.com** on 2013-08-28 at 05:17 AM_\n\n---\n\nGuava 14 supported this and the following construct could generate infinite-length InputStream:\n\n```\npublic static InputStream repeatingByteArrayInputStream(final byte[] input)\n        throws IOException {\n    return ByteStreams.join(Iterables.cycle(ImmutableList.of(\n            ByteStreams.newInputStreamSupplier(input)))).getInput();\n}\n```\n", "url": "https://github.com/google/guava/issues/1516", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:49:36", "closed": "2014-11-01 01:43:43", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NoClassDefFoundError on Finalizer$ShutDown", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1505) created by **jgl...@cloudbees.com** on 2013-08-14 at 03:22 AM_\n\n---\n\nSee https://issues.jenkins-ci.org/browse/JENKINS-19192 for background. The copy of FinalizableReferenceQueue in the JNR library fails to initialize over the Jenkins remote class loading layer. I have not tracked this down in a debugger yet, but I think I know what is happening based on code inspection (originally in the JNR copy, but the current Guava trunk sources show the same flaw).\n\nDecoupledLoader catches Exception, which would include ClassNotFoundException, in case the URLClassLoader it constructs according to some guesswork cannot in fact find Finalizer.class. If the ClassLoader which loaded FinalizableReferenceQueue and friends was somehow special\u2014i.e. did not produce URLs from getResource which could automatically load related classes\u2013then this load would fail, but that is OK since the CNFE would be caught and the next loader tried.\n\nThe problem seems to be that Finalizer also refers to a nested class ShutDown. If the original ClassLoader is unusual in any way (as the Jenkins remoting class loader certainly is, due to various optimizations), it could happen that the base URL is capable of loading Finalizer.class but not Finalizer$ShutDown.class. In that case a NoClassDefFoundError would be thrown, and as this is not caught, the whole initialization sequence would fail.\n\nI would recommend either\n1. Catching LinkageError, or at least NoClassDefFoundError, in addition to Exception.\n2. Removing the ShutDown nested class and just using e.g. java.lang.Error with a special detail message for the control flow you need.\n", "url": "https://github.com/google/guava/issues/1505", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:49:12", "closed": "2014-11-01 01:38:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Race condition in AbstractFuture.addListener(...)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1496) created by **frens...@frensjan.nl** on 2013-08-05 at 07:37 PM_\n\n---\n\nI'm using a library built on guava (Cassandra CQL  java driver from DataStax) which allows asynchronous execution of queries. That is, the ResultSetFuture allows to get(...) with a timeout and also to add a listener which is called when the result is available. Internally this depends on AbstractFuture.addListener(...)\n\nI'm wondering whether the behaviour of AbstractFuture related to addListener(...) can be considered a race condition. I tend to think so: the documentation of ListenableFuture.addListener(...) indicates that 'The listener will run when the Future's computation is complete or, if the computation is already complete, immediately'.\n\nHowever, looking at the AbstractFuture implementation, I cannot identify code which would result in this behavior. If set(...) is called after addListener(...), the listeners are run. However, if the set(...) method is called before addListener(...), the added listener never gets run since it is only added to the executionList.\n\nI think I have witnessed this behavior in the aforementioned Cassandra CQL java driver. I hammer a Cassandra cluster with asynchronous queries until a maximum amount of queries is pending. The pending counter gets decremented when a listener to the ResultSetFuture (which extends AbstractFuture) is ran. However, many of them don't get run. Which can be explained given my 'race condition in AbstractFuture.addListener(...) hypothesis'.\n", "url": "https://github.com/google/guava/issues/1496", "user": "gissuebot", "labels": ["package=concurrent", "status=invalid", "type=defect"], "created": "2014-10-31 17:48:53", "closed": "2014-11-01 01:33:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MinMaxPriorityQueue.add violates java.util.Queue.add contract", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1482) created by **leonov** on 2013-07-19 at 07:46 AM_\n\n---\n\nThe contract for java.util.Queue.add(E) states: Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an _IllegalStateException_ if no space is currently available.\n\nMinMaxPriorityQueue.add(E) states: Adds the given element to this queue. If this queue has a maximum size, after adding element the queue will automatically evict its greatest element (according to its comparator), which may be element itself.\n\nThe description of the add method in MinMaxPriorityQueue gives implementation details, but at the end of the day evicting the element which was just added is the same as rejecting it.  So I think it violates the Queue.add contract.\n\nConsider the following client code (and please ignore it's stupidity).\n\npublic static void add5(final Queue&lt;Integer> queue){\n&nbsp;&nbsp;&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(5);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Added 5 to the queue\");\n&nbsp;&nbsp;&nbsp;}catch(IllegalStateException e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(\"Cannot add 5, queue full\");\n&nbsp;&nbsp;&nbsp;}\n}\n\nThe method add5(Queue) is agnostic to what kind of queue it gets.\n\nIf for example it is given a MinMaxPriorityQueue with maximumSize of 3 containing elements [1,2,3] the integer 5 will be immediately evicted.  But the method will succeed and print \"Added 5 to the queue\".\n", "url": "https://github.com/google/guava/issues/1482", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:48:24", "closed": "2014-11-01 01:31:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ServiceManager example deadlocks if service fails on startup ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1478) created by **a...@relational.io** on 2013-07-17 at 07:26 AM_\n\n---\n\nThe ServiceManager example located at https://google.github.io/guava/apidocs/com/google/common/util/concurrent/ServiceManager.html does not work.\n\nThe example deadlocks if any Service fails on startup. The call to `manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);`&nbsp;in the shutdown hook never returns.\n\nI can make the example work if I swap the Executor given to manager.addListener from a `MoreExecutors.sameThreadExecutor()`&nbsp;to a `Executors.newSingleThreadExecutor()`&nbsp;(or other alternative)\n\nGiven the following code:\n\n```\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.*;\n\nimport java.util.Set;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\npublic class DeadlockTest {\n\n    public static class ShutdownIgnoringLogManager extends LogManager {\n        @Override\n        public void reset() throws SecurityException {\n            // override reset() so logging handlers still work in shutdown hooks\n        }\n    }\n\n    static {\n        System.setProperty(\"java.util.logging.manager\", ShutdownIgnoringLogManager.class.getName());\n    }\n\n    static class TestService extends AbstractIdleService {\n        @Override\n        protected void startUp() throws Exception {\n            throw new IllegalStateException(\"failed\");\n        }\n\n        @Override\n        protected void shutDown() {\n        }\n    }\n\n    public static void main(String[] args) {\n        final Logger logger = Logger.getLogger(DeadlockTest.class.getName());\n\n        Set<Service> services = ImmutableSet.<Service>of(new TestService());\n        final ServiceManager manager = new ServiceManager(services);\n        manager.addListener(new ServiceManager.Listener() {\n            public void stopped() {}\n            public void healthy() {\n                // Services have been initialized and are healthy, start accepting requests...\n            }\n            public void failure(Service service) {\n                // Something failed, at this point we could log it, notify a load balancer, or take\n                // some other action.  For now we will just exit.\n                System.exit(1);\n            }\n        },\n                MoreExecutors.sameThreadExecutor()\n                //Executors.newSingleThreadExecutor()\n        );\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n                // requests.\n                try {\n                    logger.info(\"Shutting down services\");\n                    manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n                    logger.info(\"Successfully shut down services\");\n                } catch (TimeoutException timeout) {\n                    logger.severe(\"Shutdown timeout reached\");\n                }\n            }\n        });\n        manager.startAsync();  // start all the services asynchronously\n    }\n}\n```\n\nWhich is near-identical to the example \u2014 I've added a bit of logging and an actual Service to start.\nThis happens:\n\n```\nJul 17, 2013 5:24:06 PM com.google.common.util.concurrent.ServiceManager$ServiceListener startTimer\nINFO: Starting TestService [NEW]\nJul 17, 2013 5:24:06 PM com.google.common.util.concurrent.ServiceManager$ServiceListener failed\nSEVERE: Service TestService [FAILED] has failed in the STARTING state.\njava.lang.IllegalStateException: failed\n    at DeadlockTest$TestService.startUp(DeadlockTest.java:29)\n    at com.google.common.util.concurrent.AbstractIdleService$1$1.run(AbstractIdleService.java:43)\n    at java.lang.Thread.run(Thread.java:724)\n\nJul 17, 2013 5:24:06 PM com.google.common.util.concurrent.ServiceManager$ServiceListener finishedStarting\nINFO: Started TestService [FAILED] in 33 ms.\nJul 17, 2013 5:24:06 PM DeadlockTest$2 run\nINFO: Shutting down services\n```\n\nIt never completes.\n\nSwapping out the Executor for a different implementation allows the application gracefully shutdown.\n\nSystem:\n$ java -version\njava version \"1.7.0_25\"\nJava(TM) SE Runtime Environment (build 1.7.0_25-b15)\nJava HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)\n\n$ uname -a\nDarwin Adams-Mac-mini.local 12.4.0 Darwin Kernel Version 12.4.0: Wed May  1 17:57:12 PDT 2013; root:xnu-2050.24.15~1/RELEASE_X86_64 x86_64\n", "url": "https://github.com/google/guava/issues/1478", "user": "gissuebot", "labels": ["package=concurrent", "status=fixed", "type=defect"], "created": "2014-10-31 17:48:16", "closed": "2014-11-01 01:33:27", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.toString(File, Charset) puts an extra newline char to the result", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1474) created by **hangcsapda** on 2013-07-11 at 09:36 AM_\n\n---\n\nIf you read a text file with Files.toString(File, Charset) into a String, and your input file did not contain a newline at the end (blah-blahEOF), the resulting String will carry an extra (and I think redundant) newline char.\nIf it's a conscious behavior, I would suggest some warning into the javadocs.\n\nSystem: Linux amd64\nGuava: 14.0.1\njava version \"1.7.0_25\"\n", "url": "https://github.com/google/guava/issues/1474", "user": "gissuebot", "labels": ["package=io", "type=defect"], "created": "2014-10-31 17:48:07", "closed": "2020-01-13 21:10:57", "commits": {}, "ttf": 1900.0002777777777, "commitsDetails": []}, {"title": "Infinite loop in ClassPath with directories that contain cycles", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1465) created by **whosc...@cloudera.com** on 2013-07-02 at 02:04 AM_\n\n---\n\nWe just ran into a bug where the ClassPath helper runs in to an infinite loop (and eventually runs out of perm gen space) with directories that contain cycles (e.g. via symlinks). I believe guava should log and otherwise ignore such cycles. \n\nI posted two corresponding comments in a code review that describes a fix, here: https://github.com/google/guava/blob/fab8b9744496a0ebca5232863ab186b7ac63c8e0/guava/src/com/google/common/reflect/ClassPath.java#L269\n\nThoughts?\n", "url": "https://github.com/google/guava/issues/1465", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:47:48", "closed": "2014-11-01 01:30:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "getFileExtension return wrong result when path contains dot and filename without extension", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1462) created by **wajdyessam** on 2013-06-30 at 08:58 PM_\n\n---\n\nfrom getFileExtension docs:\n\n\"Returns the file extension for the given file name, or the empty string if the file has no extension\"\n\nthis working fine when the path like:\nD:\\Projects\\this file\n\nthe result is empty string.\n\nbut when the path is:\nD:\\Files.Projects\\this file\n\nthe result is not empty string, result is \"Projects\\this file\"\n\nsuggested solution to fix this:\n\npublic static String getFileExtension(String fileName) {\n&nbsp;checkNotNull(fileName);\n\n&nbsp;String extension = \"\";  \n&nbsp;int index = fileName.lastIndexOf(\"\\\");\n&nbsp;if ( index > 0 ) {  \n&nbsp;&nbsp;&nbsp;fileName= fileName.substring(index+1);\n&nbsp;}            \n\n&nbsp;index = fileName.lastIndexOf(\".\");\n&nbsp;if ( index > 0 ) {\n&nbsp;&nbsp;&nbsp;extension = fileName.substring(index+1);\n&nbsp;}\n\n&nbsp;return extension;\n}\n\nRegards,\n", "url": "https://github.com/google/guava/issues/1462", "user": "gissuebot", "labels": ["package=io", "status=obsolete", "type=defect"], "created": "2014-10-31 17:47:42", "closed": "2014-11-01 01:29:02", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Consider using an interface as the return value of the mutable collection factories.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1454) created by **j...@nwsnet.de** on 2013-06-24 at 04:13 PM_\n\n---\n\nMethods like Lists#newArrayList, Lists#newLinkedList, Sets#newHashSets etc. specify an actual implementation as the return value's type instead of an interface (List, Set, etc.). What is the rationale for that?\n\nThat was pointed out to me and I have to agree that this is surprising (haven't seen something like that in the JFC) and not what people should use in almost every case anyway (declare a constructed collection with an interface instead of the implementation, i.e. `List<Foo> foos = Lists.newArrayList();`).\n\nIt also gets in the way in test assertions, so given\n\n```\nSet<Integer> ids = instanceUnderTest.getIds();\n```\n\none has to write\n\n```\nassertThat(actual, is((Set<Integer>) Sets.newHashSet(1, 2, 3)));\n```\n\ninstead of\n\n```\nassertThat(actual, is(Sets.newHashSet(1, 2, 3)));\n```\n\nIn the case of ArrayList, there's at least Arrays#asList, but there's no equivalent for sets.\n", "url": "https://github.com/google/guava/issues/1454", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:47:25", "closed": "2014-11-01 01:28:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Predicates.assignableFrom is named backward, and its doc is backward, too", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\n\n---\n\nJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\n\nAnd the doc says: \"true if the class being tested is assignable from the given class\"\ufeff\nhttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\n\nBut it's the other way around.\n", "url": "https://github.com/google/guava/issues/1444", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:47:04", "closed": "2016-04-26 20:08:19", "commits": {"1de67afcb295c771fb00a98281c6becf74926e76": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 543.0002777777778, "commitsDetails": [{"commitHash": "1de67afcb295c771fb00a98281c6becf74926e76", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["ddda106332902b7b0888eb3b04b8c538e6f3e8d6"], "nameRev": "1de67afcb295c771fb00a98281c6becf74926e76 tags/v20.0-rc1~346", "commitMessage": "Predicates.subtypeOf, a correctly-named duplicate of Predicates.assignableFrom. Deprecate the latter. Add javadoc.\n\nhttps://github.com/google/guava/issues/1444\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=120843247\n", "commitDateTime": "2016-04-26 13:27:34", "authoredDateTime": "2016-04-26 13:03:24", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/base/PredicatesTest.java", "insertions": 19, "deletions": 17, "lines": 36}, {"filePath": "guava/src/com/google/common/base/Predicates.java", "insertions": 39, "deletions": 9, "lines": 48}], "commitSpoonAstDiffStats": [{"spoonFilePath": "PredicatesTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.PredicatesTest.testIsAssignableFrom_apply()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.PredicatesTest.testIsAssignableFrom_subclass()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.PredicatesTest.testIsAssignableFrom_interface()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.PredicatesTest.testIsAssignableFrom_equality()", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.PredicatesTest.testIsAssignableFrom_serialization()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.PredicatesTest.testSubtypeOf_equality()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Predicates.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.Predicates.assignableFrom(java.lang.Class)", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "com.google.common.base.Predicates.AssignableFromPredicate", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.Predicates.AssignableFromPredicate.equals(java.lang.Object)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.Predicates.AssignableFromPredicate.apply(java.lang.Class)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.Predicates.AssignableFromPredicate.hashCode()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.Predicates.AssignableFromPredicate.toString()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1de67afcb295c771fb00a98281c6becf74926e76"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 39, "deletions": 9, "lines": 48, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13, "UPD": 11, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/base"], "changesInPackagesSPOON": ["com.google.common.base.Predicates.AssignableFromPredicate.toString()", "com.google.common.base.Predicates.assignableFrom(java.lang.Class)", "com.google.common.base.Predicates.AssignableFromPredicate.equals(java.lang.Object)", "com.google.common.base.Predicates.AssignableFromPredicate", "com.google.common.base.Predicates.AssignableFromPredicate.apply(java.lang.Class)", "com.google.common.base.Predicates.AssignableFromPredicate.hashCode()"]}, {"title": "Unable to copy ArrayTable with ImmutableTable.copyOf", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1442) created by **corin.lawson** on 2013-06-10 at 06:56 AM_\n\n---\n\nThe attached test fails. Thanks.\n", "url": "https://github.com/google/guava/issues/1442", "user": "gissuebot", "labels": ["package=collect", "status=invalid", "type=defect"], "created": "2014-10-31 17:47:00", "closed": "2015-10-08 19:21:25", "commits": {}, "ttf": 342.0002777777778, "commitsDetails": []}, {"title": "Joiner.skipNulls() does not skip nulls if they were returned by Object.toString()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1434) created by **transparentpolitics** on 2013-05-30 at 04:41 AM_\n\n---\n\nIn  public Joiner.skipNulls() this code:\n\n```\n    while (parts.hasNext()) {\n      Object part = parts.next();\n      if (part != null) {\n        appendable.append(Joiner.this.toString(part));\n        break;\n      }\n    }\n    while (parts.hasNext()) {\n      Object part = parts.next();\n      if (part != null) {\n        appendable.append(separator);\n        appendable.append(Joiner.this.toString(part));\n      }\n    }\n```\n\nis wrong because it assumes that Joiner.this.toString(part) does not return null\n\nIn both loops there needs to be additional checks for Joiner.this.toString() returning a null\n", "url": "https://github.com/google/guava/issues/1434", "user": "gissuebot", "labels": ["package=base", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:46:43", "closed": "2014-11-01 01:28:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NavigableAsMap.headMap(K, boolean) Ignores Boolean Argument", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1423) created by **vydaeon** on 2013-05-22 at 09:45 PM_\n\n---\n\nThe NavigableAsMap.headMap method that takes a boolean \"inclusive\" argument passes a hard-coded false value to the delegate NavigableMap instead of passing the value of \"inclusive\".  This affects code that calls e.g. TreeMultimap.asMap().headMap(someValue, true).\n", "url": "https://github.com/google/guava/issues/1423", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:46:20", "closed": "2014-11-01 01:30:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "RegularImmutableSortedSet uses unsafeCompare in equals method", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1414) created by **mcarrieruri** on 2013-05-15 at 02:17 PM_\n\n---\n\nIssue: If I have two ImmutableSortedSets that each contain 1 object (call them objects a and b). Objects a and b are both of the same Type (call it Type). Type has overridden equals and compareTo methods. The equals method is a deep equals and the compareTo method just uses one of the fields to compare. This could result in the following behavior:\n\n((a.compareTo(b) == 0) != (a.equals(b)))\n\nThis is not advised but is allowed in the javadoc:\n\n\"It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"\"\n\nWith this in place two unequal sets can be considered equal because RegularImmutableSortedSet uses compareTo instead of equals.\n", "url": "https://github.com/google/guava/issues/1414", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:46:01", "closed": "2014-11-01 01:23:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NPE in ClassPath.scanDirectory() for directory without file system read permission", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1407) created by **whoschek** on 2013-05-10 at 08:57 PM_\n\n---\n\nHere is the code in question in ClassPath (trunk, but the same bug exists in the 14.0.1 release, and probably prior) \n\nprivate void scanDirectory(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File directory, ClassLoader classloader, String packagePrefix) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (File f : directory.listFiles()) {\n\ndirectory.listFiles() can return null, which causes an NPE. For example if the dir does not have Unix fs read permissions. We ran into this bug here today. I believe the correct fix is to ignore the directory if directory.listFiles() returns null. \n\nI left a comment to this effect as a code review here: https://github.com/google/guava/blob/c6c66536dc903ef9e870d3c8562d25808bbe66b2/guava/src/com/google/common/reflect/ClassPath.java#L298\n\nThoughts? \n", "url": "https://github.com/google/guava/issues/1407", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:45:46", "closed": "2014-11-01 01:22:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NullPointerException at ComparisonChain.compare after upgrade from java 6 to java 7", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1373) created by **m...@nimbustecnologia.com.br** on 2013-04-18 at 08:06 PM_\n\n---\n\nAfter upgrade from java 6 to java 7, the same code started to raise this exception when passing null objects to ComparisonChain:\n\nCaused by: java.lang.NullPointerException\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ComparisonChain$1.compare(ComparisonChain.java:72)\n\nWorkround:\n\nPrevent from compare any null object using ComparisonChain.compare\n", "url": "https://github.com/google/guava/issues/1373", "user": "gissuebot", "labels": ["package=collect", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:44:35", "closed": "2014-11-01 01:17:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Entry<TypeToken<? extends B>, B>.setValue(B) bypasses TypeToInstanceMap typesafe?", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1352) created by **jysjys1486** on 2013-03-26 at 09:07 AM_\n\n---\n\nI was curious as to whether setting the value of an entry from the entry set of TypeToInstanceMap would disrupt the type safety that TypeToInstanceMap attempts to ensure.  Should these entries be immutable to protect type safety? Has this already been brought up?\n\nSo far, it seems as if the forwarding map returns the entry set of the backing hash map, which can be modified.\n", "url": "https://github.com/google/guava/issues/1352", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:43:53", "closed": "2014-11-01 01:14:18", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "reflect.ClassPath.from() can throw StackOverflowError ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1351) created by **stephen.foust.christensen** on 2013-03-25 at 07:16 PM_\n\n---\n\nMy company uses Weblogic, and one of the provided JARs is net.sf.antcontrib_1.1.0.0_1-0b2.  (Can be found here: http://sourceforge.net/projects/ant-contrib/files/ant-contrib/ant-contrib-1.0b2/ )\n\nThis particular JAR references itself in its MANIFEST.MF 'Class-Path', which causes Guava's ClassPath.from() to throw a StackOverflowError.\n\nCould some circular-dependency protection be built into getClassPathFromManifest() to prevent returning a URI that matches the current file?  For example:\n\ntry {\n&nbsp;&nbsp;&nbsp;&nbsp;uri = getClassPathEntry(jarFile, path);\n} catch (URISyntaxException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;// Ignore bad entry\n&nbsp;&nbsp;&nbsp;&nbsp;logger.warning(\"Invalid Class-Path entry: \" + path);\n&nbsp;&nbsp;&nbsp;&nbsp;continue;\n}\n// New code\nif (jarFile.toURI().equals(uri)) {\n&nbsp;&nbsp;&nbsp;&nbsp;logger.warning(\"Invalid Class-Path entry: \" + path + \" references itself.\");\n&nbsp;&nbsp;&nbsp;&nbsp;continue;\n}\n\nA more complicated but more robust scheme could be in browseJar(), where the returned URIs from the manifest could be compared against the in-progress ImmutableSet of resources.  This would help guard against hierarchical dependency loops, if such a travesty existed.  There would be a bit more work involved to make this work, since currently the jarFile itself isn't processed until all of its Manifest has been.\n\nI realize this is the fault of the antcontrib project (or perhaps even Weblogic) and that it isn't the goal of Guava to try to handle odd edge cases like this.  My hope is that the market share of Weblogic might be enough to grant this some consideration.  Thanks!\n", "url": "https://github.com/google/guava/issues/1351", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:43:51", "closed": "2014-11-01 01:14:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Hashing.crc32() provides incorrect result", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1332) created by **izs...@live.ru** on 2013-03-13 at 06:15 PM_\n\n---\n\nJava 1.7 Update 15, Guava 14.0\n\nExample: Hashing.crc32().hashString(\"1234567890\").toString() gives e7033050, while the expected result, if I'm not wrong, is 261daee5.\n\nNot a character encoding problem as this also happens on byte data and, for example, MD5 hasher works properly.\n", "url": "https://github.com/google/guava/issues/1332", "user": "gissuebot", "labels": ["package=hash", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:43:13", "closed": "2014-11-01 01:11:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableSet.toArray issue on singletonImmutableSet for v14", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1328) created by **gokhanoner** on 2013-03-11 at 03:23 PM_\n\n---\n\nHi,\n\nprivate static final ImmutableSet&lt;String> ISLEM_EB_FIELDS = ImmutableSet.of(\"ISLBLG\");\n\nFor above desc, a singletonImmutableSet is created. When I try\n\nISLEM_EB_FIELDS.toArray(new String[0])\n\non V13.0.1, ist OK but in v14, it throw class not found exception for\n\ncom.google.common.collect.GwtPlatform.java\n\nI tried it on a GWT application.\n", "url": "https://github.com/google/guava/issues/1328", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:43:04", "closed": "2014-11-01 01:15:53", "commits": {"82810968135e9ac4c9120f44b0936d478492066e": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "82810968135e9ac4c9120f44b0936d478492066e", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["3f825ffd9d4485afeb70bb73fa10daf2facf0893"], "nameRev": "82810968135e9ac4c9120f44b0936d478492066e tags/v20.0-rc1~650", "commitMessage": "Remove support for deprecated GWT Dev Mode (but continue to support Super Dev Mode).\n\nRelated: https://github.com/google/guava/issues/1328\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=109588917\n", "commitDateTime": "2015-12-07 12:39:39", "authoredDateTime": "2015-12-07 09:31:17", "commitGitStats": [{"filePath": "guava-gwt/pom.xml", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/GwtPlatform.java", "insertions": 0, "deletions": 47, "lines": 47}, {"filePath": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "guava-gwt/src/com/google/common/collect/GwtPlatform.java", "insertions": 0, "deletions": 51, "lines": 51}, {"filePath": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/GwtPlatform.java", "insertions": 0, "deletions": 39, "lines": 39}, {"filePath": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/Platform.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "guava-gwt/test/com/google/common/collect/testing/GwtPlatform.java", "insertions": 0, "deletions": 39, "lines": 39}], "commitSpoonAstDiffStats": [{"spoonFilePath": "GwtPlatform.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.testing.GwtPlatform", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "Platform.java", "spoonMethods": [{"spoonMethodName": "com.google.common.collect.testing.Platform.clone(java.lang.Object[])", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["82810968135e9ac4c9120f44b0936d478492066e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 11, "deletions": 178, "lines": 189, "gitFilesChange": 6}, "spoonStatsSummary": {"TOT": 3, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 1, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava-gwt/src/com/google/common/collect", "guava-gwt/src-super/com/google/common/collect/super/com/google/common", "guava-gwt/test/com/google/common/collect/testing", "guava-gwt/test-super/com/google/common/collect/testing/super/com/google"], "changesInPackagesSPOON": ["com.google.common.collect.testing.GwtPlatform", "com.google.common.collect.testing.Platform.clone(java.lang.Object[])"]}, {"title": "ExecutionList is not threadsafe", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1324) created by **sylvain.laurent** on 2013-03-07 at 09:46 PM_\n\n---\n\n(Guava 14.0)\n\nExecutionList.execute() polls it \"runnables\" instance field without synchronizing on it. Since this is a java.util.LinkedList which is not thread-safe, then ExecutionList is not thread-safe.\n\nNon-safety could occur if :\n- a thread A is executing ExecutionList.execute(), regularly polling the LinkedList without synchronizing access on it.\n- another thread B executes ExecutionList.add(...), which adds an element to the LinkedList after synchronizing on it.\n", "url": "https://github.com/google/guava/issues/1324", "user": "gissuebot", "labels": ["package=concurrent", "status=invalid", "type=defect"], "created": "2014-10-31 17:42:56", "closed": "2014-11-01 01:09:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableTable.Builder builds array backed table for large sparse tables due to overflow error", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1322) created by **rma350** on 2013-03-07 at 12:19 AM_\n\n---\n\nWhen creating an ImmutableTable using a builder, the builder uses a heuristic to determine what data structure to use for storing data, as seen below from line 163 of RegularImmutableTable.java (in version 14.0):\n\n```\n// use a dense table if more than half of the cells have values\n// TODO(gak): tune this condition based on empirical evidence\nreturn (cellList.size() > ((rowSpace.size() * columnSpace.size()) / 2)) ?\n    new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace) :\n    new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);\n```\n\nIf the data for the table is large and sparse, then rowSpace.size()*columnSpace.size() may overflow to a negative number, causing a DenseImmutableTable to be created instead of a sparse one.  This in turn will use enough memory to crash the program on a large 2d array allocation.\n\nA minimal fix might be to change the logical condition to:\n\ncellList.size() > ((long)rowSpace.size()) \\* columnSpace.size()/2\n\nAttached is a short piece of code where a very sparse Table of 5,000,000 entries is created successfully, and then the ImmutableTable creating with the builder on the same data fails.\n", "url": "https://github.com/google/guava/issues/1322", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:42:52", "closed": "2014-11-01 01:21:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Calling startAndWait on a TERMINATED service returns RUNNING", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1288) created by **diwa...@maginatics.com** on 2013-02-15 at 01:18 AM_\n\n---\n\nThe following test FAILS:\n\n```\nfinal class NoOpService extends AbstractIdleService {\n    @Override\n    protected void shutDown() { }\n\n    @Override\n    protected void startUp() { }\n}\n\n@Test\npublic void testStartStopStart() {\n    Service service = new NoOpService();\n    assertThat(service.startAndWait()).isEqualTo(State.RUNNING);\n    assertThat(service.stopAndWait()).isEqualTo(State.TERMINATED);\n    // The assert below FAILS against 14rc2, returning RUNNING instead.\n    // The isRunning call later returns TERMINATED as expected though.\n    assertThat(service.startAndWait()).isEqualTo(State.TERMINATED);\n    assertThat(service.isRunning()).isFalse();\n}\n```\n", "url": "https://github.com/google/guava/issues/1288", "user": "gissuebot", "labels": ["package=concurrent", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:41:40", "closed": "2014-11-01 01:20:38", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName returns incorrect ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1287) created by **thomaschung415** on 2013-02-13 at 12:32 AM_\n\n---\n\nWhen I pass in \"http://www.appspot.com\" and try to get the topPrivateDomain for that guy, I get \"www.appspot.com\".  I believe it should be just \"appspot.com\".\n\n```\npublic static void main(String [] args) throws Exception {\n\n    URL url = new URL(\"http://www.appspot.com\");\n\n    InternetDomainName idn = InternetDomainName.from(url.getHost());\n    System.out.println(idn.topPrivateDomain().name());\n\n    // returns www.appspot.com but should be appspot.com instead\n}\n```\n", "url": "https://github.com/google/guava/issues/1287", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:41:38", "closed": "2014-11-01 01:05:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Cache.getIfPresent() and invalidate() don't use the generic type for the key", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1283) created by **dharkness** on 2013-02-07 at 10:59 PM_\n\n---\n\nIs there a reason that getIfPresent(key) and invalidate(key) accept `Object`&nbsp;for `key`\n\n```\nV getIfPresent(Object key)\n\nvoid invalidate(Object key)\n```\n\nwhereas get() uses the generic type `K`?\n\n```\nV get(K key, ...)\n```\n\nIt's not causing any problems AFAIK. I see that the first two are from 10.0 whereas get() was added in 11.0. Is this a backwards-compatibility issue?\n", "url": "https://github.com/google/guava/issues/1283", "user": "gissuebot", "labels": ["package=cache", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:41:29", "closed": "2014-11-01 01:05:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NPE in Joiner", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1272) created by **dpar...@netflix.com** on 2013-01-30 at 01:39 AM_\n\n---\n\nJoiner.on(',').useForNull(\"\").join(null,null,null) will fail with a NPE because of https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Joiner.java#L544.\n\nUsing one more or one fewer null will succeed.\n", "url": "https://github.com/google/guava/issues/1272", "user": "gissuebot", "labels": ["package=base", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:41:06", "closed": "2014-11-01 02:02:02", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "eventsToDispatch ThreadLocal not cleared by EventBus.dispatchQueuedEvents", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1263) created by **yazikkp** on 2013-01-20 at 11:36 AM_\n\n---\n\neventsToDispatch ThreadLocal is not getting cleared. \nScenario:\nIf we have multiple handlers to be called in a single thread, and the first handler throws exception, then the thread finishes its execution goes back to the thread pool, but with the remaining list of EventWithHandler in eventsToDispatch thread local. So when next time the same thread executes, the older handlers are getting called which is stale, along with the new handlers for the current thread.\n\nI suggest it should be like below code snippet:\n\nvoid dispatchQueuedEvents() {\n&nbsp;&nbsp;&nbsp;&nbsp;// don't dispatch if we're already dispatching, that would allow reentrancy\n&nbsp;&nbsp;&nbsp;&nbsp;// and out-of-order events. Instead, leave the events to be dispatched\n&nbsp;&nbsp;&nbsp;&nbsp;// after the in-progress dispatch is complete.\n&nbsp;&nbsp;&nbsp;&nbsp;if (isDispatching.get()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n```\nisDispatching.set(true);\ntry {\n  Queue<EventWithHandler> events = eventsToDispatch.get();\n  EventWithHandler eventWithHandler;\n  while ((eventWithHandler = events.poll()) != null) {\n    dispatch(eventWithHandler.event, eventWithHandler.handler);\n  }\n} finally {\n  isDispatching.remove();\n  eventsToDispatch.remove(); //This line is required.  \n}\n```\n\n&nbsp;&nbsp;}\n\nPlease excuse if my suggestion is wrong..\n", "url": "https://github.com/google/guava/issues/1263", "user": "gissuebot", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 17:40:47", "closed": "2014-11-01 01:03:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Splitter on zero-width pattern seems to eat last character", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1262) created by **kevinb@google.com** on 2013-01-18 at 11:00 PM_\n\n---\n\nFrom an internal user.\n\nI had this code:\n\n&nbsp;/*\\* A zero-width pattern that matches the boundary between digit and non-digit characters. */\n&nbsp;private static final Pattern DIGIT_BOUNDARY = Pattern.compile(\"(?<=\\d)(?=\\D)|(?<=\\D)(?=\\d)\");\n\n&nbsp;private static final Splitter SPLITTER = Splitter.on(DIGIT_BOUNDARY);\n\nCalling SPLITTER.split(\"0T\") results in [\"0\"], where I could expect [\"0\", \"T\"]. Strangely, calling Splitter.split(\"0Ta\") correctly results in [\"0\", \"Ta\"].\n\nFinally, calling DIGIT_BOUNDARY.split(\"0T\") creates the correct result, [\"0\", \"T\"]. \n", "url": "https://github.com/google/guava/issues/1262", "user": "gissuebot", "labels": ["package=base", "status=duplicate", "type=defect"], "created": "2014-10-31 17:40:45", "closed": "2014-11-01 01:00:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FluentIterable.transformAndConcat() won't accept a Function<A, List<? extends B>>", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1260) created by **sperling.karsten** on 2013-01-17 at 05:08 AM_\n\n---\n\nIt is currently\n\npublic &lt;T> FluentIterable&lt;T> transformAndConcat(Function<? super E, ? extends Iterable&lt;T>> function);\n\nHowever this can be relaxed to be more in line with the signature of Iterables.concat() to\n\npublic &lt;T> FluentIterable&lt;T> transformAndConcat(Function<? super E, ? extends Iterable<? extends T>> function);\n\nAs an example, the following code should be valid, but isn't with the current signature:\n\npublic class FluentIterableTest {\n\n&nbsp;&nbsp;public static interface A {}\n&nbsp;&nbsp;public static interface B {\n&nbsp;&nbsp;&nbsp;&nbsp;List<? extends A> getAs();\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;public List&lt;A> allAs(Collection<? extends B> bees) {\n&nbsp;&nbsp;&nbsp;&nbsp;return FluentIterable.from(bees)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.transformAndConcat(new Function&lt;B, List<? extends A>>() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffOverride\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public List<? extends A> apply(B input) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return input.getAs();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.toList();\n&nbsp;&nbsp;}\n}\n", "url": "https://github.com/google/guava/issues/1260", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:40:41", "closed": "2014-11-01 01:13:58", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InternetDomainName isn't compatible with GWT ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1253) created by **samb...@infoarmy.com** on 2013-01-10 at 06:01 AM_\n\n---\n\ni am trying to include InternetDomainName class which is GWT compatible. did inherited Net.gwt.xml in my module and using guava-14.0-rc1 and guava-gwt-14.0-rc1 packages. but it still throwing this exception during compilation.\n\n&nbsp;[ERROR] An internal compiler exception occurred\ncom.google.gwt.dev.jjs.InternalCompilerException: Failed to get JNode\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.TypeMap.get(TypeMap.java:140)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.TypeMap.get(TypeMap.java:71)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap.getType(BuildTypeMap.java:730)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap.access$000(BuildTypeMap.java:99)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap$BuildDeclMapVisitor.visit(BuildTypeMap.java:195)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:237)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:127)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.IfStatement.traverse(IfStatement.java:245)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:239)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1239)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:687)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap.createPeersForNonTypeDecls(BuildTypeMap.java:637)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap.exec(BuildTypeMap.java:514)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.impl.BuildTypeMap.exec(BuildTypeMap.java:523)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.precompile(JavaToJavaScriptCompiler.java:599)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.jjs.JavaScriptCompiler.precompile(JavaScriptCompiler.java:33)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Precompile.precompile(Precompile.java:284)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Precompile.precompile(Precompile.java:233)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Precompile.precompile(Precompile.java:145)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Compiler.run(Compiler.java:232)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Compiler.run(Compiler.java:198)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Compiler$1.run(Compiler.java:170)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.CompileTaskRunner.doRun(CompileTaskRunner.java:88)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.CompileTaskRunner.runWithAppropriateLogger(CompileTaskRunner.java:82)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.Compiler.main(Compiler.java:177)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] &lt;no source info>: public final class com.google.common.net.InternetDomainName\n&nbsp;&nbsp;&nbsp;&nbsp;extends java.lang.Object\n/\\*   fields   _/\nprivate static final [unresolved] Unresolved type com.google.common.base.CharMatcher DOTS_MATCHER\nprivate static final [unresolved] Unresolved type com.google.common.base.Splitter DOT_SPLITTER\nprivate static final [unresolved] Unresolved type com.google.common.base.Joiner DOT_JOINER\nprivate static final [unresolved] int NO_PUBLIC_SUFFIX_FOUND\nprivate static final [unresolved] java.lang.String DOT_REGEX\nprivate static final [unresolved] int MAX_PARTS\nprivate static final [unresolved] int MAX_LENGTH\nprivate static final [unresolved] int MAX_DOMAIN_PART_LENGTH\nprivate final [unresolved] java.lang.String name\nprivate final [unresolved] Unresolved type com.google.common.collect.ImmutableList&lt;java.lang.String> parts\nprivate final [unresolved] int publicSuffixIndex\nprivate static final [unresolved] Unresolved type com.google.common.base.CharMatcher DASH_MATCHER\nprivate static final [unresolved] Unresolved type com.google.common.base.CharMatcher PART_CHAR_MATCHER\n/_   methods   */\n[unresolved] void &lt;init>(java.lang.String) \n[unresolved] private com.google.common.net.InternetDomainName ancestor(int) \n[unresolved] public com.google.common.net.InternetDomainName child(java.lang.String) \n[unresolved] public boolean equals(java.lang.Object) \n[unresolved] private int findPublicSuffix() \npublic static com.google.common.net.InternetDomainName from(java.lang.String) \n[unresolved] public static com.google.common.net.InternetDomainName fromLenient(java.lang.String) \n[unresolved] public boolean hasParent() \npublic boolean hasPublicSuffix() \n[unresolved] public int hashCode() \n[unresolved] public boolean isPublicSuffix() \n[unresolved] public boolean isTopPrivateDomain() \n[unresolved] public boolean isUnderPublicSuffix() \n[unresolved] public static boolean isValid(java.lang.String) \n[unresolved] public static boolean isValidLenient(java.lang.String) \n[unresolved] private static boolean matchesWildcardPublicSuffix(java.lang.String) \n[unresolved] public java.lang.String name() \n[unresolved] public com.google.common.net.InternetDomainName parent() \n[unresolved] public Unresolved type com.google.common.collect.ImmutableList&lt;java.lang.String> parts() \n[unresolved] public com.google.common.net.InternetDomainName publicSuffix() \n[unresolved] public java.lang.String toString() \n[unresolved] public com.google.common.net.InternetDomainName topPrivateDomain() \n[unresolved] private static boolean validatePart(java.lang.String, boolean) \n[unresolved] private static boolean validateSyntax(List&lt;java.lang.String>) \n\n```\n     org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding\n  [ERROR] at UrlValidator.java(72): InternetDomainName internetDomainName = InternetDomainName.from(primayDomain);\n     org.eclipse.jdt.internal.compiler.ast.LocalDeclaration\n```\n", "url": "https://github.com/google/guava/issues/1253", "user": "gissuebot", "labels": ["package=net", "platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:40:27", "closed": "2014-11-01 00:59:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "14.0-rc1 missing OSGi headers in manifest.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1249) created by **vulcannis** on 2013-01-06 at 08:08 AM_\n\n---\n\nOSGi metadata was added to the manifest in Issue 688, but they are not present in 14.0-rc1.\n\nMaybe broken by revision a91d5ce5b936?\n", "url": "https://github.com/google/guava/issues/1249", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:40:18", "closed": "2014-11-01 01:06:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "methods encodingStream() and decodingStream() from BaseEncoding should accept polymorphic generics arguments", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1245) created by **jbgiraudeau** on 2013-01-04 at 01:16 PM_\n\n---\n\nMethods encodingStream() and decodingStream() from BaseEncoding don't accept  polymorphic generics arguments \n\nPlease change:\n\ndecodingStream(final InputSupplier&lt;Reader> readerSupplier)\nencodingStream(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final OutputSupplier&lt;Writer> writerSupplier)\n\nto \n\ndecodingStream(final InputSupplier<? extends Reader> readerSupplier)\nencodingStream(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final OutputSupplier<? extends Writer> writerSupplier)\n", "url": "https://github.com/google/guava/issues/1245", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:40:10", "closed": "2014-11-01 00:58:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Fix Unsafe usage throughout library to be Android friendly", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1236) created by **alex.radeski** on 2012-12-21 at 03:55 PM_\n\n---\n\nHave discovered another usage of sun.misc.Unsafe that is not Android friendly in https://github.com/google/guava/blob/release14/guava/src/com/google/common/primitives/UnsignedBytes.java line 334.\n\nIdeally Guava would use a helper class to fetch the unsafe instance so then  all usages would be fixed through the library.\n\nFYI \"theUnsafe\" is \"THE_ONE\" on Android. I'm using Android 4.2.\n\n(The other usage I bumped into was in Striped64, this has been fixed on the master branch)\n", "url": "https://github.com/google/guava/issues/1236", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:39:51", "closed": "2014-11-01 01:02:16", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "EventBus publishes all objects to a templated subscriber", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1235) created by **paul.hodson** on 2012-12-20 at 02:41 PM_\n\n---\n\nI have a unit test that uses a templated subscriber.  I found that it gets all events posted to the event bus, and therefore the DeadEvent subscriber is not invoked.  This is curious.\n\nI have attached a minimal code sample that shows this.  The test creates a String event subscriber but publishes an Integer event.  The String subscriber receives the Integer event.\n\nIs this a bug or an invalid use of EventBus?\n\n(Ignore the fact that the unit test here has no success/fail reporting).\n\nUsing: jdk1.7.0_09, guava-13.0.1.jar, junit_4.10.0\n", "url": "https://github.com/google/guava/issues/1235", "user": "gissuebot", "labels": ["package=eventbus", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:39:49", "closed": "2014-11-01 00:53:43", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "AbstractCache.SimpleStatsCounter LongAddr usage of Striped64 breaks on Android", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1228) created by **alex.radeski** on 2012-12-13 at 10:12 PM_\n\n---\n\nI'm using CacheBuilder in an Android app and when I use CacheBuilder.recordStats() it fails because SimpleStatsCounter uses Striped64, which uses Unsafe, which isn't present on Android (or at least doesn't work in the same way).\n\nIdeally the API would allow me to _easily_ provide an alternatice implementation, but I currently have to do some OO gymnastics to make it work (or not use stats at all). For example recordStats(StatsSupplier) would fit into the current builder API style.\n", "url": "https://github.com/google/guava/issues/1228", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:39:34", "closed": "2014-11-01 00:55:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Classpath scanning fails every time on OSX", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1215) created by **kasperni** on 2012-11-29 at 09:38 AM_\n\n---\n\nClasspath should probably ignore non valid jar files.\n\nFor example, when used on OSX. Classpath scanning attempts to open this file\n/System/Library/Java/Extensions/libAppleScriptEngine.jnilib\n\nHowever it is not a zip file so it fails with\n\nException in thread \"main\" java.util.zip.ZipException: error in opening zip file\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.zip.ZipFile.open(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.zip.ZipFile.&lt;init>(ZipFile.java:214)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.zip.ZipFile.&lt;init>(ZipFile.java:144)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.jar.JarFile.&lt;init>(JarFile.java:152)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.jar.JarFile.&lt;init>(JarFile.java:116)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.reflect.ClassPath.readClassesFromJar(ClassPath.java:248)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.reflect.ClassPath.readClassesFrom(ClassPath.java:222)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.reflect.ClassPath.readClassesFrom(ClassPath.java:208)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.reflect.ClassPath.from(ClassPath.java:82)\n", "url": "https://github.com/google/guava/issues/1215", "user": "gissuebot", "labels": ["package=reflect", "status=fixed", "type=defect"], "created": "2014-10-31 17:39:07", "closed": "2014-11-01 00:56:00", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Some tests of our testers (in guava-testlib) fail on some JDKs", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1213) created by **cgruber@google.com** on 2012-11-28 at 07:00 PM_\n\n---\n\nOne example:  Sun JDK 1.6 on what I must presume is a linux machine (Cloudbees) under Jenkins.\n\nFailed\n\ncom.google.common.collect.testing.testers.MapPutTester.testPut_nullKeySupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: zero] subMap NO_BOUND-EXCLUSIVE [collection size: zero] descending [collection size: zero]](from com.google.common.collect.testing.SafeTreeMapTest)\n\nFailing for the past 20 builds (Since #\ufeff4 )\nTook 5 ms.\nadd description\nError Message\n\ndid not contain expected element null=April, expected = [null=April], actual = []\nStacktrace\n\njunit.framework.AssertionFailedError: did not contain expected element null=April, expected = [null=April], actual = []\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.fail(Assert.java:47)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder(Helpers.java:91)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractContainerTester.expectContents(AbstractContainerTester.java:112)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractMapTester.expectContents(AbstractMapTester.java:195)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractContainerTester.expectAdded(AbstractContainerTester.java:144)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.testers.MapPutTester.testPut_nullKeySupportedNotPresent(MapPutTester.java:145)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runTest(TestCase.java:168)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runBare(TestCase.java:134)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult$1.protect(TestResult.java:110)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.runProtected(TestResult.java:128)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.run(TestResult.java:113)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.run(TestCase.java:124)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:107)\n&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)\n", "url": "https://github.com/google/guava/issues/1213", "user": "gissuebot", "labels": ["P4", "package=testing", "status=obsolete", "type=defect"], "created": "2014-10-31 17:39:03", "closed": "2019-08-30 20:48:03", "commits": {}, "ttf": 1764.0002777777777, "commitsDetails": []}, {"title": "Apparent Cache.refresh race condition", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1211) created by **lowasser@google.com** on 2012-11-23 at 01:37 AM_\n\n---\n\nhttp://stackoverflow.com/q/13521523/869736\n\nIf I understand what's going on correctly, the issue is that in between the steps\n1. Check that the entry is eligible for refresh, according to its last write time.\n2. Acquire the segment lock.\n3. Check that the entry isn't still loading.\n4. Schedule a refresh.\n\ncan interleave badly with the end of a refresh:\n\nA. Finish the refresh future.\nB. Acquire the segment lock.\nC. Set the value, using a StrongValueReference instead of a LoadingValueReference.\nD. Update the write time.\nE. Release the lock.\n\nIn particular, what can happen is that if a get happens just as the entry is done refreshing, the steps can interleave\n\nA, B, 1, C, D, E, 2, 3, 4\n\nin which case a refresh will get inappropriately scheduled: it will see that the write time was long enough ago that a refresh is appropriate, and then it will see that the entry has a StrongValueReference and is not currently loading, so it will start a refresh immediately after the previous refresh completed.\n", "url": "https://github.com/google/guava/issues/1211", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:38:58", "closed": "2014-11-01 01:00:34", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Cache.getAll fails to trigger refresh", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1201) created by **kevinb@google.com** on 2012-11-09 at 11:16 PM_\n\n---\n\nAfter determining which keys we already have in the cache, we could check which of those are already stale, and include those in the set we query.  If any of those don't happen to come back, perhaps we still use the stale values.\n", "url": "https://github.com/google/guava/issues/1201", "user": "gissuebot", "labels": ["package=cache", "status=duplicate", "type=defect"], "created": "2014-10-31 17:38:37", "closed": "2014-11-01 00:47:13", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LoadingCache.refresh(key) should not bump the access time", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1198) created by **kevinb@google.com** on 2012-11-09 at 10:18 PM_\n\n---\n\n(It should of course continue to update the write time.)\n", "url": "https://github.com/google/guava/issues/1198", "user": "gissuebot", "labels": ["P3", "package=cache", "status=invalid", "type=defect"], "created": "2014-10-31 17:38:31", "closed": "2019-08-30 21:03:20", "commits": {}, "ttf": 1764.0002777777777, "commitsDetails": []}, {"title": "Splitter.onPattern drops last token when zero width matches are used", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1190) created by **travis.downs** on 2012-11-04 at 10:17 AM_\n\n---\n\nIf you split on a zero-width regex, the last element may be dropped.\n\nString input = \"foo\";\nString regex = \"(?=o)|(?<=o)\";\nSplitter splitter = Splitter.onPattern(regex);\nSystem.out.println(Arrays.asList(input.split(regex)));\nSystem.out.println(Arrays.asList(Iterables.toArray(splitter.split(input),String.class)));\n\nThis does zero-width lookaround for 'o', so the string will be split before and after any o, but the o characters will also be returned as individual items.\n\nNote that String.split works correctly here, but Guava splitter drops the last o.\n\nExamining the code, this was probably introduced in this fix (granted, it didn't work at all before that):\n\nhttps://github.com/google/guava/issues/936\n\nIn particular, this bit of logic in Splitter.java:\n\n```\n    if (offset == nextStart) {\n      /*\n       * (ommit comment)\n       */\n      offset++;\n      if (offset >= toSplit.length()) {\n        offset = -1;\n      }\n      continue;\n    }\n```\n\nneglects to the the \"last element\" handling that the general logic above does (setting end to toSplit.lenth() if no more separators are found).\n", "url": "https://github.com/google/guava/issues/1190", "user": "gissuebot", "labels": ["package=base", "type=defect"], "created": "2014-10-31 17:38:14", "closed": "2016-10-31 18:40:50", "commits": {"55524c66de8db4c2e44727b69421c7d0e4f30be0": {"commitGHEventType": "closed", "commitUser": "cpovirk"}}, "ttf": 731.0002777777778, "commitsDetails": [{"commitHash": "55524c66de8db4c2e44727b69421c7d0e4f30be0", "commitGHEventType": "closed", "commitUser": "cpovirk", "commitParents": ["5367a2d0687ec4c1901f693559cd4d2d14ca65d1"], "nameRev": "55524c66de8db4c2e44727b69421c7d0e4f30be0 tags/v21.0-rc1~79", "commitMessage": "Fix #1190\n\nBefore this fix, splitting a single character input string with a\nSplitter.onPattern instance created with a zero-width regex pattern,\nwould have caused the input string to be dropped from the output,\nresulting in an empty iterable being returned rather than a single\nelement one.\n\nThis fix ensures that the input passes through untouched.\n\nFor example, whereas before in this code snippet, 'words' would have\nbeen initialized as an empty iterable...\n\n   String string = \"f\";\n   Iterable<String> words =\n       Splitter.on(Pattern.compile(\"\\\\b\")).split(string);\n   // words is empty!\n\nFixes #2615, #2086\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=137723825\n", "commitDateTime": "2016-10-31 11:40:26", "authoredDateTime": "2016-10-31 11:08:30", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/base/SplitterTest.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "guava/src/com/google/common/base/Splitter.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SplitterTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.SplitterTest.testPatternSplitWordBoundary_singleCharInput()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.base.SplitterTest.testPatternSplitWordBoundary_singleWordInput()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Splitter.java", "spoonMethods": [{"spoonMethodName": "com.google.common.base.Splitter.SplittingIterator.computeNext()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "It seems wrong that Splitter.fixedLength(n).split(\"\") returns [\"\"], not []", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1178) created by **kevinb@google.com** on 2012-10-25 at 11:38 PM_\n\n---\n\nSo all separator-based splitters that don't use omitEmptyStrings have the property that split(\"\") yields an Iterable containing just the empty string [\"\"].  This follows from the fact that (a) if the separator doesn't exist anywhere in the input, splitting should yield only the entire input, and (b) we reject any separator regex that matches the empty string.\n\nBut one type of Splitter isn't separator-based: Splitter.fixedLength.  Here also, splitting the empty string yields an Iterable containing only the empty string.  (Again, unless omitEmptyStrings is requested, which is just a strange thing to have to request of a fixed-length Splitter.)\n\nBut in this case, this seems weird.  It violates the otherwise-invariant that split().size() == divide(input.length(), fixedLength, CEILING). For Splitter.fixedLength(4), there are 4 different input sizes that can yield an Iterable of size 2, or 3, etc., but there are 5 different input sizes that can yield an Iterable of size 1. This is not how Lists.partition() behaves, so why Splitter?\n\nI tried to rationalize this by thinking of fixedLength as though imaginary zero-width separators were jammed into the input at positions n, 2n, etc. (But not at position 0 since that would violate the rule that the separator must not match the empty string).  However, that's no help, as that implies that fixedLength(4).split(\"abcd\") would yield [\"abcd\", \"\"].\n\nI could find no record that we discussed this question when reviewing the code initially. A reviewer did remark on how quirky it was that fixedLength().omitEmptyString() could actually be useful, but that didn't raise a red flag.\n\nIt's tough to know what could get subtly broken by changing this now, so I'm attempting to convince myself that this little quirk is either (a) good or (b) at least tolerable.\n", "url": "https://github.com/google/guava/issues/1178", "user": "gissuebot", "labels": ["package=base", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:37:49", "closed": "2015-11-24 19:19:30", "commits": {}, "ttf": 389.0002777777778, "commitsDetails": []}, {"title": "Throwables.getRootCause leads to infinite loop sometimes", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1173) created by **Alexandr.Berdnik** on 2012-10-19 at 06:36 AM_\n\n---\n\nSome SqlExceptions thrown by Oracle jdbc drivers has reference to itself in cause field. For this exception: ex == ex.getCause() and it leads to infinite loop if getRootCause() used.\nActually it can be treated as defect in drivers. Anyway, the proposed fix: additional condition could be used to prevent it.\n\n&nbsp;&nbsp;public static Throwable getRootCause(Throwable throwable) {\n&nbsp;&nbsp;&nbsp;&nbsp;Throwable cause;\n&nbsp;&nbsp;&nbsp;&nbsp;while ((cause = throwable.getCause()) != null && cause != throwable) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throwable = cause;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return throwable;\n&nbsp;&nbsp;}\n", "url": "https://github.com/google/guava/issues/1173", "user": "gissuebot", "labels": ["package=base", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:37:39", "closed": "2014-11-01 01:37:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "PEST ADMINISTRATION", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1167) created by **elsiddeeq** on 2012-10-12 at 10:46 AM_\n\n---\n\nMY OWN PROBLEM IS THAT IN MY FARM, THE FRUITS WHEN ABOUT TO MATURE THEY WILL START SHOWING SOME DEFORMATIONS. I WANT HELP SO THAT I CAN ADMINISTER SOME PESTS  ON IT.BELOW ARE THE PICTURES.\n", "url": "https://github.com/google/guava/issues/1167", "user": "gissuebot", "labels": ["package=general", "status=invalid", "type=defect"], "created": "2014-10-31 17:37:26", "closed": "2014-11-01 00:40:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Uses of @Nullable in guava-gwt:13.0.1 causes errors", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1152) created by **marcus.goldritter.lindner** on 2012-09-19 at 01:32 PM_\n\n---\n\nI switched from guava-gwt 12.0.1 to 13.0.1 and get a huge amount of error messages of the type:\n[ERROR] Errors in 'jar:file:/&lt;snip>/.m2/repository/com/google/guava/guava-gwt/13.0.1/guava-gwt-13.0.1.jar!/com/google/common/collect/ForwardingMultimap.java'\n[INFO]       [ERROR] Line 26:  The import javax.annotation.Nullable cannot be resolved\n[INFO]       [ERROR] Line 57:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 57:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 62:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 67:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 77:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 112:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 112:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 117:  Nullable cannot be resolved to a type\n[INFO]       [ERROR] Line 136:  Nullable cannot be resolved to a type'\n\nI personally does not use @\ufeffNullable in any form in my program and there are many of these errors (for example for Maps.java, MapDifference.java, MapConstraints.java, ...)\n\nWhen I add the dependency \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>net.sourceforge.findbugs&lt;/groupId>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>jsr305&lt;/artifactId>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>1.3.2&lt;/version>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency>\ninto the project these errors disapear. But I does not use @\ufeffNullable in my code. \n", "url": "https://github.com/google/guava/issues/1152", "user": "gissuebot", "labels": ["package=general", "platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:36:55", "closed": "2014-11-01 00:50:22", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Objects.toStringHelper(Object) gives an incorrect class name if class name contains a dollar sign", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1133) created by **berratum** on 2012-09-02 at 02:10 PM_\n\n---\n\nExamples of classes (see my comments in each main(...) method):\n\npublic class Test {\n&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = Objects.toStringHelper(new Test()).toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// OK; result equals \"Test{}\"\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\npublic class Te$t {\n&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = Objects.toStringHelper(new Te$t()).toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// BUG: result equals \"t{}\"\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\npublic class $ {\n&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = Objects.toStringHelper(new $()).toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// BUG: result equals \"{}\"\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n", "url": "https://github.com/google/guava/issues/1133", "user": "gissuebot", "labels": ["package=base", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:36:15", "closed": "2014-11-01 00:34:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "BloomFilter broken when really big", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1119) created by **Maaartinus** on 2012-08-24 at 05:40 PM_\n\n---\n\n**BUG 1:\nWhen the number of bits in a BloomFilter gets high, it's FPP is much worse than expected. The culprit is the modular arithmetic in BloomFilterStrategies.MURMUR128_MITZ_32.\n\nYou compute `x%N`&nbsp;where `N=bits.size()`&nbsp;and `x`&nbsp;is uniformly distributed in range `0..Integer.MAX_VALUE`. For big `N`, `x%N`&nbsp;is far from uniform in range `0..N-1`. For example, with `N=3<<29`, values below `1<<29`&nbsp;are twice as probable as the others.\n\nThis non-uniformity leads to results like this:\ndesiredFpp   0.000001000000\nexpectedFpp  0.000000610089\nrealFpp      0.000003000000\n\nHere, `desiredFpp`&nbsp;is the value used in `BloomFilter.create`, `expectedFpp`&nbsp;was reported after exactly `expectedInsertions`&nbsp;were done. Obviously, much fewer bits than expected were set. If this happened once, it might be a good luck but here it's a sign of this bug, as the `realFpp`&nbsp;shows.\n\nThis problem is well reproducible, it's no glitch caused by bad luck with selected values. AFAIK it concerns all versions since the switch from powers of two.\n\n**BUG 2:\nWith \"31149b4 The number of bits can reach Integer.MAX_VALUE now, rather than Integer.MAX_VALUE/64\" another bug was introduced. The commit message is obviously wrong, as there can be allocated up to `Integer.MAX_VALUE`&nbsp;longs, allowing nearly `2**37`&nbsp;bits. However, the arithmetic is still int-based and allows to address only`2**31`&nbsp;bits. So most of the allocated memory get wasted.\n\nEven worse, `bits.size()`&nbsp;may overflow leading to all kinds of disaster, like \"/ by zero\" (e.g. for expectedInsertions=244412641 and desiredFpp=1e-11) or using only 64 bits.\n\n**INEFFICIENCY:\nIn `MURMUR128_MITZ_32`&nbsp;there are one modulus operation and one unpredictable branch per hash function. This is quite wasteful, as it's enough to compute modulus for the basic two hashes and than use conditional subtraction.\n\n**ENHANCEMENT 1:\nAs the filter may take up to 16 GB, there should be a method to find out the memory consumption.\n\n**ENHANCEMENT 2:\nPossibly there could be a strategy using a power of two table, which may be faster. In case the speed up is non-negligible, such a strategy makes a lot of sense, as the additional memory (assuming rounding up) is not wasted at all -- you get better FPP.\n\nQUESTION:\nI see no reason for limiting `numHashFunctions`&nbsp;to 25.5 In the `SerialForm`, there's an `int`, so why?\n\n**PROPOSED SOLUTION:\nBecause of serialized form compatibility, I'd suggest to leave MURMUR128_MITZ_32 alone, and create MURMUR128_MITZ_64, which\n- extracts two longs instead of two ints from the HashCode\n- uses long arithmetic for everything\n\nThe `BitArray`&nbsp;must use long indexes, long `bitCount()`&nbsp;and `size()`, too. This works with both strategies and the `SerialForm`&nbsp;needs no change.\n\nFor small filters (up to few millions bits, before the non-uniformity starts to make problems) it's fine to use the old strategy,\nfor larger the new one must get used. I'd suggest to use the new one for all new filters.\n\nIn order to get maximum speed, the following comes in mind:\n- create package-private `HashCode.asSecondLong()`\n- compute hash2 only if `numHashFunctions>1`\n\nThe attached patch solves it all.\n", "url": "https://github.com/google/guava/issues/1119", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:35:46", "closed": "2014-11-01 02:07:59", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ListeningExecutorService causes deadlock on exception", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1109) created by **bahri.gencsoy** on 2012-08-15 at 02:54 PM_\n\n---\n\nWhen an exception occurs in the submitted task roughly this flow occurs:\n\n(JDK)FutureTask.innerSetException -> (Guava)ListenableFutureTask.done -> (Guava)ExecutionList.execute\n\nWhich will eventually lock since we are already in execute() block.\n\nFollowing code doesn't output anything and never finishes due to deadlock:\n\npublic class GuavaFutureTest {\n\n```\nUncaughtExceptionHandler u = new UncaughtExceptionHandler() {\n\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        e.printStackTrace(System.err);\n    }\n};\n\nvoid doTest() {\n    ListeningExecutorService dec = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(2,\n            new ThreadFactoryBuilder().setUncaughtExceptionHandler(u).build()));\n    dec.submit(new Runnable() {\n        @Override\n        public void run() {\n            throw new RuntimeException(\"we should log this\");\n        }\n    });\n}\n\npublic static void main(String[] args) throws InterruptedException {\n    new GuavaFutureTest().doTest();\n    Thread.sleep(2000);\n}\n```\n\n}\n", "url": "https://github.com/google/guava/issues/1109", "user": "gissuebot", "labels": ["package=concurrent", "status=invalid", "type=defect"], "created": "2014-10-31 17:35:25", "closed": "2014-11-01 00:28:59", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "BloomFilter.equals() should use Funnel.equals()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1098) created by **argaul** on 2012-08-07 at 11:03 PM_\n\n---\n\nAfter serializing and deserializing a BloomFilter I was surprised that equals against the original object returned false.  This is due to Guava using reference equality instead of object equality in BloomFilter.equals.  I pushed a fix to GitHub:\n\nhttps://github.com/andrewgaul/guava-libraries/tree/bloom-filter-funnel-object-equality\n", "url": "https://github.com/google/guava/issues/1098", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:35:02", "closed": "2014-11-01 00:30:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "guava-gwt-13.0 contains testlib classes", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1097) created by **david.nouls** on 2012-08-07 at 07:35 AM_\n\n---\n\nDetected with: guava R13\n\nWhen compiling my GWT application that is depending on guava-gwt I get the following errors with guava 13:\ncompile:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[echo] Invoking GWT JavaScript compiler. Style=PRETTY Workers:2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java] Compiling module com.swift.gwt.platform.Platform\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]    Validating newly compiled units\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]       [ERROR] Errors in 'jar:file:/scm/vobs/rlsCOTS5/guava/JAVA/lib/guava-gwt.jar!/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/SetGenerators.ja\nva'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 17: The declared package \"com.google.common.collect.testing.google\" does not match the expected package \"com.google.common.collect.testing.google.super.com.google.co\nmmon.collect.testing.google\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 22: The import com.google.common.collect.testing.SampleElements cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 23: The import com.google.common.collect.testing.SampleElements cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 24: The import com.google.common.collect.testing.SampleElements cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 25: The import com.google.common.collect.testing.SampleElements cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 26: The import junit cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 38: The import com.google.common.collect.testing.TestCollectionGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 39: The import com.google.common.collect.testing.TestCollidingSetGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 40: The import com.google.common.collect.testing.TestIntegerSortedSetGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 41: The import com.google.common.collect.testing.TestSetGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 42: The import com.google.common.collect.testing.TestStringListGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 43: The import com.google.common.collect.testing.TestStringSetGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 44: The import com.google.common.collect.testing.TestStringSortedSetGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 45: The import com.google.common.collect.testing.TestUnhashableCollectionGenerator cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 46: The import com.google.common.collect.testing.UnhashableObject cannot be resolved\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 65: TestStringSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 66: The method create(String[]) of type SetGenerators.ImmutableSetCopyOfGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 72: TestCollidingSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 76: TestCollectionGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 78: The method create(Object...) of type SetGenerators.ImmutableSetWithBadHashesGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 84: TestStringSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 88: The method create(String[]) of type SetGenerators.DegeneratedImmutableSetGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 95: TestStringSortedSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 96: The method create(String[]) of type SetGenerators.ImmutableSortedSetCopyOfGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 102: TestStringSortedSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 103: The method create(String[]) of type SetGenerators.ImmutableSortedSetHeadsetGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 112: TestStringSortedSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 113: The method create(String[]) of type SetGenerators.ImmutableSortedSetTailsetGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 122: TestStringSortedSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 123: The method create(String[]) of type SetGenerators.ImmutableSortedSetSubsetGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 133: TestStringSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 138: The method create(String[]) of type SetGenerators.ImmutableSortedSetExplicitComparator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 144: The method order(List&lt;String>) of type SetGenerators.ImmutableSortedSetExplicitComparator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 151: TestStringSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 156: The method create(String[]) of type SetGenerators.ImmutableSortedSetExplicitSuperclassComparatorGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 162: The method order(List&lt;String>) of type SetGenerators.ImmutableSortedSetExplicitSuperclassComparatorGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 169: TestStringSetGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 171: The method create(String[]) of type SetGenerators.ImmutableSortedSetReversedOrderGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 177: The method order(List&lt;String>) of type SetGenerators.ImmutableSortedSetReversedOrderGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 183: The hierarchy of the type ImmutableSortedSetUnhashableGenerator is inconsistent\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 185: UnhashableObject cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 185: The method create(UnhashableObject[]) of type SetGenerators.ImmutableSortedSetUnhashableGenerator must override or implement a supertype method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 186: UnhashableObject cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 192: TestStringListGenerator cannot be resolved to a type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[java]          [ERROR] Line 193: The method create(String[]) of type SetGenerators.ImmutableSetAsListGenerator must override or implement a supertype method\n(the list goes on).\n\nI tend to always compile in strict mode so for me it is blocking.\n\nWorkaround:\nDo not use -strict when gwt compiling.\n", "url": "https://github.com/google/guava/issues/1097", "user": "gissuebot", "labels": ["package=general", "platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:35:00", "closed": "2014-11-01 00:50:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Flushables.flushQuietly(Flushable) doesn't check for null (and doesn't use @Nullable)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1086) created by **laurent.malvert** on 2012-07-26 at 04:09 PM_\n\n---\n\nThe Problem:\n\nCloseables.closeQuietly(Closeable) is null-safe, whereas Flushables.flushQuietly(Flushable) isn't.\n\nThe Solution:\n\nIn Flushables, this (which is invoked by flushQuietly):\n\n```\npublic static void flush(Flushable flushable, boolean swallowIOException)\n  throws IOException {\ntry {\n  flushable.flush();\n} catch (IOException e) {\n  if (swallowIOException) {\n    logger.log(Level.WARNING,\n        \"IOException thrown while flushing Flushable.\", e);\n  } else {\n    throw e;\n  }\n}\n```\n\n&nbsp;&nbsp;}\n\nShould become this (to replicate Closeables.close(Closeable, boolean)):\n\n&nbsp;&nbsp;public static void flush(@\ufeffNullable Flushable flushable, boolean swallowIOException)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException {\n&nbsp;&nbsp;&nbsp;&nbsp;if (flushable == null) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flushable.flush();\n&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (swallowIOException) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.log(Level.WARNING,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"IOException thrown while flushing Flushable.\", e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n\n(changes are a simple null-check and @\ufeffNullable on the first parameter).\n\nWould probably need a Javadoc update as well.\n\nPossibly invalid:\n\nI was surprised by this inconsistency and thought it was probably by design as I assume something like this would have been noticed already, considering these are rather often used (I think), but as I couldn't find a reference of this already mentioned somewhere (or anyone else already bitten by it), I figured I'd report it anyways.\n\nApologies if this is invalid or was already debated and rejected.\n", "url": "https://github.com/google/guava/issues/1086", "user": "gissuebot", "labels": ["package=io", "status=obsolete", "type=defect"], "created": "2014-10-31 17:34:37", "closed": "2014-11-01 01:52:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CharStreams.copy(Readable from, Appendable to) hangs", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1061) created by **christoph.henkelmann** on 2012-07-11 at 12:51 PM_\n\n---\n\nWhen using a Reader that does not always fill the available buffer space completely on each read, the CharStreams.copy method can get stuck in an endless loop. \n\nThe reason is that the buffer does not get cleared after a call to CharBuffer.flip(). If the buffer was not completely filled, this causes the limit of the buffer to stay at the position to which was last written. That way the buffer limit approaches 0, which causes an endless loop, as no chars are read but the end of the reader is never reached.\n\nEven if the limit does not reach zero, the performance may degrade significantly, as the buffer size gets smaller and smaller.\n\nI have attached an example file with a main method that demonstrates the behavior and a suggested fix.\n", "url": "https://github.com/google/guava/issues/1061", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:33:45", "closed": "2014-11-01 00:15:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LocalLoadingCache doesn't ever expand/rehash", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1055) created by **Ionized** on 2012-07-04 at 12:03 AM_\n\n---\n\nNo matter how many elements get loaded into the LoadingCache, expand() on the Segment never gets called (it gets called on put(), but not on getOrLoad())\n\nThe following code reproduces the issue:\n\nCacheLoader&lt;String, Object> loader = new CacheLoader&lt;String, Object>() {\n&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffOverride\n&nbsp;&nbsp;&nbsp;&nbsp;public Object load(String key) throws Exception {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return key + 1;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n};\nLoadingCache&lt;String, Object> cache = CacheBuilder.newBuilder().build(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader);\n\nfor (int i = 0; i < 100000; i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;cache.getUnchecked(i + \"\");\n}\n", "url": "https://github.com/google/guava/issues/1055", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:33:32", "closed": "2014-11-01 00:36:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Minor bug in ArbitraryOrdering", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1032) created by **Maaartinus** on 2012-06-14 at 11:16 PM_\n\n---\n\nWhile Ordering.arbitrary() doesn't not specify what happens for null arguments, the current behavior is surely unintended. Calling compare(null, obj) works fine except when identityHashCode(obj) happens to be 0 for an obj!=null. In this very unlikely but possible case an NPE in ComputingConcurrentHashMap gets thrown.\n\nAFAIK there's no guarantee for identityHashCode(obj) to be non-zero, albeit the only implementation I've seen avoids 0:\n\nhttp://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp\n", "url": "https://github.com/google/guava/issues/1032", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:32:44", "closed": "2014-11-01 00:15:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableSorted*.orderedBy should allow comparators of supertypes", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1030) created by **joe.j.kearney** on 2012-06-13 at 09:37 AM_\n\n---\n\nSuppose I want an ImmutableSet of my Iterable&lt;Thing>, ordered by Thing#toString.\n\n```\nImmutableSortedSet<Thing> set = ImmutableSortedSet.orderedBy(Ordering.usingToString()).addAll(things).build();\n```\n\nThis fails to compile, since the rhs is an ImmutableSortedSet&lt;Object>, not ImmutableSortedSet&lt;Thing>. It can't be fixed by providing an explicit type parameter to orderedBy.\n\nClearly this applies to a whole class of generalised comparators, not just usingToString(). Can we change orderedBy(Comparator&lt;K>) to orderedBy(Comparator<? super K>)? Then at  least you can provide the explicit type parameter and this will compile:\n\n```\nImmutableSortedSet<Thing> set = ImmutableSortedSet.<Thing>orderedBy(Ordering.usingToString()).addAll(things).build();\n```\n\nOrdering.usingToString is an Ordering&lt;Object>. The workaround for this case is to cast (Ordering&lt;Thing>) (Ordering<?>) Ordering.usingToString(). Though disgusting, this generates an unchecked cast warning that is safe since everything being compared is a Thing, which is an Object.\n", "url": "https://github.com/google/guava/issues/1030", "user": "gissuebot", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:32:40", "closed": "2014-11-01 00:00:59", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LinkedListMultiMap fails to be deserialized by the GWT client", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1024) created by **r...@flavor8.com** on 2012-06-05 at 07:50 PM_\n\n---\n\nRelated to #\ufeff1023.\n\nIn one of my DTOs, I have:\n\nprivate LinkedListMultimap&lt;Attribute, String> attributes = LinkedListMultimap.create();\n\nAttribute is an enum:\n\npublic enum Attribute implements IsSerializable {\n\n```\n// a bunch of stuff including\nCANPUBLISH,\nCANEXPORT;\n```\n\n}\n\nIn GWT hosted mode, I can populate the data structure and send it back and forth over the wire. As soon as I deploy as a GWT webapp, however, I get a deserialization failure. Here's the client error:\n\ncom.google.common.collect.LinkedListMultimap/1479929602\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$fillInStackTrace(StackTraceCreator.java:168)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.Exception_0(StackTraceCreator.java:421)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.SerializationException_0(SerializationException.java:27)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$check(SerializerBase.java:137)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$instantiate(SerializerBase.java:111)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$readObject(AbstractSerializationStreamReader.java:119)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.deserialize_99(JobStatusBundle_FieldSerializer.java:120)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$deserialize_0(SerializerBase.java:46)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$deserialize(SerializerBase.java:92)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$readObject(AbstractSerializationStreamReader.java:119)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.read_8(RequestCallbackAdapter.java:106)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$onResponseReceived(RequestCallbackAdapter.java:214)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$fireOnResponseReceived(Request.java:287)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.onReadyStateChange_0(RequestBuilder.java:395)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.anonymous(XMLHttpRequest.java:287)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.apply(Impl.java:168)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.entry0(Impl.java:213)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.anonymous(Impl.java:57)\n", "url": "https://github.com/google/guava/issues/1024", "user": "gissuebot", "labels": ["package=collect", "platform=gwt", "status=invalid", "type=defect"], "created": "2014-10-31 17:32:27", "closed": "2014-11-01 00:00:16", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "EventBus.newHandlerSet isn't actually used", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=993) created by **wiz.saturday** on 2012-05-04 at 01:24 PM_\n\n---\n\nThe javadoc that EventBus.newHandlerSet creates a new Set for insertion into the handler map. \nBut handlersByType is initialized using new CopyOnWriteArraySet&lt;EventHandler> without EventBus.newHandlerSet.\n", "url": "https://github.com/google/guava/issues/993", "user": "gissuebot", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 17:31:22", "closed": "2014-11-01 00:22:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Improve error reporting of ImmutableMap", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=988) created by **Ash2kk** on 2012-05-02 at 11:07 AM_\n\n---\n\nIt can be easier to debug a little if Guava provided key of the value in the error message in ImmutableMap.entryOf() (and other such places).\n\njava.lang.NullPointerException: null value\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:208)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ImmutableMap.entryOf(ImmutableMap.java:144)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ImmutableMap.copyOf(ImmutableMap.java:292)\n", "url": "https://github.com/google/guava/issues/988", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:31:12", "closed": "2014-11-01 00:18:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CaseFormat could be smarter for camel case conversion", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=987) created by **Sebastian.Zarnekow** on 2012-05-02 at 09:03 AM_\n\n---\n\nConsider the following camel case identifier: getURIScheme\n\nConverting this one to UPPER_UNDERSCORE will yield GET_U_R_I_SCHEME where one could expect GET_URI_SCHEME since subsequent uppercase characters could be treated as a single word (besides for the last one if it is followed by a lower case character).\n", "url": "https://github.com/google/guava/issues/987", "user": "gissuebot", "labels": ["package=base", "status=working-as-intended", "type=defect"], "created": "2014-10-31 17:31:10", "closed": "2014-10-31 23:24:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Concurrency issue in LocalCache", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=976) created by **dumais.guy** on 2012-04-19 at 02:51 PM_\n\n---\n\nThere seems to be a synchronization issue within LocalCache.\n\nI've attached a simple unit test showing that interleaving a refresh call   on a key with an invalidateAll call followed by a get call on the same key turn the cache into a weird state.\n\nThe cache returns a cache value even when invalidateAll is called but the underlying map is empty!\n\nThe attached file has more details.\n\nWe have seen that issue with Guava 11.0 and 11.0.2.\n", "url": "https://github.com/google/guava/issues/976", "user": "gissuebot", "labels": ["package=cache", "status=fixed", "type=defect"], "created": "2014-10-31 17:30:47", "closed": "2014-11-01 00:09:09", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "UnsignedLongs.join error", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=966) created by **wasserman.louis** on 2012-04-09 at 10:39 PM_\n\n---\n\nUnsignedLongs.join(String, long...) is implemented as\n\n```\nbuilder.append(array[0]);\nfor (int i = 1; i < array.length; i++) {\n  builder.append(separator).append(toString(array[i]));\n}\n```\n\nwhich does not treat array[0] as unsigned.  It should be builder.append(toString(array[0])).\n", "url": "https://github.com/google/guava/issues/966", "user": "gissuebot", "labels": ["package=primitives", "status=fixed", "type=defect"], "created": "2014-10-31 17:30:26", "closed": "2014-10-31 23:17:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "No source for java.nio.charset.Charset in guava-gwt", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=961) created by **rwsims** on 2012-04-05 at 11:49 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Use 12.-rc1 in a gwt project\n2. Inherit com.google.common.base.Base\n3. Compile GWT project\n\nThis results in an error about not being able to find the java.nio.charset.Charset module on the classpath; it's inherited by the Base module, and there's no module by that name in the super-src directory.\n", "url": "https://github.com/google/guava/issues/961", "user": "gissuebot", "labels": ["platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:30:15", "closed": "2014-11-01 00:50:17", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableMultimap.builder.orderKeysBy -- document better or change behavior", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=955) created by **wasserman.louis** on 2012-04-01 at 08:00 PM_\n\n---\n\nhttp://stackoverflow.com/questions/7881629/sort-guava-multimap-by-number-of-values/7882417#7882417 discusses a surprising case in which it wasn't clear that ImmutableMultimap.builder().orderKeysBy(comparator) conflates keys that compare as equal.\n\nThis should either be documented more clearly, or simply changed to something less surprising.  (I prefer option 2, but breakages might result for users depending on the current, weird-ish behavior.)\n", "url": "https://github.com/google/guava/issues/955", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:30:02", "closed": "2014-10-31 23:15:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Broken links on the \"PreconditionsExplained\" page", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=954) created by **Basil.Bourque** on 2012-03-31 at 11:03 PM_\n\n---\n\nThis page:\nhttp://code.google.com/p/guava-libraries/wiki/PreconditionsExplained\nhas a table whose first column \"Signature (not including extra args)\" contains link which are broken.\n\nSuch as:\n\nhttps://google.github.io/guava/apidocs/com/google/common/base/Preconditions.html#checkArgument(boolean)\n\nhttps://google.github.io/guava/apidocs/com/google/common/base/Preconditions.html#checkNotNull(T)\n\nI tried simplifying the link to: \nhttps://google.github.io/guava/apidocs/com/google/common/base/Preconditions.html\n\u2026 but that also results in a 404 error.\n", "url": "https://github.com/google/guava/issues/954", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:30:00", "closed": "2014-10-31 23:14:02", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ComputingMapAdapter triggers javac bug", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=950) created by **sandeepchauhan1822** on 2012-03-29 at 02:32 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Download 10.0.1 source.\n2. Try to build using \"mvn install\".\n\n<b>What is the expected output? What do you see instead?</b>\n\nBuild should succeed.\n\nI get an error:\n\n[ERROR] COMPILATION ERROR : \n[INFO] -------------------------------------------------------------\n[ERROR] Failure executing javac, but could not parse the error:\nAn exception has occurred in the compiler (1.6.0_29). Please file a bug at the Java Developer Connection (http://java.sun.com/webapps/bugreport)  after checking the Bug Parade for duplicates. Include your program and the following diagnostic in your report.  Thank you.\njava.lang.NullPointerException\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.comp.Check.checkCompatibleConcretes(Check.java:1215)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.comp.Check.checkCompatibleSupertypes(Check.java:1567)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.comp.Attr.attribClassBody(Attr.java:2674)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.comp.Attr.attribClass(Attr.java:2628)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.comp.Attr.attribClass(Attr.java:2564)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.main.JavaCompiler.attribute(JavaCompiler.java:1045)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.main.JavaCompiler.compile2(JavaCompiler.java:768)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:730)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.tools.javac.main.Main.compile(Main.java:353)\n(Stacktrace truncated for avoiding verbosity)       \n\n<b>What version of the product are you using? On what operating system?</b>\n\n10.0.1 on Mac OS X. Maven 3.0.3.\n\n<b>Please provide any additional information below.</b>\n\nWhen I tried to google for this bug, I found same problem reported by someone on stackoverflow\n\nhttp://stackoverflow.com/questions/6513152/google-guava-trunk-build-problem\n\nBut, I didn't get by reading comments/answer, how he ever get it resolved.\n", "url": "https://github.com/google/guava/issues/950", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:29:52", "closed": "2014-11-01 00:49:39", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Splitter fails on word-boundary regexp", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=936) created by **ives.ae...@datadobi.com** on 2012-03-13 at 04:11 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n\n&nbsp;Iterable&lt;String> parts = Splitter.on(Pattern.compile(\"\\b\")).split(\"foo&lt;bar>bletch\");\n&nbsp;int i = 0;\n&nbsp;for (String part : parts) {\n&nbsp;&nbsp;&nbsp;System.out.println(i++ + \" '\" + part + \"'\");\n&nbsp;}\n\n<b>What is the expected output? What do you see instead?</b>\n\nI would expect:\n\n1 'foo'\n2 '<'\n3 'bar'\n4 '>'\n3 'bletch'\n\nInstead I get an endless output of empty strings:\n\n1 ''\n2 ''\n3 ''\netc.\n\n<b>What version of the product are you using? On what operating system?</b>\n\nguava 11.0.2 on Ubuntu 10.10\n\nNot: using String.split() like this:\n\n\"foo&lt;bar>bletch\".split(\"\\b\")\n\ngives:\n\n[, foo, <, bar, >, bletch]\n", "url": "https://github.com/google/guava/issues/936", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:29:23", "closed": "2014-11-01 00:57:09", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Method, ImmutableSet.of, not being recognized", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=931) created by **sandeepchauhan1822** on 2012-03-12 at 05:35 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Put guava-11.0.2.jar on project build path \n2. Write any Java program which is using Google Youtube client service(com.google.gdata.client.Service) to fetch videos using search terms.\n3. Run the program.\n\n<b>What is the expected output? What do you see instead?</b>\n\nShould see a list containing information about videos. But I get following exception:\n\njava.lang.NoSuchMethodError: com.google.common.collect.ImmutableSet.of([Ljava/lang/Object;)Lcom/google/common/collect/ImmutableSet;\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gdata.wireformats.AltFormat$Builder.setAcceptableTypes(AltFormat.java:399)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gdata.wireformats.AltFormat$Builder.setAcceptableXmlTypes(AltFormat.java:387)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gdata.wireformats.AltFormat.&lt;clinit>(AltFormat.java:49)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gdata.client.Service.&lt;clinit>(Service.java:558)\n\n<b>What version of the product are you using? On what operating system?</b>\n\n11.0.2\n\nMac OS X\n\n<b>Please provide any additional information below.</b>\n\nUsing Eclipse IDE.\n", "url": "https://github.com/google/guava/issues/931", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:29:12", "closed": "2014-10-31 21:03:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "In Maven Central the Ivy configuration does not download a compiled jar", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=925) created by **f.dalm...@miriade.it** on 2012-03-06 at 10:24 AM_\n\n---\n\nI try to configure Ivy dep as explained in documentation and in maven central repo\n\n&lt;dependency org=\"com.google.guava\" name=\"guava\" rev=\"11.0.2\" >\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifact name=\"guava\" type=\"jar\" />\n&lt;/dependency>\n\nIvy retrieve task downloads a jar without .class files. It contains only .java files.\nI suppose it requires a post-compilation step, but this is not documented.\n", "url": "https://github.com/google/guava/issues/925", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:29:00", "closed": "2014-10-31 21:02:09", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Issue with interpretation of @Nullable for parameters", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=920) created by **daniel.holmes.duke** on 2012-03-02 at 01:31 PM_\n\n---\n\nUpgrading my toolset to using Findbugs 2.0.0 now is identifyng erros because of the use of the @\ufeffNullable on the parameter of this interface.\n\nFrom my reading of the annotation meaning and the Javadoc for the Function.apply() function, they seem in conflict.\n\nMy understanding of @\ufeffNullable as a parameter is \"An element annotated with @\ufeffNullable claims the null value is perfectly valid to return (for methods), pass to (for parameters) and hold (for local variables and fields).\" - from http://www.jetbrains.com/idea/documentation/howto.html  To me this means that the method with a Nullable parameter should handle a null input cleanly and not NPE because of it.\n\nThe Function.apply() is documented as \"    Throws:      NullPointerException - if input is null and this function does not accept null arguments\", which seems to mean that the contract for the method in fact not in accordance with what @\ufeffNullable would mean for the parameter.  \n\nI wrote my functions based on the allowed NPE behavior being OK.\nI have static private anonymous uses of Function that I know are NPE safe because I know I pass non nulls, so I don't do any assert level checking or have null input handling.  Now with the newest findbugs it is identifying potential NPE problems here.\n\nI don't want to add warning suppression for Finbugs NP errors, that would be a pattern that I don't want new people on my project to see and copy wrongly.  I think that the root of the problem however is the @\ufeffNullable in the Function interface definition, and unfortunately from the definition of these annotations, I cannot override this setting either in my implementations of the interface.\n\n<b>What steps will reproduce the problem?</b>\n<b>1.</b>\n<b>2.</b>\n<b>3.</b>\n\n<b>What is the expected output? What do you see instead?</b>\n\n<b>What version of the product are you using? On what operating system?</b>\n\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/920", "user": "gissuebot", "labels": ["package=general", "status=duplicate", "type=defect"], "created": "2014-10-31 17:28:49", "closed": "2014-11-01 02:25:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ListMultiMap - Failed to 'put' causes the internal iterator in inconsistent state - NoSuchElementException thrown", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=919) created by **stinkyminky** on 2012-03-01 at 11:19 PM_\n\n---\n\nFailed to add 'value' to 'list'-value will make MultiMap in inconsistent state - so iterating through entry-iterator can throw NoSuchElementException is throw.\n\nThis happens if you only attempt to do MultiMap.put() - which fails b/c the supplied list fail to 'add()'.\n\nIf you try to putAll into another multimap, you get\n\nException in thread \"main\" java.util.NoSuchElementException\n&nbsp;&nbsp;&nbsp;&nbsp;at java.util.AbstractList$Itr.next(AbstractList.java:350)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.AbstractMultimap$EntryIterator.next(AbstractMultimap.java:1140)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.AbstractMultimap$EntryIterator.next(AbstractMultimap.java:1108)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.AbstractMultimap.putAll(AbstractMultimap.java:264)\n\nThe sample code can reproduce the problem\n", "url": "https://github.com/google/guava/issues/919", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:28:47", "closed": "2014-10-31 21:05:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Patch for /guava/src/com/google/common/collect/Multimap.java", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=914) created by **tuckerpmt** on 2012-03-01 at 04:07 PM_\n\n---\n\nAdd size(K key) to the interface so we don't have to do get(K key).size()\n\n0 can be returned if the key is not found.\n", "url": "https://github.com/google/guava/issues/914", "user": "gissuebot", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:28:37", "closed": "2014-10-31 23:28:12", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "guava event bus synchronization", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=898) created by **stephanebrossier** on 2012-02-10 at 09:48 PM_\n\n---\n\nIn the snippet below, its is possible to have two concurrent threads executing this code; they both check that isDispatching.get() is false [in a multi core environment or if scheduling happens right at this point]  and then they would both execute the dispatching in parallel.\n\nSuggestion use compareAndSet instead.\n\n---\n\n&nbsp;protected void dispatchQueuedEvents() {\n&nbsp;&nbsp;&nbsp;&nbsp;// don't dispatch if we're already dispatching, that would allow reentrancy\n&nbsp;&nbsp;&nbsp;&nbsp;// and out-of-order events. Instead, leave the events to be dispatched\n&nbsp;&nbsp;&nbsp;&nbsp;// after the in-progress dispatch is complete.\n&nbsp;&nbsp;&nbsp;&nbsp;if (isDispatching.get()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n```\nisDispatching.set(true);\n```\n", "url": "https://github.com/google/guava/issues/898", "user": "gissuebot", "labels": ["package=eventbus", "status=invalid", "type=defect"], "created": "2014-10-31 17:28:04", "closed": "2014-11-01 00:15:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Cache Bug - wrong removal", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=896) created by **kwak70** on 2012-02-10 at 03:52 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1.Test the following source.\n\n```\npublic static void main(String[] args) throws Exception\n{\n    CacheBuilder cacheBuilder = CacheBuilder.newBuilder();\n    cacheBuilder.maximumSize(5);\n    cacheBuilder.removalListener(new RemovalListener() {\n        public void onRemoval(RemovalNotification notification) {\n            System.out.println(\"\\t * onRemoval # \"+ notification);            \n            }\n    });\n    Cache<Integer,Integer> cache = cacheBuilder.build();\n    for(int i=0;i<10;i++)\n    {\n        cache.put(i,i);\n        System.out.println(\">>> i:cache # \"+ i +\":\"+ cache.size() +\":\"+ cache.stats() +\":\"+ cache.asMap());\n        Thread.sleep(5000);\n    }\n```\n\n<b>What is the expected output? What do you see instead?</b>\n\n> > > i:cache # 0:1:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=0}:{0=0}\n> > > i:cache # 1:2:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=0}:{0=0, 1=1}\n> > > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* onRemoval # 1=1(****\\* why remove ?)\n> > > i:cache # 2:2:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1}:{0=0, 2=2}\n> > > i:cache # 3:3:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1}:{0=0, 2=2, 3=3}\n> > > i:cache # 4:4:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1}:{0=0, 2=2, 3=3, 4=4}\n> > > i:cache # 5:5:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1}:{5=5, 0=0, 2=2, 3=3, 4=4}\n> > > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* onRemoval # 5=5(****\\* not remove by LRU)\n> > > i:cache # 6:5:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=2}:{6=6, 0=0, 2=2, 3=3, 4=4}\n> > > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* onRemoval # 0=0(****\\* not remove by LRU)\n> > > i:cache # 7:5:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=3}:{6=6, 7=7, 2=2, 3=3, 4=4}\n> > > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* onRemoval # 7=7(****\\* not remove by LRU)\n> > > i:cache # 8:5:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=4}:{6=6, 8=8, 2=2, 3=3, 4=4}\n> > > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* onRemoval # 2=2(****\\* not remove by LRU)\n> > > i:cache # 9:5:CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=5}:{6=6, 8=8, 9=9, 3=3, 4=4}\n\n<b>What version of the product are you using? On what operating system?</b>\n11.0.1,Windows XP\n\n<b>Please provide any additional information below.</b>\n1. cache.size less than maximumSize,onRemoval happened.\n2. removal order is not LRU order.\n", "url": "https://github.com/google/guava/issues/896", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:27:59", "closed": "2014-11-01 01:55:33", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "BloomFilter throws exception on large tables", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=892) created by **wasserman.louis** on 2012-02-02 at 02:09 AM_\n\n---\n\nFrom StackOverflow, http://stackoverflow.com/questions/9105690/guava-bloom-filter-does-not-support-large-insertions :\n\n\"I was using the BloomFilter in guava v.11.0.1 and it seems like I am getting an exception when my insertion is large. I tried at 10 million with 0.001 fpp, and it failed.\n\njava.lang.IllegalArgumentException: Number of bits must be positive at com.google.common.base.Preconditions.checkArgument(Preconditions.java:88) at com.google.common.hash.BloomFilterStrategies.checkPositiveAndMakeMultipleOf64(BloomFilterStrategies.java:72) at com.google.common.hash.BloomFilterStrategies.access$000(BloomFilterStrategies.java:18) at com.google.common.hash.BloomFilterStrategies$From128ToN.withBits(BloomFilterStrategies.java:37) at com.google.common.hash.BloomFilter.create(BloomFilter.java:192) at com.ipg.collection.BloomFilterWritable.impl(BloomFilterWritable.java:43) at com.ipg.collection.BloomFilterWritable.put(BloomFilterWritable.java:62) at com.ipg.prophet.twitter.twitflow.archive.UnzipTweetsProcessAndUpload$ProcessorConsumer.process(UnzipTweetsProcessAndUpload.java:107) at com.ipg.prophet.twitter.twitflow.archive.UnzipTweetsProcessAndUpload$ProcessorConsumer.run(UnzipTweetsProcessAndUpload.java:84) at java.lang.Thread.run(Thread.java:662)\n\nI think at least it should support that many insertions with such a high fpp no?\"\n\nI've verified this independently, and I believe this to be a genuine bug, caused by the following mistake (which also probably causes _major_ performance issues): The line \n\n&nbsp;&nbsp;&nbsp;HashFunction hashFunction = BloomFilterStrategies.From128ToN.withBits(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bits.size() \\* k, Hashing.murmur3_128());\n\nshould be\n&nbsp;&nbsp;&nbsp;HashFunction hashFunction = BloomFilterStrategies.From128ToN.withBits(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log2(bits.size()) \\* k, Hashing.murmur3_128());\n\nWhat's going on here is that the extended hash function should output enough bits to determine k indices in the \"bits\" bit-vector, but that means it should be outputting k times the logarithm.\n\nAs it stands, this almost certainly evaded testing because it only changes the _semantics_ for very large table sizes.  Specifically, it fails badly when n is especially large, which the tests don't seem to hit.\n\nThis makes BloomFilter really inadvisable to use while it's left unfixed, as it slows down all Bloom filters by an _exponential_ factor, even the ones it doesn't actively break.\n", "url": "https://github.com/google/guava/issues/892", "user": "gissuebot", "labels": ["package=hash", "status=fixed", "type=defect"], "created": "2014-10-31 17:27:51", "closed": "2014-10-31 23:06:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "prevent recursive removal notifications?", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=891) created by **m...@talios.com** on 2012-02-01 at 10:09 PM_\n\n---\n\nWhat steps will reproduce the problem?\n\nWhen using a RemovalListener on a Cache, adding the same key back into the Cache when the notification was not an eviction notification yields a recursive call stack, which can sometimes blow out to a StackOverflow.  When running this test code locally, the code completes successfully but consistently calls the RemovalListener 618/619 times for each cycle.\n\nThe following sample code demonstrates the behavior:\n\npackage smx3.reporting.subscriptions.queue;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.RemovalListener;\nimport com.google.common.cache.RemovalNotification;\nimport org.testng.annotations.Test;\n\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\npublic class RemovalListenerTest {\n\n```\nCache<String, Integer> cache;\n\n@Test\npublic void testStackOverflowOnRemovalListener() {\n\n    cache = CacheBuilder.newBuilder()\n            .expireAfterWrite(100, TimeUnit.MILLISECONDS)\n            .removalListener(new RemovalListener<String, Integer>() {\n                @Override\n                public void onRemoval(RemovalNotification<String, Integer> notification) {\n                    System.out.println(String.format(\"Removal of %s with value %s, was it evicted: %s\", notification.getKey(), notification.getValue(),notification.wasEvicted()));\n                    cache.put(notification.getKey(), notification.getValue() + 1);\n                }\n            })\n            .build();\n\n    final long start = new Date().getTime();\n    System.out.println(\"Initial Item - \" + start);\n    cache.put(\"foo\", 1);\n    System.out.println(\"Replacement Item\");\n    cache.put(\"foo\", 1000);\n    System.out.println(\"Ended after \" + (new Date().getTime() - start) + \" ms\");\n\n}\n```\n\n}\n\nThe output of the above is posted to https://gist.github.com/bec13b184f6521365cc0\n\nWhat we're doing is somewhat nasty in that we're wanting to modify the behavior of expireAfterWrite, if we only re-add the key if notification.wasEvicted() is true the problem should go away.\n\nWhen thinking about what I'm doing, ideally I want someway of saying \"roll back this eviction\", something like \"notification.rollback()\" which the Cache could handle appropriately.\n\nWhat version of the product are you using? On what operating system?\n\nOS/X and Redhat Linux, Guava 11.0\n", "url": "https://github.com/google/guava/issues/891", "user": "gissuebot", "labels": ["package=cache", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:27:49", "closed": "2014-10-31 21:04:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "GWT compilation error with CacheBuilder", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=887) created by **guiroux22** on 2012-01-27 at 04:29 PM_\n\n---\n\nI'm using the CacheBuilder of Guava 11.0.1 in GWT, but I'm getting an error during the compilation.\nHere's the code I've used :\nFunction&lt;Date, Range&lt;Date>> monthRangeFunction = CacheBuilder.newBuilder().build(CacheLoader.from(new Function&lt;Date, Range&lt;Date>>(){ ... }));\n\nAnd the compilation error :\n[INFO] [ERROR] Errors in 'jar:file:/C:/Users/User/.m2/repository/com/google/guava/guava-gwt/11.0.1/guava-gwt-11.0.1.jar!/com/google/common/cache/super/com/google/common/cache/CacheBuilder.java'\n[INFO]    [ERROR] Line 114:  The type CacheBuilder&lt;K,V>.LocalManualCache&lt;K,V> must implement the inherited abstract method Cache&lt;K,V>.get(K)\n\nThanks\n", "url": "https://github.com/google/guava/issues/887", "user": "gissuebot", "labels": ["platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:27:40", "closed": "2014-11-01 00:50:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Can't build current git repo with Maven", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=885) created by **keithl** on 2012-01-26 at 07:32 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. git clone https://code.google.com/p/guava-libraries\n2. mvn -e -X test\n\n<b>What is the expected output? What do you see instead?</b>\n\nSee attached file. The main error is:\n\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-dependency-plugin:2.3:copy-dependencies (prep-guava-bootstrap) on project guava: Error copying artifact from /Users/keith/Code/guava-libraries/guava-bootstrap/target/classes to /Users/keith/Code/guava-libraries/guava/target/dependency/guava-bootstrap-latest.jar: /Users/keith/Code/guava-libraries/guava-bootstrap/target/classes (No such file or directory)\n\n<b>What version of the product are you using? On what operating system?</b>\n\nApache Maven 3.0.3 (r1075438; 2011-02-28 12:31:09-0500)\nMaven home: /usr/share/maven\nJava version: 1.6.0_29, vendor: Apple Inc.\nJava home: /Library/Java/JavaVirtualMachines/1.6.0_29-b11-402.jdk/Contents/Home\nDefault locale: en_US, platform encoding: MacRoman\nOS name: \"mac os x\", version: \"10.7.2\", arch: \"x86_64\", family: \"mac\"\n", "url": "https://github.com/google/guava/issues/885", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:27:36", "closed": "2014-10-31 20:40:44", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Annoying warning on TreeMultiset.comparator", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=871) created by **Yoav.Zibin** on 2012-01-17 at 10:44 PM_\n\n---\n\nMy GWT code uses Multiset&lt;Long> and when I compile it I get this warning:\n\ncom.google.common.collect.Multiset&lt;java.lang.Long>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifying instantiability\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.google.common.collect.TreeMultiset&lt;java.lang.Long>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analyzing the fields of type 'com.google.common.collect.TreeMultiset&lt;java.lang.Long>' that qualify for serialization\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[WARN] Field 'private final java.util.Comparator<? super E> comparator' will not be serialized because it is final\n", "url": "https://github.com/google/guava/issues/871", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:27:07", "closed": "2014-10-31 20:41:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Optional.presentInstances is faulty", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=850) created by **em...@soldal.org** on 2012-01-02 at 01:28 PM_\n\n---\n\nThis method returns and Iterable which you can only be accessed once, perhaps the method should look something like this:\n\n```\npublic static <T> Iterable<T> presentInstances(final Iterable<Optional<T>> optionals) {\n    checkNotNull(optionals);\n    checkNotNull(optionals.iterator());\n    return new Iterable<T>() {\n        @Override\n        public Iterator<T> iterator() {\n            final Iterator<Optional<T>> iterator = optionals.iterator();\n            return new AbstractIterator<T>() {\n                @Override\n                protected T computeNext() {\n                    while (iterator.hasNext()) {\n                        Optional<T> optional = iterator.next();\n                        if (optional.isPresent()) {\n                            return optional.get();\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        };\n    };\n}\n```\n", "url": "https://github.com/google/guava/issues/850", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:26:22", "closed": "2014-10-31 20:32:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "new Stopwatch() throws exception java.lang.IncompatibleClassChangeError on Ubuntu", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=842) created by **tdziurko** on 2011-12-26 at 01:14 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Stopwatch stopwatch = new Stopwatch();\n\n<b>What is the expected output? What do you see instead?</b>\nIt should create new instance of Stopwatch.\n\nWhat I get is:\njava.lang.IncompatibleClassChangeError: Found interface com.google.common.base.Ticker, but class was expected\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Stopwatch.&lt;init>(Stopwatch.java:84)\n\n<b>What version of the product are you using? On what operating system?</b>\nGuava 10.0.1, Ubuntu 10, Java 1.6.0_26\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/842", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:26:05", "closed": "2014-10-31 20:23:36", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.forUriString() throws IllegalArgumentException for IPv4-mapped IPv6 address", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=837) created by **bordoley** on 2011-12-23 at 07:22 PM_\n\n---\n\nInetAddresses.forUriString(\"[::FFFF:129.144.52.38]\"); throws an IllegalArgumentException. Looking at the code this is due to the following snippet:\n\n```\n// IPv6 address\nif (!(hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))) {\n  throw new IllegalArgumentException(\"Not a valid address: \\\"\" + hostAddr + '\"');\n}\n\nretval = forString(hostAddr.substring(1, hostAddr.length() - 1));\nif (retval instanceof Inet6Address) {\n  return retval;\n}\n```\n\n&nbsp;I don't think it's necessary to verify that retval is an Inet6Address object.\n", "url": "https://github.com/google/guava/issues/837", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:25:54", "closed": "2014-10-31 21:00:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MessageDigestHashFunctions not thread-safe", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=830) created by **toellrich** on 2011-12-21 at 12:12 PM_\n\n---\n\nI've had a look at the new hash functions in Guava 11 and plan on replacing my password hashing code with it since it gives me a nice, fluent API without checked exceptions.\n\nThe MessageDigest hash functions (MD5, SHA-1, SHA-256 and SHA-512) however, don't seem to work in multi-threaded applications. That's because they are stored as class variables. In order to make it work the following code \n\npublic static HashFunction sha256() {\n&nbsp;&nbsp;&nbsp;&nbsp;return SHA_256;\n}\n\nshould be replaced with \n\npublic static HashFunction sha256() {\n&nbsp;&nbsp;&nbsp;&nbsp;return new MessageDigestHashFunction(\"SHA-256\");\n}\n\nA similar change is required for the other MessageDigest hash functions. Even then, there should be a comment in the JavaDoc saying that the resulting HashFunction is not thread-safe (but would work in multi-threaded applications).\n", "url": "https://github.com/google/guava/issues/830", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:25:40", "closed": "2014-10-31 23:06:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Document AbstractScheduledService concurrency policy", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=826) created by **tpeierls** on 2011-12-15 at 04:11 PM_\n\n---\n\nThe use of unguarded fields in the example in the class comment of AbstractScheduledService strongly suggests that runOneIteration will never be executed by more than one thread concurrently, and that there are happens-before edges between consecutive calls to runOneIteration. \n\nI can't find a guarantee of this in the docs, however.\n", "url": "https://github.com/google/guava/issues/826", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:25:31", "closed": "2014-10-31 23:04:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Spelling error in example in AbstractScheduledService class comment", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=825) created by **tpeierls** on 2011-12-15 at 04:06 PM_\n\n---\n\nThe class comment for AbstractScheduledService in 11.0-rc1 has an example that defines a protected method schedule() returning a Schedule, but the actual API defines protected method scheduler() returning a Scheduler.\n\nIn addition, the example uses newFixedRateSchedule instead of newFixedRateScheduler.\n", "url": "https://github.com/google/guava/issues/825", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:25:29", "closed": "2014-10-31 23:04:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Decrease in generated garbage", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=820) created by **frank.pavageau** on 2011-12-12 at 12:11 PM_\n\n---\n\nPredicates$AndPredicate and Predicate$OrPredicate use a for-each loop in their apply method when they could use for (int i = 0, size = components.size(); ...) since the components field contains an ArrayList.\n\nIt might seem like a premature optimization, but it's really not. I have a project relying heavily on guava for some pretty intensive computations, and the iterators instanciated by these 2 predicates alone amount to 1.5% of the number of garbage-collected objects and 1% of the size.\n", "url": "https://github.com/google/guava/issues/820", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:25:18", "closed": "2014-10-31 20:53:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Clarify LoadingCache behavior on refresh", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=817) created by **wasserman.louis** on 2011-12-07 at 09:57 PM_\n\n---\n\nI can't tell, from the documentation, if a LoadingCache.refresh call will execute a RemovalNotification, and what the Notification would say..  Will it generate a REPLACED notification, but only after the refresh is complete?  Will it not generate any notification?\n\nI'd like to know the answer, but more importantly, I'd like to fix the documentation.\n", "url": "https://github.com/google/guava/issues/817", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:25:12", "closed": "2014-10-31 21:21:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "invalid boolean expression", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=805) created by **kofemann** on 2011-11-25 at 10:43 AM_\n\n---\n\nIn IntMath:\n\n&nbsp;&nbsp;public static boolean isPowerOfTwo(int x) {\n&nbsp;&nbsp;&nbsp;&nbsp;return x > 0 & (x & (x - 1)) == 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^\n&nbsp;&nbsp;}\n\nshould be:\n\n&nbsp;&nbsp;public static boolean isPowerOfTwo(int x) {\n&nbsp;&nbsp;&nbsp;&nbsp;return x > 0 && (x & (x - 1)) == 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^^\n&nbsp;&nbsp;}\n\nOr I am wrong?\n", "url": "https://github.com/google/guava/issues/805", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:24:47", "closed": "2014-10-31 20:06:36", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Entries from MapMaker.weakValues() are not removed", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=801) created by **boucher.frederic** on 2011-11-23 at 01:38 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n\nUsing guava 10.0.0 :\n- Instantiate a new MapMaker.weakValues().makeMap();\n- Put a new value: map.put(\"KEY1\", new Object());\n- Launch the garbage collector using System.gc();\n\n\"KEY1\" is no longer available but the associated entry is never removed from the map.\n\n<b>What is the expected output? What do you see instead?</b>\n\nExcept that the entries from a map built using MapMaker.weakValues().makeMap() are removed after the weak value is garbage collected. But the entries are never removed.\n\n<b>What version of the product are you using? On what operating system?</b>\n\nThe Entry removal works with guava 9.0.0 but not with 10.0.0\n", "url": "https://github.com/google/guava/issues/801", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:24:38", "closed": "2014-10-31 20:06:17", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Patch for /guava/src/com/google/common/eventbus/EventBus.java", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=798) created by **zhilyaev** on 2011-11-21 at 04:30 PM_\n\n---\n\nAvoids adding duplicates to the list with parent interfaces when flatten hierarchy is retrieved.\n", "url": "https://github.com/google/guava/issues/798", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:24:32", "closed": "2014-10-31 23:28:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "HashBasedTable GWT-RPC Serialization Exception", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=791) created by **mishamo** on 2011-11-15 at 11:08 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Instantiate a HashBasedTable&lt;X,Y,Z> with HashBasedTable.create();\nwhere X, Y and Z are all 'IsSerializable' types.\n2. Send the table as part of a GWT-RPC request.\n\n<b>What is the expected output? What do you see instead?</b>\nExpected output is to receive the HashBasedTable&lt;X,Y,Z> on the servlet side. Instead this exception is thrown by GWT:\n\ncom.google.gwt.user.client.rpc.SerializationException\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$fillInStackTrace(StackTraceCreator.java:168)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.fillInStackTrace(StackTraceCreator.java:421)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.Exception_0(Throwable.java:46)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.SerializationException_0(SerializationException.java:27)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$check(SerializerBase.java:137)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$serialize(SerializerBase.java:122)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$writeObject(AbstractSerializationStreamWriter.java:126)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.serialize_7(HashBasedTable_CustomFieldSerializer.java:56)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$serialize_0(SerializerBase.java:64)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$serialize(SerializerBase.java:123)\n&nbsp;&nbsp;&nbsp;&nbsp;at Unknown.$writeObject(AbstractSerializationStreamWriter.java:126)\n\n<b>What version of the product are you using? On what operating system?</b>\nUsing guava-gwt-10.0.1 on Ubuntu 10.04\n\n<b>Please provide any additional information below.</b>\nThe likely cause of this is that HashBasedTable calls 'super(backingMap, factory)' when created where its super class (StandardTable) has final instance variables which breaks the contract required by GWT-RPC:\n\n\"1. A user-defined class is serializable if all of the following apply:\nIt is assignable to IsSerializable or Serializable, either because it directly implements one of these interfaces or because it derives from a superclass that does\n2. All non-final, non-transient instance fields are themselves serializable, and\n3. As of GWT 1.5, it must have a default (zero argument) constructor (with any access modifier) or no constructor at all.\"\n", "url": "https://github.com/google/guava/issues/791", "user": "gissuebot", "labels": ["platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:24:17", "closed": "2014-10-31 20:09:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "TreeMultimap iterator.remove() bug", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=790) created by **nick.stroh** on 2011-11-14 at 08:43 PM_\n\n---\n\nThe following code using TreeMultimap.keySet().iterator().remove() has unexpected behavior.  \n\nIf \"valueToRemove\" is 50 or 300, the code works fine.  If the value is 100, the multimap removes the values for \"300\" in addition to the values for \"100\".\n\n```\n    TreeMultimap<Long, String> m = new TreeMultimap<Long, String>();\n    m.put(new Long(50), \"50\");\n    m.put(new Long(100), \"100\");\n    m.put(new Long(300), \"300\");\n    m.put(new Long(300), \"301\");\n    long valueToRemove = 100;\n\n\n    Iterator<Long> it = m.keySet().iterator();\n    while (it.hasNext()) {\n        Long l = it.next();\n        if (l.longValue() == valueToRemove) {\n            it.remove();\n        }\n    }\n\n    for (Long l : m.keySet()) \n        System.out.println(l + \" : \" + m.get(l));\n}\n```\n\n<b>What version of the product are you using? On what operating system?</b>\n1.0, CentOS\n", "url": "https://github.com/google/guava/issues/790", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:24:15", "closed": "2014-10-31 20:03:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Minor Futures.chain Javadoc issue", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=788) created by **cgdecker** on 2011-11-11 at 03:10 AM_\n\n---\n\nFutures.chain has the following example:\n\n&nbsp;&nbsp;&nbsp;ListenableFuture&lt;RowKey> rowKeyFuture = indexService.lookUp(query);\n&nbsp;&nbsp;&nbsp;Function&lt;RowKey, ListenableFuture&lt;QueryResult>> queryFunction =\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Function&lt;RowKey, ListenableFuture&lt;QueryResult>>() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ListenableFuture&lt;QueryResult> apply(RowKey rowKey) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dataService.read(rowKey);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;ListenableFuture&lt;QueryResult> queryFuture =\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain(queryFuture, queryFunction);\n\nThe first argument to chain there should be \"rowKeyFuture\" rather than \"queryFuture\". The same is true of the other overload.\n", "url": "https://github.com/google/guava/issues/788", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:24:11", "closed": "2014-10-31 20:10:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "eventbus dispatches single event multiple times to most-derived listener if parents are listeners for same event", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=783) created by **alexrhelder** on 2011-11-05 at 05:57 AM_\n\n---\n\nConsider the following:\n\npublic class main {\n\n```\nstatic class Foo {}\nstatic class Bar extends Foo {}\n\nstatic class BaseListener {\n    @Subscribe\n    public void foo(Foo foo) {\n        System.out.println(\"base \" + foo.toString());\n    }\n}\n\nstatic class DerivedListener extends BaseListener {\n    @Subscribe\n    public void foo(Foo foo) {\n        System.out.println(\"derived \" + foo.toString());\n    }\n}\n\npublic static void main(String[] args) {\n\n    EventBus eventbus = new EventBus(\"eventbus\");\n\n    DerivedListener d = new DerivedListener();\n    eventbus.register(d);\n    eventbus.post(new Bar());\n}\n```\n\n}\n\nThe output will be:\n\nderived foo main$Bar@99b5393\nderived foo main$Bar@99b5393\n\nI would expect derived foo to be called once.\n", "url": "https://github.com/google/guava/issues/783", "user": "gissuebot", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 17:24:00", "closed": "2014-10-31 23:20:33", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "com.google.common.base.Ticker$1 not serializable", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=782) created by **heuermh** on 2011-11-04 at 02:16 AM_\n\n---\n\nWhen attempting to serialize a Cache created with\n\ncache = CacheBuilder.newBuilder().build(cacheLoader);\n\nwhere cacheLoader is serializable, I hit\n\njava.io.NotSerializableException: com.google.common.base.Ticker$1\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1180)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1528)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1493)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1416)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1174)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1528)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1493)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1416)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1174)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:346)\n...\n\nFeel free to merge with issue 615, if appropriate.\n", "url": "https://github.com/google/guava/issues/782", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:23:58", "closed": "2014-10-31 20:03:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "EventBus.dispatch exposes package private class EventHandler", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=780) created by **ostybosty** on 2011-11-03 at 01:27 PM_\n\n---\n\nIt's impossible to override EventBus.dispatch(Object, EventHandler) due to the package private visibility of EventHandler.\n", "url": "https://github.com/google/guava/issues/780", "user": "gissuebot", "labels": ["package=eventbus", "status=fixed", "type=defect"], "created": "2014-10-31 17:23:54", "closed": "2014-11-01 00:34:39", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "RemovalListeners semantics bug", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=778) created by **nto...@maginatics.com** on 2011-11-02 at 06:17 PM_\n\n---\n\nI was looking at the RemovalListeners.asynchronous() method and the Javadoc promises that it \"processes all eviction notifications asynchronously.\" However, the implementation in 10.0.1 calls executor.execute() whose Javadoc [1] mentions that \"The command may execute... in the calling thread.\"\n\nIf I am reading this correctly, this would make the eviction notification synchronous. Should RemovalListeners.asynchronous() be using an ExecutorService and calling the .submit() method instead?\n\n[1] http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html#execute%28java.lang.Runnable%29\n", "url": "https://github.com/google/guava/issues/778", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:23:50", "closed": "2014-10-31 20:08:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Clarification of Beta-APIs", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=770) created by **drothmaler** on 2011-10-21 at 09:00 AM_\n\n---\n\nRecently the usage of some API-parts, marked as @\ufeffBeta caused some misunderstandings inside our team.\nBecause \"beta\" sounds evil and buggy.\n\nSo it would be nice, if you could include the statement, made at the discussion-group ( http://groups.google.com/group/guava-discuss/browse_thread/thread/16822b864d52608e/4f15baa530a717e9 ) as part of the JavaDoc of the Beta annotation.\n\nAlso you may consider renaming the Beta annotation to something more friendly like \"SubjectToChange\" or \"MayChange\".\n\nBest regards,\nDaniel\n", "url": "https://github.com/google/guava/issues/770", "user": "gissuebot", "labels": ["package=general", "status=fixed", "type=defect"], "created": "2014-10-31 17:23:33", "closed": "2014-10-31 23:08:34", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Function interface mismatch causes failure at runtime  ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=765) created by **Todd.Schiller** on 2011-10-19 at 05:43 AM_\n\n---\n\nI define a Function of the form:\n\nnew Function&lt;MyType, String>(){\n&nbsp;&nbsp;@\ufeffOverride\n&nbsp;&nbsp;public String apply(MyType arg0){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...;\n&nbsp;&nbsp;}\n}\n\n, which compiles in Eclipse as expected. However, at runtime in hosted mode, I receive the following errors:\n\n[ERROR] [MyProject] - Line XXX: The type new Function&lt;MyType,String>(){} must implement the inherited abstract method Function&lt;MyType,String>.apply(Object)\n\n[ERROR] [MyProject] - Line YYY: The method apply(MyType) of type new Function&lt;MyType,String>(){} must override or implement a supertype method\n\n<b>What version of the product are you using? On what operating system?</b>\n\nGuava GWT 10.0.1\n\n<b>Please provide any additional information below.</b>\n\nGWT 2.4.0\nGuava 10.0.1\nEclipse 3.7.1\nJavaSE-1.6\nFedora Core 14 (2.6.35.14-96.fc14.i686.PAE)\n", "url": "https://github.com/google/guava/issues/765", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:23:23", "closed": "2014-10-31 20:08:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Request to revert change to mark ListenableFutureTask as final", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=760) created by **jdsullivan** on 2011-10-16 at 05:34 PM_\n\n---\n\nThis is a request that the change to mark ListenableFutureTask as final be reverted. This reduces the utility of this class as applications can no longer override done() to be notified when the task is finished executing. For people familiar with FutureTask, this is an inconsistency in how the class can be used.\n\nIf this change can't be made, I'd like to request that a new interface such as RunnableListenableFuture be introduced. This should be similar to RunnableFuture, but implement ListenableFuture as well. The comments for ListenableFutureTask should also be cleaned up to remove references to overriding done().\n", "url": "https://github.com/google/guava/issues/760", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:23:12", "closed": "2014-11-01 01:26:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Itera*s methods with \"T defaultValue\" are missing a wildcard on the input Itera*", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=745) created by **cheremin** on 2011-10-07 at 02:26 PM_\n\n---\n\nCurrently signature is\n\npublic static &lt;T> T getFirst(Iterable&lt;T> iterable, @\ufeffNullable T defaultValue)\n\nbut it'll be more usefull to have\n\npublic static &lt;T> T getFirst(Iterable<? extends T> iterable, @\ufeffNullable T defaultValue)\n\nSame for \n\nIterators.getNext(Iterator&lt;T> iterator, @\ufeffNullable T defaultValue) \n\nto become\n\nIterators.getNext(Iterator<? extends T> iterator, @\ufeffNullable T defaultValue) \n", "url": "https://github.com/google/guava/issues/745", "user": "gissuebot", "labels": ["package=collect", "status=fixed", "type=defect"], "created": "2014-10-31 17:22:41", "closed": "2014-10-31 23:09:41", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CacheBuilder newBuilder method should be parameterised", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=738) created by **samuel.lb** on 2011-10-04 at 07:22 PM_\n\n---\n\nThe current (10.0) implementation is:\n\npublic static CacheBuilder&lt;Object, Object> newBuilder() {\n&nbsp;&nbsp;&nbsp;&nbsp;return new CacheBuilder&lt;Object, Object>();\n}\n\nmy take is  that it was meant to be:\n\npublic static &lt;K, V> CacheBuilder&lt;K, V> newBuilder() {\n&nbsp;&nbsp;return new CacheBuilder&lt;K, V>();\n}\n", "url": "https://github.com/google/guava/issues/738", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:22:26", "closed": "2014-11-01 01:38:43", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Multimaps.newListMultimap should document that map must be empty", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=736) created by **dancerjohn** on 2011-10-04 at 06:29 PM_\n\n---\n\nIf the map passed to Multimaps.newListMultimap is not empty an IllegalArgumentException is thrown. This should be documented. \n\nLooking at this method I thought I could use it to create a copy or a view of an existing Map&lt;K, Collection&lt;V>>. There is a not a way to do this and I will open another issue to address that issue.\n", "url": "https://github.com/google/guava/issues/736", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:22:22", "closed": "2014-10-31 20:08:23", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Suppliers.supplierFunction should return Function<Supplier<? extends T>, T>", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=735) created by **joesbigidea** on 2011-10-04 at 01:44 PM_\n\n---\n\nThe SupplierFunction can safely handle any Supplier of type ? extends T, so Suppliers.supplierFunction should really return Function&lt;Supplier<? extends T>, T>.  At least, I can't think of why you wouldn't.\n", "url": "https://github.com/google/guava/issues/735", "user": "gissuebot", "labels": ["package=base", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:22:20", "closed": "2014-10-31 20:52:55", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Stopwatch.elapsedTime(TimeUnit) hardcoded to NANOSECONDS", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=727) created by **jonathan.russell** on 2011-09-30 at 12:26 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Use the Stopwatch to time something\n2. make a call to elapsedTime(TimeUnit) and supply a TimeUnit other than NANOSECONDS\n\n<b>What is the expected output? What do you see instead?</b>\nExpect to see the elapsed time in the specified TimeUnit.  Instead, it is always returned in NANOSECONDS\n\n<b>What version of the product are you using? On what operating system?</b>\nrelease 10.0 on OS X 10.7.2\n\n<b>Please provide any additional information below.</b>\nLooking at the associated source code for this release revealed the problem: \n\n&nbsp;&nbsp;public long elapsedTime(TimeUnit desiredUnit) {\n&nbsp;&nbsp;&nbsp;&nbsp;return desiredUnit.convert(elapsedNanos(), NANOSECONDS);\n&nbsp;&nbsp;}\n", "url": "https://github.com/google/guava/issues/727", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:22:03", "closed": "2014-10-31 19:48:42", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "simplifyPath RC3", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=722) created by **thomas.andreas.jung** on 2011-09-26 at 11:16 AM_\n\n---\n\nI found some more bugs in the 10 RC3 version of simplifyPath\n\nin >/../c< out >//c< expected >/c<\nin >/./a< out >//a< expected >/a<\nin >./../../< out >....< expected >../..<\n", "url": "https://github.com/google/guava/issues/722", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:52", "closed": "2014-10-31 19:49:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "TreeMultiset.subMultiset().size() overflow condition", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=720) created by **wasserman.louis** on 2011-09-23 at 01:38 AM_\n\n---\n\nHere is the failing test that should pass:\n\n```\nTreeMultiset<String> ms = TreeMultiset.create();\nms.add(\"a\", Integer.MAX_VALUE);\nms.add(\"b\", Integer.MAX_VALUE);\nms.add(\"c\", 3);\n\nassertEquals(3, ms.tailMultiset(\"c\", BoundType.CLOSED).size());\nassertEquals(Integer.MAX_VALUE, ms.tailMultiset(\"b\", BoundType.CLOSED).size());\n```\n\nA patch adding the test and fixing the bug is in http://code.google.com/r/wassermanlouis-guava/source/detail?r=d80fac77bada0d7bd588de64b6383ad3e2bc5471&name=fix-treemultiset-size .\n", "url": "https://github.com/google/guava/issues/720", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:48", "closed": "2014-10-31 19:49:54", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.simplifyPath(\"./a\") -> \"/a\"", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=716) created by **thomas.andreas.jung** on 2011-09-16 at 07:51 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\nassertEquals(\"a\", Files.simplifyPath(\"./a\"));\n\n<b>What version of the product are you using? On what operating system?</b>\ncommit 64b32d8a33f284adc71e423515b93fa83694fe97\nDate:   Thu Sep 15 10:25:07 2011 -0400\n\nI implemented a test hack to find the problems with simplifyPath. It creates a path string from the characters [a-c./] and checks that the canonical path does not change due to simplifyPath.\n\nassertEquals(new File(path).getCanonicalPath(), new File(Files.simplifyPath(path)).getCanonicalPath());\n\nSadly, this can't be used in an ordinary test. It depends on the current working directory for relative paths and produces invalids paths (for example \"a../b\" produces an IOException).\n\nOne way to increase the test coverage could be to create canonical paths (a, a/b, ../a, ..) and add changes that can be simplified to the canonical path:\nsimplyPath(\u201cx/../\u201d + relativePath) == relativePath\nsimplyPath(path + \u201c/x/../\u201d) == path\nsimplyPath(lpath + \u201c/x/../\u201d + rpath) == lpath + rpath\nsimplyPath(\u201c/\u201d + absolutePath) == absolutePath\nsimplyPath(\u201c./\u201d + relativePath) == relativePath\nsimplyPath(path + \u201c/./\u201d) == path\nsimplyPath(lpath + \u201c/./\u201d + rpath) == lpath + rpath\n\nThe changes to the canonical paths can also be generated \u201c/x/../\u201d is equivalent to \u201c/x/y/../../\u201d, \u201c/x/../y/../\u201d, etc.\n\nIf someone is interested I could implement this test.\n", "url": "https://github.com/google/guava/issues/716", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:40", "closed": "2014-10-31 19:47:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "remove completed TODO from CharMatcher", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=715) created by **yin...@yiningzhao.info** on 2011-09-16 at 02:34 AM_\n\n---\n\nmatchesAnyOf(CharSequence sequence) is implemented on line 745.\n", "url": "https://github.com/google/guava/issues/715", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:21:37", "closed": "2014-10-31 23:28:08", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CacheBuilder caches should be serializable", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=712) created by **kevinb@google.com** on 2011-09-14 at 03:42 PM_\n\n---\n\n(Since makeComputingMap is deprecated, and those were serializable)\n", "url": "https://github.com/google/guava/issues/712", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:31", "closed": "2014-10-31 19:53:41", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Truncation of Javadoc for com.google.common.base.Charsets", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=709) created by **Paul.Cager** on 2011-09-14 at 09:58 AM_\n\n---\n\nVery minor Javadoc problem:\n\nThe field summary for US_ASCII reads:\n\n&nbsp;&nbsp;&nbsp;\"US-ASCII: seven-bit ASCII, a.k.a.\"\n\n(i.e. has been truncated after the full stop).\n", "url": "https://github.com/google/guava/issues/709", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:24", "closed": "2014-10-31 20:08:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Documentation for Stopwatch's methods reset(), start() and stop() doesn't explain their return values", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=706) created by **ogregoire** on 2011-09-12 at 12:12 PM_\n\n---\n\nThe Javadoc doesn't explicitly mention the fact that the methods start(), stop() and reset() do actually return \"this\". One may think that it's another instance.\n\nI know it's kind of obvious that it returns this, but I think it's worth being mentioned.\n", "url": "https://github.com/google/guava/issues/706", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:18", "closed": "2014-10-31 23:28:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "simplifyPath(\"x/../../b\") is \"..b\" instead of \"../b\"", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=705) created by **thomas.andreas.jung** on 2011-09-12 at 11:27 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\nassertEquals(\"../b\", Files.simplifyPath(\"x/../../b\"));\n\n<b>What is the expected output? What do you see instead?</b>\nexpected: \"../b\", is: \"..b\"\n\n<b>What version of the product are you using? On what operating system?</b>\n&lt;dependency>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>com.google.guava&lt;/groupId>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>guava&lt;/artifactId>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>10.0-rc1&lt;/version>\n&lt;/dependency>\n", "url": "https://github.com/google/guava/issues/705", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:15", "closed": "2014-10-31 19:46:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "r10's Optional doesn't work with scala", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=704) created by **ebow...@boboco.ie** on 2011-09-11 at 01:08 AM_\n\n---\n\nBecause BaseHolder is package-protected, and because of https://issues.scala-lang.org/browse/SI-1430, using an Optional from Scala causes an IllegalAccessError.\n\nWould you be willing to consider making BaseHolder public?\n", "url": "https://github.com/google/guava/issues/704", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:12", "closed": "2014-10-31 19:46:17", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Unable to access ForwardingMap.StandardKeySet / ForwardingMap.StandardValues outside of c.g.c.collect", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=701) created by **neveue** on 2011-09-02 at 03:24 PM_\n\n---\n\nIn ForwardingMap, the methods standardKeySet() / standardValues() have been deprecated for release 10, with a suggestion to use the StandardKeySet / StandardValues protected inner classes instead.\n\nThis works flawlessly when the ForwardingMap subclass is in the com.google.common.collect package, but I get a compilation error when I attempt to subclass ForwardingMap in a different package:\n\npackage my.otherpackage;\n\nimport com.google.common.collect.ForwardingMap;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\n\npublic class MyForwardingMap&lt;K, V> extends ForwardingMap&lt;K, V> {\n\n```\nprivate final Map<K, V> backingMap;\n\npublic MyForwardingMap(SortedMap<K, V> backingMap) {\n    this.backingMap = backingMap;\n}\n\n@Override\nprotected Map<K, V> delegate() {\n    return backingMap;\n}\n\n@Override\npublic Set<K> keySet() {\n    return new StandardKeySet();\n}\n\n@Override\npublic Collection<V> values() {\n    return new StandardValues();\n}\n```\n\n}\n\n[ERROR] /home/etienne/code/checkouts/guava-by-example/src/main/java/my/otherpackage/MyForwardingMap.java:[25,15] StandardKeySet() has protected access in com.google.common.collect.ForwardingMap.StandardKeySet\n[ERROR] \n[ERROR] /home/etienne/code/checkouts/guava-by-example/src/main/java/my/otherpackage/MyForwardingMap.java:[30,15] StandardValues() has protected access in com.google.common.collect.ForwardingMap.StandardValues\n\nIt compiles fine when I create anonymous subclasses:\n\n```\n@Override\npublic Set<K> keySet() {\n    return new StandardKeySet(){};\n}\n\n@Override\npublic Collection<V> values() {\n    return new StandardValues(){};\n}\n```\n\nAccording to http://stackoverflow.com/questions/1487734/cant-access-protected-inner-class-while-inheriting , we need to add a public constructor to StandardKeySet / StandardValues, since the default constructor is protected for protected inner classes.\n\nI tried it out, and it seems to fix the problem:\n\n&nbsp;&nbsp;protected class StandardKeySet extends Maps.KeySet&lt;K, V> {\n&nbsp;&nbsp;&nbsp;&nbsp;public StandardKeySet() {}\n\n```\n@Override\nMap<K, V> map() {\n  return ForwardingMap.this;\n}\n```\n\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;protected class StandardValues extends Maps.Values&lt;K, V> {\n&nbsp;&nbsp;&nbsp;&nbsp;public StandardValues() {}\n\n```\n  @Override\nMap<K, V> map() {\n  return ForwardingMap.this;\n}\n```\n\n&nbsp;&nbsp;}\n", "url": "https://github.com/google/guava/issues/701", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:21:04", "closed": "2014-10-31 19:46:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.deleteDirectoryContents() does not work reliably in Windows with long usernames and temporary directories", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=693) created by **niklas.collin** on 2011-08-22 at 10:04 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. create temporary directory with Files.createTempDir();\n2. write some files into it\n3. try to remove the temp directory with Files.deleteRecursively()\n\n<b>What is the expected output? What do you see instead?</b>\nExpected output is that first the temp dir is written into c:\\users\\longusername\\AppData\\Local\\temp, then the files are written and after that all written files plus temporary directory is deleted from the system. Instead none of the files are deleted but an access denied error is shown.\n\n<b>What version of the product are you using? On what operating system?</b>\nGoogle Guava r09 from maven central repo on Windows 7 Professional x64.\n\n<b>Please provide any additional information below.</b>\nThe bug happens since Files.deleteDirectoryContents() thinks to be deleted directory to be behind a symbolic link. This is due to the fact that in Windows File.getAbsolutePath() and File.getCanonicalPath() return different Strings if the directory is within user's home directory AND the Windows username is longer than 8 characters. This is an unfortunate DOS remnant.\n", "url": "https://github.com/google/guava/issues/693", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:20:45", "closed": "2014-10-31 20:08:12", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableMap may not be using proper equals () method", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=682) created by **capidepadua** on 2011-08-10 at 05:45 AM_\n\n---\n\nI have a `Map <Transcription, File> m`. Transcription is user defined, with a user defined `equals ()`&nbsp;method. When I define a new Transcription t, and call m.get (t), it works properly, but when I use `ImmutableMap.copyOf (m).get (t)`, it returns `null`.\n", "url": "https://github.com/google/guava/issues/682", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:20:22", "closed": "2014-10-31 19:40:39", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Iterable returned from transform fails contains criteria.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=673) created by **dancerjohn** on 2011-07-29 at 04:32 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Create list of Files.\n2. Create Function&lt;File, String> that returns file name.\n3. Execute Lists.transform on list of files using function.\n4. Call Iterables.contains on transformation using a name (String) that should match.\n\n<b>What is the expected output? What do you see instead?</b>\nShould return true. Returns false.\n\n<b>What version of the product are you using? On what operating system?</b>\nr09\nRedhat\n\n<b>Please provide any additional information below.</b>\nIt appears that TransformingRandomAccessList does not account for AbstractCollection's implementation of contains which uses the iterator. It appears that the iterator returned from TransformingRandomAccessList is an iterator over the pre-transformation type instead of the post-transformation type.\n\nThe same is true for TransformingSequentialList as it only overrides listIterator but not iterator.\n", "url": "https://github.com/google/guava/issues/673", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:20:02", "closed": "2014-10-31 19:38:56", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Consider adding BYTES constant to all primitives classes", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=668) created by **esta...@comcast.net** on 2011-07-21 at 02:11 PM_\n\n---\n\nThere's a BYTES on Chars, but nothing else (I think).\nIt would be useful to have a BYTES on all of the primitives classes:\n&nbsp;(Booleans, Bytes, Chars, Doubles, Floats, Ints, Longs, Shorts, SignedBytes, UnsignedBytes).\n\nThe JDK wrappers provide a SIZE in bits, which of course has to be divided down.\n\nThe Primitives class itself could use \n&nbsp;static int bits(Class clazz)\n&nbsp;static int bytes(Class clazz)\nwhich would throw on a class that isn't a JDK primitive wrapper.\n\nFWIW, see http://stackoverflow.com/questions/6766343/best-practice-for-getting-datatype-sizesizeof-in-java/6772163#6772163 for what motivated me to write.\n", "url": "https://github.com/google/guava/issues/668", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:19:52", "closed": "2014-10-31 19:43:23", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ByteStreams.copy(InputSupplier, OutputSupplier) may not log exception", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=667) created by **achaphiv** on 2011-07-21 at 12:31 AM_\n\n---\n\nThe code is currently:\n\nboolean threw = true;\nInputStream in = from.getInput();\ntry {\n&nbsp;&nbsp;&nbsp;&nbsp;OutputStream out = to.getOutput();\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long count = copy(in, out);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threw = false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return count;\n&nbsp;&nbsp;&nbsp;&nbsp;} finally {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closeables.close(out, threw);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n} finally {\n&nbsp;&nbsp;&nbsp;&nbsp;Closeables.close(in, threw);\n}\n\nIn the case where copy succeeds, but out/in fail, the exception for out is never logged.\n\nProposed fix:\nboolean copyThrew = true;\nboolean outThrew = true;\nInputStream in = from.getInput();\ntry {\n&nbsp;&nbsp;&nbsp;&nbsp;OutputStream out = to.getOutput();\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long count = copy(in, out);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyThrew = false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return count;\n&nbsp;&nbsp;&nbsp;&nbsp;} finally {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closeables.close(out, copyThrew);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outThrew = false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n} finally {\n&nbsp;&nbsp;&nbsp;&nbsp;Closeables.close(in, copyThrew || outThrew);\n}\n", "url": "https://github.com/google/guava/issues/667", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:19:50", "closed": "2014-10-31 20:08:41", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "com.google.common.base.internal.Finalizer security violation on Websphere 7", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=666) created by **dh6864** on 2011-07-20 at 04:35 AM_\n\n---\n\nHi, since google-collection.jar is discontinued and renamed as guava, I guess I would ask here.  When our application deployed on Websphere 7, java 2 security violation is thrown for Finalizer.\n\n[11/16/10 11:38:02:825 EST] 0000001d SecurityManag W   SECJ0314W: Current Java 2 Security policy reported a potential violation of Java 2 Security Permission. Please refer to InfoCenter for further information.\n\nPermission:\n\n```\n  accessDeclaredMembers : Access denied (java.lang.RuntimePermission accessDeclaredMembers)\n```\n\nCode:\n\n```\n com.google.common.base.internal.Finalizer  in  {wsjar:file:/proj/fmms/was/install/fmms_TeamConnect-3.2.0.1.ear/TeamConnect-3.2.0.1.war/WEB-INF/lib/google-collections-1.0.jar!/}\n```\n\nWe opened an ticket with IBM to investigate why com.ibm.ws.security.core.SecurityManager.checkPermission() wouldn't find Permissions we granted for Finalizer in was.policy file.  IBM said the way that google computes the BaseURL for loading Finalizer has 'wsjar:file:' as protocol instead of 'file:'.\n\nIBM Lev3 updated the PMR.\n# \n1.  The codesource URL for the class is:  \n   wsjar:file:/proj/fmms/was/install/fmms_TeamConnect-3.2.0.1.ear/TeamConne\n   ct-3.2.0.1.war/WEB-INF/lib/google-collections-1.0.jar!/                 \n2.  The codesource security is expecting is:  \n   file:/proj/fmms/was/install/fmms_TeamConnect-3.2.0.1.ear/TeamConnect-3. \n   2.0.1.war/WEB-INF/lib/google-collections-1.0.jar                        \n\nSo the problem is the \"wsjar:\" and the \"!/\".                            \n\nCompoundClassloader is not adding or appending any of those values.  \nWhen we set the codesource we do a getURL call.  \nFrom looking at the code:                                               \n\nURL finalizerUrl = getClass().getClassLoader().getResource(finalizerPath\n);                                                                      \n\nWe see it is using getResource.  \nThe finalizer path at that point would be:  \n&nbsp;wsjar:file:/proj/fmms/was/install/fmms_TeamConnect-3.2.0.1.ear/TeamConn\ne  \nct-3.2.0.1.war/WEB-INF/lib/google-collections-1.0.jar!/&lt;Whatever the  \npath with in the jar, like com/foo/MyFoos.class>                        \n\nNext we see the code remove &lt;Whatever the path with in the jar...> from \nthe URL string:  \nurlString = urlString.substring(0,  \nurlString.length() - finalizerPath.length());                           \n\nSo my understanding is the sample code needs to consider this and finish\nthe truncation (removing the protocol which is wsjar:).  Additionally,  \nthey only removed the class from the end of the string, and did not  \nremove the markers of !/ which java uses to specify the root folder with\nin the jar file.                                                        \n\nThank you for using IBM products and support.\nhttp://www.ibm.com/support \nEND of IBM Lev3 updated the PMR.\n\nCould you please let us know if google would fix the way BaseURL is calculated in DecoupledLoader?\n\nThanks,\nDean\n", "url": "https://github.com/google/guava/issues/666", "user": "gissuebot", "labels": ["status=obsolete", "type=defect"], "created": "2014-10-31 17:19:48", "closed": "2014-10-31 19:38:22", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ForwardingMap.get() - wrong signature?", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=663) created by **esta...@comcast.net** on 2011-07-15 at 03:22 PM_\n\n---\n\nThe signature currently is \n&nbsp;&nbsp;&nbsp;&nbsp;public V get(Object key)\n\nI believe it should be\n&nbsp;&nbsp;&nbsp;&nbsp;public V get(K key)\n\nIf this is not possible, please consider fixing HashBiMap, at least.\nIf it's by design, consider noting it in the JavaDoc - it's certainly odd.\n", "url": "https://github.com/google/guava/issues/663", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:19:41", "closed": "2014-10-31 19:34:04", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Minor FileBackedOutputStream(int fileThreshold) constructor JavaDoc issue", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=648) created by **morten.hattesen** on 2011-06-27 at 09:12 PM_\n\n---\n\nA minor JavaDoc comment mistake on the JavaDoc of FileBackedOutputStream(int fileThreshold).\n\nQuote: \"Equivalent to ThresholdOutputStream(fileThreshold, false).\"\n\nShould read \"Equivalent to FileBackedOutputStream(fileThreshold, false).\"\n\nSee http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html\n\nIt seems the FileBackedOutputStream class started life with a different name.\n", "url": "https://github.com/google/guava/issues/648", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:19:10", "closed": "2014-10-31 19:38:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.toUriString() have to strip scopeid for ipv6", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=646) created by **kofemann** on 2011-06-14 at 05:07 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n<b>1.</b>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumeration&lt;NetworkInterface>  interfaces\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= NetworkInterface.getNetworkInterfaces();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(interfaces.hasMoreElements()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NetworkInterface iface = interfaces.nextElement();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( !iface.isUp() )\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumeration&lt;InetAddress> ifaceAddresses = iface.getInetAddresses();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(ifaceAddresses.hasMoreElements()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetAddress ip = ifaceAddresses.nextElement();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(toUriString(ip));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n<b>2.</b>\n<b>3.</b>\n\n<b>What is the expected output? What do you see instead?</b>\nexpected: [2001:638:700:20b9:0:0:1:44]\nsee: [2001:638:700:20b9:0:0:1:44%2]\n\n<b>What version of the product are you using? On what operating system?</b>\nr09, trunk have the same issue.\n\n<b>Please provide any additional information below.</b>\n\nfix attached.\n", "url": "https://github.com/google/guava/issues/646", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:19:06", "closed": "2014-10-31 19:37:53", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Objects.toStringHelper has minor bugs now", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=639) created by **ray.j.greenwell** on 2011-06-03 at 01:27 AM_\n\n---\n\nGlad to see ToStringHelper just use a StringBuilder internally now, I had wanted something like that back in issue 400.\n\nBut two behavior changes were introduced with the change:\n- If a null name is provided to add() then the separator will be appended prior to the NPE being thrown. Ideally, a precondition happens pre anything destructive, right?\n- toString() cannot be called repeatedly without it adding extra close curlies. I'm not entirely sure why you'd want to call it repeatedly, but the original implementation seemed to accommodate it. Perhaps one would want to toString() some initial details, then add more to the same ToStringHelper, and toString() it again...\n\nBoth of these are simple to fix. See attached diff.\n", "url": "https://github.com/google/guava/issues/639", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:18:51", "closed": "2014-10-31 19:35:44", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.deleteDirectoryContents(File file) fails when the directory is in the default temp directory in windows", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=637) created by **davidrab** on 2011-06-01 at 01:40 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Use windows machine\n2. Create a temp directory using Files.createTempDir()\n3. Add some files\n4. Call Files.deleteDirectoryContents(dir)\n5. It will exit without deleting the content\n\n<b>What is the expected output? What do you see instead?</b>\nThe files to be deleted - I was actually using deleteRecursively(File)\n\n<b>What version of the product are you using? On what operating system?</b>\nr09\n\n<b>Please provide any additional information below.</b>\nThe bug is in the following code:\n&nbsp;&nbsp;&nbsp;&nbsp;// Symbolic links will have different canonical and absolute paths\n&nbsp;&nbsp;&nbsp;&nbsp;if (!directory.getCanonicalPath().equals(directory.getAbsolutePath())) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;}\nsince:\ndirectory.getCanonicalPath()=C:\\Users\\david.MOBIMATE\\AppData\\Local\\Temp\\1306934914921-0\ndirectory.getAbsolutePath()=C:\\Users\\DAVID~1.MOB\\AppData\\Local\\Temp\\1306934914921-0\nBut both are the same dir and the different names are because of the windows naming.\n", "url": "https://github.com/google/guava/issues/637", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:18:47", "closed": "2014-10-31 19:37:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Key as Arraylist, cant be found, when softKey() is on", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=636) created by **bartlomiej.szejna** on 2011-06-01 at 01:00 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\nSimple example:\n\nprivate ConcurrentMap&lt;Object, Object> map = new MapMaker().softKeys().makeMap();\nprivate ArrayList&lt;Object> mapKey = new ArrayList&lt;Object>();\n\nmapKey.add(\"key1\");\nmapKey.add(1111);\nmap.put(mapKey, \"value1\");\nSystem.out.println(\"value from map: \"+map.get(mapKey)+ \", hashCode of key \"+mapKey.hashCode());\n\nmapKey = new ArrayList&lt;Object>();\nmapKey.add(\"key1\");\nmapKey.add(1111);\nSystem.out.println(\"value from map: \"+map.get(mapKey)+ \", hashCode of key \"+mapKey.hashCode());\n\n<b>What is the expected output? What do you see instead?</b>\nExpected value - \"value1\"\nInstead of it, get() returns - null\n\n<b>What version of the product are you using? On what operating system?</b>\nguava verions = r09\nOS - win7\njava- 1.6.0_25\n\n<b>Please provide any additional information below.</b>\nOnly occurs when softKey() is on\n", "url": "https://github.com/google/guava/issues/636", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:18:45", "closed": "2014-10-31 19:22:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Using Maps.newTreeMap(Comparator) triggers openJDK bug.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=635) created by **ian.b.robertson** on 2011-05-29 at 08:05 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Create TreeMapExample.java as follows:\n\nimport java.util.Comparator;\nimport java.util.TreeMap;\nimport com.google.common.collect.Maps;\n\npublic class TreeMapExample {\n&nbsp;&nbsp;public static final Comparator&lt;String> foo = null;\n&nbsp;&nbsp;private TreeMap&lt;String, String> instance = Maps.newTreeMap(foo);\n}\n1. Compile this using OpenJDK 1.6.0_20\n\n<b>What is the expected output? What do you see instead?</b>\n\nThis should compile without errors; instead, the compiler outputs:\nTreeMapExample.java:7: incompatible types; no instance(s) of type variable(s) K,V exist so that java.util.TreeMap&lt;K,V> conforms to java.util.TreeMap&lt;java.lang.String,java.lang.String>\nfound   : &lt;K,V>java.util.TreeMap&lt;K,V>\nrequired: java.util.TreeMap&lt;java.lang.String,java.lang.String>\n&nbsp;&nbsp;private TreeMap&lt;String, String> instance = Maps.newTreeMap(foo);\n\n<b>What version of the product are you using? On what operating system?</b>\nguava r08 on Linux.\n\n<b>Please provide any additional information below.</b>\n\nI believe this is tied to openjdk bug 100167 \n(https://bugs.openjdk.java.net/show_bug.cgi?id=100167).\n\nThe current version of newTreeMap has the following signature and comment:\n\n&nbsp;&nbsp;public static &lt;C, K extends C, V> TreeMap&lt;K, V> newTreeMap(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffNullable Comparator&lt;C> comparator) {\n&nbsp;&nbsp;&nbsp;&nbsp;// Ideally, the extra type parameter \"C\" shouldn't be necessary. It is a\n&nbsp;&nbsp;&nbsp;&nbsp;// work-around of a compiler type inference quirk that prevents the\n&nbsp;&nbsp;&nbsp;&nbsp;// following code from being compiled:\n&nbsp;&nbsp;&nbsp;&nbsp;// Comparator&lt;Class<?>> comparator = null;\n&nbsp;&nbsp;&nbsp;&nbsp;// Map&lt;Class<? extends Throwable>, String> map = newTreeMap(comparator);\n&nbsp;&nbsp;&nbsp;&nbsp;return new TreeMap&lt;K, V>(comparator);\n&nbsp;&nbsp;}\n\nInterestingly, changing the signature to its old (pre v40 in google-collections) signature:\n\n&nbsp;&nbsp;public static &lt;K, V> TreeMap&lt;K, V> newTreeMap(Comparator<? super K> comparator)\n\nfixes the problem. I'm not sure what combination of javac and client code was causing issues with the original signature, but I cannot reproduce it at this point with any versions (Oracle or openjdk) of javac that I've tried.\n", "url": "https://github.com/google/guava/issues/635", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:18:43", "closed": "2014-10-31 19:39:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.TeredoInfo constructor uses %d in Preconditions.checkArgument format string", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=621) created by **timw.at.work** on 2011-05-15 at 09:13 PM_\n\n---\n\nI noticed this while browsing through some of the code in release 9: the TeredoInfo constructor (InetAddresses.java line 581 or so) has:\n\nPreconditions.checkArgument((port >= 0) && (port <= 0xffff),\n&nbsp;&nbsp;&nbsp;&nbsp;\"port '%d' is out of range (0 <= port <= 0xffff)\", port);\nPreconditions.checkArgument((flags >= 0) && (flags <= 0xffff),\n&nbsp;&nbsp;&nbsp;&nbsp;\"flags '%d' is out of range (0 <= flags <= 0xffff)\", flags);\n\nThe format strings for checkArgument only accept %s (I just double-checked, and that is still true as of release 9). That said, it wouldn't cause any nasty problems--just an odd-looking exception string.\n\nI double-checked the latest trunk published to google code, and the problem remains.\n", "url": "https://github.com/google/guava/issues/621", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:18:13", "closed": "2014-10-31 19:24:53", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Lists.partition() gives incorrect result when partition size is Integer.MAX_VALUE", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=616) created by **qforce.bak** on 2011-05-02 at 07:06 PM_\n\n---\n\nHello,\n\nIt seems the method Lists.partition() behaves incorrectly when given a partition size of Integer.MAX_VALUE or Integer.MAX_VALUE - 1. The following snippet (based on Guava r08) demonstrates this:\n\nList&lt;String> list = Arrays.asList(\"a\", \"b\", \"c\");\nfor (int i = 0; i < 5; i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;List&lt;String>> partition = Lists.partition(list, Integer.MAX_VALUE - i);\n&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"size=\" + partition.size() + \" for i=\" + i);\n}\n\nThe console output is:\n\nsize=-1 for i=0\nsize=-1 for i=1\nsize=1 for i=2\nsize=1 for i=3\nsize=1 for i=4\n\nI would expect size=1 if i=0 or i=1.\n\nBest regards\nTran Nam Quang\n", "url": "https://github.com/google/guava/issues/616", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:18:03", "closed": "2014-10-31 19:42:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.forString does not throw IllegalArgumentException on an invalid IPv4 address", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=614) created by **krzysztof.t.olszewski** on 2011-04-27 at 11:04 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1.InetAddresses.forString(\"1.1.1.1.\");\nor\nInetAddresses.forString(\"1.1.1.1..\");\nand so on...\n\n<b>What is the expected output? What do you see instead?</b>\nI expect an IllegalArgumentException.\nInstead I receive a Inet4Address object with the address \"1.1.1.1\".\n\n<b>What version of the product are you using? On what operating system?</b>\nguava-r08 \nWindows XP Professional 32bit\n", "url": "https://github.com/google/guava/issues/614", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:17:59", "closed": "2014-10-31 19:24:25", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.toUriString does not return canonical form of IPv6 address", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=610) created by **krzysztof.t.olszewski** on 2011-04-21 at 10:55 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. InetAddresses.toUriString(InetAddresses.forString(\"feed::3\"))\n\n<b>What is the expected output? What do you see instead?</b>\nExpected: \"[feed::3]\"\nInstead: \"[feed:0:0:0:0:0:0:3]\"\n\n<b>What version of the product are you using? On what operating system?</b>\nGuava r.08 / Windows XP 32\n\n<b>Please provide any additional information below.</b>\nAccording to the latest http://tools.ietf.org/html/rfc5952 canonical form of IPv6 text representation is it's shortest possible form compliant with the http://tools.ietf.org/html/rfc4291.\n", "url": "https://github.com/google/guava/issues/610", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:17:50", "closed": "2014-10-31 19:38:00", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Maven Files Need Updated (src folder & java version)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=607) created by **sahendrickson** on 2011-04-17 at 05:23 AM_\n\n---\n\nThe Maven configuration files seem to have two errors:\n&nbsp;(1) guava source folder is \"file://$MODULE_DIR$/guava/src\" (with the \"guava\" folder) not \"file://$MODULE_DIR$/src\"\n&nbsp;(2) guava trunk requires JDK 1.6, see [1].\nThe attached patch updates the maven configuration files for both issues. Only after these changes were made did m2eclipse correctly configure the guava project within Eclipse.\n\n[1] https://github.com/google/guava/issues/32\n", "url": "https://github.com/google/guava/issues/607", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:17:44", "closed": "2014-10-31 19:45:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Guava JAR is HUGE", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=605) created by **ceefour666** on 2011-04-14 at 08:03 PM_\n\n---\n\nGoogle Collections 1.0 is ~600 KB\n\nGuava r09 is 1.1 MB.\n\nPlease split the library into smaller pieces (at least two, -core and -extras)\n\nThe core should contain only the most frequently used classes and it should be around 100-300 KB. The extras contains the rest of the stuff.\n", "url": "https://github.com/google/guava/issues/605", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:17:40", "closed": "2014-11-01 02:18:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Ticker interface", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=602) created by **gscerbak** on 2011-04-14 at 04:21 PM_\n\n---\n\nI was looking for some more information about the Ticker Beta interface in r09, but I found only that it was (should be) rolled back in r248 (http://code.google.com/p/guava-libraries/source/detail?r=248).\n\nIs its presence in the release an error or if not, what is the use of it? There is no issue for it and I couldn't find any provided implementations.\n", "url": "https://github.com/google/guava/issues/602", "user": "gissuebot", "labels": ["status=working-as-intended", "type=defect"], "created": "2014-10-31 17:17:34", "closed": "2014-10-31 19:13:53", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Pronoun reference problem in MapMaker doc", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=601) created by **tpeierls** on 2011-04-13 at 03:28 PM_\n\n---\n\nThe MapMaker class comment includes this paragraph:\n\n\"The returned map has weakly consistent iteration: an iterator over one of the map's view collections may reflect some, all or none of the changes made to the map after the iterator was created. They do not throw ConcurrentModificationException, and may proceed concurrently with other operations.\"\n\nIt's not at all clear what \"They\" in the second sentence refers to.\n\nIn addition, either the comma in second sentence should be dropped or the pronoun \"they\" should be repeated.\n", "url": "https://github.com/google/guava/issues/601", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:17:32", "closed": "2014-10-31 19:24:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MapMaker size is negative and isEmpty is false with empty weakKeys/weakValues map", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=591) created by **fry@google.com** on 2011-04-05 at 04:02 PM_\n\n---\n\n\"I am getting a negative size() and isEmpty() of false on a Map with weakKeys() and weakValues() using guava r09-rc2. The map is indeed empty and iterating over the keySet() shows no entries, but the size(), keySet().size(), and entrySet().size() all return the same negative value.\"\n\n[Originally reported in a comment on issue 552.]\n", "url": "https://github.com/google/guava/issues/591", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:17:11", "closed": "2014-10-31 19:22:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "If choosing a default classloader in Resources.getResource, choose one that makes sense", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=588) created by **lhunath** on 2011-03-31 at 01:17 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Your application calls loadConfig(Properties) on your library-X.\n2. Your library-X's loadConfig(Properties) gets a resource name from the properties and loads the resource using Resources.getResource(String)\n\n<b>What is the expected output? What do you see instead?</b>\nI expect my application's resource named by the property value I passed to my library-X's loadConfig method to be loaded.  The resource exists within my application, not within library-X and not within Guava.\n\nInstead, Guava loads the resource using the classloader that loaded Resources.class.  Which is to say, it will look at wherever Guava exists.  This is not necessarily the sensible location for my application to put its resources.\n\n<b>What version of the product are you using? On what operating system?</b>\nr05, FreeBSD/Linux\n\n<b>Please provide any additional information below.</b>\nIt makes more sense for resources to be loaded using the thread's context classloader.  This classloader defaults to one that loaded the application, which is the most sensible place to look for its resources.  If a different classloader is desired by the application, it can still change the context classloader before calling library-X.\n- URL url = Resources.class.getClassLoader().getResource(resourceName);\n- URL url = Thread.currentThread().getContextClassLoader().getResource(resourceName);\n", "url": "https://github.com/google/guava/issues/588", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:17:05", "closed": "2014-11-01 01:52:25", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "with 09 rc2, get compile errors for GWT \"The import javax.annotation cannot be resolved\"", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=586) created by **jamesthepiper** on 2011-03-30 at 10:12 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1.  Create standard GWT sample application.\n2.  Add guava-r09-rc2-gwt.jar\n3.  Add \n3.  Attempt to compile it.\n\n<b>What is the expected output? What do you see instead?</b>\nLots of compiler errors:\nLoading inherited module 'com.google.common.collect.Collect'\n&nbsp;&nbsp;&nbsp;[ERROR] Unable to find 'com/google/common/collect/Collect.gwt.xml' on your classpath; could be a typo, or maybe you forgot to include a classpath entry for source?\n[ERROR] Line 5: Unexpected exception while processing element 'inherits'\ncom.google.gwt.core.ext.UnableToCompleteException: (see previous log entries)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.cfg.ModuleDefLoader.nestedLoad(ModuleDefLoader.java:262)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.gwt.dev.cfg.ModuleDefSchema$BodySchema.__inherits_begin(ModuleDefSchema.java:478)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)\n&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)\n....\n", "url": "https://github.com/google/guava/issues/586", "user": "gissuebot", "labels": ["platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:17:00", "closed": "2014-11-01 00:50:12", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Behavior of MapMaker.evictionListener() on a ComputingMap", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=579) created by **morten.hattesen** on 2011-03-25 at 02:06 PM_\n\n---\n\nIt is not clear from the MapMaker.evictionListener() JavaDoc if the evictionListener is called when Map entries are evicted from a map that was created using MapMaker.makeComputingMap().\n\nIt turns out that the MapEvictionListener is only called when evicting map entries that are manually put into the map.\nIt seems that the MapEvictionListener is never called when evicting map entries generated via the Function passed to the makeComputingMap() function.\n\nThis may be \"working as intended\", but in that case it should be documented in the evictionListener() method JavaDoc that the listener is NOT called for when evicting certain (computed) entries.\n\nI see no reason, however, why the MapEvictionListener should not be called whenever ANY map entry is evicted, even those entries computed.\n\nThe attached JUnit test case documents the described behavior (evictionListener being called on entries put into the map, but not on entries put by a ComputedMap Function).\n\nVersion of Guava: R08\n", "url": "https://github.com/google/guava/issues/579", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:16:46", "closed": "2014-10-31 19:08:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.forString does not throw IllegalArgumentException on an invalid IPv6 address", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=572) created by **krzysztof.t.olszewski** on 2011-03-18 at 09:31 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. InetAddresses.forString(\"fe80::aaaaaa\");\n\n<b>What is the expected output? What do you see instead?</b>\nI expect an IllegalArgumentException.\nInstead I receive a Inet6Address object with the address \"fe80::aa:aaaa\".\n\n<b>What version of the product are you using? On what operating system?</b>\nguava-r08 \nWindows XP Professional 32bit\n\n<b>Please provide any additional information below.</b>\nAccording to the http://tools.ietf.org/html/rfc4291#section-2.2 this form of a text representation is invalid.\n", "url": "https://github.com/google/guava/issues/572", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:16:31", "closed": "2014-10-31 19:37:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Incompatible byte code to java 5 in guava-r08-gwt.jar", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=568) created by **t.herrm...@alkacon.com** on 2011-03-04 at 11:55 AM_\n\n---\n\nUsing the release guava-r08-gwt.jar on java 5 triggers a java.lang.UnsupportedClassVersionError exception. \n\nThis issue can be resolved by adding a target=\"1.5\" attribute to the javac element of the gwt.compile target.\n\nI experienced this issue using jdk1.5.0_06 on debian linux.\nI could not reproduce the issue using the same version JDK on WindowsXP.\n", "url": "https://github.com/google/guava/issues/568", "user": "gissuebot", "labels": ["platform=gwt", "status=fixed", "type=defect"], "created": "2014-10-31 17:16:23", "closed": "2014-10-31 23:28:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "TreeMultimap has serialization issue", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=565) created by **yonseokim** on 2011-02-28 at 06:52 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Create TreeMultimap using create(keyComparator, valueComparator) method\n2. Provide comparator classes which are not declared serializable.\n3. The class gets instantiated without any problem.\n\n<b>What is the expected output? What do you see instead?</b>\n- When trying to serialize the class, you get NotSerializableException error\n\n<b>What version of the product are you using? On what operating system?</b>\n\nGuava-r08 on JDK 1.6 for Mac OS X\n\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/565", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:16:17", "closed": "2014-10-31 19:03:29", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MinMaxPriorityQueue returns non-least element on pollFirst()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=553) created by **hein.meling** on 2011-02-18 at 11:58 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Inserting elements 1, 4, 3, 5, 7 (in that order) gives incorrect ordering when invoking pollFirst().\nSee attached test case.\n\n<b>What is the expected output? What do you see instead?</b>\nExpected:  1 3 4 5 7 \nGet:            1 4 3 5 7 \n\n<b>What version of the product are you using? On what operating system?</b>\nRelease 8 (latest from svn repos), Mac OS X 10.6.x\n\n<b>Please provide any additional information below.</b>\nI believe the test case is pretty clear. \nNote that the insertion order matters, if you insert elements in order, the output will be ordered as expected.\nNote that you'll want to change the package placement to where you have test cases in your system.\nAlso the equals() method fails for a similar reason.\n", "url": "https://github.com/google/guava/issues/553", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:15:51", "closed": "2014-10-31 19:08:20", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ByteStreams.toByteArray(inputStream); and java.lang.OutOfMemoryError: Java heap space", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=551) created by **ptr.nowicki** on 2011-02-18 at 03:42 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. When you want to create an array of bytes from the stream for files over 300 megabytes in size using the function ByteStreams.toByteArray (InputStream), gets the output exception: java.lang.OutOfMemoryError: Java heap space\n\n<b>What version of the product are you using? On what operating system?</b>\nguava-r08.jar. Windows 7 64-bit and windows XP 32-bit. Eclipse Helios JEE SR1\n\n<b>Please provide any additional information below.</b>\nPrintScreen in attachment.\n", "url": "https://github.com/google/guava/issues/551", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:15:47", "closed": "2014-10-31 19:01:47", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Eclipse 3.6.1 shows a lot of error/warning for missing @Override annotations", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=539) created by **kuaw26** on 2011-02-01 at 09:43 AM_\n\n---\n\nJust download r08 and open as a project in Eclipse 3.6.1.\n\nBy default my eclipse configured to treat missing @\ufeffOverride annotation as error and I get tons of such errors.\n\nBut thanks to eclipse it could be fixed in 5 second with help of mass quick-fix.\n\nIt is possible to add those missing annotations?\n\nI need it, because I support my own guava fork and missing annotations result in many false differences.\n", "url": "https://github.com/google/guava/issues/539", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:15:22", "closed": "2014-10-31 23:28:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Suppliers.memoize() should use double-checked locking", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=532) created by **kevinb@google.com** on 2011-01-27 at 07:34 PM_\n\n---\n\nPer discussion on guava-discuss.\n", "url": "https://github.com/google/guava/issues/532", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:15:07", "closed": "2014-10-31 18:56:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Omnibus issue for release08 Futures.makeListenable improvements", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=528) created by **cpovirk@google.com** on 2011-01-24 at 10:04 PM_\n\n---\n- makeListenable(someFuture) now catches any RuntimeException thrown by someFuture.get() and invokes the user callback at that point.  In short, it treats a never-wrapped RuntimeException like an ExecutionException.  This prevents an unexpected RuntimeException from breaking callback invocation.\n- If the future is already completed, makeListenable now enqueues its\n  listeners inline instead of in an executor thread.  Note that the actual execution of the listeners still occurs in the threads associated with them in addListener, so this change is only an optimization except in the case of executors like sameThreadExecutor (which, of course, should only be used in cases where this distinction is unimportant :)).\n- makeListenable now gives its threads meaningful names.  The current form is \"ListenableFutureAdapter-thread-%d.\"\n", "url": "https://github.com/google/guava/issues/528", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:58", "closed": "2014-10-31 18:51:37", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "put() for a computing map violates linearizability", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=527) created by **kevinb@google.com** on 2011-01-24 at 09:23 PM_\n\n---\n\nThe specified behavior of MapMaker puts during computation was:\n\n\"If Map.put(K, V) is called before a computation completes, other threads waiting on the computation will wake up and return the stored value. When the computation completes, its new result will overwrite the value that was put in the map manually.\"\n\nThis definition violates the principle of linearizability.\n\nWe've fixed this and fixed the doc.\n", "url": "https://github.com/google/guava/issues/527", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:56", "closed": "2014-10-31 17:14:56", "commits": {}, "ttf": null, "commitsDetails": []}, {"title": "MapMaker forgets to send removal notification when entries containing garbage-collected values are reused", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=526) created by **kevinb@google.com** on 2011-01-24 at 09:19 PM_\n\n---\n\n(Already fixed.)\n", "url": "https://github.com/google/guava/issues/526", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:54", "closed": "2014-10-31 17:14:54", "commits": {}, "ttf": null, "commitsDetails": []}, {"title": "Iterables.reverse(List) has been deprecated too early", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=525) created by **finnw1** on 2011-01-22 at 01:25 PM_\n\n---\n\nI don't think this method should be @\ufeffDeprecated yet, because its replacement is still @\ufeffBeta.\n", "url": "https://github.com/google/guava/issues/525", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:52", "closed": "2014-10-31 23:28:17", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Revise JavaDoc for Equivalence", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=522) created by **ullenboom** on 2011-01-20 at 09:35 AM_\n\n---\n\nThe JavaDoc for Equivalence#equivalent() is copied from Object#equals() but a wording could be enhanced. E.g. for reflexive:\n\n&nbsp;&nbsp;It is reflexive: for any non-null reference value x, x.equals(x) should return true. \n\nto\n\n&nbsp;&nbsp;It is reflexive: for any non-null reference values x and y, \nequivalent(x,y) should return true.\n\nidentity() returns an Equivalence which has nothing to do with equals(). Another problem is the mention of \"any non-null reference\" which is misleading if nullAwareEquals() or identity() are used, because null-values are fine. Then the exact null-handling is an implementation issue.\n", "url": "https://github.com/google/guava/issues/522", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:14:45", "closed": "2014-10-31 18:50:35", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "InetAddresses.forString throws IllegalArgumentException on valid IPv6 address", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=516) created by **krzysztof.t.olszewski** on 2011-01-07 at 10:35 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. InetAddresses.forString(\"::7:6:5:4:3:2:1\")\n\n<b>What is the expected output? What do you see instead?</b>\nI expect a java.net.Inet6Address object.\nInstead I get exception: \"java.lang.IllegalArgumentException: '::7:6:5:4:3:2:1' is not an IP string literal.\"\n\n<b>What version of the product are you using? On what operating system?</b>\nguava-r07 // Compiled from InetAddresses.java (version 1.5 : 49.0, super bit)\nWindows XP Professional 32bit\n\n<b>Please provide any additional information below.</b>\nCases: \"8:7:6:5:4:3:2:1\", \"0:7:6:5:4:3:2:1\", \":7:6:5:4:3:2:1\" \"::6:5:4:3:2:1\" works all right, it happens when only the first group are zeros (suppressed to double colons).\nhttp://www.faqs.org/rfcs/rfc1884.html\n", "url": "https://github.com/google/guava/issues/516", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:33", "closed": "2014-10-31 18:50:56", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.copy deletes the file contents when both from and to refer to the same file", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=515) created by **Roman.Zenka** on 2011-01-06 at 10:40 PM_\n\n---\n\n@\ufeffTest\npublic void shouldNotDestroyContents() throws IOException {\n&nbsp;&nbsp;&nbsp;&nbsp;File file = File.createTempFile(\"test\", \".txt\");\n&nbsp;&nbsp;&nbsp;&nbsp;Files.write(\"hello world\", file, Charsets.UTF_8);\n&nbsp;&nbsp;&nbsp;&nbsp;Assert.assertTrue(file.length()>0);\n&nbsp;&nbsp;&nbsp;&nbsp;Files.copy(file, file);\n&nbsp;&nbsp;&nbsp;&nbsp;Assert.assertTrue(file.length()>0);  \n&nbsp;&nbsp;&nbsp;&nbsp;file.delete();\n}\n\nI expect the copy operation to do nothing when file is copied over itself. Instead, the file contents get truncated to zero length and the test fails.\n\nVersion r06.\n\nThis could get very complicated to test, especially on Linux where files can appear to have distinct paths, yet refer physically to the same file. Anyway, I should have been at least warned in the documentation that this function can destroy my data.\n", "url": "https://github.com/google/guava/issues/515", "user": "gissuebot", "labels": ["package=io", "status=fixed", "type=defect"], "created": "2014-10-31 17:14:31", "closed": "2014-11-01 00:20:55", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Clarify Multimaps#index's key / value order (Javadoc and example)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=514) created by **neveue** on 2011-01-05 at 07:19 PM_\n\n---\n\nhttps://github.com/google/guava/blob/146/trunk/src/com/google/common/collect/Multimaps.java#L1661\n\nCurrently, Multimaps#index returns an ImmutableListMultimap, which has, according to its Javadoc, a \"reliable user-specified key and value iteration order\".\n\nSince this return type is specified in ImmutableListMultimap#index's method signature, I suppose it may be considered as a part of the API's contract. The iteration order of the returned Multimaps' keys should thus have the same order as the order in which the keys are encountered when iterating on the source iterable, applying the keyFunction. A quick look at the source code seems to confirm this.\n\nBut the example given in the Javadoc is confusing. According to it:\n\nList&lt;String> badGuys = Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\nFunction&lt;String, Integer> stringLengthFunction = ...\nMultimap&lt;Integer, String> index = Multimaps.index(badGuys, stringLengthFunction);\nSystem.out.println(index);\n\nshould print:\n\n{4=[Inky], 5=[Pinky, Pinky, Clyde], 6=[Blinky]}\n\n(notice that it is ordered by ordering the keys)\n\nIt didn't match my expectations, so I tested it, and it actually prints:\n\n{4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n\n(notice that \"6=[Blinky]\" comes before \"5=[Pinky, Pinky, Clyde]}\", because \"Blinky\" (5 letters long) precedes \"Pinky\" (the first element in the source values which is 4 letters long)\n\nIt would be great if the Javadoc clarified the intent concerning the returned Multimap's iteration order (if it indeed is part of the method's contract?). I think the example should also be updated, because it is currently wrong/confusing.\n", "url": "https://github.com/google/guava/issues/514", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:29", "closed": "2014-10-31 19:08:01", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Equivalences.identity()'s behavior does not match its Javadoc", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=511) created by **neveue** on 2010-12-30 at 11:49 PM_\n\n---\n\nIn com.google.common.base.Equivalences.equivalent()'s Javadoc:\n\nhttps://github.com/google/guava/blob/144/trunk/src/com/google/common/base/Equivalences.java#L55\n\n\"{@\ufefflink Equivalence#equivalent} returns {@\ufeffcode true} if both values are null\"\n--> but implementation throws NPE when 'a' is null.\n\n\"{@\ufefflink Equivalence#hash} throws a {@\ufefflink NullPointerException} if passed a null value\"\n--> but implementation returns 0 when passed a null value (because System.identityHashCode() returns 0 for null values)\n\nThanks :)\n", "url": "https://github.com/google/guava/issues/511", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:22", "closed": "2014-10-31 18:51:32", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Collections2.FilteredCollection should implement equals and hashCode", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=509) created by **koppernickus** on 2010-12-29 at 03:39 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n\n```\n@Test\npublic void testEqualityForFilteredCollection() throws Exception {\n    Collection<String> s = ImmutableList.of(\"a\");\n    assertEquals(filter(s, alwaysTrue()), s);\n}\n```\n\n<b>What is the expected output? What do you see instead?</b>\n\nI expect pass but it fails.\n\n<b>What version of the product are you using? On what operating system?</b>\n\nr07\n\n<b>Please provide any additional information below.</b>\n\nCollections2.FilteredCollection doesn't implement equals and hashCode.\n", "url": "https://github.com/google/guava/issues/509", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:14:18", "closed": "2014-10-31 18:45:45", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Exception from HostSpecific.from(String) leaves out useful information", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=507) created by **transparentpolitics** on 2010-12-28 at 02:16 AM_\n\n---\n\nWhen throwing an exception in a catch block please always set the initCause() to the original exception.\n\nFor example, in HostSpecifier, notice how the comment in the catch block notes that \"the IAE can originate at several different points inside fromValid()\" and this code makes damn certain that the exact location will continue to be mysterious! Why the secrecy? Debugging production server exceptions are hard enough, please show _all_ available information! There is no reason why the new ParseException can not have its initCause set to the IAE!\n\nline 122 (r07):\n&nbsp;&nbsp;public static HostSpecifier from(String specifier)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws ParseException {\n&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fromValid(specifier);\n&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalArgumentException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Since the IAE can originate at several different points inside\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fromValid(), we implement this method in terms of that one rather\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// than the reverse.\n\n```\n  throw new ParseException(\"Invalid host specifier: \" + specifier, 0);\n}\n```\n\n&nbsp;&nbsp;}\n", "url": "https://github.com/google/guava/issues/507", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:14:14", "closed": "2014-10-31 18:51:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.deleteDirectoryContents() fails for relative directory", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=498) created by **christophe.domas** on 2010-12-16 at 05:38 PM_\n\n---\n\nHi, \nI've created a File object from a relative path under windows:\nnew File(\"./src/test/resources/target-dir\");\n\nI copied some files inside this directory and tried to remove the content with Files.deleteDirectoryContents().\n\nIt fails silently cause of:\nif (!directory.getCanonicalPath().equals(directory.getAbsolutePath())) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n}\n\nThe cause is that directory.getCanonicalPath() returns \"C:\\work\\dev\\test\\src\\test\\resources\\target-dir\\tmp\"\n\nand directory.getAbsolutePath() returns \n\"C:\\work\\dev\\test.\\src\\test\\resources\\target-dir\\tmp\"\n\n(notice the dot before src)\n", "url": "https://github.com/google/guava/issues/498", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:13:55", "closed": "2014-10-31 19:34:08", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "AndPredicate and OrPredicate Hashcode methods leaves something to be desired.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=492) created by **Bjorn.Soldal** on 2010-12-06 at 12:58 PM_\n\n---\n\nThe HashCode functions for these two classes use AND and OR respectively to compose the hashcode, while this almost makes sense when considering the functions that the classes perform, it leaves the hashcode function almost entirely useless for larger predicates.\n\nIf you have 7 predicates within an AND or OR predicate, the likelihood is that the hashcode returned from the AND or OR predicate will be either 0 of 0xFFFFFFFF respectively. \n\nI'd say this is a cute way of solving the hashcodes but ultimately it goes beyond what the class is perceived to do and will cause issues for complex predicate structures.\n", "url": "https://github.com/google/guava/issues/492", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:13:42", "closed": "2014-10-31 18:51:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MapMaker expiration not behaving as expected", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=482) created by **keith.jo...@glebepark.com** on 2010-11-19 at 04:20 PM_\n\n---\n\nI checked out trunk and written some tests using the new functionality.  In both expire after access and expire after write, the eviction listener is not being hit where I expect.\n\nHere are the two tests I have which are failing:\n\n```\n@Test\npublic void testMapMakerExpireAfterAccess() throws InterruptedException {\n    final AtomicBoolean stopped = new AtomicBoolean(false);\n    final ConcurrentMap<String, Double> map = new MapMaker().expireAfterAccess(1, TimeUnit.SECONDS).evictionListener(new MapEvictionListener<String, Double>() {\n        @Override\n        public void onEviction(String key, Double value) {\n            System.out.println(\"Eviction listener hit for \" + key);\n            stopped.set(true);\n        }\n    }).makeMap();\n\n    new Thread(new Runnable() {\n\n        @Override\n        public void run() {\n            while (!stopped.get()) {\n                // make key 1 and key 2 tick\n                map.put(\"key1\", Math.random());\n                map.put(\"key2\", Math.random());\n                // get key2 so its acccess time is updated\n                map.get(\"key2\");\n                try {\n                    Thread.sleep(100L);\n                } catch (InterruptedException e) {\n                    // no action\n                }\n            }\n        }\n    }).start();\n    Thread.sleep(2000L);\n    // expect key2 to be present because of the thread accessing it, but key1 has only been written not read so it should expire\n    assertEquals(1, map.size());\n    assertTrue(map.containsKey(\"key2\"));\n    assertFalse(map.containsKey(\"key1\"));\n}\n\n@Test\npublic void testMapMakerExpiresAfterWrite() throws InterruptedException {\n    final AtomicBoolean stopped = new AtomicBoolean(false);\n    final ConcurrentMap<String, Double> map = new MapMaker().expireAfterWrite(1, TimeUnit.SECONDS).evictionListener(new MapEvictionListener<String, Double>() {\n        @Override\n        public void onEviction(String key, Double value) {\n            System.out.println(\"Eviction listener hit for \" + key);\n        }\n    }).makeMap();\n    map.put(\"key1\", Math.random());\n    map.put(\"key2\", Math.random());\n    new Thread(new Runnable() {\n\n        @Override\n        public void run() {\n            while (!stopped.get()) {\n                map.get(\"key2\");\n                try {\n                    Thread.sleep(100L);\n                } catch (InterruptedException e) {\n                    // no action\n                }\n            }\n        }\n    }).start();\n    Thread.sleep(2000L);\n    // nothing has been written for 2 seconds, so the get calls on the other thread should have caused the items to be evicted\n    stopped.set(true);\n    assertEquals(0, map.size());\n}\n```\n", "url": "https://github.com/google/guava/issues/482", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:13:20", "closed": "2014-10-31 19:02:53", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "small javadoc typo in MapMaker#weakValues()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=474) created by **joe.j.kearney** on 2010-11-09 at 04:42 PM_\n\n---\n\nCurrently:\n&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffthrows IllegalStateException if the key strength was already set\n\nShould be:\n&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffthrows IllegalStateException if the value strength was already set\n\nAppears to be correct for #softValues().\n", "url": "https://github.com/google/guava/issues/474", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:13:02", "closed": "2014-10-31 18:51:26", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NullPointerException thrown during auto-unboxing of Boolean, Integer etc\u2026", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=466) created by **valerav** on 2010-11-04 at 11:04 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Declare class variable Boolean myBool;\n2. In any method add\nif(myBool) {\n&nbsp;&nbsp;&nbsp;// block 1\n} else {\n&nbsp;&nbsp;&nbsp;// this block is usually expected to run\n}\n\n<b>What is the expected output? What do you see instead?</b>\nUnexperienced developer does not expect and usually do not understand why the NullPointerException thrown in condition of if\n\nI resolved it by static methods:\npublic static boolean unbox(final Boolean obj)\npublic static boolean unbox(final Boolean obj, final boolean defaultValue)\netc. for all Numbers and Character\n\nThe methods can be also added to ObjectUtils\n", "url": "https://github.com/google/guava/issues/466", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:12:46", "closed": "2014-10-31 18:41:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ArrayListMultimap performance", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=459) created by **arnoldomuller** on 2010-10-27 at 10:36 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Create a Multimap&lt;String, MyObj> m = ArrayListMultimap.create();\n2. Insert 1000 elements\n3. Query the map 80 million times\n\n<b>What is the expected output? What do you see instead?</b>\n\nThe performance of the m.get() method is low and eventually memory errors will occur. Using HashMap&lt;String,ArrayList&lt;MyObj>> instead is much more efficient and no memory errors will rise. \n\n<b>What version of the product are you using? On what operating system?</b>\n\nr07, Ubuntu 10.04 x64, Oracle JRockit(R) (build R28.0.1-21-133393-1.6.0_20-20100512-2126-linux-x86_64)\n\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/459", "user": "gissuebot", "labels": ["status=invalid", "type=defect"], "created": "2014-10-31 17:12:31", "closed": "2014-10-31 19:35:55", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Document immutability of `PatternFilenameFilter`", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=454) created by **j...@nwsnet.de** on 2010-10-20 at 10:37 AM_\n\n---\n\nIt looks to me that `PatternFilenameFilter`&nbsp;is immutable and maybe even thread-safe (I'm not absolutely sure, though). If that is the case (but also if not), please document these properties.\n\nBackground: One might want to use instances of this class as constants.\n", "url": "https://github.com/google/guava/issues/454", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:12:21", "closed": "2014-10-31 19:38:05", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "EnumMap.entrySet() considered harmful: EnumMultiset.entrySet() is afffected", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=448) created by **ray.j.greenwell** on 2010-10-11 at 11:20 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n\n&nbsp;&nbsp;&nbsp;static enum Foo { ONE, TWO, THREE }\n&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;System.err.println(\"Oh no: \" + Lists.newArrayList(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMultiset.create(Arrays.asList(Foo.ONE, Foo.ONE, Foo.TWO, Foo.THREE)).entrySet()));\n\nWhat is the expected output?\n&nbsp;&nbsp;&nbsp;Oh no: ONE x 2, TWO, THREE\n\nWhat do you see instead?\n&nbsp;&nbsp;&nbsp;Oh no: THREE, THREE, THREE\n\n<b>What version of the product are you using? On what operating system?</b>\n\n&nbsp;&nbsp;Guava r7, all.\n\n<b>Please provide any additional information below.</b>\n\n&nbsp;&nbsp;This is the result of what I would consider a bug in EnumMap.entrySet().\n\n&nbsp;&nbsp;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6312706\n\n&nbsp;&nbsp;Guava's AbstractMapBasedMultiset iterates over the Map.Entry objects from the backing map and returns a Multiset.Entry wrapper around each. However, with EnumMap's entrySet, only one Entry is ever removed. The Multiset creates N wrappers for this single entry...\n\n&nbsp;&nbsp;I came across this while trying to sort entries by highest count.\n\nWorkaround:\n\n&nbsp;&nbsp;Use a HashMultiset instead.\n", "url": "https://github.com/google/guava/issues/448", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:12:08", "closed": "2014-10-31 19:12:37", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Maps.capacity gives bad estimate (16) when expectedSize >= 2^30", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=442) created by **ddlatham** on 2010-10-06 at 09:47 PM_\n\n---\n\nMaps.capacity is used to give initial sizes to new hash maps and sets so that they can avoid expensive reallocations.  However, if the expected size is at least 2^30, then the computation overflows, and it ends up returning 16.\n", "url": "https://github.com/google/guava/issues/442", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:11:55", "closed": "2014-10-31 18:51:11", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Multimap.asMap().get() javadoc not consistent with behaviour", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=437) created by **joe.j.kearney** on 2010-09-30 at 03:04 PM_\n\n---\n\nMultimap.asMap() javadoc says:\nThe collections returned by asMap().get(Object) have the same behavior as those returned by get(K). Behaviour appears to be defined only when the given object is of type K, which is fair.\n\nHowever, the following shows a discrepancy:\n&nbsp;&nbsp;&nbsp;&nbsp;HashMultimap&lt;String, Integer> hashMultimap = HashMultimap.create();\n&nbsp;&nbsp;&nbsp;&nbsp;hashMultimap.put(\"a\", 2);\n\n```\nCollection<Integer> fromAsMap = hashMultimap.asMap().get(\"b\"); // null\nCollection<Integer> fromGet = hashMultimap.get(\"b\"); // empty set\nCollection<Integer> fromAsMapWrongType = hashMultimap.asMap().get(new Object()); // null\n```\n\nThe problem appears to be in in AbstractMultimap.AsMap#get(Object). We look up the key first and return null if there's no current mapping. However this appears to be used as an attempt to check the type of the key (declared Object). If the key is present, the collection of values is wrapped and returned.\n\nGiven that we don't know the type of the key at this point, it's difficult to see what to do that doesn't involve deferring any ClassCastException to much later on. For example the ValuesCollection could store the key as an Object and cast on each use, yuk.\n\n==== Test case ====\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class AsMapGetTest {\n&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\n&nbsp;&nbsp;&nbsp;&nbsp;public void testAsMapGetSameAsGet() throws Exception {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMultimap&lt;String, Integer> hashMultimap = HashMultimap.create();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashMultimap.put(\"a\", 2);\n\n```\n    assertEquals(hashMultimap.get(\"b\"), hashMultimap.asMap().get(\"b\")); // spec expects same as get() - fail\n}\n```\n\n}\n", "url": "https://github.com/google/guava/issues/437", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:11:45", "closed": "2014-10-31 18:51:23", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Equivalences.nullAwareEquals().hash(null) should return 0 rather than throw a NullPointerException", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=411) created by **bolinfest** on 2010-09-05 at 03:07 PM_\n\n---\n\nI was pretty surprised to discover that Equivalences.nullAwareEquals().hash(null) throws an NPE (by design). If it is \"null aware,\" why doesn't it just return 0?\n\nBecause of this, Equivalence did not add much value when I had to implement my own Pair class:\n\nhttp://code.google.com/p/plovr/source/browse/src/org/plovr/util/Pair.java\n\nThough of course, if https://github.com/google/guava/issues/203 were fixed, then this would have been less of an issue for me!\n", "url": "https://github.com/google/guava/issues/411", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:10:51", "closed": "2014-10-31 18:51:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableMap.copyOf can throw NPE", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=409) created by **shiva.prius** on 2010-08-30 at 07:05 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Create a regular hashmap. Set any keys but place the value as null\n2. Invoke ImmutableMap.copyOf on the map in step 1.\n3. Throws as NPE.\n\n<b>What is the expected output? What do you see instead?</b>\nShould not throw NPE's but should return an ImmutableMap\n\n<b>What version of the product are you using? On what operating system?</b>\n0.8. Ubuntu.\n\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/409", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:10:47", "closed": "2014-10-31 18:33:25", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MapMaker().weakKeys() causes thread leak in webapp", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=382) created by **veaven** on 2010-07-20 at 09:39 AM_\n\n---\n\n&nbsp;&nbsp;Currently, I am using google-collections 1.0. If we call new MapMaker().weakKeys().makeMap() to create a new Map, it will start a daemon thread to call finalizeReferent method internally.\n\n&nbsp;&nbsp;This works fine for any java standalone application, however, it can cause thread leak in a Java EE application, because the java ee container may not shutdown for deploy/undeploy an application. so the daemon thread will remain in the container after we undeploy the application.\n\n&nbsp;&nbsp;Can MapMaker create a weak reference map with a flag to enable/disable backgroup thread? \n\nCheers,\nDavid\n", "url": "https://github.com/google/guava/issues/382", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:09:50", "closed": "2014-10-31 18:34:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "removeIf() broken for RandomAccess lists that don't support set()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=377) created by **sylvain.mina** on 2010-07-12 at 07:38 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n&nbsp;final ArrayList&lt;Integer> crash = Lists.newArrayList(1, 2, 3, 4, 5); \n&nbsp;Iterables.removeIf(Lists.transform(crash, intoDouble()), even()); \n&nbsp;System.out.println(crash);\n\n<b>What is the expected output? What do you see instead?</b>\n&nbsp;Expected result should be [1,3,5]\n&nbsp;Instead, this exception is reported:\n\njava.lang.UnsupportedOperationException \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at java.util.AbstractList.set(AbstractList.java:115) \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.Iterables.removeIfFromRandomAccessList(Iterables. java: 167) \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.Iterables.removeIf(Iterables.java:152) \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..... \n\n<b>What version of the product are you using? On what operating system?</b>\n&nbsp;&nbsp;guava r05\n\n<b>Please provide any additional information below.</b>\n\nthis have already been discussed here:\n\nhttp://groups.google.com/group/guava-discuss/browse_thread/thread/2d422600e7f87367/1e6c6a7b41c87aac#1e6c6a7b41c87aac\n", "url": "https://github.com/google/guava/issues/377", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:09:40", "closed": "2014-10-31 19:14:00", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Cartesian product size calculation bug", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=373) created by **jim.andreou** on 2010-06-18 at 03:28 PM_\n\n---\n\nAt the risk of being voted for the grossest nitpicking of the year, here is an example of Sets.cartesianProduct silently producing the wrong size().\n\nI create some sets with sizes of 2, 3, 17, etc, and make the cartesian product of those, which thinks that its size is merely 858993458, and no overflow happened, while the real size is 18446744074568545074 (i.e., does not fit in a long).\n\nThe problem with that funny (but not unique) number is that the bits at indexes 32 to 63 are all zero, in which case the current overflow check is not adequate.\n\nI feel guilty for even mentioning this - obviously this \"bug\" has zero practical significance. I was just looking at the source of cartesianProduct(), and I was very curious, thinking \"woah, apparently Kevin uses some fancy number theory\", but I couldn't figure why this works, so I tried various numbers till I found a counterexample.\n\nSincerely sorry for wasting your time.\n", "url": "https://github.com/google/guava/issues/373", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:09:31", "closed": "2014-10-31 19:42:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "LinkedHashMultimap slow on removeAll(key) when only one key in map", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=371) created by **gabi.kaltman** on 2010-06-15 at 01:24 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Run the following code:\n\nMultimap&lt;Integer, Integer> map = LinkedHashMultimap.create();\nRandom random = new Random();\nInteger key = 10;\nfor (int i = 0; i < 20000; i++)\n&nbsp;&nbsp;&nbsp;map.put(key, random.nextInt());\n\n//map.put(2, 2);\nlong start = System.currentTimeMillis();\nmap.removeAll(key);\nSystem.out.println(\"Time is \" + (System.currentTimeMillis() - start));\n1. Uncomment line //map.put(2,2) and run again\n\n<b>What is the expected output? What do you see instead?</b>\n\nremoveAll(key) is slower when the map contains only 1 key than when the map contains more keys.\n\n<b>What version of the product are you using? On what operating system?</b>\ngoogle collection 1.0, ubuntu 10.04\n\n<b>Please provide any additional information below.</b>\nLinkedHashMultimap$SetDecorator.clear calls LinkedHashSet.removeAll(Collection<?> c) with an ArrayList as argument.\n\nWhen the map has only one key, removeAll will perform a contains(Object o) on the ArrayList for all the values corresponding to the key.\n", "url": "https://github.com/google/guava/issues/371", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:09:27", "closed": "2014-10-31 19:35:42", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "MultiMap.asMap() does not return a fully serializable Map.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=366) created by **scholz.henning** on 2010-06-09 at 02:10 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n<b>1.</b>\nFill a multimap and call asMap().\n\n<b>What is the expected output? What do you see instead?</b>\nThe Map returned and the Collection of values should implement java.io.Serializable.\n\n<b>What version of the product are you using? On what operating system?</b>\nr03\n", "url": "https://github.com/google/guava/issues/366", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:09:17", "closed": "2014-10-31 18:26:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Files.deleteRecursively does nothing on Windows ", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=365) created by **ralphschaer** on 2010-06-04 at 11:08 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\nCreate a directory\n&nbsp;&nbsp;File d = new File(\"d:/dir\");\n&nbsp;&nbsp;d.mkdir();\ntry to delete the directory with \n&nbsp;&nbsp;Files.deleteRecursively(d);\nnothing happens\n\ntry to delete with \n&nbsp;&nbsp;d.delete();\ndirectory deleted\n\n<b>What is the expected output? What do you see instead?</b>\nFiles.deleteRecursively(d) should delete the directory\n\n<b>What version of the product are you using? On what operating system?</b>\nguava-r05\nWindows 7 Professional\nJava(TM) SE Runtime Environment (build 1.6.0_20-b02)\n\n<b>Please provide any additional information below.</b>\nThe problem is this check inside deleteDirectoryContents method\nif (!directory.getCanonicalPath().equals(directory.getAbsolutePath())) {\n&nbsp;&nbsp;return;\n}\n\ndirectory.getCanonicalPath()  -->  D:\\dir\ndirectory.getAbsolutePath() --> d:\\dir\n\nThe directory will be deleted with this statement because canonical and \nabsolute path are the same:\nFiles.deleteRecursively(new File(\"D:/dir\"));\nIt also works with this statement\nFiles.deleteRecursively(new File(\"D:\\dir\"));\n", "url": "https://github.com/google/guava/issues/365", "user": "gissuebot", "labels": ["status=obsolete", "type=defect"], "created": "2014-10-31 17:09:14", "closed": "2014-10-31 23:26:16", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Guava cannot be built with old javac's (1.5)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=364) created by **mikael.barbero** on 2010-05-29 at 07:55 AM_\n\n---\n\nDear guava developers,\n\nIt seems that Guava is using Java 6 only @\ufeffOverride annotations. It appears 14 times in r34 (it \nseems it started in r09).\n\nMaybe this is known and ignored as it should not break binary compatibility but it IMHO, it \nshould stick to Java 5 SDK. Here is the list of files being concerned:\n\n&nbsp;&nbsp;\\* The method apply(Character) of type CharMatcher must override a superclass method  \nCharMatcher.java    com/google/common/base    @ line 1126\n&nbsp;&nbsp;\\* The method getNextExpirable() of type CustomConcurrentHashMap&lt;K,V>.NullExpirable must \noverride a superclass method    CustomConcurrentHashMap.java    com/google/common/collect  \n@ line 621\n&nbsp;&nbsp;\\* The method getPreviousExpirable() of type CustomConcurrentHashMap&lt;K,V>.NullExpirable \nmust override a superclass method    CustomConcurrentHashMap.java  \ncom/google/common/collect    @ line 628\n&nbsp;&nbsp;\\* The method getWriteTime() of type CustomConcurrentHashMap&lt;K,V>.NullExpirable must \noverride a superclass method    CustomConcurrentHashMap.java    com/google/common/collect  \n@ line 614\n&nbsp;&nbsp;\\* The method setNextExpirable(CustomConcurrentHashMap.Expirable) of type \nCustomConcurrentHashMap&lt;K,V>.NullExpirable must override a superclass method  \nCustomConcurrentHashMap.java    com/google/common/collect    @ line 625\n&nbsp;&nbsp;\\* The method setPreviousExpirable(CustomConcurrentHashMap.Expirable) of type \nCustomConcurrentHashMap&lt;K,V>.NullExpirable must override a superclass method  \nCustomConcurrentHashMap.java    com/google/common/collect    @ line 632\n&nbsp;&nbsp;\\* The method setWriteTime(long) of type CustomConcurrentHashMap&lt;K,V>.NullExpirable must \noverride a superclass method    CustomConcurrentHashMap.java    com/google/common/collect  \n@ line 618\n&nbsp;&nbsp;\\* The method addListener(Runnable, Executor) of type ForwardingListenableFuture&lt;V> must \noverride a superclass method    ForwardingListenableFuture.java  \ncom/google/common/util/concurrent    @ line 44\n&nbsp;&nbsp;\\* The method valueComparator() of type ForwardingSortedSetMultimap&lt;K,V> must override a \nsuperclass method    ForwardingSortedSetMultimap.java    com/google/common/collect    @ line \n58\n&nbsp;&nbsp;\\* The method apply(I) of type new Function&lt;I,ListenableFuture&lt;O>>(){} must override a \nsuperclass method    Futures.java    com/google/common/util/concurrent    @ line 315\n&nbsp;&nbsp;\\* The method compare(Object, Object) of type Ordering&lt;T>.ArbitraryOrdering must override a \nsuperclass method    Ordering.java    com/google/common/collect    @ line 214\n&nbsp;&nbsp;\\* The method hasNext() of type Sets.PowerSet&lt;E>.BitFilteredSetIterator&lt;E> must override a \nsuperclass method    Sets.java    com/google/common/collect    @ line 1061\n&nbsp;&nbsp;\\* The method next() of type Sets.PowerSet&lt;E>.BitFilteredSetIterator&lt;E> must override a \nsuperclass method    Sets.java    com/google/common/collect    @ line 1065\n&nbsp;&nbsp;\\* The method newThread(Runnable) of type new ThreadFactory(){} must override a superclass \nmethod    ThreadFactoryBuilder.java    com/google/common/util/concurrent    @ line 155\n\nBest regards,\nMikael\n", "url": "https://github.com/google/guava/issues/364", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:09:12", "closed": "2014-11-01 00:53:56", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FilteredSet doesn't play nicely with Predicates.instanceOf()", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=363) created by **dan.rosen** on 2010-05-25 at 07:30 AM_\n\n---\n\nExample:\n\n&nbsp;&nbsp;Set&lt;Base> unfiltered = allYourBase();\n&nbsp;&nbsp;Set&lt;Base> filtered =\n&nbsp;&nbsp;&nbsp;&nbsp;Sets.filter(unfiltered, Predicates.instanceOf(Derived1.class));\n&nbsp;&nbsp;Base obj = new Derived2();\n&nbsp;&nbsp;filtered.contains(obj); // will always return false\n&nbsp;&nbsp;Set&lt;Base> copied = ImmutableSet.copyOf(filtered);\n&nbsp;&nbsp;copied.contains(obj); // workaround, will return true when appropriate\n\nIf Derived1 and Derived2 have compatible or identical implementations of \nequals() and hashCode(), and there's a corresponding entry for obj of \ntype Derived1 in unfiltered, then I expect filtered.contains(obj) to \nreturn true even though obj itself does not satisfy the predicate.\n", "url": "https://github.com/google/guava/issues/363", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:09:10", "closed": "2014-10-31 18:33:03", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableMap.Builder.put() should throw an IllegalArgumentExcepotion for duplicate keys", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=360) created by **erharold** on 2010-05-12 at 01:31 PM_\n\n---\n\nMaps do not allow duplicate keys. ImmutableMap.Builder does allow duplicate\nkeys. That is, you can put as many duplicate keys in the map as you like,\nand no exception is thrown. However an IllegalArgumentException is thrown\nwhen you attempt to build() an ImmutableMap from the builder. \n\nThere is nothing one can do with an ImmutableMap.Builder that contains\nduplicate keys. You can't inspect it, and you can't build a map from it.\nYou can't even remove the duplicate key. As soon as the duplicate key is\ninserted, the builder is irretrievably broken.\n\nInstead of allowing a duplicate key to be inserted, the put method should\nthrow an IllegalArgumentException. This is a runtime exception and a\ncompatible change. This has two beneficial effects:\n1. It makes it much easier to locate and debug problems. Currently, you\n   only become aware of the problem when build() is called, possibly long\n   after the root cause of duplicate key insertion. It helps to know where and\n   when the duplicate key is inserted, not merely that someone, somewhere, put\n   in a duplicate key.\n2. It makes it possible to recover from duplicate key insertion by catching\n   the IllegalArgumentException. Currently this is unrecoverable. You have to\n   rebuild the map from scratch at best, and even that is difficult because\n   you can't tell what key caused the problem. Enabling the programmer to\n   (optionally) catch the exception at put time instead of build time gives\n   them the chance to ignore the exception if, for example, they just need to\n   make sure that the key has some value and don't care which of several\n   values they assign to it. \n\nIn my case I was making a map of timezones to cities. I needed one city per\ntimezone, but I didn't care which city it was. As it happened, I had\nmultiple cities (values) in some timezones (keys) and consequently the\nbuilder blew up. Debugging was complicated because the step that blew up\nwas not the step with the problem Fixing this required an extra deduping\nstep on my keys. \n", "url": "https://github.com/google/guava/issues/360", "user": "gissuebot", "labels": ["package=collect", "status=will-not-fix", "type=defect"], "created": "2014-10-31 17:09:04", "closed": "2015-04-15 19:01:14", "commits": {}, "ttf": 166.00027777777777, "commitsDetails": []}, {"title": "Files.deleteRecursively method fails on Mac OS in typical use case scenario", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=359) created by **hshsce** on 2010-05-12 at 09:22 AM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. File dir = Files.createTempDir(); (e.g. unit test set up)\n2. fill dir with some random files\n3. Files.deleteRecursively(dir); (e.g. unit test tear down).\n\n<b>What is the expected output? What do you see instead?</b>\n\nI expect directory to be deleted. IOExceptio is thrown instead\n\n<b>What version of the product are you using? On what operating system?</b>\n\nguava-io r03 from maven repository\n\nuname -a\nDarwin foo.lan 10.3.0 Darwin Kernel Version 10.3.0: Fri Feb 26 11:58:09 PST 2010; root:xnu-\n1504.3.12~1/RELEASE_I386 i386\n\n<b>Please provide any additional information below.</b>\n\nI suspect that IOException is thrown because non empty directory cannot be deleted. It is non \nempty because Files.deleteDirectoryContents() method stopped silently without any action after \ndetecting symbolic link. In fact on my Mac OS the /tmp dir is linked with symbolic link to \n/private/tmp dir.\n", "url": "https://github.com/google/guava/issues/359", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:09:02", "closed": "2014-10-31 19:37:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ImmutableMap.copyOf is slow because of its usage of #toArray", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=344) created by **james.ravn** on 2010-04-08 at 04:12 PM_\n\n---\n\nImmutableMaps are unusable for me due to this performance issue.\n\nImmutableMap.copyOf has this line of code:\n&nbsp;&nbsp;&nbsp;&nbsp;Entry&lt;K, V>[] entries = map.entrySet().toArray(new Entry[0]);\n\nSince the Entry array is too small to fit the entrySet(), AbstractCollection#toArray delegates to the \nreflection API to create the array. This is extremely slow in my profiling - copyOf spends 95% of \nits time creating these arrays.\n\nA fix is to create the initial array with the size of the map - this prevents the java library from \nusing reflection:\n&nbsp;&nbsp;&nbsp;&nbsp;Entry&lt;K, V>[] entries = map.entrySet().toArray(map.size());\n\nBefore:\n&nbsp;&nbsp;&nbsp;&nbsp;14.4 ms    1.7 s    com.google.common.collect    ImmutableMap::copyOf\n&nbsp;&nbsp;&nbsp;&nbsp;10.3 ms    1.6 s    java.util     AbstractCollection::toArray\n&nbsp;&nbsp;&nbsp;&nbsp;1.6 s    1.6 s    java.lang      Class::getComponentType\n&nbsp;&nbsp;&nbsp;&nbsp;0.0 ns    66.0 ms    java.lang.reflect      Array::newInstance\n&nbsp;&nbsp;&nbsp;&nbsp;66.0 ms    66.0 ms    java.lang.reflect       Array::newArray\n&nbsp;&nbsp;&nbsp;&nbsp;0.0 ns    16.4 ms    com.google.common.collect     ImmutableMap::entryOf\n&nbsp;&nbsp;&nbsp;&nbsp;16.4 ms    16.4 ms    com.google.common.collect      Maps::immutableEntry\n\nWith my fix:\n&nbsp;&nbsp;&nbsp;&nbsp;96.4 ms    162.3 ms    com.google.common.collect    ImmutableMap::copyOf\n&nbsp;&nbsp;&nbsp;&nbsp;33.9 ms    55.6 ms    java.util     AbstractCollection::toArray\n&nbsp;&nbsp;&nbsp;&nbsp;0.0 ns    21.7 ms    java.util      HashMap$EntrySet::iterator\n&nbsp;&nbsp;&nbsp;&nbsp;10.3 ms    21.7 ms    java.util       HashMap::newEntryIterator\n&nbsp;&nbsp;&nbsp;&nbsp;0.0 ns    11.4 ms    java.util        HashMap$EntryIterator::&lt;init>\n&nbsp;&nbsp;&nbsp;&nbsp;11.4 ms    11.4 ms    java.util         HashMap$EntryIterator::&lt;init>\n&nbsp;&nbsp;&nbsp;&nbsp;0.0 ns    10.3 ms    com.google.common.collect     RegularImmutableMap::&lt;init>\n&nbsp;&nbsp;&nbsp;&nbsp;10.3 ms    10.3 ms    com.google.common.collect      Hashing::chooseTableSize\n\nAs a workaround I avoid using ImmutableMap.copyOf and use unmodifiable HashMaps.\n", "url": "https://github.com/google/guava/issues/344", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:08:30", "closed": "2014-10-31 18:23:44", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "ForwardingSetMultimap missing.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=340) created by **harschware** on 2010-03-17 at 04:54 PM_\n\n---\n\nForwardingSetMultimap and other Multimap derivatives are missing from the \ncollections.\n\n<b>What steps will reproduce the problem?</b>\n1.  look in the package hierarchy\n<b>2.</b>\n<b>3.</b>\n\n<b>What is the expected output? What do you see instead?</b>\n\n<b>What version of the product are you using? On what operating system?</b>\n1.0-FINAL, all OS\n\n<b>Please provide any additional information below.</b>\n", "url": "https://github.com/google/guava/issues/340", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:08:22", "closed": "2014-10-31 18:23:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Concurrency bug in AbstractMultimap", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\n\n---\n\nMultiple concurrent reads of HashMultimap result in null pointer exception.\n\nUsing Google collections version 1.0\n\nProblem\ncom.google.common.collect.AbstractMultimap.AsMap.entrySet()\ncan return null when called by multiple threads.\n\n1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\n1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\n1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\n1314    }\n1. thread 1 executes line 1312\n2. thread 2 executes 1312 and 1313\n3. thread 1 executes 1313.\n\nThread 1 will return null.\n\nFix by\n1313      return (result == null) ? entrySet = new AsMapEntries() : result;\n", "url": "https://github.com/google/guava/issues/339", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:08:20", "closed": "2014-10-31 18:55:50", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Why is HashMultimap final?", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=338) created by **amanic** on 2010-03-12 at 03:17 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\nI want to make a more convenient to work with subclass of HashMultimap eg:\n&nbsp;&nbsp;&nbsp;&nbsp;private static class TypeToRendererMap extends\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMultimap&lt;String, EnvVarRendererMetadata> {\n&nbsp;&nbsp;&nbsp;&nbsp;}\nBut I can't because HashMultimap is final (for no good reason I can see).\nMy only alternatives is to \n1) encapsulate it, but I don't want to add that overhead. \n2) clone the implementation and make it non-final, but then I have to \nmaintain it :(\n\n<b>What version of the product are you using? On what operating system?</b>\ngoogle-collections 1.0\n", "url": "https://github.com/google/guava/issues/338", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:08:18", "closed": "2014-10-31 18:22:12", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Out of Memory Exception, due to unlimited number of TimerTasks when .expiration(..) map created", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=335) created by **dominic.tootell** on 2010-02-28 at 04:49 PM_\n\n---\n## = Description/Issue =\n\nAttempting to create a memory-sensitive cache (uses hard keys and soft\nvalues), where the entries themselves have an associated expiry, i.e.:\n\n```\nnew MapMaker().concurrencyLevel(32)\n              .softValues()\n          .expiration(300, TimeUnit.SECONDS) // 5 mins\n              .makeMap();\n```\n\nWhen the garbage collector runs, entries from the map are pruned.  This\nworks well when a map is made whose entries do not have an expiration. \nHowever, when entries do have an expiration; an Out Of Memory exception\nwill occur due to the Creation of TimerTask objects that are added to the\n_ExpirationTimer.instance_, but are never removed when the garbage\ncollector runs and prunes the map (MapMaker, 495-517):\n\n```\n    void scheduleRemoval(K key, V value) {\n      /*\n       * TODO: Keep weak reference to map, too. Build a priority\n       * queue out of the entries themselves instead of creating a\n       * task per entry. Then, we could have one recurring task per\n       * map (which would clean the entire map and then reschedule\n       * itself depending upon when the next expiration comes). We\n       * also want to avoid removing an entry prematurely if the\n       * entry was set to the same value again.\n       */\n      final WeakReference<K> keyReference = new WeakReference<K>(key);\n      final WeakReference<V> valueReference = new WeakReference<V>(value);\n      ExpirationTimer.instance.schedule(\n          new TimerTask() {\n            @Override public void run() {\n              K key = keyReference.get();\n              if (key != null) {\n                // Remove if the value is still the same.\n                map.remove(key, valueReference.get());\n              }\n            }\n          }, TimeUnit.NANOSECONDS.toMillis(expirationNanos));\n    }\n\n```\n\nYou eventually see something like the following:\n\n```\nException in thread \"com.google.common.base.internal.Finalizer\"\njava.lang.OutOfMemoryError: Java heap space\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n```\n## = What steps will reproduce the problem? =\n\nRun the following main program, after maybe 2 mins you will see the issue.\nYou will notice the size of the map goes down as the program runs, due to\nthe amount of available heap is reduced by the number of TimerTasks that\nare occupying the ram.\n\n```\n\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.common.collect.MapMaker;\nimport com.google.common.collect.MyMapMaker;\n\npublic class App2 {\n    public static void main(String[] args)\n    {\n        ConcurrentMap cache = new MapMaker().concurrencyLevel(32)                                                          \n                                          .softValues()\n                                          .expiration(300, TimeUnit.SECONDS) // 5 mins\n                                          .makeMap();\n\n        long start = System.currentTimeMillis();\n\n        for (int j = 0; j < 10000000; j++) {\n            if (j % 10000 == 0) {\n                System.out.println(\"map size: \" + cache.size());\n                System.out.println(\"Max: \" + Runtime.getRuntime().maxMemory()\n                        + \" Free: \" + Runtime.getRuntime().freeMemory()\n                        + \" Total: \" + Runtime.getRuntime().totalMemory());\n            }\n            String id = UUID.randomUUID().toString();\n            cache.put(id, id.toString() + \"\");\n        }\n\n        System.out.println(\"\" + (System.currentTimeMillis() - start));\n    }\n}\n\n```\n\n== What is the expected output? What do you see instead? ==\n\nHere's the output you will see is as follows.  You will see the number of\nentries in the map get smaller and smaller, until you hit an O.O.M.\n\n```\nMax: 85393408 Free: 369656 Total: 85393408\nmap size: 33784\nMax: 85393408 Free: 1193056 Total: 85393408\nmap size: 33474\nMax: 85393408 Free: 424704 Total: 85393408\nmap size: 28057\nMax: 85393408 Free: 1548432 Total: 85393408\nmap size: 24822\nMax: 85393408 Free: 337224 Total: 85393408\nmap size: 22095\nMax: 85393408 Free: 149976 Total: 85393408\nException in thread \"com.google.common.base.internal.Finalizer\"\njava.lang.OutOfMemoryError: Java heap space\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at java.lang.Long.toUnsignedString(Long.java:218)\n    at java.lang.Long.toHexString(Long.java:155)\n    at java.util.UUID.digits(UUID.java:409)\n    at java.util.UUID.toString(UUID.java:399)\n    at App2.main(App2.java:27)\n```\n\n= What version of the product are you using? On what operating system? =\n\nMacOSx 10.6.1, \n\n```\n    <dependency>\n        <groupId>com.google.collections</groupId>\n        <artifactId>google-collections</artifactId>\n        <version>1.0</version>\n    </dependency>\n```\n", "url": "https://github.com/google/guava/issues/335", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:08:12", "closed": "2014-10-31 18:24:31", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NPE inside of ImmutableBiMap.get(Object)", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=333) created by **ndcom.net** on 2010-02-24 at 03:31 PM_\n\n---\n\nI am using an ImmutableBiMap&lt;Byte, Character> for the translation table of\na CharsetProvider. Its charset is used rather extensively in a long-running\nTomcat application.\n\nThe translation table is a static final field and initialized in a static\ninitializer, like this:\n\nprivate static final BiMap&lt;Byte, Character> TRANSLATION;\nstatic {\n&nbsp;&nbsp;&nbsp;&nbsp;Builder&lt;Byte, Character> builder = ImmutableBiMap.builder();\n&nbsp;&nbsp;&nbsp;&nbsp;builder.put((byte) 0x80, (char) 0x20AC);\n&nbsp;&nbsp;&nbsp;&nbsp;builder.put((byte) 0x82, (char) 0x201A);\n&nbsp;&nbsp;&nbsp;&nbsp;// ...\n&nbsp;&nbsp;&nbsp;&nbsp;TRANSLATION = builder.build();\n}\n\nThe translation table is sparse and contains only those code points where\nthe character values differ from the byte values. I access the translation\ntable in the CharsetDecoder like this:\n\n// ...\n/\\* Line 78 _/ byte input = in.get();\n/_ Line 79 _/ Character output = TRANSLATION.get(input);\n/_ Line 80 */ if (output != null) // ...\n// ...\n\nThe expected output would be the byte decoded to the character of the\nencoding, or null if the table does not contain a mapping for that byte.\n\nToday, I got a NullPointerException when trying to access TRANSLATION.get;\nthe key is not null, as it is a boxed byte variable. The stack trace is as\nfollows:\n\njava.lang.NullPointerException\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.ImmutableBiMap.get(ImmutableBiMap.java:230)\n&nbsp;&nbsp;&nbsp;&nbsp;at\nat.telekom.zusdie.com.encoding.APILikeWindows1252$APILikeWindows1252CharsetDecoder.decodeLoop(APILikeWindows1252.java:79)\n[outer frames omitted]\n\nThe problem disappeared after a restart of the Tomcat process and could not\nbe reproduced.\n\nVersions used:\n- Google Collections 1.0 final\n- Tomcat 6.0.20\n- Java HotSpotServer VM (build 14.0-b16)\n- SuSE Linux 2.6.27.19 with an x86_64 kernel\n\nI am quite puzzled how this problem could even occur since line 230 of\nImmutableBiMap in 1.0 final is:\n\nreturn delegate().get(key);\n\n(&lt;http://code.google.com/p/google-collections/source/browse/trunk/src/com/google/common/collect/ImmutableBiMap.java#230>)\n\nwhich means that delegate() would have to return null.\n", "url": "https://github.com/google/guava/issues/333", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:08:07", "closed": "2014-10-31 18:54:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "GWT Module missing", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=328) created by **sudhir.j** on 2010-02-21 at 07:17 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Try to use a @\ufeffGwtCompatible class in GWT code\n\n<b>What is the expected output? What do you see instead?</b>\nA No source code available error message. \n\nI believe google-collections 1.0 was supposed to have a GWT module... has \nthis plan been cancelled?\n", "url": "https://github.com/google/guava/issues/328", "user": "gissuebot", "labels": ["platform=gwt", "status=invalid", "type=defect"], "created": "2014-10-31 17:07:57", "closed": "2014-10-31 18:21:23", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Audit System.arraycopy() calls for GWT safety", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=272) created by **cpovirk+external@google.com** on 2009-10-23 at 09:10 PM_\n\n---\n\narraycopy() doesn't work right in GWT:\nhttp://code.google.com/p/google-web-toolkit/issues/detail?id=3621\n\nWe've suppressed some tests because of this bug, but the right thing is to\nstop calling arraycopy() when it's not guaranteed to work.\n\nWe should also look at all uses of arraycopy() in the library to verify\nthat they won't trigger this bug.\n\nAn easy solution is to create Platform.arraycopy() and substitute a manual\nelement-by-element copy on the GWT side.  We'd then use\nPlatform.arraycopy() exclusively.  This has the disadvantage that GWT can\nnever use its faster nativeArraycopy(), but it's easier than proving that\nwe're using arraycopy() only when it's safe.\n\nhttp://www.google.com/codesearch/p?hl=en&sa=N&cd=1&ct=rc#A1edwVHBClQ/user/super/com/google/gwt/emul/java/lang/System.java&q=System.java%20package:http://google-web-toolkit\\.googlecode\\.com\n", "url": "https://github.com/google/guava/issues/272", "user": "gissuebot", "labels": ["platform=gwt", "status=obsolete", "type=defect"], "created": "2014-10-31 17:06:44", "closed": "2014-10-31 21:01:38", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Disable or fix GWT serialization for classes without serializers", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=271) created by **cpovirk+external@google.com** on 2009-10-23 at 09:04 PM_\n\n---\n\nIssue 205, comment 32 by alen_vrecko@yahoo.com notes that serializing a\nHashBiMap results in an empty HashBiMap -- no elements, but no error.\n\nWe should either clearly break GWT serialization for such classes...\n\n&nbsp;&nbsp;private HashBiMap() {\n->\n&nbsp;&nbsp;private HashBiMap(Void void) {\n\n...or we should write the serializers.  Probably the latter.\n", "url": "https://github.com/google/guava/issues/271", "user": "gissuebot", "labels": ["package=general", "platform=gwt", "status=research", "type=defect"], "created": "2014-10-31 17:06:42", "closed": "2019-07-27 17:09:16", "commits": {}, "ttf": 1730.0002777777777, "commitsDetails": []}, {"title": "Test fails for ibm jdk: CollectionToStringTester#testToString_size1 \t\t\t\t", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=198) created by **abhishekgupta123** on 2009-06-23 at 01:46 AM_\n\n---\n\n&nbsp;&nbsp;I use the google-collections test framework and recently hit an\nissue with testing our libraries on multiple-environments.\nSpecifically on ibm jdk 1.6.0_04.\n\nI got the following test failing using that jdk:\n\ntestToString_size1[ArrayBackedMap [collection size: one] entrySet\n[collection size: one]]    Failure    size1Collection.toString should\nreturn [{element}] expected:<[[java.util.Collections$SingletonMap\n$1$1$1@f656562c]]> but was:<[[one=January]]>\n\nThis is basically because SingletonMap's entrySet implementation in\nibm jdk does not have a toString method and the one in Sun's does.\nI was wondering, since toString is not part of the spec, should this\ntest be relaxed to not test for something like this?\n\nComments appreciated.\n\nThanks,\nAbhi\n", "url": "https://github.com/google/guava/issues/198", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:06:01", "closed": "2014-10-31 23:28:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Iterators.concat(a, b) minor memory issue", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=102) created by **jvdneste** on 2008-10-29 at 09:20 AM_\n\n---\n\nIs implemented using Arrays.asList (in turn using new ArrayList()).\n\nWhich means you're hanging on to a after you've moved on to b.\nNot terribly important unless you've got a lot of generators (producing \nresults with little or no backing collections)\n\nAn Iterators.of(T... a) which nulls references to returned items might be \nhandy.\n", "url": "https://github.com/google/guava/issues/102", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:04:44", "closed": "2014-10-31 18:23:57", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FinalizableReferenceQueue keeps ClassLoaders around.", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=92) created by **nairb774** on 2008-07-28 at 05:39 PM_\n\n---\n\nIf the class loader which loaded the google-collections jar is let go\n(consider redeploying a war to Apache Geronimo) the class loader will not\nbe able to be garbage collected.  This is caused by the thread started by\nFinalizableReferenceQueue never ending.  In other words the garbage\ncollection (for the class loader) can only happen when the thread stops. \nThe solution is to stop the thread when there are no more objects on the\nqueue.  This will happen eventually if the rest of the app behaves\ncorrectly by not placing state outside of its class loader's environment. \nAttached is a version of the class which I have used to this effect.\n\nThis is also a problem in the OSGi space where every jar gets its own class\nloader and they can be refreshed easily at runtime to do rolling\nupgrades/bug fixes.\n", "url": "https://github.com/google/guava/issues/92", "user": "gissuebot", "labels": ["package=base", "status=fixed", "type=defect"], "created": "2014-10-31 17:04:41", "closed": "2014-11-01 02:07:25", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "[Patch] Add a target to build a jar file", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=9) created by **blair-ol...@orcaware.com** on 2009-12-12 at 07:17 PM_\n\n---\n\nHere's a small patch to build a jar file from the project.  This would make it\neasier for people to use the jar in projects before it gets Mavenized.\n\n```\ndiff --git a/build.xml b/build.xml\nindex fb0b0e4..3f43b1a 100644\n--- a/build.xml\n+++ b/build.xml\n@@ -21,6 +21,10 @@\n     </javac>\n   </target>\n\n+  <target name=\"jar\" depends=\"compile\">\n+    <jar destfile=\"google-guava.jar\" basedir=\"build/classes\" />\n+  </target>\n+\n   <target name=\"clean\"\n       description=\"Remove generated files.\">\n     <delete dir=\"build\"/>\n```\n", "url": "https://github.com/google/guava/issues/9", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:03:43", "closed": "2014-10-31 18:22:40", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "com.google.common.util.concurrent.Executors should be renamed to Executors2", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=8) created by **cky944** on 2009-11-13 at 04:26 PM_\n\n---\n\nGiven that the functionality of com.google.common.util.concurrent.Executors\nis (from my inspection, anyway) supposed to complement that of\njava.util.concurrent.Executors, it's reasonable to expect to import both\nclasses together.\n\nThus, in order to reduce import conflicts, using a name like Executors2\nshould be considered, in line with how Google Collections has a\nCollections2 that complements java.util.Collections.\n", "url": "https://github.com/google/guava/issues/8", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:03:41", "closed": "2014-10-31 20:19:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Provide abilty to put null into immutable map", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=7) created by **kuaw26** on 2009-10-06 at 12:38 PM_\n\n---\n\nWhy ImmutableMap check value for null?\nWhat should I do if I want to put null value?\n\nMay by it would be reasonable to introduce:\nImmutableMap.allowNullValues().&lt;all nice methods of ImmutableMap>\n\nOr do not check value for null.\n", "url": "https://github.com/google/guava/issues/7", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:03:39", "closed": "2014-10-31 18:19:19", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Use javax.annotation.* consistently", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=6) created by **montsean** on 2009-09-25 at 02:39 PM_\n\n---\n\nAny chance of making consistent use of javax.annotation.\\* for clarifying\nnull safety of method params and return values?  FindBugs users would thank\nyou for it.\n\nUsing the concurrency annotations would help as well to document thread safety.\n", "url": "https://github.com/google/guava/issues/6", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:03:37", "closed": "2014-10-31 18:23:51", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Joiner seems to be missing", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=4) created by **ted.dunning** on 2009-09-18 at 10:33 PM_\n\n---\n\nWhy is Joiner not in the library?  It is mentioned in the pdf sketch and\nseems like a natural function to include.  What happeneed?\n\n<b>What steps will reproduce the problem?</b>\n1. Look at rough sketch pdf \n2. Note it mentions Joiner\n3. Look at API docs and jars, note Joiner is missing\n\n<b>What version of the product are you using? On what operating system?</b>\n\n0.1\n", "url": "https://github.com/google/guava/issues/4", "user": "gissuebot", "labels": ["status=duplicate", "type=defect"], "created": "2014-10-31 17:03:32", "closed": "2014-10-31 18:16:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Javadoc bug (typo) in com.google.common.io.Resources", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=3) created by **ivo.wever** on 2009-09-17 at 06:35 PM_\n\n---\n\n<b>What steps will reproduce the problem?</b>\n1. Open 'http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/\ngoogle/common/io/Resources.html'\n2. Read the class documentation.\n3. Note that \"Note that even those these methods use URL parameters,\" does \nnot make any sense, because 'those' should be 'though'.\n\n<b>What version of the product are you using? On what operating system?</b>\nsvn trunk as of 2009-09-17\n", "url": "https://github.com/google/guava/issues/3", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:03:30", "closed": "2014-10-31 18:23:49", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "`Predicate` missing", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=2) created by **j...@nwsnet.de** on 2009-09-17 at 02:39 PM_\n\n---\n\nIn `com.google.com.base`: The interface `Predicate`&nbsp;exists in Google\nCollections, but is missing in Guava. However, it is at least used in Guava\nby `CharMatcher`.\n\nIs the idea to keep the interface in Collections for further development\nand have Guava in a somewhat incomplete state until integration of the\nformer or was it just forgotten to copy it?\n\nRegards,\nJochen Kupperschmidt\n", "url": "https://github.com/google/guava/issues/2", "user": "gissuebot", "labels": ["status=will-not-fix", "type=defect"], "created": "2014-10-31 17:03:28", "closed": "2014-10-31 18:15:58", "commits": {"b6381b286a8cd45f1b7533b4e76abe202e8a5c23": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "b6381b286a8cd45f1b7533b4e76abe202e8a5c23", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["d6235bd2cf3a551780b071c7022b2c8d2c96e955"], "nameRev": "b6381b286a8cd45f1b7533b4e76abe202e8a5c23 tags/v20.0-rc1~192", "commitMessage": "Update MutableGraph javadoc to state in no uncertain terms that there can only be a single edge connecting a pair of nodes. Delete TODOs regarding parallel edges for Graphs, which we will not do.\n\nRegarding motivation:\n\n1) Having a Graph with parallel edges complicates things a fair bit. There are certain assumptions you can make about graphs without parallel edges that you cannot make about graphs with parallel edges. Given that we don't even expose an \"allowsParallelEdges()\" method, there's literally no way to future-proof yourself if we did later add Graphs with parallel edges. We'd just break a lot of code.\n\n2) In order for a Graph with parallel edges to actually make sense, we would have to expose several additional methods (at the least, getEdgeCount(nodeA, nodeB), setEdgeCount(nodeA, nodeB), and allowsParallelEdges()). Given that Graph is supposed to be the simpler interface, this would be unfortunate.\n\n3) With my proposed ValueGraph interface, a ValueGraph<N, Integer> would be exactly analogous to a Graph<N> with parallel edges, but with clearer semantics. However, I feel points #1 and #2 are sufficient to resolve this matter.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=128824588\n", "commitDateTime": "2016-07-29 11:48:31", "authoredDateTime": "2016-07-29 10:57:56", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "insertions": 0, "deletions": 2, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/graph/GraphsTest.java", "insertions": 0, "deletions": 2, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/AbstractGraph.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "guava/src/com/google/common/graph/GraphBuilder.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "guava/src/com/google/common/graph/Graphs.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/ImmutableGraph.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/MutableGraph.java", "insertions": 4, "deletions": 9, "lines": 13}, {"filePath": "guava/src/com/google/common/graph/MutableNetwork.java", "insertions": 7, "deletions": 7, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractGraphTest.java", "spoonMethods": []}, {"spoonFilePath": "GraphsTest.java", "spoonMethods": []}, {"spoonFilePath": "AbstractGraph.java", "spoonMethods": []}, {"spoonFilePath": "ConfigurableMutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "GraphBuilder.java", "spoonMethods": []}, {"spoonFilePath": "Graphs.java", "spoonMethods": []}, {"spoonFilePath": "ImmutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "MutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "MutableNetwork.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}, {"commitHash": "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["7da42d206b81c8fe184f73a9314fd8ffcf565560"], "nameRev": "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed tags/v24.0~28", "commitMessage": "Fix REE handling in SerializingExecutor.\n\nThe old implementation had two bugs:\n1. Tasks that threw RejectedExecutionException on submission would still execute later\n2. Two threads submitting to an idle SequentialExecutor might see one submission succeed, even if the delegate threw REE. The submitted task wouldn't run until someone else successfully submitted another task.\n\nThis costs a possible extra lock acquisition  (to solve #2) and an allocation (to solve #1) when submitting to a SequentialExecutor that doesn't already have worker scheduled or running.\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=181810127\n", "commitDateTime": "2018-01-16 11:25:36", "authoredDateTime": "2018-01-12 16:46:03", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "insertions": 43, "deletions": 1, "lines": 44}, {"filePath": "android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "insertions": 110, "deletions": 34, "lines": 144}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "insertions": 43, "deletions": 1, "lines": 44}, {"filePath": "guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "insertions": 110, "deletions": 34, "lines": 144}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SequentialExecutorTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutorTest.testDelegateRejection()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutorTest.testRejectedExecutionThrownWithMultipleCalls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SequentialExecutor.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor", "TOT": 6, "UPD": 3, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.startQueueWorker()", "TOT": 9, "UPD": 2, "INS": 0, "MOV": 5, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.execute(java.lang.Runnable)", "TOT": 21, "UPD": 1, "INS": 9, "MOV": 8, "DEL": 3}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.QueueWorker.run()", "TOT": 5, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.QueueWorker.workOnQueue()", "TOT": 6, "UPD": 1, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Maven repo", "body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1) created by **b.k.oxley** on 2009-09-16 at 04:03 PM_\n\n---\n\nTop issues for me -- when you begin releasing jar files, please provide\nsome kind of maven support for them.  Ideal would be to include the\nbinary/source/javadoc triplet jars in the maven central repo.\n", "url": "https://github.com/google/guava/issues/1", "user": "gissuebot", "labels": ["status=fixed", "type=defect"], "created": "2014-10-31 17:03:26", "closed": "2014-10-31 18:26:27", "commits": {"b6381b286a8cd45f1b7533b4e76abe202e8a5c23": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "ed63eb90b1f2feba71d7d3cde8c4611b853add6b": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}, "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed": {"commitGHEventType": "referenced", "commitUser": "cpovirk"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "b6381b286a8cd45f1b7533b4e76abe202e8a5c23", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["d6235bd2cf3a551780b071c7022b2c8d2c96e955"], "nameRev": "b6381b286a8cd45f1b7533b4e76abe202e8a5c23 tags/v20.0-rc1~192", "commitMessage": "Update MutableGraph javadoc to state in no uncertain terms that there can only be a single edge connecting a pair of nodes. Delete TODOs regarding parallel edges for Graphs, which we will not do.\n\nRegarding motivation:\n\n1) Having a Graph with parallel edges complicates things a fair bit. There are certain assumptions you can make about graphs without parallel edges that you cannot make about graphs with parallel edges. Given that we don't even expose an \"allowsParallelEdges()\" method, there's literally no way to future-proof yourself if we did later add Graphs with parallel edges. We'd just break a lot of code.\n\n2) In order for a Graph with parallel edges to actually make sense, we would have to expose several additional methods (at the least, getEdgeCount(nodeA, nodeB), setEdgeCount(nodeA, nodeB), and allowsParallelEdges()). Given that Graph is supposed to be the simpler interface, this would be unfortunate.\n\n3) With my proposed ValueGraph interface, a ValueGraph<N, Integer> would be exactly analogous to a Graph<N> with parallel edges, but with clearer semantics. However, I feel points #1 and #2 are sufficient to resolve this matter.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=128824588\n", "commitDateTime": "2016-07-29 11:48:31", "authoredDateTime": "2016-07-29 10:57:56", "commitGitStats": [{"filePath": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "insertions": 0, "deletions": 2, "lines": 2}, {"filePath": "guava-tests/test/com/google/common/graph/GraphsTest.java", "insertions": 0, "deletions": 2, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/AbstractGraph.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "guava/src/com/google/common/graph/GraphBuilder.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "guava/src/com/google/common/graph/Graphs.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/ImmutableGraph.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "guava/src/com/google/common/graph/MutableGraph.java", "insertions": 4, "deletions": 9, "lines": 13}, {"filePath": "guava/src/com/google/common/graph/MutableNetwork.java", "insertions": 7, "deletions": 7, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "AbstractGraphTest.java", "spoonMethods": []}, {"spoonFilePath": "GraphsTest.java", "spoonMethods": []}, {"spoonFilePath": "AbstractGraph.java", "spoonMethods": []}, {"spoonFilePath": "ConfigurableMutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "GraphBuilder.java", "spoonMethods": []}, {"spoonFilePath": "Graphs.java", "spoonMethods": []}, {"spoonFilePath": "ImmutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "MutableGraph.java", "spoonMethods": []}, {"spoonFilePath": "MutableNetwork.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}, {"commitHash": "ed63eb90b1f2feba71d7d3cde8c4611b853add6b", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["e16c9e16b2e645d884944b721522aeb85e4c8bbf"], "nameRev": "ed63eb90b1f2feba71d7d3cde8c4611b853add6b tags/v20.0-rc1~129", "commitMessage": "Completely overhaul top-level javadoc for common.graph interfaces in light of the new interface hierarchy. Spend a lot of time answering what I think will be the #1 question users have: should I use a Graph or a Network? Spend a lot less time defining graph theory terms, that's what wikipedia is for :) plus the method-level javadoc defines terms as necessary. Overall, make it a lot more concise. Javadoc that's too long for anyone to bother reading is just as good as javadoc that doesn't exist!\n\nAlso, ran g4 fix on these files.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=130673920\n", "commitDateTime": "2016-08-18 13:46:59", "authoredDateTime": "2016-07-16 13:16:06", "commitGitStats": [{"filePath": "guava/src/com/google/common/graph/BasicGraph.java", "insertions": 60, "deletions": 131, "lines": 191}, {"filePath": "guava/src/com/google/common/graph/Graph.java", "insertions": 80, "deletions": 29, "lines": 109}, {"filePath": "guava/src/com/google/common/graph/MutableBasicGraph.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "guava/src/com/google/common/graph/MutableGraph.java", "insertions": 8, "deletions": 8, "lines": 16}, {"filePath": "guava/src/com/google/common/graph/MutableNetwork.java", "insertions": 5, "deletions": 5, "lines": 10}, {"filePath": "guava/src/com/google/common/graph/Network.java", "insertions": 74, "deletions": 194, "lines": 268}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed", "commitGHEventType": "referenced", "commitUser": "cpovirk", "commitParents": ["7da42d206b81c8fe184f73a9314fd8ffcf565560"], "nameRev": "a43b4aa7f43c4fad61ca20c3c6744a6f4f1b68ed tags/v24.0~28", "commitMessage": "Fix REE handling in SerializingExecutor.\n\nThe old implementation had two bugs:\n1. Tasks that threw RejectedExecutionException on submission would still execute later\n2. Two threads submitting to an idle SequentialExecutor might see one submission succeed, even if the delegate threw REE. The submitted task wouldn't run until someone else successfully submitted another task.\n\nThis costs a possible extra lock acquisition  (to solve #2) and an allocation (to solve #1) when submitting to a SequentialExecutor that doesn't already have worker scheduled or running.\n\nRELNOTES=n/a\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=181810127\n", "commitDateTime": "2018-01-16 11:25:36", "authoredDateTime": "2018-01-12 16:46:03", "commitGitStats": [{"filePath": "android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "insertions": 43, "deletions": 1, "lines": 44}, {"filePath": "android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "insertions": 110, "deletions": 34, "lines": 144}, {"filePath": "guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "insertions": 43, "deletions": 1, "lines": 44}, {"filePath": "guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "insertions": 110, "deletions": 34, "lines": 144}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SequentialExecutorTest.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutorTest.testDelegateRejection()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutorTest.testRejectedExecutionThrownWithMultipleCalls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SequentialExecutor.java", "spoonMethods": [{"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor", "TOT": 6, "UPD": 3, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.startQueueWorker()", "TOT": 9, "UPD": 2, "INS": 0, "MOV": 5, "DEL": 2}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.execute(java.lang.Runnable)", "TOT": 21, "UPD": 1, "INS": 9, "MOV": 8, "DEL": 3}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.QueueWorker.run()", "TOT": 5, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.QueueWorker.workOnQueue()", "TOT": 6, "UPD": 1, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ed63eb90b1f2feba71d7d3cde8c4611b853add6b"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 231, "deletions": 371, "lines": 602, "gitFilesChange": 6}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["guava/src/com/google/common/graph"], "changesInPackagesSPOON": []}]}