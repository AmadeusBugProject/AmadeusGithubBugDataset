{"bugLabels": ["bug"], "projectName": "Netflix/Hystrix", "captureTime": "Fri Jul  3 15:21:13 2020", "issues": [{"created": "2017-04-24 10:11:11", "user": "eacdy", "body": "I\u2018ve got a problem. Here goes the code.\r\n\r\nUserController:\r\n\r\n```java\r\n@RestController\r\npublic class MovieController {\r\n  @Autowired\r\n  private UserService userService;\r\n\r\n  @HystrixCommand(fallbackMethod = \"findByIdFallback\")\r\n  @GetMapping(\"/user/{id}\")\r\n  public User findById(@PathVariable Long id) {\r\n    return this.userService.findById(id);\r\n  }\r\n\r\n  public User findByIdFallback(Long id, Throwable throwable) {\r\n    User user = new User();\r\n    user.setId(-1L);\r\n    user.setName(\"the default user\");\r\n    return user;\r\n  }\r\n}\r\n```\r\n\r\nUserService:\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    @Autowired\r\n    private RestTemplate restTemplate;\r\n\r\n    public User findById(Long id) {\r\n        throw new HystrixBadRequestException(\"business exception happens.\");\r\n    }\r\n}\r\n```\r\n\r\nWhen I invoke `MovieController.findById` with the URL <http://localhost:8010/user/1> , the code will never get into the fallback method `findByIdFallback`. I'm glad to see it.\r\n\r\nBUT a NPE happens, like below:\r\n\r\n```\r\njava.lang.NullPointerException: null\r\n\tat com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect.methodsAnnotatedWithHystrixCommand(HystrixCommandAspect.java:103) ~[hystrix-javanica-1.5.6.jar:1.5.6]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:656) ~[spring-aop-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat com.itmuch.cloud.study.user.controller.MovieController$$EnhancerBySpringCGLIB$$ff9766ae.findById(<generated>) ~[classes/:na]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121]\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121]\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121]\r\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:220) ~[spring-web-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) ~[spring-web-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:116) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) ~[spring-webmvc-4.3.5.RELEASE.jar:4.3.5.RELEASE]\r\n\t...\r\n```\r\n\r\nWHAT'S wrong with the code?\r\n\r\nWhen I change the code like this:\r\n\r\n```java\r\n@Service\r\npublic class UserService {\r\n    @Autowired\r\n    private RestTemplate restTemplate;\r\n\r\n    public User findById(Long id) {\r\n        throw new HystrixBadRequestException(\"business exception happens.\", new Exception(\"xxx\"));\r\n    }\r\n}\r\n```\r\n\r\nIt works. \r\n\r\nSO, do we have to use `new HystrixBadRequestException(message, cause)` instead of `HystrixBadRequestException(message)` ?\r\n\r\nMy Hystirx version is 1.5.6.\r\n\r\nCould you help me?\r\nCode is here: <https://github.com/eacdy/test-for-issue-hystrix>", "closed": "2017-05-18 07:22:50", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1545", "ttf": 23.00027777777778, "commits": {}, "labels": ["bug", "javanica"], "title": "Problem with HystrixBadRequestException"}, {"created": "2017-04-19 05:20:24", "user": "narusas", "body": "Hi.\r\n\r\nRecently, I need to know is circuit breaker is half-opened? can I execute command? \r\n```\r\n  @Test\r\n  public void can_read_state_of_HALF_OPEN() {\r\n    String commandKey = \"test444\"; \r\n    executeBeforeCircuiteOpenLimit(commandKey); // \r\n    {\r\n      waitHealthUpdate();\r\n      CommandHelloWorld cmd = new CommandHelloWorld(commandKey, true); <- when second arg is true, throw execption\r\n      assertFalse(cmd.isCircuitBreakerOpen());\r\n      try {\r\n        // over 50% error!!\r\n        cmd.execute();\r\n        fail(\"Must throw exception\");\r\n      } catch (HystrixRuntimeException ex) {\r\n        // ok, circuit is opened! \r\n      }\r\n      waitHealthUpdate();\r\n      assertTrue(\"Error ratio is over 50%, circuit must be opened\", cmd.isCircuitBreakerOpen());\r\n      {\r\n        CommandHelloWorld cmdAllowRequest = new CommandHelloWorld(commandKey, true);\r\n        assertFalse(\"When circuit is opened, not allow request\", cmdAllowRequest.allowRequest());\r\n      }\r\n    }\r\n\r\n    {\r\n      waitSleepTime();\r\n      waitHealthUpdate();\r\n      CommandHelloWorld cmd = new CommandHelloWorld(commandKey, false);\r\n\r\n      assertTrue(\"Over sleep time, but no request tried, no status change. So circuit status is opened, too\", cmd.isCircuitBreakerOpen());\r\n      /* CHECK ALLOW */ assertTrue(\"But over sleep time, circuit is half opened, must allow request \", cmd.allowRequest());\r\n\r\n      \r\n    }\r\n    \r\n    { \r\n      CommandHelloWorld cmd = new CommandHelloWorld(commandKey, false); <- when second arg is false, not throw execption, success\r\n     /* HERE */  cmd.execute();\r\n\r\n      assertFalse(\"over sleep, first request is succcees, circut status must be  changed\", cmd.isCircuitBreakerOpen());\r\n    }\r\n    {\r\n      CommandHelloWorld cmd = new CommandHelloWorld(commandKey, false);\r\n      cmd.execute();\r\n    }\r\n\r\n  }\r\n\r\n  class CommandHelloWorld extends HystrixCommand<String> {\r\n    ...\r\n    public boolean allowRequest() {\r\n      return circuitBreaker.allowRequest();\r\n    }\r\n    ...\r\n    @Override\r\n    protected String run() {\r\n      if (error) {\r\n        throw new IllegalArgumentException(\"No\");\r\n      }\r\n      return \"Hello \" + name + \"!\";\r\n    }\r\n\r\n  }\r\n```\r\nBut this test is failed at /* HERE */  . \r\nResult: Circuit is shorted \r\n\r\nSo I remove /* CHECK ALLOW */ line (remove call allowRequest ), \r\nTest is success. \r\n\r\nI trace into circuitBreaker.allowRequest(),\r\nAnd found \u200bHystrixCircuitBreakerImpl allowSingleTest method\r\n```\r\n  public boolean allowSingleTest() {\r\n    long timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();\r\n    // 1) if the circuit is open\r\n    // 2) and it's been longer than 'sleepWindow' since we opened the circuit\r\n    if (circuitOpen.get() && System.currentTimeMillis() > timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) {\r\n      // We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.\r\n      // If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.\r\n      if (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) {\r\n        // if this returns true that means we set the time so we'll return true to allow the singleTest\r\n        // if it returned false it means another thread raced us and allowed the singleTest before we did\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n```\r\n\r\nAt  Seconds If statement, It change circuitOpenedOrLastTestedTime. \r\n\r\nI think this is bug. I just call query method, but it change status. \r\n\r\n", "closed": "2017-06-21 18:43:20", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1541", "ttf": 63.000277777777775, "commits": {}, "labels": ["bug", "enhancement", "hystrix-core"], "title": "CircuitBreaker.allowRequest change state of isOpen"}, {"created": "2017-01-18 23:25:45", "commits": {"82a6610c6b59aeb7f0fd9cc6c8e3e55bcbf24a0e": {"commitGHEventType": "closed", "commitUser": "mattrjacobs"}}, "numCommits": 1, "changesInPackagesSPOON": ["com.netflix.hystrix.AbstractCommand.decomposeException(java.lang.Exception)"], "closed": "2017-03-24 16:49:08", "filteredCommits": ["82a6610c6b59aeb7f0fd9cc6c8e3e55bcbf24a0e"], "commitsDetails": [{"nameRev": "82a6610c6b59aeb7f0fd9cc6c8e3e55bcbf24a0e tags/v1.5.11~7^2", "commitMessage": "Fixes #1458 : it is now possible to implements \"ExceptionNotWrappedByHystrix\" to get back the original exception and not an HystrixBadRequestException\n", "commitParents": ["710a537ec7d820fb19c88accc96577ccf64a29a2"], "spoonStatsSkippedReason": "", "commitHash": "82a6610c6b59aeb7f0fd9cc6c8e3e55bcbf24a0e", "authoredDateTime": "2017-03-19 19:03:39", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 29, "deletions": 0, "lines": 29, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, {"insertions": 6, "deletions": 0, "lines": 6, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/AbstractTestHystrixCommand.java"}], "commitDateTime": "2017-03-19 19:03:39", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.ExecutionResult"}], "spoonFilePath": "AbstractTestHystrixCommand.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 6, "MOV": 3, "INS": 3, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.AbstractFlexibleTestHystrixCommand.run()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNotWrappedBadRequestWithNoFallback()"}], "spoonFilePath": "HystrixCommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 12, "MOV": 6, "INS": 4, "DEL": 2, "spoonMethodName": "com.netflix.hystrix.AbstractCommand.decomposeException(java.lang.Exception)"}], "spoonFilePath": "AbstractCommand.java"}]}], "url": "https://github.com/Netflix/Hystrix/issues/1458", "ttf": 64.00027777777778, "gitStatsSummary": {"insertions": 6, "deletions": 0, "lines": 6, "gitFilesChange": 1}, "title": "Incorrectly getting error \"Collapser method must have one argument\" from CollapserMetaHolderFactory", "statsSkippedReason": "", "user": "ppetrosyan", "changesInPackagesGIT": ["hystrix-core/src/main/java/com/netflix/hystrix"], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 1, "TOT": 12, "MOV": 6, "INS": 4, "DEL": 2, "spoonFilesChanged": 1}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 0, "alsoFixesPhrase": 0}, "body": "I am having a strange issue. I have a method which is annotated with HystrixCommand\r\n\r\n`\r\n@Override\r\n\t@HystrixCommand(fallbackMethod = \"getDataFallback\",\r\n\t        commandProperties = {\r\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"60000\"),\r\n            @HystrixProperty(name=\"execution.isolation.thread.interruptOnTimeout\", value=\"TRUE\"),\r\n            @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"20\"),\r\n            @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"),\r\n            @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\")\r\n            },\r\n            threadPoolProperties  = {\r\n\t\t\t@HystrixProperty(name = \"coreSize\", value = \"10\")\r\n\t})\r\n\r\npublic List<String> getData(String id, Date date) {\r\n   return null;\r\n}\r\n`\r\n\r\nit works most of the times, but rarely without changing anything I get the following exception\r\n\r\n` java.lang.IllegalStateException: Collapser method must have one argument: public java.util.List getData(String,Date)`\r\n\r\n\r\nI checked the code of Hystrix and found that the meta holder factory checks if the HystrixCommand annotation is present then it initializes CommandMetaHolderFactory, otherwise CollapserMetaHolderFactory. In my case, I have the HystrixCommand but it still tries to use CollapserMetaHolderFactory which complains about method not having 1 argument. \r\n\r\nThis happens rarely and it's possible no one has seen it yet, I was just wondering if there is a recent fix related to this issue. I am using hystrix 1.5.0.\r\n\r\n\r\nThanks in advance.", "labels": ["bug", "javanica", "question"]}, {"created": "2017-01-11 08:27:14", "commits": {"a938284799b988a2e50c1a0c8944aa094cc7e143": {"commitGHEventType": "closed", "commitUser": "mattrjacobs"}, "1460419e1800710d3845d0f92cf66760815496d4": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}}, "numCommits": 1, "closed": "2017-06-14 21:50:09", "filteredCommits": ["a938284799b988a2e50c1a0c8944aa094cc7e143"], "commitsDetails": [{"nameRev": "a938284799b988a2e50c1a0c8944aa094cc7e143 tags/v1.5.13~4^2", "commitMessage": "Escape user entered input to avoid HTML injection. This fixes #1456\n", "commitParents": ["ea14be2464de0ce59e05ee740308eb1fc0187738"], "spoonStatsSkippedReason": "", "commitHash": "a938284799b988a2e50c1a0c8944aa094cc7e143", "authoredDateTime": "2017-06-07 21:24:53", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 1, "deletions": 1, "lines": 2, "filePath": "hystrix-dashboard/src/main/webapp/index.html"}], "commitDateTime": "2017-06-07 21:24:53", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": []}, {"nameRev": "1460419e1800710d3845d0f92cf66760815496d4 tags/v1.5.13~4", "commitMessage": "Merge pull request #1606 from atoulme/issue_1456\n\nEscape user entered input to avoid HTML injection. This fixes #1456", "commitParents": ["027578a26dccba4d3acb653b69ffb4e148abb006", "a938284799b988a2e50c1a0c8944aa094cc7e143"], "spoonStatsSkippedReason": "", "commitHash": "1460419e1800710d3845d0f92cf66760815496d4", "authoredDateTime": "2017-06-14 14:50:01", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 1, "deletions": 1, "lines": 2, "filePath": "hystrix-dashboard/src/main/webapp/index.html"}], "commitDateTime": "2017-06-14 14:50:01", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": []}], "url": "https://github.com/Netflix/Hystrix/issues/1456", "ttf": 154.00027777777777, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "title": "XSS and HTML Injection in title field and stream URL field", "statsSkippedReason": "", "user": "onlineaccount", "changesInPackagesGIT": ["hystrix-dashboard/src/main/webapp/index.html"], "spoonStatsSummary": {}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "![imagen](https://cloud.githubusercontent.com/assets/16137380/21840815/c859115a-d7df-11e6-96b4-4a4c51a141ea.png)\r\n\r\nWhen you click in Add Stream button the injection will be executed:\r\n![imagen](https://cloud.githubusercontent.com/assets/16137380/21840830/e63e773c-d7df-11e6-9dc8-e9bf5516a3c9.png)\r\n\r\nYou have to click in the injected title or url field to view the JavaSript alert.", "labels": ["PR-welcome", "bug", "dashboard"]}, {"created": "2016-12-29 15:50:42", "user": "krishna1c", "body": "Version Using 1.5.9\r\n\r\n```\r\n@HystrixCommand(fallbackMethod = \"fallback\")\r\n\tpublic <T> Observable<T> callAsync(final String url, final Class<T> responseType, final Map<String, ?> params){\r\n\t\treturn Observable.create(new Observable.OnSubscribe<T>() {\r\n\t\t\t@Override\r\n\t\t\tpublic void call(Subscriber<? super T> observer) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!observer.isUnsubscribed()) {\r\n\t\t\t\t\t\tobserver.onNext(restClient.callForAsync(url, responseType, params));\r\n\t\t\t\t\t\tobserver.onCompleted();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tobserver.onError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}).subscribeOn(Schedulers.io());\r\n\t}\r\n```\r\n\r\n`public <T> T fallback(final String url, final Class<T> responseType, final Map<String, ?> params){\r\n\t\treturn null;\r\n\t}`\r\n\r\n", "closed": "2017-02-22 17:32:23", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1452", "ttf": 55.000277777777775, "commits": {}, "labels": ["bug", "javanica"], "title": "Error : Hystrix Fallback return type Generic is giving \"Incompatible return type must return: T or its subclass\""}, {"created": "2016-12-05 21:10:52", "user": "ptab", "body": "I am configuring my application using Archaius and a local configuration file (set by `-Darchaius.configurationSource.additionalUrls`), and the `hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize` property seems to be ignored by Hystrix - making all my threadpools have a fixed size = `coreSize`.\r\n\r\nI have not yet created a test case to support the theory, but by browsing [HystrixThreadPoolProperties.java](https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java) I believe this happens because `allowMaximumSizeToDivergeFromCoreSize` is set as a `boolean` instead of a `HystrixProperty<Boolean>`, so it is only read once once during the threadpool initialization phase and any further changes are ignored.", "closed": "2016-12-20 22:32:17", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1434", "ttf": 15.000277777777777, "commits": {}, "labels": ["bug", "hystrix-core", "question"], "title": "Runtime changes to allowMaximumSizeToDivergeFromCoreSize are ignored"}, {"created": "2016-12-04 10:29:32", "user": "ahmednasir91", "body": "Our service is running on AWS elastic beanstalk behind a load balancer there are 3 instances. The circuit was open probably the remote service went down, but one 2 of the instances the circuit was closed again.\r\n\r\nHowever for the third instance, the circuit remained open, for more than 2 hours until i manually restarted the instance. Following configuration we are using\r\n\r\n```\r\n\"hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds\": 400,\r\n\"hystrix.command.default.circuitBreaker.requestVolumeThreshold\": 60,\r\n\"hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds\": 60000,\r\n\"hystrix.command.default.circuitBreaker.errorThresholdPercentage\": 50,\r\n```\r\n\r\nSo my question is, how calculating if the circuit can be closed again, does it require to meet `requestVolumeThreshold`? Because to me it looks like the requests were below threshold.\r\n\r\nThanks", "closed": "2017-02-22 17:48:00", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1433", "ttf": 80.00027777777778, "commits": {}, "labels": ["bug", "hystrix-core", "question"], "title": "Question around circuit open and close"}, {"created": "2016-11-25 14:50:02", "commits": {"11ca011d9c5b86425eaddeae4bb9a3c5db81ef9b": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}, "62d9c30e61576a9e1b164ebcb5b340454ccd56be": {"commitGHEventType": "closed", "commitUser": "mattrjacobs"}}, "numCommits": 1, "changesInPackagesSPOON": ["com.netflix.hystrix.contrib.sample.stream.HystrixSampleSseServlet.handleRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)"], "closed": "2016-12-21 19:37:47", "filteredCommits": ["62d9c30e61576a9e1b164ebcb5b340454ccd56be"], "commitsDetails": [{"nameRev": "11ca011d9c5b86425eaddeae4bb9a3c5db81ef9b tags/v1.5.9~8", "commitMessage": "Merge pull request #1442 from mattrjacobs/fix-1430\n\nFix #1430 by detecting case when client connect/disconnects before me\u2026", "commitParents": ["9263593cc82e54dbf559c9bde7dcded7c8187b76", "62d9c30e61576a9e1b164ebcb5b340454ccd56be"], "spoonStatsSkippedReason": "", "commitHash": "11ca011d9c5b86425eaddeae4bb9a3c5db81ef9b", "authoredDateTime": "2016-12-14 14:52:51", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 9, "deletions": 0, "lines": 9, "filePath": "hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/sample/stream/HystrixSampleSseServlet.java"}], "commitDateTime": "2016-12-14 14:52:51", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "MOV": 0, "INS": 4, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.sample.stream.HystrixSampleSseServlet.handleRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)"}], "spoonFilePath": "HystrixSampleSseServlet.java"}]}, {"nameRev": "62d9c30e61576a9e1b164ebcb5b340454ccd56be tags/v1.5.9~8^2", "commitMessage": "Fix #1430 by detecting case when client connect/disconnects before metrics start getting emitted\n", "commitParents": ["9263593cc82e54dbf559c9bde7dcded7c8187b76"], "spoonStatsSkippedReason": "", "commitHash": "62d9c30e61576a9e1b164ebcb5b340454ccd56be", "authoredDateTime": "2016-12-14 14:39:09", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 9, "deletions": 0, "lines": 9, "filePath": "hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/sample/stream/HystrixSampleSseServlet.java"}], "commitDateTime": "2016-12-14 14:39:09", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "MOV": 0, "INS": 4, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.sample.stream.HystrixSampleSseServlet.handleRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)"}], "spoonFilePath": "HystrixSampleSseServlet.java"}]}], "url": "https://github.com/Netflix/Hystrix/issues/1430", "ttf": 26.00027777777778, "gitStatsSummary": {"insertions": 9, "deletions": 0, "lines": 9, "gitFilesChange": 1}, "title": "Metrics stream not closing connections", "statsSkippedReason": "", "user": "DangerPete", "changesInPackagesGIT": ["hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/sample"], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 1, "TOT": 4, "MOV": 0, "INS": 4, "DEL": 0, "spoonFilesChanged": 1}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "Hi,\r\n\r\nWay back in the day an issue was raised whereby connections to the metric stream were being held open when no command data was available: https://github.com/Netflix/Hystrix/issues/85\r\nSince the rewrite of the `HystrixMetricsStreamServlet` it would appear that this behaviour has slipped back in. \r\nIf no data is available the `onNext` of the subscriber in `HystrixSampleSseServlet` is never called, and hence the connection is never checked, thus connections are held forever.\r\n\r\nThis can be replicated using the hystrix example webapp by just curling the metrics stream upon app start up.\r\n\r\n```\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n^C\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n^C\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n^C\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n^C\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n^C\r\n[norvalp@mbp ~]$ curl http://localhost:8989/hystrix-examples-webapp/hystrix.stream\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"/>\r\n<title>Error 503 MaxConcurrentConnections reached: 5</title>\r\n</head>\r\n<body><h2>HTTP ERROR 503</h2>\r\n<p>Problem accessing /hystrix-examples-webapp/hystrix.stream. Reason:\r\n<pre>    MaxConcurrentConnections reached: 5</pre></p><hr /><i><small>Powered by Jetty://</small></i><br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n</body>\r\n</html>\r\n[norvalp@mbp ~]$\r\n```\r\n\r\n", "labels": ["bug", "metrics"]}, {"created": "2016-11-09 19:44:49", "user": "ezraroi", "body": "Hi,\r\ni have the following code:\r\n\r\n@HystrixCommand(fallbackMethod = \"failedToAdd\", threadPoolKey = \"addRemoveThreadPool\",\r\n        ignoreExceptions = {HttpRequestMethodNotSupportedException.class, TypeMismatchException.class,\r\n            MethodArgumentNotValidException.class}\r\n    )\r\n\r\n    @Override\r\n    public JobDataDto addJobData(NewJobDataDto job) {\r\n        return dataJobService.addJobData(job);\r\n    }\r\n\r\n    @HystrixCommand(fallbackMethod = \"failedToMarkJobAsFinished\", threadPoolKey = \"addRemoveThreadPool\",\r\n        ignoreExceptions = {HttpRequestMethodNotSupportedException.class, TypeMismatchException.class,\r\n            MethodArgumentNotValidException.class}\r\n    )\r\n    @Override\r\n    public JobDataDto markJobAsFinished(String fullIdIteration, FinishedJobDataDto finishedJobDataDto) {\r\n        return dataJobService.markJobAsFinished(fullIdIteration, finishedJobDataDto);\r\n    }\r\n\r\n    @HystrixCommand(fallbackMethod = \"failedToAddDataPoint\", threadPoolKey = \"addDataPointThreadPool\",\r\n        ignoreExceptions = {HttpRequestMethodNotSupportedException.class, TypeMismatchException.class,\r\n            MethodArgumentNotValidException.class}\r\n    )\r\n    @Override\r\n    public DataPointDto addDataPoint(String fullIdIteration, DataPointDto dataPointDto) {\r\n        return dataJobService.addDataPoint(fullIdIteration, dataPointDto);\r\n    }\r\nThis is the only code i have that uses Hystrix.\r\nWhen i check the hytrix stream, looks like i have 3 thread pools instead of 2:\r\nNBODataService (the name of application)\r\naddDataPointThreadPool\r\naddRemoveThreadPool\r\n\r\nWhy do I have the thread pool with the service name created?\r\n\r\nI am using v 1.5.2\r\nThanks", "closed": "2016-11-28 22:27:48", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1416", "ttf": 19.00027777777778, "commits": {}, "labels": ["bug", "metrics", "question"], "title": "Hystrix is creating additional threadpool when used"}, {"created": "2016-10-19 15:07:26", "user": "danielBreitlauch", "body": "The test below regularly adds values to the HystrixRollingPercentile, asks for the mean and sleeps afterwards. The value is increased until we sleep longer than the HystrixRollingPercentile moving window. At this point there wont be any values in the data structure because they are rotated out while we sleep.\n\nIf you run the code below you would expect to get increasing mean values until sleep is bigger than the rolling buckets window. Then the mean should be 0. After the sleep gets lower than the rolling window there should be a change in the mean again.\n\nWhat happens is that it gets stuck at an arbitrary point and only returns this value. (In the example output it is 140)\n\nPlease increase cpuSpeedDependend if the test is running to fast on your cpu.\n\n```\n    public void testMeasuring() throws InterruptedException {\n        int cpuSpeedDependend = 300;\n\n        HystrixRollingPercentile executionDuration = new HystrixRollingPercentile(cpuSpeedDependend / 3, 10, 100, HystrixProperty.Factory.asProperty(true));\n\n        for (int x=1; x < cpuSpeedDependend; x++) {\n            executionDuration.addValue(x);\n            int mean = executionDuration.getMean();\n            System.out.println(x + \":\" + mean);\n            Thread.sleep(mean);\n        }\n        for (int x=cpuSpeedDependend; x > 1; x--) {\n            executionDuration.addValue(x);\n            int mean = executionDuration.getMean();\n            System.out.println(x + \":\" + mean);\n            Thread.sleep(mean);\n        }\n    }\n```\n\nOutput of the run:\n...\n16:8\n17:8\n18:9\n19:9\n20:10\n...\n98:97\n99:98\n100:99\n101:101\n102:0\n103:0\n104:0\n105:0\n...\n175:0\n176:0\n177:0\n178:0\n179:140\n180:140\n181:140\n182:140\n...\n300:140\n299:140\n...\n5:140\n4:140\n3:140\n2:140\n", "closed": "2016-10-27 09:46:25", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1392", "ttf": 7.000277777777778, "commits": {}, "labels": ["bug", "metrics"], "title": "HystrixRollingPercentile is producing wrong values"}, {"created": "2016-10-19 11:25:59", "user": "sahlex", "body": "In Hystrix 1.5.5, when calling `HystrixPlugins.getInstance()` I get a \n\n```\njava.lang.NoClassDefFoundError: Could not initialize class com.netflix.hystrix.strategy.HystrixPlugins$LazyHolder\n```\n\nexception in an OSGi environment.\n\nIn 1.4.x it worked without problems.\nHow is intended to work?\n\nThe private inner class effectively prevents the OSGi classloader to make it available to client bundles. As soon as I patch it to be publicly available, I can use the plugin mechanism again. As it worked fine in 1.4.x I'd consider this a defect.\n", "closed": "2016-10-25 15:14:56", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1390", "ttf": 6.000277777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixPlugins.getInstance() returns private instance"}, {"created": "2016-09-19 18:53:26", "user": "cadef", "body": "We've been using Hystrix in Google App Engine, and have run into a major issue with the new Flexible Environment in App Engine. Basically, when a new service spins up with a Hystrix client, the first request via Hystrix succeeds and then every request after that fails with `java.lang.IllegalStateException: Cannot create new threads after the request thread stops.`\n\nThe GAE `VmRequestThreadFactory` appears to be designed to be used only for a single request, but Hystrix keeps the TheadFactory around much longer. So the first Hystrix request goes through, and once the request is done GAE sets `allowNewRequestThreadCreation = false` on the `VmRequestThreadFactory` from that request. GAE spins up a new `VmRequestThreadFactory` for the next request, but unfortunately Hystrix is stuck with a reference to the `VmRequestThreadFactory` from the first request, which it will keep forever. Once that first request is done, GAE won't allow it to spawn any new threads, resulting in the behavior we're seeing.\n\nI locally patched `PlatformSpecific.isAppEngine()` to always return false, and the issue went away completely. In the Flexible Environment we are no longer subject to the GAE sandbox, so there's no reason to use the custom GAE ThreadFactory when the one from `java.util.current` will work just fine.\n\nI am working on a way to programmatically distinguish the GAE Standard Environment from the Flexible Environment so that Flex users can get the standard ThreadFactory. Once I get that worked out I am happy to throw up a PR that will fix this issue.\n", "closed": "2016-09-21 16:18:26", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1352", "ttf": 1.0002777777777778, "commits": {}, "labels": ["bug", "enhancement", "hystrix-core"], "title": "Hystrix doesn't work with App Engine Flexible Environment"}, {"created": "2016-08-23 22:47:43", "user": "mattnelson", "body": "When upgrading from `1.5.3` to `1.5.5` semaphore circuits now contain a thread pool entry in the `hystrix-metrics-event-stream`. It looks like this is only a stream regression as I don't see a corresponding increase in the number of threads.\n\n1.5.5 stream\n\n```\ndata: {\n  \"type\": \"HystrixCommand\",\n  \"name\": \"circuit155\",\n  \"group\": \"circuit155\",\n  \"rollingCountSemaphoreRejected\": 0,\n  \"rollingCountThreadPoolRejected\": 0,\n  \"propertyValue_executionIsolationStrategy\": \"SEMAPHORE\",\n  \"propertyValue_executionIsolationThreadTimeoutInMilliseconds\": 60000,\n  \"propertyValue_executionIsolationThreadInterruptOnTimeout\": true,\n  \"propertyValue_executionIsolationThreadPoolKeyOverride\": null,\n  \"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests\": 100,\n  \"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests\": 10,\n  \"threadPool\": \"circuit155\"\n}\n\ndata: {\n  \"type\": \"HystrixThreadPool\",\n  \"name\": \"circuit155\"\n}\n```\n\n1.5.3 stream\n\n```\ndata: {\n  \"type\": \"HystrixCommand\",\n  \"name\": \"circuit153\",\n  \"group\": \"circuit153\",\n  \"rollingCountSemaphoreRejected\": 0,\n  \"rollingCountThreadPoolRejected\": 0,\n  \"propertyValue_executionIsolationStrategy\": \"SEMAPHORE\",\n  \"propertyValue_executionIsolationThreadTimeoutInMilliseconds\": 60000,\n  \"propertyValue_executionIsolationThreadInterruptOnTimeout\": true,\n  \"propertyValue_executionIsolationThreadPoolKeyOverride\": null,\n  \"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests\": 100,\n  \"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests\": 10,\n  \"threadPool\": \"circuit153\"\n}\n```\n", "closed": "2016-09-26 22:24:13", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1330", "ttf": 33.000277777777775, "commits": {}, "labels": ["bug", "metrics"], "title": "Semaphore circuit thread pool metrics regression"}, {"created": "2016-08-22 22:23:10", "user": "VaultB0Y", "body": "I am trying to introduce the Hystrix Javanica in the Spring Resttemplate.\nI tried to add the hystrix command to getForEntity, but it throws an exception:\n\n```\ncom.netflix.hystrix.contrib.javanica.exception.FallbackDefinitionException: Incompatible return types. Command method: public org.springframework.http.ResponseEntity hystrix.HystrixCircuitBreakerRestTemplate.getForEntity(java.lang.String,java.lang.Class,java.lang.Object[]) throws org.springframework.web.client.RestClientException, fallback method: public org.springframework.http.ResponseEntity hystrix.HystrixCircuitBreakerRestTemplate.getForEntityFallback(java.lang.String,java.lang.Class,java.lang.Object[]) throws org.springframework.web.client.RestClientException. Hint: \n    at com.netflix.hystrix.contrib.javanica.utils.FallbackMethod.validateReturnType(FallbackMethod.java:132)\n    at com.netflix.hystrix.contrib.javanica.utils.FallbackMethod.validateReturnType(FallbackMethod.java:111)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect.setFallbackMethod(HystrixCommandAspect.java:292)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect.access$300(HystrixCommandAspect.java:62)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$MetaHolderFactory.metaHolderBuilder(HystrixCommandAspect.java:155)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$CommandMetaHolderFactory.create(HystrixCommandAspect.java:236)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$MetaHolderFactory.create(HystrixCommandAspect.java:145)\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect.methodsAnnotatedWithHystrixCommand(HystrixCommandAspect.java:91)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)\n    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)\n    at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:68)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)\n    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:644)\n...\n```\n\n```\npublic class HystrixCircuitBreakerRestTemplate extends RestTemplate {\n    @Override\n    @HystrixCommand(fallbackMethod = \"getForEntityFallback\", \n    commandProperties = { \n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"10\"),\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"),\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"3\"),\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"10\"),\n        @HystrixProperty(name = \"circuitBreaker.forceOpen\", value = \"true\")\n    }) \n    public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... urlVariables) throws RestClientException {\n        System.out.println(\"HystrixCircuitBreakerRestTemplate: getForEntity\");\n        return super.getForEntity(url, responseType, urlVariables);\n    }\n\n    public <T> ResponseEntity<T> getForEntityFallback(String url, Class<T> responseType, Object... urlVariables) throws RestClientException {\n        System.out.println(\"HystrixCircuitBreakerRestTemplate: Fallback\");\n        return null;\n    }\n}\n```\n\nIf I remove the fallbackMethod in the HystrixCommand, it is working fine. It doesn't work with the fallbackMethod. It's strange that the two return types are the same but throws incompatible return type exception. I suspect there is something wrong with the generics. \n", "closed": "2016-09-16 22:33:20", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1328", "ttf": 25.00027777777778, "commits": {}, "labels": ["bug", "javanica", "question"], "title": "Incompatible Return Types when returning generics in Javanica"}, {"created": "2016-08-18 19:16:00", "user": "caarlos0", "body": "When trying to upgrade from `1.4.23` to `1.5.4`, I started to get this error:\n\n```\njava.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;\n```\n\nThe issue seems somewhat related to https://github.com/Netflix/Hystrix/pull/359 and the issue seems to be described [here](https://gist.github.com/AlainODea/1375759b8720a3f9f094).\n\nFWIW version `1.5.3` works.\n", "closed": "2016-08-19 01:50:22", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1322", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug"], "title": "version 1.5.4 doesn't work on JDK 7"}, {"created": "2016-08-09 13:03:14", "user": "jorgefr", "body": "In the specified line of GenericCommand, any `Throwable` being thrown by the fallback is supposed to be logged:\n\nhttps://github.com/Netflix/Hystrix/blob/f918595cf2fed44c9e1706abe4b55d73d80f31e9/hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericCommand.java#L79\n\nBut in the `exception()` method of `FallbackErrorMessageBuilder` only `HystrixBadRequestException` and `HystrixRuntimeException` are being logged:\n\nhttps://github.com/Netflix/Hystrix/blob/f918595cf2fed44c9e1706abe4b55d73d80f31e9/hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AbstractHystrixCommand.java#L227\n\nGoing back to GenericCommand, after the logging sentence, the cause of the exception is wrapped (not the exception itself): `throw new FallbackInvocationException(e.getCause());` The problem is that the cause might be null quite often.\n\nEven if an implementation of `HystrixCommandExecutionHook#onFallbackError` is provided, there is nothing useful from the original exception, so the real cause of the exception is hidden everywhere.\n\nIs there any other place where the real exception can be managed?\n", "closed": "2016-10-19 21:21:39", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1313", "ttf": 71.00027777777778, "commits": {}, "labels": ["bug", "javanica", "question"], "title": "The real exception is hidden when an unexpected exception is thrown in a fallback, and the cause is null"}, {"created": "2016-08-01 15:53:33", "user": "mattnelson", "body": "The CachedValuesHistogram class preloads[1] 1000 instances of HDRHistogram. Through some profiling it looks like each instance of the HDRHistogram is using 41k of memory. Which equates to 41m of memory for preloading these histograms. The class will create a new histogram on a pool miss[2], so I'm wondering how the 1000 default was decided on #1047. Would you need 1000 unique commands in order to exhaust the pool?\n\n[1] https://github.com/Netflix/Hystrix/blob/v1.5.3/hystrix-core/src/main/java/com/netflix/hystrix/metric/CachedValuesHistogram.java#L27-L31\n[2] https://github.com/Netflix/Hystrix/blob/v1.5.3/hystrix-core/src/main/java/com/netflix/hystrix/metric/CachedValuesHistogram.java#L165-L167\n", "closed": "2016-09-28 20:18:20", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1296", "ttf": 58.000277777777775, "commits": {}, "labels": ["bug", "enhancement", "hystrix-core", "metrics"], "title": "CachedValuesHistogram memory overhead"}, {"created": "2016-07-25 14:25:48", "user": "thesmith", "body": "The following code at https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L146 ignores the return value from awaitTermination called on the ThreadPoolExecutor.\n\n```\npool.getExecutor().awaitTermination(timeout, unit);\n```\n\nThere's no guarantee that the executor has terminated. The message in the RuntimeException that is thrown if there's an InteruptedException indicates that the intention is to make sure the ThreadPool is properly shutdown, so I think this is an exceptional state.\n\nTypically I would put this in a loop even though this somewhat changes the semantics of timeout / unit to be a frequency to check.\n\nBTW this particularly causes problems in tests (where Hystrix.reset is called a lot) and there are Hystrix managed threads that get put to sleep a lot. My use-case is a Hystrix command that wraps the HTTP call to SQS, which lets you wait up to 20sec for a message.\n", "closed": "2016-09-21 18:21:11", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1289", "ttf": 58.000277777777775, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixThreadPool.Factory.shutdown(timeout, unit) does not guarantee threadpool shuts-down"}, {"created": "2016-07-06 04:04:57", "user": "mattrjacobs", "body": "Raised in https://github.com/Netflix/Hystrix/pull/1204#issuecomment-229606028\n", "closed": "2016-08-11 10:27:16", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1268", "ttf": 36.000277777777775, "commits": {}, "labels": ["bug", "enhancement", "hystrix-core"], "title": "Make Future returned by HystrixCommand.queue() respect thread interruption"}, {"created": "2016-07-01 21:34:45", "user": "rakinim", "body": "Hi Team,\n\n```\n    Greetings! Its such a great concept.Thanks for that. I'm new to this and when I tried to build the Hystrix it failed due to the following error:\n```\n\ncom.netflix.hystrix.metric.consumer.HealthCountsStreamTest > testShortCircuited FAILED\n    java.lang.AssertionError at HealthCountsStreamTest.java:248\n\n604 tests completed, 1 failed, 1 skipped\n:hystrix-core:test FAILED\n:hystrix-core:generateCoberturaReport SKIPPED\n:hystrix-core:performCoverageCheck SKIPPED\n\nFAILURE: Build failed with an exception.\n\nWhen I checked the report its like:\njava.lang.AssertionError\n    at org.junit.Assert.fail(Assert.java:92)\n    at org.junit.Assert.assertTrue(Assert.java:43)\n    at org.junit.Assert.assertTrue(Assert.java:54)\n    at com.netflix.hystrix.metric.consumer.HealthCountsStreamTest.testShortCircuited(HealthCountsStreamTest.java:248)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:105)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:56)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:64)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:50)\n    at sun.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:106)\n    at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)\n    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)\n    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n\nWhat necessary steps should I take. And thanks in advance for your help! \n", "closed": "2016-07-11 18:03:10", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1266", "ttf": 9.000277777777777, "commits": {}, "labels": ["bug", "metrics"], "title": "com.netflix.hystrix.metric.consumer.HealthCountsStreamTest > testShortCircuited FAILED     java.lang.AssertionError at HealthCountsStreamTest.java:248  604 tests completed, 1 failed, 1 skipped :hystrix-core:test FAILED"}, {"created": "2016-06-18 12:55:43", "commits": {"db18a5c2e489b07b9e773f2874b4f1559cd5abeb": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}}, "numCommits": 0, "closed": "2016-07-06 22:20:50", "filteredCommits": [], "commitsDetails": [{"nameRev": "db18a5c2e489b07b9e773f2874b4f1559cd5abeb tags/v1.5.4~31", "commitMessage": "Merge pull request #1253 from jmirc/master\n\nFix issue #1251", "commitParents": ["c86931bf3d04b252f1e44344e31fbda9c922de11", "2f4a6e25886ce53505f600938d9b2e7d7c4b9d80"], "spoonStatsSkippedReason": "", "commitHash": "db18a5c2e489b07b9e773f2874b4f1559cd5abeb", "authoredDateTime": "2016-06-21 14:00:44", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 1, "deletions": 4, "lines": 5, "filePath": "hystrix-dashboard/src/main/webapp/components/hystrixCommand/hystrixCommand.js"}], "commitDateTime": "2016-06-21 14:00:44", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": []}], "url": "https://github.com/Netflix/Hystrix/issues/1251", "ttf": 18.00027777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "HystrixDashboard - doesn't seem to display the right TPS", "statsSkippedReason": "", "user": "jmirc", "changesInPackagesGIT": [], "spoonStatsSummary": {}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "I am using the version 1.1.2.RELEASE of turbine stream and I think the dashboard has an issue. Let me know, if I am wrong or not.\n\nHere is an example of the data that I got from the turbine stream\n\n```\ndata: {\"rollingCountFallbackFailure\":0,\"rollingCountFallbackSuccess\":0,\"propertyValue_circuitBreakerRequestVolumeThreshold\":\"200\",\"propertyValue_circuitBreakerForceOpen\":false,\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\":\"10000\",\"latencyTotal_mean\":55,\"type\":\"HystrixCommand\",\"rollingCountResponsesFromCache\":0,\"TypeAndName\":\"TypeAndName=>HystrixCommand_lcs.aurora-read\",\"rollingCountTimeout\":0,\"propertyValue_executionIsolationStrategy\":\"THREAD\",\"instanceId\":\"lcs:08fe0c944c1c:8080\",\"rollingCountFailure\":0,\"rollingCountExceptionsThrown\":0,\"latencyExecute_mean\":55,\"isCircuitBreakerOpen\":false,\"errorCount\":0,\"group\":\"AuroraLcsCacheDao\",\"rollingCountSemaphoreRejected\":0,\"latencyTotal\":{\"0\":35,\"25\":52,\"50\":69,\"75\":69,\"90\":85,\"95\":87,\"99\":143,\"99.5\":143,\"100\":441},\"requestCount\":2597,\"rollingCountCollapsedRequests\":0,\"rollingCountShortCircuited\":0,\"latencyExecute\":{\"0\":35,\"25\":52,\"50\":68,\"75\":69,\"90\":85,\"95\":87,\"99\":144,\"99.5\":144,\"100\":441},\"propertyValue_circuitBreakerSleepWindowInMilliseconds\":\"5000\",\"currentConcurrentExecutionCount\":1,\"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests\":\"10\",\"errorPercentage\":0,\"rollingCountThreadPoolRejected\":0,\"propertyValue_circuitBreakerEnabled\":true,\"propertyValue_executionIsolationThreadInterruptOnTimeout\":true,\"propertyValue_requestCacheEnabled\":true,\"rollingCountFallbackRejection\":0,\"propertyValue_requestLogEnabled\":true,\"rollingCountSuccess\":2612,\"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests\":\"50\",\"InstanceKey\":\"InstanceKey=>lcs:08fe0c944c1c:8080\",\"propertyValue_circuitBreakerErrorThresholdPercentage\":\"50\",\"propertyValue_circuitBreakerForceClosed\":false,\"name\":\"lcs.aurora-read\",\"reportingHosts\":17,\"propertyValue_executionIsolationThreadPoolKeyOverride\":\"null\",\"propertyValue_executionIsolationThreadTimeoutInMilliseconds\":\"10000\"}\n```\n\nHere is the extracted interesting data:\n`propertyValue_metricsRollingStatisticalWindowInMilliseconds: 10000`\n`reportingHosts: 17` -- As it is described this will get summed across instances in a cluster\n`requestCount: 2597`\n\nIf I am looking the code in the `hystrixCommand.js` file I can find the following method\n\n```\nfunction preProcessData(data) {\n...\n   // do math\n   convertAllAvg(data);\n   calcRatePerSecond(data);\n}\n```\n\nThe `convertAllAvg` method updates the `propertyValue_metricsRollingStatisticalWindowInMilliseconds` value in the following way\n\n```\n    // the following will break when it becomes a compound string if the property is dynamically changed\n   convertAvg(data, \"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", false);\n\n....\n\n    function convertAvg(data, key, decimal) {\n    if (decimal) {\n       data[key] = getInstanceAverage(data[key], data[\"reportingHosts\"], decimal);\n    } else {\n       data[key] = getInstanceAverage(data[key], data[\"reportingHosts\"], decimal);\n    }\n   }\n```\n\nAfter this call, the  `propertyValue_metricsRollingStatisticalWindowInMilliseconds` is set to `Math.floor(10000 / 17) = 588`\n\nSo now, the TPS is starting to be wrong.\n\n```\nfunction calcRatePerSecond(data) {\n  var numberSeconds = data[\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\"] / 1000; (1)\n  var totalRequests = data[\"requestCount\"]; (2)\n  if (totalRequests < 0) {\n    totalRequests = 0;\n  }\n  data[\"ratePerSecond\"] =  roundNumber(totalRequests / numberSeconds); (3)\n  data[\"ratePerSecondPerHost\"] =  roundNumber(totalRequests / numberSeconds / data[\"reportingHosts\"]) (4)\n}\n```\n\n(1)  numberSeconds = 588 / 1000 = 0.588\n(2) totalRequests = 2597\n(3) ratePerSecond = 2597 / 0.588 = 4416\n(4) ratePerSecondPerHost = `2597 / 0.588 / 17 = 259`\n\nIt should be \n\n(1)  numberSeconds = 10000 / 1000 = 10\n(2) totalRequests = 2597\n(3) ratePerSecond = 2597 / 10 = 259.7\n(4) ratePerSecondPerHost = `2597 / 10000 / 17 = 15.27`\n\nIn conclusion we should remove the line\n\n```\n convertAvg(data, \"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", false);\n```\n\nLet me know if I am wrong.\n", "labels": ["bug", "dashboard"]}, {"created": "2016-05-10 09:25:00", "user": "petehannam", "body": "This essentially reopens #320.\n\nWe (currently) use Tomcat, so are getting Hystrix memory leak errors when it's shutdown or we redeploy.\n\nThe issue is that in the `shutdown()` method, it doesn't clear out the `requestVariables` field. (I'd be happy to submit a PR, but couldn't see a contributor's guide, so wasn't sure on your process).\n\nFor anyone else who's been looking at this, we also had to call `Schedulers.shutdown();` in our `ServletContextListener`, as RxJava holds its own threadpool.\n", "closed": "2016-09-16 23:17:34", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1202", "ttf": 129.00027777777777, "commits": {}, "labels": ["bug", "enhancement", "hystrix-core"], "title": "ThreadLocal memory leak in HystrixRequestContext "}, {"created": "2016-04-28 10:36:48", "user": "pratikkumar19", "body": "I am using hystrix to make a Network call . The execution isolation strategy is THREAD. \nThe thread timeout is set as 20 ms.\nFor 95 percentile requests the timeout is getting honoured, but for 98 and 99 percentile requests the time taken for getting response from Network Call is around 50-100 ms.\n", "closed": "2016-07-06 22:35:06", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1196", "ttf": 69.00027777777778, "commits": {}, "labels": ["bug", "hystrix-core", "question"], "title": "Hystrix Timeout Not Getting  Honoured"}, {"created": "2016-04-20 19:13:00", "user": "mattrjacobs", "body": "Currently, the Hystrix Servo integration uses the tags \"type=HystrixCommand\" and \"instance=<commandKey.name()>\"\n\nThis poses a problem for Atlas, as \"type\" is used to distinguish between metric types.  Most other Servo integrations use class/id for the above tag concepts.\n\nThis is a breaking change w.r.t. metrics published to Servo, so I'll only put it in 2.0.x\n", "closed": "2016-04-20 19:43:55", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1189", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug", "enhancement", "metrics"], "title": "Modify Servo tag names to be consistent with other projects"}, {"created": "2016-04-13 15:28:35", "user": "ctoestreich", "body": "We are using the Annotated methods on classes where a service extends another service\n\n``` groovy\nclass WishlistService extends CartService { ... }\n```\n\nAnd then inside CartService there is a some methods like\n\n``` groovy\n @HystrixCommand(commandProperties = [\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\")\n    ], threadPoolProperties = [\n            @HystrixProperty(name = \"coreSize\", value = \"20\"),\n            @HystrixProperty(name = \"maxQueueSize\", value = \"150\"),\n            @HystrixProperty(name = \"queueSizeRejectionThreshold\", value = \"150\")\n    ], threadPoolKey = 'CartService', fallbackMethod = 'transferItemsFallback')\n    CartResponseDTO transferItems(CartKey fromKey, CartKey toKey, List itemIds){\n     ...\n}\n\nCartResponseDTO transferItemsFallback(CartKey fromKey, CartKey toKey, List items, Throwable e) { ... }\n```\n\nWhen using the service `wishListService` in a class the following exception is thrown\n\n``` console\ncom.netflix.hystrix.contrib.javanica.exception.FallbackDefinitionException: fallback method wasn't found: transferItemsFallback([class com.bsb.cart.domain.CartKey, class com.bsb.cart.domain.CartKey, interface java.util.List])\n    at com.netflix.hystrix.contrib.javanica.utils.MethodProvider.getFallbackMethod(MethodProvider.java:82) ~[hystrix-javanica-1.5.2.jar:1.5.2]\n    at com.netflix.hystrix.contrib.javanica.utils.MethodProvider.getFallbackMethod(MethodProvider.java:55) ~[hystrix-javanica-1.5.2.jar:1.5.2]\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$MetaHolderFactory.metaHolderBuilder(HystrixCommandAspect.java:120) ~[hystrix-javanica-1.5.2.jar:1.5.2]\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$CommandMetaHolderFactory.create(HystrixCommandAspect.java:208) ~[hystrix-javanica-1.5.2.jar:1.5.2]\n    at com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect$MetaHolderFactory.create(HystrixCommandAspect.java:106) ~[hystrix-javanica-1.5.2.jar:1.5.2]\n```\n\nIt would appear that when calling reflection for the class in com.netflix.hystrix.contrib.javinca.utils.MethodProvider line 92 \n`return Optional.of(type.getDeclaredMethod(name, parameterTypes));` it does not resolve the super classes fallback method.  \n\nWe are using groovy and grails and this may be a factor in the evaluation of the type methods via reflection.  However calling the following DOES resolve the method.\n\n``` java\ntype.getSuperclass().getDeclaredMethod(name, parameterTypes)\n```\n\n![screen shot 2016-04-13 at 10 27 47 am](https://cloud.githubusercontent.com/assets/691357/14499090/7422e470-0162-11e6-98fe-acea8158db4e.png)\n", "closed": "2016-07-09 03:04:37", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1177", "ttf": 86.00027777777778, "commits": {}, "labels": ["bug", "javanica", "question"], "title": "Javanica fallback not found when contained in super class"}, {"created": "2016-03-17 19:46:38", "user": "ckstettler", "body": "I have implemented a fallback that accepts Throwable.\n\nWhat I see is the following:\n\nIf I get into my @HystrixCommand annotated function and throw an exception, then I do in fact see the correct throwable in the fallback function.\n\nIf the exception is raised as part of the @HystrixCommand processing within javanica such as timeout or queue threshold is reached etc, then the throwable in the fallback is not populated.\n\nIs there anyway for me to see these exceptions?  I am using 1.5.1.\n", "closed": "2016-04-04 12:36:12", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1155", "ttf": 17.00027777777778, "commits": {}, "labels": ["bug", "javanica"], "title": "Hystrix exceptions not passed into fallback."}, {"created": "2016-03-14 14:42:08", "user": "johanhaleby", "body": "We have a fixed thread pool (P) of size 1 that does the following:\n1. Reads a message from a queue (blocking)\n2. Create a hystrix command based on the message\n3. Executes this command using `command.execute()`\n4. Repeats\n\nThe hystrix group thread pool is configured with only 1 thread (..`andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(1))`). When two messages are available in the queue, (P) reads the messages synchronously (i.e. one by one) and calls `command.execute()` (as its supposed to). However the second command will trigger the `getFallback` method without any exception being thrown. I can only assume that happens because the thread pool is full (according to the [docs](https://github.com/Netflix/Hystrix/wiki/How-it-Works#5-is-the-thread-poolqueuesemaphore-full)) but I can't understand how this can happen if `command.execute()` truly is synchronous. Here are some logs:\n\n``` java\n2016-03-14 14:56:34,423 [pool-3-thread-1] DEBUG com.company.Queue   - Read message with timestamp 7746146279215218\n2016-03-14 14:56:34,446 [pool-3-thread-1] DEBUG com.company.Publisher  - About to execute hystrix command for {\"A\", queuedAtTime=7746146279215218}\n2016-03-14 14:56:34,482 [hystrix-group-name] DEBUG com.company.Publisher  - Message 7746146279215218 was sent to the consumer (took 26 ms)\n2016-03-14 14:56:34,483 [pool-3-thread-1] DEBUG com.company.Publisher  - Executed hystrix command for {\"A\", queuedAtTime=7746146279215218}\n2016-03-14 14:56:34,489 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.enabled to use NEXT property: hystrix.command.default.circuitBreaker.enabled = true\n2016-03-14 14:56:34,489 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.requestVolumeThreshold to use NEXT property: hystrix.command.default.circuitBreaker.requestVolumeThreshold = 20\n2016-03-14 14:56:34,489 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.sleepWindowInMilliseconds to use NEXT property: hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds = 5000\n2016-03-14 14:56:34,489 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.errorThresholdPercentage to use NEXT property: hystrix.command.default.circuitBreaker.errorThresholdPercentage = 50\n2016-03-14 14:56:34,489 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.forceOpen to use NEXT property: hystrix.command.default.circuitBreaker.forceOpen = false\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.circuitBreaker.forceClosed to use NEXT property: hystrix.command.default.circuitBreaker.forceClosed = false\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.execution.isolation.strategy to use NEXT property: hystrix.command.default.execution.isolation.strategy = THREAD\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.execution.isolation.thread.timeoutInMilliseconds to use it's current value:5000\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.execution.timeout.enabled to use NEXT property: hystrix.command.default.execution.timeout.enabled = true\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.execution.isolation.thread.interruptOnTimeout to use NEXT property: hystrix.command.default.execution.isolation.thread.interruptOnTimeout = true\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.execution.isolation.semaphore.maxConcurrentRequests to use NEXT property: hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests = 10\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.fallback.isolation.semaphore.maxConcurrentRequests to use NEXT property: hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests = 10\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.fallback.enabled to use NEXT property: hystrix.command.default.fallback.enabled = true\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingStats.timeInMilliseconds to use NEXT property: hystrix.command.default.metrics.rollingStats.timeInMilliseconds = 10000\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingStats.numBuckets to use NEXT property: hystrix.command.default.metrics.rollingStats.numBuckets = 10\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingPercentile.enabled to use NEXT property: hystrix.command.default.metrics.rollingPercentile.enabled = true\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingPercentile.timeInMilliseconds to use NEXT property: hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds = 60000\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingPercentile.numBuckets to use NEXT property: hystrix.command.default.metrics.rollingPercentile.numBuckets = 6\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.rollingPercentile.bucketSize to use NEXT property: hystrix.command.default.metrics.rollingPercentile.bucketSize = 100\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.metrics.healthSnapshot.intervalInMilliseconds to use NEXT property: hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds = 500\n2016-03-14 14:56:34,490 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.requestCache.enabled to use NEXT property: hystrix.command.default.requestCache.enabled = true\n2016-03-14 14:56:34,491 [pool-3-thread-1] DEBUG com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty  - Flipping property: hystrix.command.command-name.requestLog.enabled to use NEXT property: hystrix.command.default.requestLog.enabled = true\n2016-03-14 14:56:34,506 [pool-3-thread-1] DEBUG com.company.Publisher  - About to execute hystrix command for { \"B\", queuedAtTime=7746146281492122}\n2016-03-14 14:56:34,521 [pool-3-thread-1] WARN  com.company.Publisher  - Message {\"B\", queuedAtTime=7746146281492122} could not be delivered, will try again later.\n2016-03-14 14:56:34,523 [pool-3-thread-1] DEBUG com.company.Publisher  - Executed hystrix command for {\"B\", queuedAtTime=7746146281492122}\n2016-03-14 14:56:34,529 [pool-3-thread-1] DEBUG com.company.Queue  - Read message with timestamp 7746146281492122\n2016-03-14 14:56:34,530 [pool-3-thread-1] DEBUG com.company.Publisher  - About to execute hystrix command for {\"B\", queuedAtTime=7746146281492122}\n2016-03-14 14:56:34,550 [hystrix-group-name] DEBUG com.company.Publisher  - Message 7746146281492122 was sent to the consumer (took 19 ms)\n2016-03-14 14:56:34,551 [pool-3-thread-1] DEBUG com.company.Publisher  - Executed hystrix command for {\"B\", queuedAtTime=7746146281492122}\n```\n\nOur fallback simply logs \"Message {\"B\", queuedAtTime=7746146281492122} could not be delivered, will try again later\" (so this is why we know that the fallback is executed) and as indicated by the logs we try again (asap) and this time we can execute the command successfully.\n\nWe're using hystrix 1.5.1 (and have also tried 1.4.18).\n", "closed": "2016-04-20 20:55:36", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1146", "ttf": 37.000277777777775, "commits": {}, "labels": ["bug"], "title": "execute method on HystrixCommand doesn't appear to be synchronous under load?"}, {"created": "2016-02-19 16:08:46", "user": "costimuraru", "body": "We seem to have gotten into a situation where we're stuck in a deadlock. The use case:\n**Setup:**\n[] Convert the HystrixCommand into an Observable\n[] Wrap this observable with a retry(x times)\n**When:**\n[] HystrixCommand times out\n**Then:**\n[] Instead of retrying the same command x times, a deadlock occurs.\n\nBelow you can see the code that exhibits this deadlock.\n\n> io.reactivex:rxjava:1.1.1\n> com.netflix.hystrix:hystrix-core:1.4.23\n\n``` java\npublic class Command extends HystrixCommand<String> {\n\n    public Command() {\n        super(Setter.withGroupKey(asKey(\"test\"))\n                .andThreadPoolPropertiesDefaults(\n                        HystrixThreadPoolProperties.Setter()\n                                .withCoreSize(10)\n                )\n                .andCommandPropertiesDefaults(\n                        HystrixCommandProperties.Setter()\n                                .withExecutionTimeoutInMilliseconds(10)\n                ));\n    }\n\n    @Override\n    protected String run() throws Exception {\n        Thread.sleep(200);\n        return \"response\";\n    }\n}\n```\n\n``` java\npublic class CommandWithRetryTest {\n\n    public static void main(String[] Args) {\n        String result = Observable.just(1)\n                .flatMap(i -> new Command()\n                                .toObservable()\n                                .retry(2) // This triggers the deadlock.\n                )\n                .toBlocking()\n                .first(); // ===> deadlock\n    }\n}\n```\n", "closed": "2016-10-27 03:40:47", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1100", "ttf": 250.00027777777777, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "Hystrix timeout + rx retry() = deadlock"}, {"created": "2016-01-15 18:36:25", "user": "chrisgray", "body": "Looks like again the similar issue where the build process only got the artifacts to bintray and not maven central :'(\n", "closed": "2016-01-18 21:50:38", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1053", "ttf": 3.000277777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "Hystrix 1.4.23 is not available on Maven Central"}, {"created": "2016-01-06 10:38:05", "user": "andrewe123", "body": "Could be expected behaviour, if so please explain.\n\n```\nuserService.getUserById(\"a\").retry(2).subscribe(subscriber);\n```\n\nWhen an onError event is returned the retry should automatically resubscribe to the observable (2 more times in this case). This works when Hystrix is disabled, but when Hystrix is enabled the observer only gets the first error and doesn't retry. \n\nThe HystrixCommand looks like this\n\n```\n@HystrixCommand\n    public Observable<User> getUserById(final String id) {\n        return Observable.create(new Observable.OnSubscribe<User>() {\n                @Override\n                public void call(Subscriber<? super User> observer) {\n                    try {\n                        if (!observer.isUnsubscribed()) {\n                            observer.onNext(new User(id, name + id));\n                            observer.onCompleted();\n                        }\n                    } catch (Exception e) {\n                        observer.onError(e);\n                    }\n                }\n            });\n    }\n```\n", "closed": "2016-04-20 21:29:45", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1038", "ttf": 105.00027777777778, "commits": {}, "labels": ["bug", "javanica", "question"], "title": "RxJava Observable retry doesn't work with HystrixCommand (Javanica)"}, {"created": "2015-12-18 23:37:48", "user": "mattrjacobs", "body": "As seen in #996, when there's a version mismatch between `hystrix-core` and a metric publisher, the failure results in no metrics.  This can be improved to allow publishing of all metrics shared between the 2 artifacts by more granular error-handling\n", "closed": "2016-01-25 07:22:41", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1021", "ttf": 37.000277777777775, "commits": {}, "labels": ["bug", "enhancement", "metrics"], "title": "Gracefully handle version mismatches between metrics output and hystrix-core"}, {"created": "2015-12-07 18:29:14", "commits": {"b7ef9b1fecbc287283c33229d354a5c67c7e2bb7": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-04-20 20:58:50", "filteredCommits": [], "commitsDetails": [{"nameRev": "b7ef9b1fecbc287283c33229d354a5c67c7e2bb7 tags/v1.5.0-rc.3~31", "commitMessage": "Merge pull request #1032 from tine2k/ManyHystrixTimerThreads1030\n\nImplementation for feature request #1013", "commitParents": ["90c83c7521ad33fcffadf6b8ce33734267d180c5", "fcfce6591c5886332ebec09aa82517c5a6b81d40"], "spoonStatsSkippedReason": "", "commitHash": "b7ef9b1fecbc287283c33229d354a5c67c7e2bb7", "authoredDateTime": "2016-01-13 13:08:54", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 29, "deletions": 0, "lines": 29, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesTimerThreadPoolDefault.java"}, {"insertions": 14, "deletions": 0, "lines": 14, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesStrategy.java"}, {"insertions": 56, "deletions": 12, "lines": 68, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/util/HystrixTimerTest.java"}, {"insertions": 79, "deletions": 0, "lines": 79, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/HystrixTimerThreadPoolProperties.java"}, {"insertions": 7, "deletions": 1, "lines": 8, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java"}], "commitDateTime": "2016-01-13 13:08:54", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.strategy.properties.HystrixPropertiesTimerThreadPoolDefault"}], "spoonFilePath": "HystrixPropertiesTimerThreadPoolDefault.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy.getTimerThreadPoolProperties()"}], "spoonFilePath": "HystrixPropertiesStrategy.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "MOV": 0, "INS": 3, "DEL": 1, "spoonMethodName": "com.netflix.hystrix.util.HystrixTimer.ScheduledExecutor.initialize()"}], "spoonFilePath": "HystrixTimer.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixTimerThreadPoolProperties"}], "spoonFilePath": "HystrixTimerThreadPoolProperties.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.util.HystrixTimerTest.tearDown()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.util.HystrixTimerTest.testThreadPoolSizeConfiguredWithBuilder()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.util.HystrixTimerTest.setUp()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.util.HystrixTimerTest.testThreadPoolSizeDefault()"}], "spoonFilePath": "HystrixTimerTest.java"}]}], "url": "https://github.com/Netflix/Hystrix/issues/1013", "ttf": 135.00027777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "HystrixCommand getFailedExecutionException().getMessage() causes Hystrix circuit short-circuited ", "statsSkippedReason": "", "user": "edwardahaynes", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "I am running a Spring Boot application that make use of Hystrix commands. I have a HystrixCommand where in the getFallback() method, I am calling getFailedExecutionException().getMessage(). When this gets executed more then X times (say 20 failed requests), the Hystrix command stops executing the fallback method and instead the container throws a 500 Internal Server Error. Other then not calling this method (which is a valid workaround), how do I resolve this? What is causing this exception?  \n\nHere is the exception\n\n```\n[Request processing failed; nested exception is com.netflix.hystrix.exception.HystrixRuntimeException: ShortCicuitDemoCommand short-circuited and fallback failed.] with root cause\n\njava.lang.RuntimeException: Hystrix circuit short-circuited and is OPEN\n    at com.netflix.hystrix.AbstractCommand$1.call(AbstractCommand.java:413) ~[hystrix-core-1.4.20.jar:1.4.20]\n    at com.netflix.hystrix.AbstractCommand$1.call(AbstractCommand.java:363) ~[hystrix-core-1.4.20.jar:1.4.20]\n```\n\n``` java\n//Spring boot application\n@SpringBootApplication\n@EnableCircuitBreaker\npublic class ShortCicuitDemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ShortCicuitDemoApplication.class, args);\n    }\n}\n\n//Controller command\n@RestController\npublic class ShortCicuitDemoController {\n    private RestTemplate restTemplate = new RestTemplate();\n    @RequestMapping(value = \"/shortcicuit\")\n    @ResponseBody\n    public String doSomething() {\n        ShortCicuitDemoCommand command = new ShortCicuitDemoCommand(restTemplate);\n        String results = command.execute();\n        return results;\n    }\n}\n\n//HystrixCommand\npublic class ShortCicuitDemoCommand extends HystrixCommand<String> {\n    private static final Logger log = LoggerFactory.getLogger(ShortCicuitDemoCommand.class);\n    private RestTemplate restTemplate;\n    public ShortCicuitDemoCommand(RestTemplate restTemplate) {\n    super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"ShortCicuitDemoGroup\"))\n            .andCommandKey(HystrixCommandKey.Factory.asKey(\"ShortCicuitDemoCommand\")));\n        this.restTemplate = restTemplate;\n    }\n    @Override\n    protected String run() throws Exception {\n        // make the call that will fail\n        String response = restTemplate.getForObject(\"http://localhost/donothing\", String.class);\n        return response;\n    }\n    @Override\n    protected String getFallback() {\n        log.error(\"Fallback {}\", this.getFailedExecutionException().getMessage());\n        return null;\n    }\n}\n```\n\nAttached is the full compressed project (only 3 files)\n\n[ShortCicuitDemo.zip](https://github.com/Netflix/Hystrix/files/54399/ShortCicuitDemo.zip)\n", "labels": ["bug", "javanica"]}, {"created": "2015-12-07 11:53:58", "user": "mzeijen", "body": "We sometimes get a warning logged of a NullPointer within the LinkedList of the Hystrix#list field when it's pop methods is called during the Hystrix#endCurrentThreadExecutingCommand execution. It can happen a couple of thousands of times an hour and sometimes almost never\n\nI don't know when this happens and we can't reproduce it. Looks like a multi threading issue where there is some concurrent access on that linked list which causes the problem. \n\nWe see this in Hystrix version 1.4.13 but the Hystrix code regarding this part seems the same in the current 1.4.21 version. Maybe this is already fixed but I can't find anything related in the issues.\n\nStacktrace:\n\n```\njava.lang.NullPointerException\n    at java.util.LinkedList.remove(LinkedList.java:791)\n    at java.util.LinkedList.removeFirst(LinkedList.java:134)\n    at java.util.LinkedList.pop(LinkedList.java:601)\n    at com.netflix.hystrix.Hystrix.endCurrentThreadExecutingCommand(Hystrix.java:134)\n    at com.netflix.hystrix.Hystrix.access$000(Hystrix.java:32)\n    at com.netflix.hystrix.Hystrix$2.call(Hystrix.java:121)\n    at com.netflix.hystrix.AbstractCommand.handleThreadEnd(AbstractCommand.java:916)\n    at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:665)\n    at rx.Observable$11.onCompleted(Observable.java:4309)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:46)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:53)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$1.onCompleted(OperatorOnErrorResumeNextViaFunction.java:64)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:53)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:53)\n    at com.netflix.hystrix.AbstractCommand$HystrixObservableTimeoutOperator$3.onCompleted(AbstractCommand.java:1012)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:53)\n    at rx.internal.operators.OperatorDoOnEach$1.onCompleted(OperatorDoOnEach.java:53)\n    at com.netflix.hystrix.AbstractCommand$DeprecatedOnRunHookApplication$1.onCompleted(AbstractCommand.java:1481)\n    at com.netflix.hystrix.AbstractCommand$ExecutionHookApplication$1.onCompleted(AbstractCommand.java:1379)\n    at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:44)\n        at .... (we call the onCompleted here of the observable)\n```\n", "closed": "2016-01-11 06:46:41", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/1012", "ttf": 34.000277777777775, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "NullPointerException when pop on Hystrix#list is called Hystrix#endCurrentThreadExecutingCommand"}, {"created": "2015-11-27 11:20:55", "user": "willpowerforever", "body": "In my project, I can see the command is executed from the log but when I access the hystrix-stream, it always show \"ping \" and no data shown in dashboard. Do I need to explicitly call anything in the application for the metrics? \n\nI configured the Metrics servlet in the web.xml:\n\n``` html\n  <servlet>\n        <description></description>\n        <display-name>HystrixMetricsStreamServlet</display-name>\n        <servlet-name>HystrixMetricsStreamServlet</servlet-name>\n        <servlet-class>com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>HystrixMetricsStreamServlet</servlet-name>\n        <url-pattern>/hystrix.stream</url-pattern>\n    </servlet-mapping>\n```\n", "closed": "2015-12-29 05:38:18", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/996", "ttf": 31.00027777777778, "commits": {}, "labels": ["bug", "metrics", "question"], "title": "hystrix-stream shows ping message only and no data."}, {"created": "2015-11-26 10:11:48", "user": "alexejk", "body": "Hi,\n\nI'm hitting a bit of a confusing issue when trying to use request caching with Hystrix Command.\nThe `@HystrixCommand` without `@CacheResult` annotation works perfectly fine, however as soon as I add the annotation, it fails with a NullPointerException.\n\n```\nCaused by: java.lang.NullPointerException: null\n    at com.netflix.hystrix.HystrixRequestCache.get(HystrixRequestCache.java:104) ~[hystrix-core-1.4.20.jar:1.4.20]\n    at com.netflix.hystrix.AbstractCommand.toObservable(AbstractCommand.java:346) ~[hystrix-core-1.4.20.jar:1.4.20]\n    at com.netflix.hystrix.HystrixCommand.toObservable(HystrixCommand.java:42) ~[hystrix-core-1.4.20.jar:1.4.20]\n    at com.netflix.hystrix.HystrixCommand.queue(HystrixCommand.java:378) ~[hystrix-core-1.4.20.jar:1.4.20]\n    at com.netflix.hystrix.HystrixCommand.execute(HystrixCommand.java:335) ~[hystrix-core-1.4.20.jar:1.4.20]\n```\n\nThe HystrixCommand takes one argument, which is a string, CacheKey is being detected properly but for some reason I'm always getting this NPE.\n", "closed": "2016-02-08 19:39:14", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/995", "ttf": 74.00027777777778, "commits": {}, "labels": ["bug", "javanica"], "title": "@CacheResult on @HystrixCommand causes a NPE"}, {"created": "2015-11-20 04:34:28", "user": "mattrjacobs", "body": "Discovered in https://github.com/Netflix/Hystrix/issues/702#issuecomment-158264925.  \n\nFrom a clean gradle cache, I see:\n\nDownload https://jcenter.bintray.com/org/aspectj/aspectjtools/1.7.4/aspectjtools-1.7.4.pom\nDownload https://jcenter.bintray.com/org/aspectj/aspectjtools/1.7.4/aspectjtools-1.7.4.jar\n[ant:iajc] /Users/mjacobs/Projects/forks/Hystrix/hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/utils/MethodProvider.java [error] The type java.util.Map$Entry cannot be resolved. It is indirectly referenced from required .class files\n[ant:iajc](no source information available)\n[ant:iajc]\n[ant:iajc] 1 error\n:hystrix-javanica:compileAjcJava FAILED\n\nFAILURE: Build failed with an exception.\n- Where:\n  Build file '/Users/mjacobs/Projects/forks/Hystrix/hystrix-contrib/hystrix-javanica/build.gradle' line: 55\n- What went wrong:\n  Execution failed for task ':hystrix-javanica:compileAjcJava'.\n  \n  > compile errors: 1\n", "closed": "2015-12-03 23:59:08", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/988", "ttf": 13.000277777777777, "commits": {}, "labels": ["bug", "javanica"], "title": "hystrix-javanica:compileAjcJava cannot be built with Java 8"}, {"created": "2015-11-19 14:48:39", "user": "ghost", "body": "When I try to call a method that is annotated with `@HystrixCommand` and returns a `ObservableResult` I get the following exception:\n `java.lang.ClassCastException: rx.subjects.ReplaySubject cannot be cast to com.netflix.hystrix.contrib.javanica.command.ObservableResult`. \n\nHystrix/javanic version: `1.4.21`\nrxjava-Version: `1.0.14`\naspectJ-Version: `1.8.7``\nWeavingMode: LoadTime\n\n```\n@HystrixCommand\npublic ObservableResult<Data> get(@NotNull final String id) {\n    return new ObservableResult<Data>() {\n        @Override\n        public CarportData invoke() {\n           return new Data();\n        }\n    };\n}\n```\n", "closed": "2016-04-20 20:57:51", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/987", "ttf": 153.00027777777777, "commits": {}, "labels": ["bug", "javanica"], "title": "ClasscastException on Observable Command Call"}, {"created": "2015-11-17 22:32:23", "user": "jojitj", "body": "I have been playing with hystrix for sometime. \nMy configurations as per our requirements is \nexecution.isolation.thread.timeoutInMilliseconds is 50 millis\ncircuitBreaker.enabled is false, since our boss doesn't want the remote call to be skipped.\nand then I have a fallback method too which should get triggered if ever the timeout is crossed.\n\nhystrix.threadpool.default.coreSize is 50 since my concurrency for the outgoing call is around that.\n\nI am using the javanica annotations. \nAlso my annotated method is a Synchronous method, resulting in the HystrixCommand.execute() call.\n\nMy observation is, at low TPS, when the concurrency is below 10 or something it is good.\nI put in some logs, and I could see that the below code in the AbstractCommand gets triggered \n            final Reference<TimerListener> tl = HystrixTimer.getInstance().addTimerListener(listener);\nThe Timer triggers at 50 millis  and everything is a happy flow, cutting off the remote call after 50 ms and falling back.\n\nBut when the TPS increases, the the Timer is not getting triggered everytime. It does work sometimes but not everytime. \nI am having a hard time understanding what is going wrong. One thing I observed is the ScheduledThreadPoolExecutor in HystrixTimer has a core size of 4, since my box is 4-core, but this need not be  trouble as I understand.\n\nI was considering a future.get() based custom framework if I can't get this to work, since all I need is a timeout-cutoff-fallback framework. Let me know if any thoughts/paramters to be tuned.\n", "closed": "2016-01-19 22:40:34", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/985", "ttf": 63.000277777777775, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "Under high concurrency, timeouts not always firing"}, {"created": "2015-11-16 19:46:48", "user": "mattrjacobs", "body": "Currently, everytime I do a release, I am getting a timeout when publishing to Bintray.  Here's an example: https://netflixoss.ci.cloudbees.com/job/NetflixOSS/job/Hystrix/job/Hystrix-release/35/console\n\nThis leaves the release in a half-done state.  The binaries all make it to Bintray, but not to Maven Central, and the tag isn't getting created in Github.\n\nI'm working on getting this straightened out.\n", "closed": "2016-02-11 23:51:35", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/979", "ttf": 87.00027777777778, "commits": {}, "labels": ["bug"], "title": "Timeouts in Bintray Publish"}, {"created": "2015-11-13 11:24:34", "user": "victormferrara", "body": "Hi,\n\nI've been using the extended fallbacks made in #828 (which are great) and I've seen that when the execution times out the Throwable is null as the execution didn't actually fail. It would be nice to have some kind of TimeoutException there to know the real reason and don't have to dead with nulls. Looking at the code, probably the same thing happens with rejected executions.\n\nThanks!\n", "closed": "2016-04-04 21:37:37", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/974", "ttf": 143.00027777777777, "commits": {}, "labels": ["bug", "javanica"], "title": "Throwable in extended fallback is null for timeouts"}, {"created": "2015-11-12 18:50:31", "user": "mattrjacobs", "body": "If the hook throws an exception, it should propagate the error to the caller as the execution result and _not_ perform the work in the execution observable.\n\nThe current behavior returns the error thrown by the hook and performs the work in the execution observable.\n", "closed": "2015-11-13 18:55:42", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/971", "ttf": 1.0002777777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "Throwing an exception in onRunStart hook still lets run() execute"}, {"created": "2015-11-11 15:35:52", "user": "davidkarlsen", "body": "hystrix-core drags in servlet-api 2.5 as a runtime dependency - maybe this should be set as provided as it is usually provided by container - and many may run v3.1 or 3.0\n", "closed": "2015-11-13 17:24:12", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/969", "ttf": 2.000277777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "set servlet-api dependency provided"}, {"created": "2015-10-21 06:12:12", "user": "amitcse", "body": "Hi, I am facing a weird issue wherein the observable returned by `HystrixCollapser` completes without emitting any item. Since I am using `HystrixCollapser.toObservable()` inside to do composition using RxJava operator, this is leading to items being missed from the data flow. \nOn debugging I have found that the `HystrixCollapser` do call the `HystrixCommand.run()` and `mapResponsetoRequests` function is also called. \nI am unable to debug this more because this behaviour is completely random. \n\nFor reference, my rx observable composition is something like this,\n\n```\nObservable.from(id1, id2, id3, ....)\n.flatMap(id -> collapser1(id))\n.flatMap(collapser1Result -> {\n    collapser2Observable = collapser2(collapser1Result);\n    collapser3Observable = collapser3(collapser1Result);\n    collapser4Observable = collapser4(collapser1Result);\n\n    return Observable.zip(collapser2Observable, collapser3Observable, collapser4Observable, \n        (collapser2Res, collapser3Res, collapser4Res) \n                    -> makeFinalResult(collapser2Res, collapser3Res, collapser4Res));\n})\n.map(finalResult -> doSomeTransformations(finalResult))\n.toList().toBlocking().single();\n```\n\nSince any of collapser2/3/4 completes without emitting, this lead to zip being called and corresponding related result goes missing from the final list.\n", "closed": "2016-04-20 21:24:58", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/955", "ttf": 182.00027777777777, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixCollapser completes without emitting"}, {"created": "2015-10-09 18:26:57", "user": "john-roj", "body": "On our project we have 2 classes Annotated with `@HystrixCommand`\n\n```\npublic class SomeService {\n\n     @HystrixCommand(\n        ignoreExceptions = { NonSevereClientException.class },\n        commandProperties = {\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = 5000)\n        },\n        threadPoolProperties = {\n            @HystrixProperty(name = \"coreSize\", value = 75,\n            @HystrixProperty(name = \"maxQueueSize\", value = 5)\n        })\n        public Response getAll(Long someParam) {}  ...\n```\n\nThe other class uses defaults for thread pool properties:\n\n```\npublic class SomeOtherService {\n\n     @HystrixCommand(\n        ignoreExceptions = { NonSevereClientException.class },\n        commandProperties = {\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = 5000)\n        }\n        public Response getStuff() {}  ...\n```\n\nHowever when we check the Dashboard both thread pools have poolSize set to 75.\n\n<img width=\"467\" alt=\"screen shot 2015-10-09 at 11 23 37 am\" src=\"https://cloud.githubusercontent.com/assets/4062524/10402145/799cee5a-6e78-11e5-850f-f9d0dc678df7.png\">\n\nIs this expected?\n", "closed": "2015-11-04 13:07:25", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/926", "ttf": 25.00027777777778, "commits": {}, "labels": ["bug", "javanica"], "title": "Javanica threadpool properties per class are applied to all thread pools"}, {"created": "2015-09-14 17:50:29", "user": "chrisgray", "body": "Hystrix 1.4.15 release looks to be cut, but it's not available on Maven Central (search.maven.org)\n", "closed": "2015-09-23 04:44:22", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/898", "ttf": 8.000277777777777, "commits": {}, "labels": ["bug"], "title": "Hystrix 1.4.15 not available on Maven Central"}, {"created": "2015-08-19 17:14:29", "user": "mattrjacobs", "body": "Bug reported in https://groups.google.com/forum/#!topic/hystrixoss/etlb_JE90CU.\n\nThe root cause is that, upon receiving the first piece of a batch response which matches a request arg, that Collapser has onNext(data) and onCompleted() invoked.  This happens even if more data is available for that Collapser.\n", "closed": "2015-09-10 04:14:03", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/865", "ttf": 21.00027777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixObservableCollapser does not properly handle streams per request arg"}, {"created": "2015-08-14 14:35:49", "user": "genshapiro", "body": "![forcedclosed](https://cloud.githubusercontent.com/assets/12349330/9276099/f68be1ee-426f-11e5-9856-5cafc780d8ff.jpg)\n\nWhile Forced-Closed the Dashboard continues to state that some of command circuits in the cluster remain open when in fact all circuits are closed.\n", "closed": "2016-02-04 04:14:02", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/860", "ttf": 173.00027777777777, "commits": {}, "labels": ["bug", "dashboard"], "title": "Possibly misleading Dashboard info"}, {"created": "2015-08-06 13:43:00", "user": "mattrjacobs", "body": "As outlined in #789, it's an antipattern to allocate a new HystrixCommand.Setter on each HystrixCommand constructor invocation.\n", "closed": "2015-08-07 23:00:13", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/850", "ttf": 1.0002777777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixCommand constructors allocating too much"}, {"created": "2015-08-03 23:04:16", "commits": {"a9b80bcf7a1d592d04ab26ae8f11863acd832858": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}, "0e92136728ce9f20f2e40fd09ff0c0e128d6411d": {"commitGHEventType": "referenced", "commitUser": "mattrjacobs"}, "09949d6ead2b7a95b8c528da50d52a9392b8611c": {"commitGHEventType": "closed", "commitUser": "mattrjacobs"}}, "numCommits": 1, "changesInPackagesSPOON": ["com.netflix.hystrix.AbstractCommand.getRunObservableDecoratedForMetricsAndErrorHandling().9.call(java.lang.Throwable)"], "closed": "2015-08-25 19:22:49", "filteredCommits": ["09949d6ead2b7a95b8c528da50d52a9392b8611c"], "commitsDetails": [{"nameRev": "0e92136728ce9f20f2e40fd09ff0c0e128d6411d tags/v1.4.15~7", "commitMessage": "Merge pull request #876 from mattrjacobs/fix-racy-request-log\n\nFixed #847 by adding BAD_REQUEST to the HystrixRequestLog", "commitParents": ["a98f3de0543c40aaaabb83c396c8b44e4b529f46", "81cdd4512d0e08d8b52e9d8b7f1b49d1707d08c0"], "spoonStatsSkippedReason": "", "commitHash": "0e92136728ce9f20f2e40fd09ff0c0e128d6411d", "authoredDateTime": "2015-08-25 12:18:22", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 14, "deletions": 0, "lines": 14, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/CommonHystrixCommandTests.java"}, {"insertions": 92, "deletions": 55, "lines": 147, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, {"insertions": 1, "deletions": 0, "lines": 1, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java"}], "commitDateTime": "2015-08-25 12:18:22", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.CommonHystrixCommandTests.assertSaneHystrixRequestLog(int)"}], "spoonFilePath": "CommonHystrixCommandTests.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionHystrixFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaQueueSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaObserve()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCountersOnExecutionTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutThrowsException()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache2()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaQueueSemaphore1()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorWithNoFallbackThrowsError()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackImplementedButDisabled()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueUnknownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadUsingQueueSize()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheOnTimeoutThrowsException()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccess()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testSemaphoreExecutionWithTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaObserve()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionMultipleTimes()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThreadOnResponseFromCache()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailures()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnThreadRejectionThrowsException()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExceptionConvertedToBadRequestExceptionInExecutionHookBypassesCircuitBreaker()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheWithSlowExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsAndDifferentDependency()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObserveSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservableTimeoutNoFallbackThreadContext()"}, {"UPD": 0, "TOT": 7, "MOV": 1, "INS": 6, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInSemaphore()"}, {"UPD": 2, "TOT": 7, "MOV": 0, "INS": 5, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsButSameCircuitBreaker()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInSemaphore()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccessWithCircuitBreakerDisabled()"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testTimedOutCommandDoesNotExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueKnownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testShortCircuitFallbackCounter()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailuresViaQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorMaskedByFallbackButLogged()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testFallbackSemaphore()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutCausesNullPointerException()"}], "spoonFilePath": "HystrixCommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.AbstractCommand.getRunObservableDecoratedForMetricsAndErrorHandling().9.call(java.lang.Throwable)"}], "spoonFilePath": "AbstractCommand.java"}]}, {"nameRev": "a9b80bcf7a1d592d04ab26ae8f11863acd832858 tags/v1.4.19~45", "commitMessage": "Merge pull request #877 from mattrjacobs/master-fix-bad-request-in-request-log\n\nFixed #847 by adding BAD_REQUEST to the HystrixRequestLog", "commitParents": ["5601488a877cf64d0110e85f62008f4f95619d3a", "09949d6ead2b7a95b8c528da50d52a9392b8611c"], "spoonStatsSkippedReason": "", "commitHash": "a9b80bcf7a1d592d04ab26ae8f11863acd832858", "authoredDateTime": "2015-08-25 12:22:47", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 14, "deletions": 0, "lines": 14, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/CommonHystrixCommandTests.java"}, {"insertions": 92, "deletions": 55, "lines": 147, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, {"insertions": 1, "deletions": 0, "lines": 1, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java"}], "commitDateTime": "2015-08-25 12:22:47", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.CommonHystrixCommandTests.assertSaneHystrixRequestLog(int)"}], "spoonFilePath": "CommonHystrixCommandTests.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionHystrixFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaQueueSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaObserve()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCountersOnExecutionTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutThrowsException()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache2()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaQueueSemaphore1()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorWithNoFallbackThrowsError()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackImplementedButDisabled()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueUnknownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadUsingQueueSize()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheOnTimeoutThrowsException()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccess()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testSemaphoreExecutionWithTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaObserve()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionMultipleTimes()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThreadOnResponseFromCache()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailures()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnThreadRejectionThrowsException()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExceptionConvertedToBadRequestExceptionInExecutionHookBypassesCircuitBreaker()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheWithSlowExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsAndDifferentDependency()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObserveSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservableTimeoutNoFallbackThreadContext()"}, {"UPD": 0, "TOT": 7, "MOV": 1, "INS": 6, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInSemaphore()"}, {"UPD": 2, "TOT": 7, "MOV": 0, "INS": 5, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsButSameCircuitBreaker()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInSemaphore()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccessWithCircuitBreakerDisabled()"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testTimedOutCommandDoesNotExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueKnownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testShortCircuitFallbackCounter()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailuresViaQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorMaskedByFallbackButLogged()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testFallbackSemaphore()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutCausesNullPointerException()"}], "spoonFilePath": "HystrixCommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.AbstractCommand.getRunObservableDecoratedForMetricsAndErrorHandling().9.call(java.lang.Throwable)"}], "spoonFilePath": "AbstractCommand.java"}]}, {"nameRev": "09949d6ead2b7a95b8c528da50d52a9392b8611c tags/v1.4.19~45^2", "commitMessage": "Fixed #847 by adding BAD_REQUEST to the HystrixRequestLog\n", "commitParents": ["5601488a877cf64d0110e85f62008f4f95619d3a"], "spoonStatsSkippedReason": "", "commitHash": "09949d6ead2b7a95b8c528da50d52a9392b8611c", "authoredDateTime": "2015-08-25 12:09:16", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 14, "deletions": 0, "lines": 14, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/CommonHystrixCommandTests.java"}, {"insertions": 92, "deletions": 55, "lines": 147, "filePath": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, {"insertions": 1, "deletions": 0, "lines": 1, "filePath": "hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java"}], "commitDateTime": "2015-08-25 12:15:29", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.CommonHystrixCommandTests.assertSaneHystrixRequestLog(int)"}], "spoonFilePath": "CommonHystrixCommandTests.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionHystrixFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaQueueSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaObserve()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCountersOnExecutionTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutThrowsException()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache2()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaQueueSemaphore1()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorWithNoFallbackThrowsError()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallbackImplementedButDisabled()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueUnknownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 28, "MOV": 27, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheViaExecuteSemaphore1()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadUsingQueueSize()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCacheOnTimeoutThrowsException()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccess()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCheckedExceptionViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testSemaphoreExecutionWithTimeout()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaObserve()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionMultipleTimes()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueuedExecutionTimeoutWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInThreadOnResponseFromCache()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailures()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSemaphoreWithExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnThreadRejectionThrowsException()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionFailureWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExceptionConvertedToBadRequestExceptionInExecutionHookBypassesCircuitBreaker()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueFailureWithFallbackFailure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheWithSlowExecution()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsAndDifferentDependency()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObserveSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservableTimeoutNoFallbackThreadContext()"}, {"UPD": 0, "TOT": 7, "MOV": 1, "INS": 6, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallbackFailure()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testUnrecoverableErrorThrownWithFallback()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaQueueInSemaphore()"}, {"UPD": 2, "TOT": 7, "MOV": 0, "INS": 5, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerAcrossMultipleCommandsButSameCircuitBreaker()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInSemaphore()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionSuccessWithCircuitBreakerDisabled()"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedThreadWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testTimedOutCommandDoesNotExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueKnownFailureWithNoFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testShortCircuitFallbackCounter()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testObservedExecutionTimeoutWithFallback()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testNoRequestCache3()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRejectedExecutionSemaphoreWithFallbackViaExecute()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testQueueSuccess()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testCircuitBreakerTripsAfterFailuresViaQueue()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRecoverableErrorMaskedByFallbackButLogged()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testFallbackSemaphore()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testBadRequestExceptionViaExecuteInThread()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.HystrixCommandTest.testRequestCacheOnTimeoutCausesNullPointerException()"}], "spoonFilePath": "HystrixCommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.AbstractCommand.getRunObservableDecoratedForMetricsAndErrorHandling().9.call(java.lang.Throwable)"}], "spoonFilePath": "AbstractCommand.java"}]}], "url": "https://github.com/Netflix/Hystrix/issues/847", "ttf": 21.00027777777778, "gitStatsSummary": {"insertions": 1, "deletions": 0, "lines": 1, "gitFilesChange": 1}, "title": "HystrixRequestLog shows [Executed] after all commands have delivered values", "statsSkippedReason": "", "user": "mattrjacobs", "changesInPackagesGIT": ["hystrix-core/src/main/java/com/netflix/hystrix"], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 1, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonFilesChanged": 1}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 2, "alsoFixesPhrase": 0}, "body": "crossposted from https://groups.google.com/forum/#!topic/hystrixoss/tiJlm32RHTQ\n", "labels": ["bug", "hystrix-core"]}, {"created": "2015-07-27 21:58:16", "user": "mattrjacobs", "body": "Ran into an issue where HystrixCollapser with GLOBAL scope was used and HystrixRequestContext was incorrect.\n\nAt a minimum, I need to add documentation of this option.\n\nAfter reviewing the code, I will likely need to make changes to how GLOBAL collapsing works w.r.t. request state. My guess is that the first thread to submit work to a GLOBAL collapser attaches its request  context for the duration of the JVM.  Will confirm and then suggest a fix.\n", "closed": "2015-08-07 23:04:38", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/842", "ttf": 11.000277777777777, "commits": {}, "labels": ["bug", "hystrix-core", "question"], "title": "Add documentation to GLOBAL scope in HystrixCollapser"}, {"created": "2015-07-10 15:27:49", "user": "stuarthalloway", "body": "The proposed fix to Clojure bug http://dev.clojure.org/jira/browse/CLJ-1232 appears to break hystrix-clj, which (if the ticket comments are correct) uses arglists metadata in a way different from the Clojure compiler.\n\nAt first glance this seems to be a bug in hystrix-clj that will become breaking once http://dev.clojure.org/jira/browse/CLJ-1232 is applied.  Looking for input/context before we do that.\n", "closed": "2015-08-06 17:48:35", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/831", "ttf": 27.00027777777778, "commits": {}, "labels": ["bug", "clojure", "question"], "title": "incorrect use of Clojure :arglists metadata?"}, {"created": "2015-06-10 23:56:57", "user": "mattrjacobs", "body": "I've seen the HystrixObservableCollapserTest.stressTestRequestCollapser fail sporadically on Cloudbees.  When I up the trial count from 100 to 10000 on my local machine, I can also reproduce is there after a few minutes.\n\nThe stack trace looks like:\n\n```\nadd listener: com.netflix.hystrix.collapser.RequestCollapser$CollapsedTask@47bcf3ec\nExecutionCount 0 => Time: 10 Delay: 10\nExecuting task ...\nexecutionCount: 1\ntasks: [com.netflix.hystrix.HystrixCollapserTest$TestCollapserTimer$ATask@5ccc0017]\n**** clear TimerListener: tasks.size => 1\n\njava.util.concurrent.ExecutionException: Observable onError\n    at rx.internal.operators.BlockingOperatorToFuture$2.getValue(BlockingOperatorToFuture.java:122)\n    at rx.internal.operators.BlockingOperatorToFuture$2.get(BlockingOperatorToFuture.java:108)\n    at com.netflix.hystrix.HystrixObservableCollapserTest.testTwoRequests(HystrixObservableCollapserTest.java:69)\n    at com.netflix.hystrix.HystrixObservableCollapserTest.stressTestRequestCollapser(HystrixObservableCollapserTest.java:85)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:157)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.RuntimeException: missing value!\n    at com.netflix.hystrix.HystrixObservableCollapserTest$TestRequestCollapser.onMissingResponse(HystrixObservableCollapserTest.java:189)\n    at com.netflix.hystrix.HystrixObservableCollapser$1$1.call(HystrixObservableCollapser.java:195)\n    at rx.Observable$11.onError(Observable.java:4314)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:65)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.innerError(OperatorMerge.java:457)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:432)\n    at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:49)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9415)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9405)\n    at rx.Observable.unsafeSubscribe(Observable.java:7531)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$1.onError(OperatorOnErrorResumeNextViaFunction.java:78)\n    at com.netflix.hystrix.AbstractCommand$CommandHookApplication$1.onError(AbstractCommand.java:1336)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at com.netflix.hystrix.AbstractCommand$DeprecatedOnCompleteWithValueHookApplication$1.onError(AbstractCommand.java:1436)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9415)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9405)\n    at rx.Observable.unsafeSubscribe(Observable.java:7531)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$1.onError(OperatorOnErrorResumeNextViaFunction.java:78)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at com.netflix.hystrix.AbstractCommand$DeprecatedOnFallbackHookApplication$1.onError(AbstractCommand.java:1516)\n    at com.netflix.hystrix.AbstractCommand$FallbackHookApplication$1.onError(AbstractCommand.java:1406)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9415)\n    at rx.Observable$ThrowObservable$1.call(Observable.java:9405)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable$1.call(Observable.java:144)\n    at rx.Observable$1.call(Observable.java:136)\n    at rx.Observable.unsafeSubscribe(Observable.java:7531)\n    at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$1.onError(OperatorOnErrorResumeNextViaFunction.java:78)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:70)\n    at com.netflix.hystrix.AbstractCommand$HystrixObservableTimeoutOperator$1.run(AbstractCommand.java:953)\n    at com.netflix.hystrix.strategy.concurrency.HystrixContextRunnable$1.call(HystrixContextRunnable.java:41)\n    at com.netflix.hystrix.strategy.concurrency.HystrixContextRunnable$1.call(HystrixContextRunnable.java:37)\n    at com.netflix.hystrix.strategy.concurrency.HystrixContextRunnable.run(HystrixContextRunnable.java:57)\n    at com.netflix.hystrix.AbstractCommand$HystrixObservableTimeoutOperator$2.tick(AbstractCommand.java:973)\n    at com.netflix.hystrix.util.HystrixTimer$1.run(HystrixTimer.java:98)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:439)\n    at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)\n    at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:204)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n    at java.lang.Thread.run(Thread.java:695)\n```\n", "closed": "2015-10-14 18:48:20", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/815", "ttf": 125.00027777777778, "commits": {}, "labels": ["bug", "hystrix-core"], "title": "HystrixObservableCollapser missing value"}, {"created": "2015-05-14 20:14:46", "user": "genshapiro", "body": "![thread pools](https://cloud.githubusercontent.com/assets/12349330/7640836/a5c73eb6-fa53-11e4-8fe1-94ded5b16224.png)\n\nVersion 1.3.18\n\nThis also seems wrong...we configure pool sizes consistently with low numbers. The dashboard seems to display arbitrary, very high pool size numbers. Does this look like an issue? Would that be an indication of pools actually sizing incorrecly or simply a case of misreporting?\n\nThanks\n", "closed": "2015-10-15 16:48:10", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/793", "ttf": 153.00027777777777, "commits": {}, "labels": ["bug", "dashboard"], "title": "Thread Pool sizes do not seem right"}, {"created": "2015-05-14 18:11:26", "user": "genshapiro", "body": "![dashboard snapshot](https://cloud.githubusercontent.com/assets/12349330/7638455/f3a7745e-fa42-11e4-8dad-ce145044a605.jpg)\n\nDashboard displays error rates well above 100%...can this be explained or is this a bug?\nThanks\n", "closed": "2015-11-13 18:20:05", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/792", "ttf": 183.00027777777777, "commits": {}, "labels": ["bug", "dashboard"], "title": "Dashboard displays error percentages above 100% when command shares name with thread pool"}, {"created": "2015-05-02 15:56:09", "commits": {"1731a02161189dbcf47a994b7025c0f991f97446": {"commitGHEventType": "closed", "commitUser": "mattrjacobs"}}, "numCommits": 1, "changesInPackagesSPOON": ["com.netflix.hystrix.contrib.javanica.utils.ajc.AjcUtils.getAjcMethod(java.lang.Class,java.lang.String,com.netflix.hystrix.contrib.javanica.utils.ajc.AjcUtils$AdviceType,java.lang.Class[])", "com.netflix.hystrix.contrib.javanica.utils.MethodProvider", "com.netflix.hystrix.contrib.javanica.utils.AopUtils.getDeclaredMethod(java.lang.Class,java.lang.String,java.lang.Class[])", "com.netflix.hystrix.contrib.javanica.annotation"], "closed": "2015-10-27 17:45:07", "filteredCommits": ["1731a02161189dbcf47a994b7025c0f991f97446"], "commitsDetails": [{"nameRev": "1731a02161189dbcf47a994b7025c0f991f97446 tags/v1.4.19~5^2", "commitMessage": "fix #784\n", "commitParents": ["9300e6537e0f5cb452e55873d0284e6117768bdc"], "spoonStatsSkippedReason": "", "commitHash": "1731a02161189dbcf47a994b7025c0f991f97446", "authoredDateTime": "2015-10-25 01:25:49", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 1, "deletions": 0, "lines": 1, "filePath": "hystrix-contrib/hystrix-javanica/build.gradle"}, {"insertions": 6, "deletions": 0, "lines": 6, "filePath": "hystrix-contrib/hystrix-javanica/src/ajcTest/java/com/netflix/hystrix/contrib/javanica/test/aspectj/command/CommandTest.java"}, {"insertions": 46, "deletions": 1, "lines": 47, "filePath": "hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/command/BasicCommandTest.java"}, {"insertions": 2, "deletions": 0, "lines": 2, "filePath": "hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/annotation/HystrixCommand.java"}, {"insertions": 4, "deletions": 2, "lines": 6, "filePath": "hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/configuration/collapser/BasicCollapserPropertiesTest.java"}, {"insertions": 121, "deletions": 0, "lines": 121, "filePath": "hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/utils/MethodProvider.java"}, {"insertions": 13, "deletions": 0, "lines": 13, "filePath": "hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/command/jdk/CommandJdkProxyTest.java"}, {"insertions": 12, "deletions": 0, "lines": 12, "filePath": "hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/command/cglib/CommandCGlibProxyTest.java"}, {"insertions": 19, "deletions": 14, "lines": 33, "filePath": "hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/command/CommandTest.java"}, {"insertions": 9, "deletions": 0, "lines": 9, "filePath": "hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/utils/AopUtils.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/utils/ajc/AjcUtils.java"}], "commitDateTime": "2015-10-25 01:25:49", "commitUser": "mattrjacobs", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "MOV": 0, "INS": 2, "DEL": 2, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.spring.command.CommandTest"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.spring.command.CommandTest.createGenericUserService()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.spring.command.CommandTest.CommandTestConfig.genericUserService()"}], "spoonFilePath": "CommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.spring.command.cglib.CommandCGlibProxyTest"}], "spoonFilePath": "CommandCGlibProxyTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.should_work_with_genericClass_fallback()"}, {"UPD": 0, "TOT": 2, "MOV": 0, "INS": 2, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.getCommand()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.createGenericUserService()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.assertGetUserSnycCommandExecuted(com.netflix.hystrix.contrib.javanica.test.common.domain.User)"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.GenericUserService"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.setUp()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.command.BasicCommandTest.testGetUserAsync()"}], "spoonFilePath": "BasicCommandTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "MOV": 0, "INS": 3, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.utils.AopUtils.getDeclaredMethod(java.lang.Class,java.lang.String,java.lang.Class[])"}], "spoonFilePath": "AopUtils.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.spring.command.jdk.CommandJdkProxyTest"}], "spoonFilePath": "CommandJdkProxyTest.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 6, "MOV": 0, "INS": 2, "DEL": 2, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.test.common.configuration.collapser.BasicCollapserPropertiesTest.UserService.getUser(java.lang.String)"}], "spoonFilePath": "BasicCollapserPropertiesTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.annotation"}], "spoonFilePath": "HystrixCommand.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.utils.MethodProvider"}], "spoonFilePath": "MethodProvider.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "MOV": 0, "INS": 1, "DEL": 1, "spoonMethodName": "com.netflix.hystrix.contrib.javanica.utils.ajc.AjcUtils.getAjcMethod(java.lang.Class,java.lang.String,com.netflix.hystrix.contrib.javanica.utils.ajc.AjcUtils$AdviceType,java.lang.Class[])"}], "spoonFilePath": "AjcUtils.java"}]}], "url": "https://github.com/Netflix/Hystrix/issues/784", "ttf": 178.00027777777777, "gitStatsSummary": {"insertions": 134, "deletions": 1, "lines": 135, "gitFilesChange": 5}, "title": "Javanica: HystrixCommandAspect not able to get generic class type", "statsSkippedReason": "", "user": "vibhaanshu", "changesInPackagesGIT": ["hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica", "hystrix-contrib/hystrix-javanica"], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 4, "TOT": 7, "MOV": 0, "INS": 6, "DEL": 1, "spoonFilesChanged": 4}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 0, "alsoFixesPhrase": 0}, "body": "I'm using hystrix command on a class which is implementing generic interface. HystrixCommandAspect is not able to retrieve the parameter types of the child class.\n\n```\npublic interface IHelloComponent <K, T>{  \n        public String getValue(final K key, final T value);\n        public String defaultValue(final K key, final T value);\n    }\n\n@Service\npublic class HelloComponent implements IHelloComponent<String, String>{\n    @Override\n    @HystrixCommand(fallbackMethod = \"defaultValue\")\n    public String getValue(final String key, final String value){\n        if(true)\n        throw new RuntimeException();\n        return \"Hello\";\n    }\n    public String defaultValue(final String key, final String value){\n        return \"default\";\n    }\n```\n\nInside `HystrixCommandAspect` Method value is coming as `public java.lang.String HelloComponent.getValue(java.lang.Object,java.lang.Object)`. Because of this it throws error `hystrixCommand cannot be null`.\n", "labels": ["bug", "javanica"]}, {"created": "2015-05-01 00:31:38", "user": "chornyi", "body": "When using Javanica, command properties are not passed to the constructor of `AbstractCommand` and therefore all default values are used there. In particular the `requestLog.enabled` is always evaluated to `true` here: https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L263\n\nThis breaks the feature that was implemented in https://github.com/Netflix/Hystrix/pull/724\n\nFirst the `super()` constructor is called and only then `commandProperties` are set: https://github.com/Netflix/Hystrix/blob/master/hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AbstractHystrixCommand.java#L55-L57\n", "closed": "2015-11-04 13:08:00", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/782", "ttf": 187.00027777777777, "commits": {}, "labels": ["bug", "javanica"], "title": "Javanica: requestLog.enabled property is not respected in AbstractCommand"}, {"created": "2015-04-17 23:32:26", "user": "mattrjacobs", "body": "See https://github.com/Netflix/Hystrix/issues/308#issuecomment-93619482\n", "closed": "2016-05-31 20:09:02", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/762", "ttf": 409.0002777777778, "commits": {}, "labels": ["bug"], "title": "Javadoc generation fails for Java 8"}, {"created": "2015-03-04 17:09:31", "user": "jpcaruana", "body": "Hi, \n\nI've upgraded hystrix to version 1.3.20, turbine-web to 1.0.0 and my dashboard is very wrong now (it used to work like a charm when I was using hystrix 1.3.19 and turbine-web-0.5.0-SNAPSHOT): \n- many circuits are missing, despite the fact the stream send the right information. Only 2 are on the board and I expect to have 6 of them\n- thread pool size is totally wrong: numbers are always growing, not showing reality:\n\n![dashboard](https://cloud.githubusercontent.com/assets/31649/6488455/ff019538-c297-11e4-819c-67ce813634d9.png)\n\nfor instance, in reality, the pool PublishToBusCommand is around 400/s on 3 servers.\n\nFor circuits, data is arriving from the stream (like this) but not showed  on the dashboard. Here is what I get when I curl one of my servers:\n\ndata: {\"type\":\"HystrixCommand\",\"name\":\"GetResponseCommand\",\"group\":\"GetResponseCommand\",\"currentTime\":1425487780484,\"isCircuitBreakerOpen\":false,\"errorPercentage\":0,\"errorCount\":0,\"requestCount\":134,\"rollingCountCollapsedRequests\":0,\"rollingCountExceptionsThrown\":5,\"rollingCountFailure\":0,\"rollingCountFallbackFailure\":0,\"rollingCountFallbackRejection\":0,\"rollingCountFallbackSuccess\":0,\"rollingCountResponsesFromCache\":0,\"rollingCountSemaphoreRejected\":0,\"rollingCountShortCircuited\":0,\"rollingCountSuccess\":141,\"rollingCountThreadPoolRejected\":0,\"rollingCountTimeout\":0,\"currentConcurrentExecutionCount\":0,\"latencyExecute_mean\":23,\"latencyExecute\":{\"0\":0,\"25\":14,\"50\":17,\"75\":24,\"90\":40,\"95\":63,\"99\":172,\"99.5\":206,\"100\":246},\"latencyTotal_mean\":26,\"latencyTotal\" {\"0\":0,\"25\":14,\"50\":17,\"75\":24,\"90\":43,\"95\":68,\"99\":300,\"99.5\":301,\"100\":527},\"propertyValue_circuitBreakerRequestVolumeThreshold\":20,\"propertyValue_circuitBreakerSleepWindowInMilliseconds\":5000,\"propertyValue_circuitBreakerErrorThresholdPercentage\":50,\"propertyValue_circuitBreakerForceOpen\":false,\"propertyValue_circuitBreakerForceClosed\":false,\"propertyValue_circuitBreakerEnabled\":true,\"propertyValue_executionIsolationStrategy\":\"THREAD\",\"propertyValue_executionIsolationThreadTimeoutInMilliseconds\":300,\"propertyValue_executionIsolationThreadInterruptOnTimeout\":true,\"propertyValue_executionIsolationThreadPoolKeyOverride\":null,\"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests\":10,\"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests\":10,\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\":10000,\"propertyValue_requestCacheEnabled\":true,\"propertyValue_requestLogEnabled\":true,\"reportingHosts\":1}\n\nWe see I receive data for the GetResponseCommand circuit, belonging to the GetResponseCommand group. We don't see the circuit on the dashboard, but we see the thread pool (with very wrong data)\n\n**What's wrong with my update ?**\n\nps: I took a screenshot of my dashboard a few weeks ago, it looked like this (traffic data is higher now):\n![hystrix](https://cloud.githubusercontent.com/assets/31649/6488694/73b4280e-c299-11e4-9a97-2c9d50444640.png)\n", "closed": "2015-10-15 16:45:19", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/703", "ttf": 224.00027777777777, "commits": {}, "labels": ["bug", "dashboard"], "title": "Dashboard not showing all circuits and wrong thread pool sizes"}, {"created": "2014-12-15 20:32:07", "user": "mattrjacobs", "body": "A conflict between JDK versions caused hystrix-contrib javanica unit tests to fail.  Details in #359.  When this issue gets resolved, uncomment javanica module in `settings.gradle`\n", "closed": "2015-01-07 06:23:58", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/363", "ttf": 22.00027777777778, "commits": {}, "labels": ["bug"], "title": "bootclasspath issue identified in #359"}, {"created": "2014-12-10 10:01:40", "user": "adamdyga", "body": "When using Hystrix 1.4.0-RC5, the commands are not interrupted when the command times out.\nThe following naive test shows how to reproduce this:\n\n``` java\npublic class InterruptTest\n{\n    private static final Logger LOG = LoggerFactory.getLogger(InterruptTest.class);\n\n    private class SleepingCommand extends HystrixCommand<Void> {\n\n        public SleepingCommand() {\n            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"mygroup\"))\n                    .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                            .withExecutionIsolationThreadInterruptOnTimeout(true)\n                            .withExecutionIsolationThreadTimeoutInMilliseconds(1000)));\n        }\n\n        private volatile boolean hasBeenInterrupted;\n\n        public boolean hasBeenInterrupted()\n        {\n            return hasBeenInterrupted;\n        }\n\n        @Override\n        protected Void run() throws Exception\n        {\n            try {\n                Thread.sleep(2000);\n            }\n            catch (InterruptedException e) {\n                LOG.error(\"Interrupted!\", e);\n                hasBeenInterrupted = true;\n            }\n\n            return null;\n        }\n    }\n\n    @Test\n    public void shouldInterruptOnTimeout() throws InterruptedException\n    {\n        // given\n        SleepingCommand cmd = new SleepingCommand();\n\n        // when\n        cmd.observe().subscribe();\n\n        // then\n        Thread.sleep(3000);\n        Assert.assertTrue(cmd.hasBeenInterrupted());\n    }\n}\n```\n\nIt works fine with Hystrix 1.3.18.\n", "closed": "2015-02-10 05:21:17", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/354", "ttf": 61.000277777777775, "commits": {}, "labels": ["bug"], "title": "interruptOnTimeout doesn't work in Hystrix 1.4.0-RC5"}, {"created": "2014-12-09 03:12:34", "user": "wangkang85", "body": "This issue happens in the Rx-based hystrix-core jar, which is version 1.4 series.\n\nWe are following exactly the same way as \"Fallback: Cache via Network\" pattern in https://github.com/Netflix/Hystrix/wiki/How-To-Use.\n\nWe are using different thread pools for primary and secondary commands.\n\nWe see our Tomcat threads completely blocked in some instances. Here is the stacktrace:\n\n\"http-0.0.0.0-7101-56\" daemon prio=10 tid=0x00007fc836453000 nid=0x1162 waiting on condition [0x00007fc0639b6000]\n   java.lang.Thread.State: WAITING (parking)\n  at sun.misc.Unsafe.park(Native Method)\n- parking to wait for  <0x00007fc3ba56b0f8> (a java.util.concurrent.CountDownLatch$Sync)\n  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)\n  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)\n  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:994)\n  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1303)\n  at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:236)\n  at rx.internal.operators.BlockingOperatorToFuture$2.get(BlockingOperatorToFuture.java:105)\n  at com.netflix.hystrix.HystrixExecutableBase$1.performBlockingGetWithTimeout(HystrixExecutableBase.java:506)\n  at com.netflix.hystrix.HystrixExecutableBase$1.get(HystrixExecutableBase.java:387)\n  at com.netflix.hystrix.HystrixExecutableBase.execute(HystrixExecutableBase.java:296)\n  at com.netflix.hystrix.HystrixObservableCommand.execute(HystrixObservableCommand.java:50)\n  at com.netflix.hystrix.HystrixCommand.execute(HystrixCommand.java:485)\n  at com.netflix.gps.isolation.sims.impl.SimsClientQueryImpl.getVideoSims(SimsClientQueryImpl.java:26)\n  ...\n", "closed": "2015-05-04 23:57:15", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/352", "ttf": 146.00027777777777, "commits": {}, "labels": ["bug"], "title": "Deadlock under \"Fallback: Cache via Network\" pattern"}, {"created": "2014-12-08 12:43:47", "user": "krutsko", "body": "Recetly we tried to migrate from Hystrix 1.3.9 to the later one 1.3.16 and faced with issue that our custom Hystrix Strategy is not working properly after Hystrix Command throw a Timeout Exception.\n\nI did some modification on this https://github.com/Netflix/Hystrix/issues/212#issuecomment-36078515 to show up issue. (In the our real strategy, we use a Guice to propagate http request scope instances `ServletScopes.scopeRequest(actual, seedMap)` which throw IllegalStateException if called twice)\n\nI'm not sure to consider this a real issue, so reject if needed.\n\n```\npackage com.netflix.hystrix;\n\nimport com.netflix.hystrix.Hystrix;\nimport com.netflix.hystrix.HystrixCommand;\nimport com.netflix.hystrix.HystrixCommandGroupKey;\nimport com.netflix.hystrix.strategy.HystrixPlugins;\nimport com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy;\nimport com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;\nimport rx.functions.Action1;\n\nimport java.util.concurrent.Callable;\n\npublic class TestOrig {\n\n    private static final ThreadLocal<String> requestIdThreadLocal = new ThreadLocal<String>();\n\n    public static class DummyCommand extends HystrixCommand<Void> {\n\n        public DummyCommand() {\n            super(HystrixCommandGroupKey.Factory.asKey(\"Dummy\"));\n        }\n\n        @Override\n        protected Void run() throws Exception {\n            System.out.println(\"requestId (run) = \" + requestIdThreadLocal.get());\n            Thread.sleep(2000);\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        HystrixPlugins.getInstance().registerConcurrencyStrategy(new HystrixConcurrencyStrategy() {\n            @Override\n            public <T> Callable<T> wrapCallable(final Callable<T> callable) {\n                return new RequestIdCallable<T>(callable);\n            }\n        });\n\n        HystrixRequestContext context = HystrixRequestContext.initializeContext();\n\n        requestIdThreadLocal.set(\"foobar\");\n        try {\n            new DummyCommand().execute();\n        } catch (Exception e) {\n            System.out.println(\"initialized = \" + HystrixRequestContext.isCurrentThreadInitialized());\n            System.out.println(\"requestId (timeout) = \" + requestIdThreadLocal.get());\n            e.getCause().printStackTrace();\n        }\n\n        // works fine using toObservable\n//        new DummyCommand().toObservable()\n//                .doOnError(new Action1<Throwable>() {\n//                    @Override\n//                    public void call(Throwable throwable) {\n//                        System.out.println(\"initialized = \" + HystrixRequestContext.isCurrentThreadInitialized());\n//                        System.out.println(\"requestId (timeout) = \" + requestIdThreadLocal.get());\n//                        throwable.getCause().printStackTrace();\n//                    }\n//                })\n//                .materialize()\n//                .toBlocking().single();\n\n\n        context.shutdown();\n        Hystrix.reset();\n    }\n\n    private static class RequestIdCallable<T> implements Callable<T> {\n        private final Callable<T> callable;\n        private final String requestId;\n\n        public RequestIdCallable(Callable<T> callable) {\n            this.callable = callable;\n            this.requestId = requestIdThreadLocal.get();\n        }\n\n        @Override\n        public T call() throws Exception {\n            String original = requestIdThreadLocal.get();\n            if (original != null) {\n                throw new IllegalStateException(\"threadlocal already initialized\");\n            }\n            requestIdThreadLocal.set(requestId);\n            try {\n                return callable.call();\n            } finally {\n                requestIdThreadLocal.set(original);\n            }\n        }\n    }\n}\n```\n\nExptected: timeout exception.\nActual: IllegalStateException\n", "closed": "2015-02-10 06:36:40", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/351", "ttf": 63.000277777777775, "commits": {}, "labels": ["bug"], "title": "Timeout handling fails for non-idempotent strategy"}, {"created": "2014-10-20 12:16:21", "user": "krutsko", "body": "1) Expected onComplete to be executed in all cases at the very end.\n2) in testExecutionHookRunFailureWithFallback - onComplete executed twice.\n\nPR to demo that https://github.com/Netflix/Hystrix/pull/327\n\nHook lifecycle captured during run of tests coming with Hystrix Core (version 1.3.9):\n{noformat}\ntestExecutionHookSuccessfulCommand (execute):\nonStart - onThreadStart - onRunStart - onRunSuccess - onComplete - onThreadComplete - \n\ntestExecutionHookSuccessfulCommand (queue)\nonStart - onThreadStart - onRunStart - onRunSuccess - onComplete - onThreadComplete - \n\ntestExecutionHookSuccessfulCommandViaFireAndForget\nonStart - onThreadStart - onRunStart - onRunSuccess - onComplete - onThreadComplete -\n\ntestExecutionHookSuccessfulCommandWithMultipleGetsOnFuture\nonStart - onThreadStart - onRunStart - onRunSuccess - onComplete - onThreadComplete - \n\ntestExecutionHookRunFailureWithoutFallback\nonStart - onThreadStart - onRunStart - **\\* simulated failed execution **\\* - onRunError - onFallbackStart - onFallbackError - onError - onThreadComplete -\n\ntestExecutionHookRunFailureWithFallback\nonStart - onThreadStart - onRunStart - **\\* simulated failed execution **\\* - onRunError - onFallbackStart - onFallbackSuccess - onComplete - onComplete - onThreadComplete - \n\ntestExecutionHookRunFailureWithFallbackFailure\nonStart - onThreadStart - onRunStart - **\\* simulated failed execution **\\* - onRunError - onFallbackStart - onFallbackError - onError - onThreadComplete -\n\ntestExecutionHookTimeoutWithoutFallback\nonStart - onThreadStart - onRunStart - ****\\* running - onFallbackStart - onFallbackError - onError - after interruption with extra sleep\nonRunSuccess - onThreadComplete - \n\ntestExecutionHookTimeoutWithFallback\nonStart - onThreadStart - onRunStart - ****\\* running - onFallbackStart - onFallbackSuccess - onComplete - after interruption with extra sleep - onRunSuccess - onThreadComplete - \n\ntestExecutionHookRejectedWithFallback\nonStart - onFallbackStart - onFallbackSuccess - onComplete\n\ntestExecutionHookShortCircuitedWithFallbackViaQueue\nonStart - onFallbackStart - onFallbackError - onError - \n\ntestExecutionHookShortCircuitedWithFallbackViaExecute\nonStart - onFallbackStart - onFallbackError - onError - \n\ntestExecutionHookSuccessfulCommandWithSemaphoreIsolation\nonStart - onRunStart - onRunSuccess - onComplete - \n\ntestExecutionHookFailureWithSemaphoreIsolation  \nonStart - onFallbackStart - onFallbackError - onError - \n\ntestExecutionHookFailedOnHystrixBadRequestWithSemaphoreIsolation:\nonStart - onRunStart - **\\* simulated failed execution ***onRunError -\n{noformat}\n", "closed": "2014-12-27 21:10:48", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/328", "ttf": 68.00027777777778, "commits": {}, "labels": ["bug"], "title": "Hook execution sequence issue"}, {"created": "2014-05-21 09:14:26", "user": "johanhaleby", "body": "We frequently run into errors like this when using Turbine 0.4 and Hystrix 1.3.16. Stacktrace example:\n\n``` java\n2014-05-21 11:04:50 ERROR  com.netflix.hystrix.dashboard.stream.ProxyStreamServlet:115 [ProxyStreamServlet] [doGet]: Error proxying request: http://xxx.y.com:8080/turbine-web-0.4/turbine.stream?cluster=my-cluster\njava.lang.RuntimeException: org.mortbay.jetty.EofException\n        at com.netflix.hystrix.dashboard.stream.ProxyStreamServlet.doGet(ProxyStreamServlet.java:109)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)\n        at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)\n        at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:390)\n        at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\n        at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)\n        at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)\n        at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:440)\n        at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)\n        at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)\n        at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\n        at org.mortbay.jetty.Server.handle(Server.java:326)\n        at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)\n        at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:926)\n        at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:549)\n        at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:212)\n        at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)\n        at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:410)\n        at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)\nCaused by: org.mortbay.jetty.EofException\n        at org.mortbay.jetty.AbstractGenerator$Output.write(AbstractGenerator.java:603)\n        at com.netflix.hystrix.dashboard.stream.ProxyStreamServlet.doGet(ProxyStreamServlet.java:97)\n        ... 19 more\n```\n\nIs this a bug or why does this happen?\n", "closed": "2015-10-15 16:40:30", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/267", "ttf": 512.0002777777778, "commits": {}, "labels": ["bug", "dashboard"], "title": "Dashboard gets \"Error proxying request\" errors when using Turbine"}, {"created": "2013-02-26 23:24:49", "user": "benjchristensen", "body": "Originally was issue https://github.com/Netflix/Hystrix/issues/80 but that got hijacked by a HystrixCollapser issue that at first was thought to be related or the same but wasn't.\n\n---\n\nWe are seeing this exception in logs. It suggests a concurrency bug.\n\nIt's a very small volume of errors - 1 or 2 per hour out of 10s of thousands of executions per instance - but it's concerning that it is happening at all.\n\n---\n\nLogging was added in pull request https://github.com/Netflix/Hystrix/pull/81 to help identify the issue.\n", "closed": "2013-02-28 23:30:37", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/113", "ttf": 2.000277777777778, "commits": {}, "labels": ["bug"], "title": "IllegalStateException: Future Not Started"}, {"created": "2013-01-09 23:31:54", "user": "benjchristensen", "body": "If a server has not yet had any command executions to generate metrics the hystrix.stream servlet will loop infinitely waiting on metrics.\n\nSince it keeps looping with no data it will never attempt writing to the outputstream.\n\nThus, it will never close the connection even if the client disconnects as it won't get an IOException or call close().\n\nThis will keep the servlet inside the try/catch and never count down the counter.\n", "closed": "2013-01-09 23:43:14", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/85", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug"], "title": "hystrix.stream holds connection open if no metrics"}, {"created": "2013-01-09 03:25:01", "user": "benjchristensen", "body": "The Command stream includes reportingHosts but ThreadPool does not. It needs to for Turbine and the Dashboard to correctly count and display the number of hosts.\n", "closed": "2013-01-09 03:28:49", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/82", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug"], "title": "ThreadPool stream should include reportingHosts"}, {"created": "2013-01-08 18:57:31", "user": "benjchristensen", "body": "Symptoms:\n- sometimes collapsed requests do not receive their response from the executing batch\n- collapsed requests that don't receive responses would block calling threads for 15+ seconds\n- latency in batch being executed\n\nCauses:\n- the only cause that was reproducible (by using real production traffic) is high load average on a box causing the timer thread to become very latent in triggering batches (seconds, not just 10s or 100s of milliseconds).\n- various concurrency bugs that made the handling of this latency bad such as resulting in long running blocked threads\n\n---\n\nThis issue was originally \"IllegalStateException: Future Not Started\" and thought to be related to this HystrixCollapser issue. It ended up not being so but taken over by it so the original bug was re-created at https://github.com/Netflix/Hystrix/issues/113. The first 2 comments including pull request https://github.com/Netflix/Hystrix/issues/81 are related to https://github.com/Netflix/Hystrix/issues/113 and not this issue about HystrixCollapser.\n", "closed": "2013-02-27 17:52:17", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/80", "ttf": 49.000277777777775, "commits": {}, "labels": ["bug"], "title": "HystrixCollapser: Response Not Received"}, {"created": "2012-12-17 19:50:05", "user": "benjchristensen", "body": "It appears that the request log is showing the time a fallback took instead of execution when a TIMEOUT occurs followed by FALLBACK.\n\nIt should show the execution time. \n\nShould we show both the execution and fallback somehow?\n\nHere is an example request log with a timeout occurring on a request with a log of executions during a latency monkey simulation:\n\n```\nDeviceTypeServiceGetType[SUCCESS][0ms], IdentityCookieAuth[SUCCESS][0ms], SubscriberGetAccount[SUCCESS][5ms], ABCallServiceInternal[SUCCESS][87ms]x2, ABTestGetAllocationMap[SUCCESS][1ms]x2, PlaylistGet[SUCCESS][11ms], ViewingHistoryGetViewingHistory[SUCCESS][29ms], ABTestGetAllocationMap[SUCCESS, RESPONSE_FROM_CACHE][0ms]x306, PlaylistGet[Executed][0ms]x5, ViewingHistoryGetViewingHistory[Executed][0ms]x5, PlaylistGet[SUCCESS, RESPONSE_FROM_CACHE][0ms]x10, NDCMapReadCassandraPersister[SUCCESS][83ms]x2, NDCMapReadEVCachePersister[SUCCESS][79ms]x2, NDCMapReadBulkCassandraPersister[SUCCESS][29ms], NDCMapReadBulkEVCachePersister[SUCCESS][19ms], MapGetLists[TIMEOUT, FALLBACK_SUCCESS][0ms], MapGetLists[TIMEOUT, FALLBACK_SUCCESS, RESPONSE_FROM_CACHE][0ms]x5, VideoMetadataGetEpisodes[SUCCESS][0ms]x28, VideoMetadataGetEpisodes[Executed][0ms]x32, SubscriberGetAccount[SUCCESS, RESPONSE_FROM_CACHE][0ms]x260, QTGetQTVGenres[SUCCESS][0ms]x13, CinematchGetMovieRatings[SUCCESS][7ms], VideoMetadataGetEpisodes[SUCCESS, RESPONSE_FROM_CACHE][0ms]x10, ABTestGetAllocationsCommand[SUCCESS][78ms], VideoHistoryGetBookmarks[SUCCESS, COLLAPSED][179ms]x13, CinematchGetMovieRatings[SUCCESS, RESPONSE_FROM_CACHE][0ms]x18, CinematchGetPredictions[SUCCESS, COLLAPSED][95ms]x17, VideoMetadataGetEpisode[SUCCESS][0ms]x6, QTGetQTVGenres[SUCCESS, RESPONSE_FROM_CACHE][0ms]x6, MapODPGetConfig[TIMEOUT][0ms]\n```\n", "closed": "2012-12-22 03:39:21", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/55", "ttf": 4.000277777777778, "commits": {}, "labels": ["bug"], "title": "HysrixRequestLog: Missing Events and Time on Timeouts"}, {"created": "2012-12-06 18:24:00", "user": "benjchristensen", "body": "Currently the HystrixPlugins implementation provides a single globally static mechanism for registering plugins. \n\nIt's simple and easy to grok but also has non-obvious issues.\n\nThis is a new concern for Hystrix as internally at Netflix there was only ever the \"default behavior\" but now anything can be customized.\n\nIf a system starts up, uses some HystrixCommands and then registers new plugins, the commands executed before will have already initialized metrics, thread-pools, metrics publishers, properties and other such things expected to live for the live of the JVM. \n\nThey are cached for a given HystrixCommandKey.\n\nThe simple answer is to just clear the caches and let everything initialize again.\n\nThat isn't quite so simple though because these aren't just objects that get garbage collected. \n\nWe need shutdown hooks then for thread-pools and metrics publishers to unpublish and gracefully cleanup - things that typically don't ever happen.\n\nThe possible approaches I've thought of are:\n\n1) Bootstrap with JVM properties\n\nIf properties were injected from the command-line (ie -Dhystrix.plugin.???=???) then we could guarantee that all HystrixCommand executions initialize with the correct values on system startup.\n\n2) Lifecycle Hooks\n\nAll plugin implementations (including the defaults) could have shutdown hooks that get executed when another plugin is registered and the plugin implementation is responsible for tearing down any resources is allocated (thread-pools, metrics being published, etc).\n\n3) IllegalStateExceptions to lock down\n\nAllow \"locking\" the plugin config so that no further plugins can be registered and alter behavior.\n\nIf something tries it would get an IllegalStateException.\n\nThis would at least protect against unexpected race conditions or malicious overrides of behavior (a bad library for example).\n\nNothing has been done on this yet as none of the solutions are great so I'm thinking on it more and discussing with others.\n", "closed": "2012-12-18 20:37:09", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/39", "ttf": 12.000277777777777, "commits": {}, "labels": ["bug", "enhancement"], "title": "HystrixPlugins Bootstrapping Problem - Race Conditions"}, {"created": "2012-12-04 19:42:53", "user": "benjchristensen", "body": "As part of the opensourcing of Hystrix there was a refactoring of how plugin behavior worked and I ended up making a poor design decision that makes it easy to end up in a bad and non-obvious state.\n\nNamely, when injecting strategies via HystrixCommand.Setter different instances with the same HystrixCommandKey could end up with different strategies.\n\nThis sounds \"flexible\" but becomes very non-obvious, especially when trying to report on metrics.\n\nWhen showing a dashboard or monitoring something people expect a command with a given key to have the same properties, metrics, concurrency strategy etc not different ones depending on code-path to instantiate.\n\nWorse, the first one to instantiate will currently create a CircuitBreaker for a given HystrixCommandKey.\n\nWe don't want multiple circuit-breakers for the same CommandKey just because different strategies were injected in, yet right now that circuit-breaker will use the first properties strategy and thus become confusing if someone does inject multiple different strategies.\n\nThus, I'm going to make the change in 1.1 to disallow injecting strategies via the HystrixCommand.\n\nThis is a \"breaking change\" if anyone is doing this already but I'm hoping that I'm catching this before anyone has integrated down this path.\n\nIf it affects anyone I apologize for this design mistake.\n", "closed": "2012-12-05 08:08:57", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/34", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug"], "title": "Remove Strategy Injection on HystrixCommand"}, {"created": "2012-11-30 18:17:46", "user": "benjchristensen", "body": "The threadpools lost their custom names which makes debugging thread-dumps difficult.\n\nBring back proper naming ...\n", "closed": "2012-11-30 19:02:04", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/28", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["bug"], "title": "Thread pools lost custom names in opensource refactoring"}, {"created": "2012-11-29 04:02:05", "user": "benjchristensen", "body": "The TotalExecutionTime is tracked on execute() but not on queue().\n\nThis is not a problem with the normal executionTime metric around the run() method, but the total end-to-end metric.\n\nFor queue() we want to track from the time queue() is invoked until the time the underlying thread completes and a Future.get() could retrieve the value even if it doesn't.\n\nWe don't want to track until Future.get() is invoked as that is not the actual processing time of the execution and can be variant depending on what the client code is doing.\n\nThis was a known missing feature but I'm marking this as a bug as it should have been there before marking the 1.0 release.\n", "closed": "2012-12-22 03:35:45", "commitsDetails": [], "url": "https://github.com/Netflix/Hystrix/issues/20", "ttf": 22.00027777777778, "commits": {}, "labels": ["bug"], "title": "TotalExecutionTime not tracked on queue()"}]}