{"bugLabels": ["Bug"], "projectName": "ReactiveX/RxJava", "captureTime": "Fri Jul  3 16:38:10 2020", "issues": [{"created": "2020-05-13 07:51:42", "user": "akarnokd", "body": "Continuing evaluating the problems from #6974\r\n\r\nThe following test hangs after a while:\r\n\r\n```java\r\n    @Test\r\n    public void issue6974Part2Case1ObserveOnNoCap() {\r\n        final int groups = 20;\r\n        int flatMapMaxConcurrency = 1_000_000;\r\n\r\n        Flowable\r\n        .range(1, 500_000)\r\n        .map(i -> i % groups)\r\n        .doOnRequest(v -> {\r\n            System.out.println(\"Source: \" + v);\r\n        })\r\n        .groupBy(i -> i)\r\n        .flatMap(gf -> gf\r\n                     .observeOn(Schedulers.computation())\r\n                     .take(10, TimeUnit.MILLISECONDS)\r\n            , flatMapMaxConcurrency)\r\n        .test()\r\n        .awaitDone(5, TimeUnit.SECONDS)\r\n        .assertNoErrors()\r\n        .assertComplete();\r\n    }\r\n```\r\n\r\nAdding `hide` makes it pass which indicates the fusion between the group and `observeOn` seems to stop requesting more items.", "closed": "2020-05-20 19:34:07", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6982", "ttf": 7.000277777777778, "commits": {}, "labels": ["3.x", "Bug"], "title": "Flowable.groupBy hangs with group consumed via observeOn and take(timed)"}, {"created": "2020-05-09 20:19:33", "user": "dbakr", "body": "Hi.\r\n\r\nAfter few days of desperate attempts to find the cause of my servers' spontaneous hangs, I managed to reproduce the issue, but still don't have a clear idea about the reason, but I think I have identified a possible direction.\r\n\r\nAll problems has started when I started using very promising operator groupBy with evicting map provider possibility:\r\n```java\r\n<K, V> Flowable<GroupedFlowable<K, V>> groupBy(@NonNull Function<? super T, ? extends K> keySelector,\r\n            @NonNull Function<? super T, ? extends V> valueSelector,\r\n            boolean delayError, int bufferSize,\r\n            @NonNull Function<? super Consumer<Object>, ? extends Map<K, Object>> evictingMapFactory)\r\n```\r\n\r\nFirst I realised that it doesn't work well with Caffeine cache, as it performs evictions on a separate thread pool, and with async eviction notification groupBy goes crazy.\r\n\r\nAfter moving to Guava things got better but only to some extent.\r\n\r\nThe tests I want to demonstrate I believe reproduce the issue I have. Definitely chain of operators is way more complicated in the production code, but here with certain variant of .publish() operator it's reproducible as well.\r\n\r\nBasically, I'm not sure if there is issue in the groupBy(...evictingMapFactory) or in the publish(Function...), or in both.\r\n\r\nAlso tests are demonstrating that eviction policy doesn't work very well when crossing async boundaries downstream.\r\n\r\nPlease take a look at the attached file, it contains few simple tests, I kindly ask to check carefully all parameters, as it's important.\r\n\r\n[FlowableOperators.java.zip](https://github.com/ReactiveX/RxJava/files/4604420/FlowableOperators.java.zip)\r\n", "closed": "2020-05-10 08:52:29", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6974", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["3.x", "Bug"], "title": "3.0.3 - Hangs when using combination of flatMap and publish"}, {"created": "2020-04-04 10:03:41", "commits": {"2cb20bd41efe70556ef7d346ee60f70e20548bae": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2020-05-01 06:28:23", "filteredCommits": [], "commitsDetails": [{"nameRev": "2cb20bd41efe70556ef7d346ee60f70e20548bae remotes/origin/2.x", "commitMessage": "2.x: Fix Observable.flatMap with maxConcurrency hangs (#6947) (#6960)\n\n", "commitParents": ["7ca43c7398810ee87c57f7f2165104822c0a4662"], "spoonStatsSkippedReason": "", "commitHash": "2cb20bd41efe70556ef7d346ee60f70e20548bae", "authoredDateTime": "2020-04-15 09:50:58", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 23, "deletions": 0, "lines": 23, "filePath": "src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java"}, {"insertions": 23, "deletions": 0, "lines": 23, "filePath": "src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java"}, {"insertions": 27, "deletions": 12, "lines": 39, "filePath": "src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java"}], "commitDateTime": "2020-04-15 09:50:58", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableFlatMapTest.mixedScalarAsync()"}], "spoonFilePath": "FlowableFlatMapTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 11, "MOV": 5, "INS": 6, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableFlatMap.MergeObserver.drainLoop()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableFlatMap.MergeObserver.subscribeMore(int)"}], "spoonFilePath": "ObservableFlatMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableFlatMapTest.mixedScalarAsync()"}], "spoonFilePath": "ObservableFlatMapTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/6947", "ttf": 26.00027777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "2.x: open for grabs: backport #6946", "statsSkippedReason": "", "user": "akarnokd", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "Fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946.", "labels": ["2.x", "Bug", "PR welcome", "good first issue"]}, {"created": "2020-04-04 08:01:31", "user": "adrian-linca", "body": "RXJava 3.0.1.\r\nI randomly got into a weird situation where my code entered a deadlock and I don't know why.\r\nI simplified the code and got to the below part which will enter a deadlock and never return.\r\nThis seems like a bug, but maybe I'm missing something.\r\nThe code:\r\n```java\r\nObservable\r\n    .range(1, 20)\r\n    .flatMap(\r\n            integer -> {\r\n                if (integer % 5 != 0) {\r\n                    return Observable\r\n                            .just(integer);\r\n                }\r\n\r\n                return Observable\r\n                        .just(-integer)\r\n                        .observeOn(Schedulers.io());\r\n            },\r\n            false,\r\n            1\r\n    )\r\n    .ignoreElements()\r\n    .blockingAwait();\r\n```", "closed": "2020-04-04 09:29:23", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6945", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["3.x", "Bug"], "title": "Deadlock"}, {"created": "2020-02-28 21:32:37", "user": "arkivanov", "body": "Version: 3.0.0\r\n\r\nHello! In the `ConnectableObservable` java docs this following is written:\r\n\r\n> Disposing the connection will reset the {@code ConnectableFlowable} to its fresh state and there is no need to call {@code reset()} in this case.\r\n\r\nSo I think If I dispose the connection then I don't need to call `reset`, it should be in its initial state. However the following test fails. But if you uncomment the `reset()` call then it passes:\r\n\r\n```kotlin\r\n    @Test\r\n    fun testReplay() {\r\n        val subject = PublishSubject.create<Int>()\r\n        val replay = subject.replay()\r\n\r\n        var observer = replay.test() // subscribe\r\n        val disposable = replay.connect() // connect\r\n        subject.onNext(1)\r\n        observer.dispose() // unsubscribe\r\n        disposable.dispose() // disconnect\r\n//        sharedStream.reset()\r\n\r\n        observer = replay.test() // subscribe again\r\n        replay.connect() // connect again\r\n        subject.onNext(0)\r\n\r\n        observer.assertValues(0) // Actual value is 1, but if reset was called then it will be 0\r\n    }\r\n```\r\n\r\nCould you please clarify whether it is a bug or expected behaviour. Thanks!", "closed": "2020-02-29 13:02:29", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6920", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["3.x", "Bug"], "title": "Observable.replay - a bug or a feature?"}, {"created": "2020-02-27 15:48:36", "user": "Dimezis", "body": "RxJava version - 2.2.18.\r\n\r\nSometimes, when the inner flowable emits >1 item, the unsubscription from the outer chain after receiving the first item doesn't trigger the unsubscription from the inner Flowable.\r\nThe completion of the outer chain also doesn't trigger the `finally` of the inner Flowable.\r\nThis doesn't happen if I replace Flowable with Observable.\r\n\r\nSorry for the pretty dumb example code, but not sure how to illustrate the problem better.\r\n\r\nSo the expected result would be that `Outer finally` and `Inner finally` both printed `10000` times.\r\nWhat happens is that `Inner finally` is sometimes not printed, and the subscription to the inner flowable remains hanging, even though the outer chain has completed.\r\nOn my machine this test produces around 9970 - 9990 `Inner finally` results instead of 10000 (It varies from run to run).\r\n\r\n```Kotlin\r\n    private val inner = AtomicInteger()\r\n    private val outer = AtomicInteger()\r\n\r\n    @Test\r\n    fun test() {\r\n        repeat(10_000) {\r\n            thread {\r\n                Flowable.create<Unit>({\r\n                    it.onNext(Unit)\r\n                }, BackpressureStrategy.LATEST)\r\n                    .switchMap { createFlowable() }\r\n                    .observeOn(Schedulers.computation())\r\n                    .doFinally {\r\n                        println(\"Outer finally\")\r\n                        outer.incrementAndGet()\r\n                    }\r\n                    .take(1)\r\n                    .subscribe({}, Throwable::printStackTrace)\r\n            }.join()\r\n        }\r\n\r\n        assert(inner.get() == outer.get())\r\n    }\r\n\r\n    private fun createFlowable(): Flowable<Unit> {\r\n        return Flowable\r\n            .create<Unit>({\r\n                Schedulers.io().scheduleDirect({\r\n                    it.onNext(Unit)\r\n                }, 10, TimeUnit.MILLISECONDS)\r\n\r\n                Schedulers.io().scheduleDirect({\r\n                    it.onNext(Unit)\r\n                }, 10, TimeUnit.MILLISECONDS)\r\n            }, BackpressureStrategy.BUFFER)\r\n            .subscribeOn(Schedulers.single())\r\n            .unsubscribeOn(Schedulers.single())\r\n            .doFinally {\r\n                println(\"Inner finally\")\r\n                inner.incrementAndGet()\r\n            }\r\n    }\r\n```", "closed": "2020-02-27 19:48:20", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6914", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "Flowable.Switchmap sometimes doesn't unsubscribe from inner stream"}, {"created": "2020-01-28 13:54:24", "user": "AnitaMell", "body": "The groupBy operator does not work as expected wrt. request handling.\r\nIf a subscriber of one of the GroupedFlowables is cancelled, the buffer space occupied by this GroupedFlowable is not released. \r\n\r\nThe code below illustrates this behavior:\r\n\r\n### Code\r\n```java\r\n        List<TestSubscriber> listOfSubscribers = new ArrayList<>();\r\n\r\n        Flowable.range(1, 1000)\r\n            .doOnNext(n -> System.out.printf(\"onNext (%d) \\n\", n))\r\n            .doOnRequest(r -> System.out.printf(\"%d requests send \\n\", r))\r\n            .groupBy(integer -> integer % 10)\r\n            .subscribe(groupedFlowable -> {\r\n                TestSubscriber<Integer> subscriber = TestSubscriber.create(0);\r\n                listOfSubscribers.add(subscriber);\r\n                groupedFlowable.subscribe(subscriber);\r\n            });\r\n```\r\n### output result\r\n```java\r\n        128 requests send \r\n        onNext (1) \r\n        1 requests send \r\n        onNext (2) \r\n        1 requests send \r\n        onNext (3) \r\n        1 requests send \r\n        onNext (4) \r\n        1 requests send \r\n        onNext (5) \r\n        1 requests send \r\n        onNext (6) \r\n        1 requests send \r\n        onNext (7) \r\n        1 requests send \r\n        onNext (8) \r\n        1 requests send \r\n        onNext (9) \r\n        1 requests send\r\n        onNext (10) \r\n        1 requests send \r\n        onNext (11) \r\n        onNext (12) \r\n        onNext (13) \r\n        ...\r\n        onNext (136) \r\n        onNext (137) \r\n        onNext (138)\r\n```\r\nAs I expected, the buffer is filled up with items until the buffer is completly full and, as a result, requests are no longer signalled to upstream\r\n\r\nIf I add a line of code which cancels all TestSubscribers I would expect that the groupBy operator signals 128 requests to upstream, because the buffer should be empty again. However this is not the case, and cancelling all TestSubscribers has no effect on the result.\r\n\r\n### Modified code with same output\r\n```java\r\n        List<TestSubscriber> listOfSubscribers = new ArrayList<>();\r\n\r\n        Flowable.range(1, 1000)\r\n            .doOnNext(n -> System.out.printf(\"onNext (%d) \\n\", n))\r\n            .doOnRequest(r -> System.out.printf(\"%d requests send \\n\", r))\r\n            .groupBy(integer -> integer % 10)\r\n            .subscribe(groupedFlowable -> {\r\n                TestSubscriber<Integer> subscriber = TestSubscriber.create(0);\r\n                listOfSubscribers.add(subscriber);\r\n                groupedFlowable.subscribe(subscriber);\r\n            });\r\n\r\n        listOfSubscribers.forEach(TestSubscriber::cancel);\r\n```\r\nWhat's your opinion on this? Could this be a bug or does it work as designed?\r\nThank you", "closed": "2020-01-29 10:57:41", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6889", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "2.x: Unexpected behaviour of GroupBy operator wrt. request handling"}, {"created": "2020-01-08 17:03:57", "user": "eugene-zolotko", "body": "Hi,\r\n \r\nI've discovered an unexpected behavior of the Flowable.flatMap() operator leading to a possible subscription leak. Localized my problem in the following scenario:\r\n1. RxJava version 2.2.16.\r\n2. Given a simple Rx chain of flowable1.flatMap(value -> flowable2).\r\n3. flowable1 emits a value (so that flatMap subscribes to flowable2).\r\n4. flowable1 emits an error.\r\nExpected result: flatMap disposes flowable2 upon handling the upstream error.\r\nActual result: flowable2 remains subscribed after the entire Rx chain terminates because of the error.\r\n\r\nReplacing the flatMap operator with concatMap fixes the problem (such a replacement is valid in my case). However I decided to raise this issue because such behavior of flatMap looks quite odd to me. Could somebody from RxJava team confirm whether my expectation is valid and the observed behavior is a defect?\r\n\r\nI've reproduced this issue in a code snippet: https://gist.github.com/eugene-zolotko/b24cbc436bc0eab2ed5de539b9e4e312\r\nI'm expecting this code to produce \"flowable2 cancelled\" output. But got \"flowable2 error\" instead, plus error2 gets thrown as UndeliverableException because it occurs after the entire chain is terminated.", "closed": "2020-01-09 07:57:52", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6825", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "2.x: Unexpected Flowable.flatMap(...) behavior while handling an upstream error"}, {"created": "2019-12-10 20:44:01", "commits": {"52346a140c29b659023f87e348c26889b6b39b13": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2019-12-11 12:15:50", "filteredCommits": [], "commitsDetails": [{"nameRev": "52346a140c29b659023f87e348c26889b6b39b13 tags/v2.2.16~1", "commitMessage": "2.x: Zip, CombineLatest, and Amb operators throw when supplied with ObservableSource implementation that doesn't subclass Observable (#6754)\n\n* 2.x: Zip, CombineLatest, and Amb operators throw when supplied with ObservableSource implementation that doesn't subclass Observable #6753\r\n\r\n* 2.x: add tests for allowing arbitrary ObservableSource implementations\r\n", "commitParents": ["31b407f3d66a1c36dcadd37a85f89b68ec62ff16"], "spoonStatsSkippedReason": "", "commitHash": "52346a140c29b659023f87e348c26889b6b39b13", "authoredDateTime": "2019-12-11 02:20:42", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 1, "deletions": 1, "lines": 2, "filePath": "src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java"}, {"insertions": 29, "deletions": 0, "lines": 29, "filePath": "src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java"}, {"insertions": 29, "deletions": 0, "lines": 29, "filePath": "src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java"}, {"insertions": 17, "deletions": 0, "lines": 17, "filePath": "src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java"}], "commitDateTime": "2019-12-11 09:20:42", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().39"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().46"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone2().37"}, {"UPD": 0, "TOT": 4, "MOV": 3, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.errorDelayed()"}, {"UPD": 0, "TOT": 2, "MOV": 2, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestDelayErrorIterableOfSources()"}, {"UPD": 1, "TOT": 6, "MOV": 2, "INS": 1, "DEL": 2, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineAsync()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().40"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestDelayErrorArrayOfSources().21"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.errorDelayed2()"}, {"UPD": 0, "TOT": 3, "MOV": 3, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestDelayErrorArrayOfSources()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone2().38"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone().36"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone2()"}, {"UPD": 0, "TOT": 3, "MOV": 3, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.cancelWhileSubscribing()"}, {"UPD": 0, "TOT": 7, "MOV": 5, "INS": 1, "DEL": 1, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.error()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().44"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestDelayErrorArrayOfSourcesWithError().22"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().47"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.onErrorRace().34"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.cancelWhileSubscribing().26"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.onErrorRace().33"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.errorDelayed().30"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.onErrorRace()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.eagerDispose().49"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.cancelWhileSubscribing().27"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.syncFirstErrorsAfterItemDelayError().50"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.errorDelayed2().31"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.eagerDispose().48"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.disposed().25"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.dontSubscribeIfDone().35"}, {"UPD": 1, "TOT": 4, "MOV": 3, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.disposed()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().42"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.onErrorRace().32"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().43"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestIterableOfSourcesNotSubclassingObservable()"}, {"UPD": 0, "TOT": 4, "MOV": 3, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combineLatestDelayErrorIterableOfSourcesWithError()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().41"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.combine2Observable2Errors().45"}, {"UPD": 4, "TOT": 4, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableCombineLatestTest.eagerDispose().48.onNext(java.lang.Integer)"}], "spoonFilePath": "ObservableCombineLatestTest.java"}, {"spoonMethods": [], "spoonFilePath": "ObservableCombineLatest.java"}, {"spoonMethods": [], "spoonFilePath": "ObservableAmb.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.noWinnerErrorDispose().11"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.singleIterableNotSubclassingObservable()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onErrorRace().8"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onCompleteRace().6"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.noWinnerCompleteDispose().12"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onCompleteRace().7"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.noWinnerSuccessDispose().10"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onCompleteRace()"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onNextRace()"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onErrorRace()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onErrorRace().9"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onNextRace().5"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableAmbTest.onNextRace().4"}], "spoonFilePath": "ObservableAmbTest.java"}, {"spoonMethods": [], "spoonFilePath": "ObservableZip.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.firstErrorPreventsSecondSubscription().49"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.firstErrorPreventsSecondSubscription().51"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.noCrossBoundaryFusion().45"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.eagerDispose().48"}, {"UPD": 4, "TOT": 4, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.eagerDispose().47.onNext(java.lang.Integer)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.firstErrorPreventsSecondSubscription().50"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.dispose().43"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.zipIterableNotSubclassingObservable()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.eagerDispose().47"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.noCrossBoundaryFusion().44"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.noCrossBoundaryFusion().46"}, {"UPD": 0, "TOT": 2, "MOV": 2, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableZipTest.noCrossBoundaryFusion()"}], "spoonFilePath": "ObservableZipTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/6753", "ttf": 0.0002777777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "2.x: Zip, CombineLatest, and Amb operators throw when supplied with ObservableSource implementation that doesn't subclass Observable", "statsSkippedReason": "", "user": "mgsholte", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "Issue found in version 2.2.15.\r\n\r\nThe Zip, CombineLatest, and Amb operators of the `Observable` class each have an overload that accepts an `Iterable<ObservableSource>` and a `Function<Array<Any>, R>` where `R` is a type parameter. The problem is that the elements of the `Iterable` are copied into an `Observable[]` internally by the `Observer` classes implementing the operators. This causes an `ArrayStoreException` if one supplies any custom `ObservableSource` implementation that doesn't subclass `Observable`.\r\n\r\nThe equivalent functions for the other stream types don't have this restriction. I.e, the Zip implementation in `Maybe` copies the source values into a `MaybeSource[]` and avoids this problem.\r\n\r\nExample kotlin code which reproduces the issue:\r\n```kotlin\r\nimport io.reactivex.Observable\r\nimport io.reactivex.ObservableSource\r\n\r\nval sourceA = ObservableSource<String> { Observable.just(\"A\").subscribe(it) }\r\nval sourceB = ObservableSource<String> { Observable.just(\"b\", \"B\").subscribe(it) }\r\n\r\nval combined =\r\n    Observable.combineLatest(\r\n       listOf(sourceA, sourceB),\r\n       { (it[0] as String) + (it[1] as String) }\r\n    )\r\n\r\nfun main() {\r\n    combined.subscribe(::println)\r\n}\r\n```\r\nA simple workaround is to wrap any `ObservableSource`. To fix the above example pass `listOf(sourceA, sourceB).map { Observable.wrap(it) }` to `combineLatest`.", "labels": ["2.x", "3.x", "Bug"]}, {"created": "2019-11-14 16:00:34", "user": "AnitaMell", "body": "Multicastprocessor does not work as expected wrt. backpressure/request handling: \r\n\r\nWith buffer size 1, everything is ok. However, for larger buffer sizes requests are no sent upstream if the amount of requests does not exactly match the buffer size or the amount of requests is a whole multiple of the buffer size.\r\n\r\nThe code below illustrates this behavior - the first example works just because the backpressure handling towards an FlowableFromArray seems to be handled differently.\r\n\r\nWe assume that there might be an issue in the drain() method of MulticastProcessor.\r\nWhat's your opinion on this? Could this be a bug or does it work as designed?\r\n\r\nCode that works as expected\r\n---\r\n```Java\r\nMulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);\r\nTestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);\r\n\r\nmulticastProcessor.subscribe(testSubscriber);\r\n\r\nFlowable.fromArray(1,2,3,4,5,6,7,8,9).subscribe(multicastProcessor);\r\n\r\ntestSubscriber.requestMore(3);\r\ntestSubscriber.requestMore(3);\r\n\r\nassertEquals(Arrays.asList(1,2,3,4,5,6), testSubscriber.values()); // expected result\r\n```\r\n\r\nCode with unexpected behaviour\r\n---\r\n```Java\r\nMulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);\r\nTestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);\r\n\r\nmulticastProcessor.subscribe(testSubscriber);\r\n\r\nFlowable.fromArray(1,2,3,4,5,6,7,8,9)\r\n    .doOnCancel(() -> System.out.println(\"log that should not change behaviour\"))\r\n    .subscribe(multicastProcessor);\r\n\r\ntestSubscriber.requestMore(3);\r\ntestSubscriber.requestMore(3);\r\n\r\nassertEquals(Arrays.asList(1,2,3,4), testSubscriber.values()); // unexpected result\r\n```\r\n\r\nCode that works again, after adjusting the request amount\r\n---\r\n```Java\r\nMulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);\r\nTestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);\r\n\r\nmulticastProcessor.subscribe(testSubscriber);\r\n\r\nFlowable.fromArray(1,2,3,4,5,6,7,8,9)\r\n    .doOnCancel(() -> System.out.println(\"log that should not change behaviour\"))\r\n    .subscribe(multicastProcessor);\r\n\r\ntestSubscriber.requestMore(2);\r\ntestSubscriber.requestMore(2);\r\n\r\nassertEquals(Arrays.asList(1,2,3,4,5,6), testSubscriber.values()); // expected result\r\n```\r\n\r\nversion\r\n---\r\n2.2.14\r\n\r\n", "closed": "2019-11-14 23:06:35", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6713", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "2.x: Unexpected behaviour of MulticastProcessor with buffer size larger than 1"}, {"created": "2019-10-16 18:53:57", "user": "akarnokd", "body": "Reported in https://github.com/ReactiveX/RxJava/issues/5927#issuecomment-542792421\r\n\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)\r\n       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)\r\n       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)\r\n       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)\r\n```\r\n\r\nWe just upgraded our project from 1.x, and did not see these errors in testing, but are seeing them in production.  We're working to figure out the exact cause, and will provide more information as we have it.\r\n\r\nHere are some additional stack traces, in case you notice any pattern:\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)\r\n       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.cancel + 168(FlowableConcatMapMaybe.java:168)\r\n       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)\r\n       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.drain + 284(FlowableConcatMapMaybe.java:284)\r\n       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.onNext + 137(FlowableConcatMapMaybe.java:137)\r\n       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)\r\n       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)\r\n```\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)\r\n       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.clear + 264(FlowableOnBackpressureBuffer.java:264)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.clear + 236(FlowableObserveOn.java:236)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated + 188(FlowableObserveOn.java:188)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 399(FlowableObserveOn.java:399)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.run + 66(ScheduledRunnable.java:66)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.call + 57(ScheduledRunnable.java:57)\r\n```\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)\r\n       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)\r\n       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.cancel + 93(FlowableSkipWhile.java:93)\r\n       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext + 74(FlowableFilter.java:74)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext + 52(FlowableFilter.java:52)\r\n       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.onNext + 56(FlowableSkipWhile.java:56)\r\n       at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext + 68(FlowableMap.java:68)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 407(FlowableObserveOn.java:407)\r\n       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)\r\n```\r\n\r\nThe full chain for the last stack trace is:\r\n```\r\nSingle.just(...)\r\n  .delaySubscription(\r\n    Completable.amb(\r\n      listOf(\r\n        Completable.timer(...),\r\n        FlowableProcessor\r\n          .map { ... }\r\n          .onBackpressureBuffer()\r\n          .compose { it.observeOn(...) }\r\n          .map { ... }\r\n          .observeOn(...)\r\n          .map { ... }\r\n          .skipWhile { ... }\r\n          .filter { ... }\r\n          .firstOrErrror()\r\n          .ignoreElement()\r\n      )\r\n    )\r\n      .toObservable<Any>()\r\n  )\r\n  .subscribeOn(...)\r\n```", "closed": "2019-10-17 13:44:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6673", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "NPE in SpscLinkedArrayQueue.clear due to concurrent invocation"}, {"created": "2019-09-12 07:12:53", "user": "chxchen", "body": "io.reactivex.Observable#window(long, java.util.concurrent.TimeUnit, long)\r\n\r\n```\r\nObservable.create((ObservableOnSubscribe<Integer>) emitter -> {\r\n            emitter.onNext(0);\r\n            emitter.onNext(1);\r\n            TimeUnit.SECONDS.sleep(1);\r\n            emitter.onNext(2);\r\n            TimeUnit.SECONDS.sleep(6);\r\n            emitter.onNext(4);\r\n            emitter.onNext(5);\r\n        })\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(Schedulers.io())\r\n                .window(5,TimeUnit.SECONDS, 2)\r\n                .flatMapSingle(Observable::toList)\r\n                .subscribe(list -> System.out.println(\"list=\" + list + \" time: \"\r\n                      + TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - l)\r\n                      + \"s\"));\r\n```\r\nLike the case of above, since 7 seconds, some empty arrays are expected,and \"2\" will be emited when the 5 seconds,but actually not.\r\n\r\n```\r\nlist=[0, 1] time: 0s\r\nlist=[2, 4] time: 7s\r\n```\r\nThere is nothing after 7 seconds, it make a confuse.\r\nAs the chart https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png\r\n it says that the timeSpan still works after winow-max-size reached.\r\n", "closed": "2019-09-30 10:43:49", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6651", "ttf": 18.00027777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "Observable#window(long, java.util.concurrent.TimeUnit, long) if reached \"window-max-count\", the timespan not work"}, {"created": "2019-09-11 09:56:19", "user": "FlyingPigQAQ", "body": "I'm a little confused about takeLast(long, TimeUnit).\r\nWhen executing the following code, each time the output order is supposed to be N digits in the last time window, but in fact the output results are inconsistent with the ideal state.\r\n### Code\r\n```\r\n public static void main(String[] args) {\r\n        ArrayList<Integer> ints = new ArrayList<>();\r\n        for (int i = 0; i < 100; i++) {\r\n            ints.add(i);\r\n        }\r\n        Observable.fromIterable(ints)\r\n                .takeLast(1,TimeUnit.NANOSECONDS)\r\n                .subscribe(longs->{\r\n                    System.out.println(longs);\r\n                });\r\n        try {\r\n            Thread.sleep(100000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n### Result\r\n![image](https://user-images.githubusercontent.com/29222599/64687577-59158200-d4bd-11e9-9def-89505d68f337.png)\r\n", "closed": "2019-09-12 10:47:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6647", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "2.x: confused of method takeLast(long,TimeUnit)"}, {"created": "2019-08-14 08:13:30", "user": "adrian-linca", "body": "This issue was reproduces on RX-Java v2.2.6 and v3.0.0-RC1\r\n\r\nI have this piece of code:\r\n```java\r\nFlowable\r\n  .range(1, 2)\r\n  .doOnNext(value -> {\r\n    System.out.println(\"value1: \" + value);\r\n  })\r\n  .switchMap(value -> Flowable.just(value * 10))\r\n  .subscribe(\r\n    value -> System.out.println(\"value2: \" + value),\r\n    throwable -> System.out.println(\"error: \" + throwable),\r\n    () -> System.out.println(\"complete\")\r\n   );\r\n```\r\nWhen run it prints:\r\nvalue1: 1\r\nvalue2: 10\r\nvalue1: 2\r\nvalue2: 20\r\ncomplete\r\n\r\nThen I have the exact same thing but with Flowable.fromIterable:\r\n```java\r\nFlowable\r\n    .range(1, 2)\r\n    .doOnNext(value -> {\r\n        System.out.println(\"value1: \" + value);\r\n    })\r\n    .switchMap(value -> Flowable.fromIterable(Arrays.asList(value * 10)))\r\n    .subscribe(\r\n        value -> System.out.println(\"value2: \" + value),\r\n        throwable -> System.out.println(\"error: \" + throwable),\r\n        () -> System.out.println(\"complete\")\r\n    );\r\n```\r\nThis one prints:\r\nvalue1: 1\r\nvalue2: 10\r\n\r\nAnd then nothing, no complete, no error, nothing.", "closed": "2019-08-14 09:40:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6615", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "Flowable.fromIterable does not work as expected when used in switchMap"}, {"created": "2019-08-02 10:29:08", "user": "riclage", "body": "The issue described below started with version 2.2.10 and continues with 2.2.11. It works with 2.2.7 through 2.2.9.\r\n\r\nI have a test where a set a `ReplaySubject` like so:\r\n\r\n```\r\nlocationPublisher = ReplaySubject.create()\r\nlocationPublisher.onNext(mockLocation)\r\nlocationPublisher.onComplete()\r\n\r\nlocationObservable = locationPublisher.share()\r\n```\r\n\r\nThen, I subscribe twice to the observable (I'm simplifying the test case just to demonstrate the bug):\r\n```\r\n        locationObservable\r\n            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))\r\n            .test()\r\n            .assertValueCount(2)\r\n\r\n\r\n        locationObservable\r\n            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))\r\n            .test()\r\n            .assertValueCount(2)\r\n```\r\nWhen I run the above test, it fails on the second test subscription on RxJava 2.2.10 or 2.2.11:\r\n> java.lang.AssertionError: Value counts differ; expected: 2 but was: 1 (latch = 0, values = 1, errors = 0, completions = 1)\r\nExpected :2 \r\nActual   :1 (latch = 0, values = 1, errors = 0, completions = 1)\r\n", "closed": "2019-08-03 08:24:01", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6608", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "ReplaySubject and buffer with debounce not emitting values after first subscription"}, {"created": "2019-07-29 12:53:00", "user": "chxchen", "body": "using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed.\r\n\r\n```java\r\nObservable.create(new ObservableOnSubscribe<Object>() {\r\n    @Override\r\n    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {\r\n        Schedulers.io().scheduleDirect(\r\n            () -> emitter.tryOnError(new Throwable(\"occurs error\")),\r\n            1, TimeUnit.SECONDS);\r\n        }\r\n    })\r\n    .mergeWith(\r\n        Completable.create(emmit ->\r\n            emmit.setCancellable(() -> System.out.println(\"mergeWith dispose\"))\r\n         )\r\n         .doOnSubscribe(dis -> System.out.println(\"mergeWith doOnSubscribe\"))\r\n    )\r\n    .subscribe(ob -> {}, System.out::println);\r\n```\r\nthe result is :\r\n```\r\nmergeWith doOnSubscribe\r\njava.lang.Throwable: occurs error\r\n```\r\n\r\nbut if add 'toObservable()' \r\n```\r\nObservable.create(new ObservableOnSubscribe<Object>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<Object> emitter) throws Exception {\r\n                Schedulers.io().scheduleDirect(() -> emitter.tryOnError(new Throwable(\"occurs error\")), 1, TimeUnit.SECONDS);\r\n            }\r\n        })\r\n                .mergeWith(Completable.create(emmit ->\r\n                        emmit.setCancellable(() -> System.out.println(\"mergeWith dispose\")))\r\n                        .doOnSubscribe(dis -> System.out.println(\"mergeWith doOnSubscribe\")).toObservable())\r\n                .subscribe(ob -> {}, System.out::println);\r\n```\r\n\r\nthe result is: \r\n```\r\nmergeWith doOnSubscribe\r\nmergeWith dispose\r\njava.lang.Throwable: occurs error\r\n```\r\n\r\nThe 'dispose' will be invoked\u3002\r\nIn case of first,it will produce a memory leak.\r\nIs that a bug?", "closed": "2019-07-30 07:27:04", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6597", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed"}, {"created": "2019-07-23 15:30:00", "user": "Erlkoenig90", "body": "Not sure if this intentional or a bug. The following code:\r\n```java\r\npackage Test;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport io.reactivex.Single;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n//\t\tObservable.just(0,1)\t\t// UndeliverableException - First concatMapSingle-block throws, interrupting second one\r\n\t\tObservable.just(2, 0)\t\t// Just \"MyError\" output, exception in first block appears to vanish\r\n\t\t\t\t.concatMapSingle(workItem2 -> {\r\n\t\t\t\t\treturn Single.just(workItem2).subscribeOn(Schedulers.computation()).map(workItem -> {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t\t\tif (workItem == 1)\r\n\t\t\t\t\t\t\t\tthrow new Exception(\"Something in first block failed\");\r\n\t\t\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\t\tSystem.out.println(\"InterruptedException in block 1\");\r\n\t\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn workItem;\r\n\t\t\t\t\t});\r\n\t\t\t\t}).concatMapSingle(workItem2 -> {\r\n\t\t\t\t\treturn Single.just(workItem2).subscribeOn(Schedulers.computation()).map(workItem -> {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t\t\tif (workItem == 2) {\r\n\t\t\t\t\t\t\t\tthrow new Exception(\"Something in second block failed\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\t\tSystem.out.println(\"InterruptedException in block 2\");\r\n\t\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn workItem;\r\n\t\t\t\t\t});\r\n\t\t\t\t}).blockingSubscribe(item -> System.out.println(\"Item finished \" + item), err -> {\r\n\t\t\t\t\tSystem.out.println(\"MyError: \" + err.toString());\r\n\t\t\t\t\terr.printStackTrace();\r\n\t\t\t\t});\r\n\t}\r\n}\r\n```\r\nhas 2 processing stages. If the first one throws an exception, the second one gets interrupted and throws an `UndeliverableException`. In the opposite case, if the 2nd block throws an exception, the 1st one gets interrupted, but its `InterruptedException` is completely ignored - not delivered to any error handler, nor thrown as `UndeliverableException`.\r\n\r\nThis is caused by some kind of race condition within `ConcatMapSingleMainObserver`. When the 2nd block throws, on the `ConcatMapSingleMainObserver` instance belonging to the 1st block, `dispose` is called before `innerError`. Because at this point `errors` is empty, `addThrowable` succeeds, but the `drain` loop is never called, because `dispose` has set the `AtomicInteger` to `1`. Therefore, the exception in `error` is never retrieved and forwarded.\r\n\r\nThis can be fixed (if it needs fixing, anyways) by having `innerError`, `dispose` and the `drain` loop check for `cancelled` and forward exceptions to `RxJavaPlugins.onError` if appropriate. I will make a PR...", "closed": "2019-08-05 15:25:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6587", "ttf": 12.000277777777777, "commits": {}, "labels": ["3.x", "Bug"], "title": "Inner errors within concatMapSingle vanish if disposed"}, {"created": "2019-07-17 14:15:06", "commits": {"e4eee64bf7b1e78a75b712130bdec12f340bb443": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2019-07-19 13:01:20", "filteredCommits": [], "commitsDetails": [{"nameRev": "e4eee64bf7b1e78a75b712130bdec12f340bb443 tags/v3.0.0-RC2~15", "commitMessage": "Fix issue #6576 - ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object (#6577)\n\n", "commitParents": ["a38268c738af7ae1ca50dc4af2bfbb5713361411"], "spoonStatsSkippedReason": "", "commitHash": "e4eee64bf7b1e78a75b712130bdec12f340bb443", "authoredDateTime": "2019-07-19 15:01:20", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 1, "deletions": 1, "lines": 2, "filePath": "src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java"}], "commitDateTime": "2019-07-19 15:01:20", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.observable.ObservableBlockingSubscribe.subscribe(io.reactivex.internal.operators.observable.ObservableSource,io.reactivex.internal.operators.observable.Observer)"}], "spoonFilePath": "ObservableBlockingSubscribe.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/6576", "ttf": 1.0002777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object", "statsSkippedReason": "", "user": "Erlkoenig90", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "The `ObservableBlockingSubscribe.observe` function appears to compare the `o` variable, i.e. the `ObservableSource`, which shouldn't ever change, with `BlockingObserver.TERMINATED`. This will probably never be true. The intention was likely to use `v` instead of `o`, in:\r\n\r\nhttps://github.com/ReactiveX/RxJava/blob/a38268c738af7ae1ca50dc4af2bfbb5713361411/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java#L64 \r\n\r\nSince this appears to be somewhat redundant with `bs.isDisposed()`, this probably does not cause any issues.", "labels": ["2.x", "3.x", "Bug", "PR welcome"]}, {"created": "2019-07-04 13:25:03", "user": "hluhovskyi", "body": "Hey there!\r\nI've faced with an issue when debouncing empty source it leads NPE. Here is simple test which demonstrates a problem:\r\n```\r\n@Test\r\npublic void debounceOnEmpty() {\r\n    Observable.empty().debounce(new Function<Object, ObservableSource<Object>>() {\r\n        @Override\r\n        public ObservableSource<Object> apply(Object o) {\r\n            return Observable.just(new Object());\r\n        }\r\n    }).subscribe();\r\n}\r\n```\r\n\r\nIssue also touches `Flowable` in the same way. RxJava version is 2.2.7 however it is also reproducible for latest 3.x.\r\n\r\nI am going to create PR with a fix soon for both of versions, let's keep this ticket to track a state of the issue.\r\n", "closed": "2019-07-05 06:10:35", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6558", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "2.x/3.x - NPE when debouncing empty source"}, {"created": "2019-06-20 02:14:43", "user": "LiuShuaiQ", "body": "RxJava version 2.2.9.\r\n\r\nI feel doubt about `Flowable#concatMapDelayError`, when I use `Flowable#fromCallable`\r\n\r\nThe following code:\r\n```java\r\n   Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)\r\n        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {\r\n          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {\r\n            return Flowable.fromCallable(new Callable<Integer>() {\r\n              @Override public Integer call() throws Exception {\r\n                if (integer >= 100) {\r\n                  throw new NullPointerException(\"test null exp\");\r\n                }\r\n                return integer;\r\n              }\r\n            });\r\n          }\r\n        })\r\n        .subscribe(new Consumer<Integer>() {\r\n          @Override public void accept(Integer integer) throws Exception {\r\n            Log.e(TAG, \"test-->complete-\" + integer);\r\n          }\r\n        }, new Consumer<Throwable>() {\r\n          @Override public void accept(Throwable throwable) throws Exception {\r\n            Log.e(TAG, \"test-->error-\" + throwable);\r\n          }\r\n        });\r\n\r\n```\r\n\r\nThe following output:\r\n```\r\n  test-->complete-1\r\n  test-->complete-2\r\n  test-->complete-3\r\n  test-->error-java.lang.NullPointerException: test null exp\r\n```\r\n\r\n\r\nIt do not delay error. But I use `Observable` is success delayed the error, And I use `Flowable#create` is success delayed the error.\r\n\r\nThe following code:\r\n```java\r\n    Observable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)\r\n        .concatMapDelayError(new Function<Integer, Observable<Integer>>() {\r\n          @Override public Observable<Integer> apply(final Integer integer) throws Exception {\r\n            return Observable.fromCallable(new Callable<Integer>() {\r\n              @Override public Integer call() throws Exception {\r\n                if (integer >= 100) {\r\n                  throw new NullPointerException(\"test null exp\");\r\n                }\r\n                return integer;\r\n              }\r\n            });\r\n          }\r\n        })\r\n        .subscribe(new Consumer<Integer>() {\r\n          @Override public void accept(Integer integer) throws Exception {\r\n            Log.e(TAG, \"test-->complete-\" + integer);\r\n          }\r\n        }, new Consumer<Throwable>() {\r\n          @Override public void accept(Throwable throwable) throws Exception {\r\n            Log.e(TAG, \"test-->error-\" + throwable);\r\n          }\r\n        });\r\n```\r\n\r\nThe following output:\r\n```\r\n  test-->complete-1\r\n  test-->complete-2\r\n  test-->complete-3\r\n  test-->complete-23\r\n  test-->complete-32\r\n  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. \r\n```\r\n\r\nThe following code:\r\n```java\r\n    Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)\r\n        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {\r\n          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {\r\n            return Flowable.create(new FlowableOnSubscribe<Integer>() {\r\n              @Override public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {\r\n                if (integer >= 100) {\r\n                  throw new NullPointerException(\"test null exp\");\r\n                }\r\n                emitter.onNext(integer);\r\n                emitter.onComplete();\r\n              }\r\n            }, BackpressureStrategy.BUFFER);\r\n          }\r\n        })\r\n        .subscribe(new Consumer<Integer>() {\r\n          @Override public void accept(Integer integer) throws Exception {\r\n            Log.e(TAG, \"test-->complete-\" + integer);\r\n          }\r\n        }, new Consumer<Throwable>() {\r\n          @Override public void accept(Throwable throwable) throws Exception {\r\n            Log.e(TAG, \"test-->error-\" + throwable);\r\n          }\r\n        });\r\n```\r\n\r\nThe following output:\r\n```\r\n  test-->complete-1\r\n  test-->complete-2\r\n  test-->complete-3\r\n  test-->complete-23\r\n  test-->complete-32\r\n  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. \r\n```", "closed": "2019-06-20 12:34:48", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6520", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "Issus about Flowable concatMapDelayError"}, {"created": "2019-06-13 21:32:56", "user": "akarnokd", "body": "This test eventually times out because one of the sources will not complete or trigger a reconnection:\r\n\r\n```java\r\nfor (int i = 0; i < 10_000; i++) {\r\n    Observable<Integer> observable = Observable.just(1).publish().refCount();\r\n\r\n    TestObserver<Integer> observer1 = observable\r\n        .subscribeOn(Schedulers.computation())\r\n        .test();\r\n\r\n        TestObserver<Integer> observer2 = observable\r\n        .subscribeOn(Schedulers.computation())\r\n        .test();\r\n\r\n    observer1\r\n        .withTag(\"observer1 \" + i)\r\n        .awaitDone(5, TimeUnit.SECONDS)\r\n        .assertNoErrors()\r\n        .assertComplete();\r\n\r\n    observer2\r\n        .withTag(\"observer2 \" + i)\r\n        .awaitDone(5, TimeUnit.SECONDS)\r\n        .assertNoErrors()\r\n        .assertComplete();\r\n}\r\n```\r\n\r\n(Originally reported as a [comment](https://github.com/ReactiveX/RxJava/pull/6187#issuecomment-501879711).)", "closed": "2019-06-20 19:30:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6501", "ttf": 6.000277777777778, "commits": {}, "labels": ["2.x", "3.x", "Bug"], "title": "publish().refCount() race may leave observers hanging"}, {"created": "2019-05-26 15:51:43", "user": "bitvale", "body": "While reading [Error handling on wiki](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling)  I realized that in a zip operator with a multiple network calls, it's possible to receive a crash with an UndeliverableException. I tried to reproduce this behavior:\r\n \r\nRxJava version: 2.2.0\r\n\r\nReproduce code:\r\n\r\n```\r\n    @Test\r\n    public void testUncaughtException() throws InterruptedException {\r\n        Observable first = Observable.create(e -> {\r\n            System.out.println(\"first\");\r\n            throw new HelperException(\"first exception\");\r\n        });\r\n\r\n        Observable second = Observable.create(e -> {\r\n            System.out.println(\"second\");\r\n            throw new HelperException(\"second exception\");\r\n        });\r\n\r\n        List<Observable<?>> observableList = new ArrayList<>();\r\n        observableList.add(first);\r\n        observableList.add(second);\r\n\r\n        Observable.zip(observableList, objects -> \"result\")\r\n                .subscribeOn(Schedulers.io())\r\n                .subscribe(\r\n                        System.out::println,\r\n                        t -> {\r\n                            System.out.println(\"exception caught!\");\r\n                        }\r\n                );\r\n        Thread.sleep(2000);\r\n    }\r\n```\r\nThe output as expected:\r\n\r\n```\r\nfirst\r\nexception caught!\r\nsecond\r\nio.reactivex.exceptions.UndeliverableException: ... HelperException: second exception ...\r\n```\r\n\r\nAnd the second test:\r\n\r\n```\r\n    @Test\r\n    public void testUncaughtExceptionWithFlatMap() throws InterruptedException {\r\n        Observable testObservable = Observable.create(e -> e.onNext(\"\"))\r\n                .flatMap((Function<Object, ObservableSource<?>>) o -> {\r\n\r\n                    Observable first = Observable.create(e -> {\r\n                        System.out.println(\"first\");\r\n                        throw new HelperException(\"first exception\");\r\n                    });\r\n\r\n                    Observable second = Observable.create(e -> {\r\n                        System.out.println(\"second\");\r\n                        throw new HelperException(\"second exception\");\r\n                    });\r\n\r\n                    List<Observable<?>> observableList = new ArrayList<>();\r\n                    observableList.add(first);\r\n                    observableList.add(second);\r\n\r\n                    return Observable.zip(observableList, objects -> \"result\");\r\n                });\r\n\r\n        testObservable\r\n                .subscribeOn(Schedulers.io())\r\n                .subscribe(\r\n                        System.out::println,\r\n                        t -> System.out.println(\"exception caught!\")\r\n                );\r\n\r\n        Thread.sleep(2000);\r\n    }\r\n```\r\nAnd I expected an UndeliverableException too, but the output is:\r\n\r\n```\r\nfirst\r\nexception caught!\r\n```\r\n\r\nIs this behavior correct? Why there is no UndeliverableException in the second test?\r\n\r\nThanks!\r\n\r\n\r\n", "closed": "2019-05-27 08:23:33", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6487", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Multiple errors in zip'ed observables with flatMap"}, {"created": "2019-04-23 22:20:42", "user": "slisaasquatch", "body": "I'm on version 2.2.8.\r\nHere's my code snippet:\r\n```java\r\n\tpublic static void main(String[] args) {\r\n\t\tFlowable<Integer> f1 = Flowable.just(1)\r\n\t\t\t\t.delaySubscription(1, TimeUnit.MILLISECONDS)\r\n\t\t\t\t.doOnNext(i -> {\r\n\t\t\t\t\tSystem.out.println(\"f1: \" + i);\r\n\t\t\t\t})\r\n\t\t\t\t.cache();\r\n\t\tFlowable<Integer> f2 = f1.map(i -> i + 1)\r\n\t\t\t\t.doOnNext(i -> {\r\n\t\t\t\t\tSystem.out.println(\"f2: \" + i);\r\n\t\t\t\t})\r\n\t\t\t\t.cache();\r\n\t\tFlowable<Integer> f3 = f1\r\n\t\t\t\t.map(i -> {\r\n\t\t\t\t\treturn f2.blockingFirst() + 1; // This is where it gets stuck\r\n\t\t\t\t})\r\n\t\t\t\t.doOnNext(i -> {\r\n\t\t\t\t\tSystem.out.println(\"f3: \" + i);\r\n\t\t\t\t});\r\n\t\tFlowable<Integer> f4 = f3\r\n\t\t\t\t.zipWith(f2, (f3Val, f2Val) -> 4)\r\n\t\t\t\t.doOnNext(i -> {\r\n\t\t\t\t\tSystem.out.println(\"f4: \" + i);\r\n\t\t\t\t});\r\n\t\t// If I use the version of f4 below, everything will work.\r\n//\t\tFlowable<Integer> f4 = f3\r\n//\t\t\t\t.concatMap(f3Val -> f2.map(f2Val -> 4))\r\n//\t\t\t\t.doOnNext(i -> {\r\n//\t\t\t\t\tSystem.out.println(\"f4: \" + i);\r\n//\t\t\t\t});\r\n\t\tSystem.out.println(f4.blockingFirst());\r\n\t}\r\n```\r\nThe code above will get stuck at `return f2.blockingFirst() + 1;`.\r\nIf `f4` is replaced with the version in the commented code, `blockingFirst` will not get stuck.\r\nCan someone please provide an explanation of why this is happening? Thanks!", "closed": "2019-04-24 10:36:34", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6464", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[Question] Flowable.blockingFirst gets stuck"}, {"created": "2019-02-12 20:04:06", "user": "rossdanderson", "body": "Hi, I have a question regarding the behaviour of concatEager in version 2.2.6.\r\n\r\nWe were caught out recently by the behaviour of concatEager when the downstream unsubscribes before the upstream sources have completed, namely that the upstream sources are not unsubscribed from when this happens. This left us with a rather nasty memory leak in our application due to some downstream periodical resubscription logic.\r\n\r\nConsider the following two tests (apologies for the Kotlin, I can convert to Java on request, but I hope it makes sense)\r\n\r\n```\r\n    @Test\r\n    fun concat() {\r\n        val _publisher1 = PublishProcessor.create<Unit>()\r\n        val _publisher2 = PublishProcessor.create<Unit>()\r\n        val publisher1 = _publisher1.doOnSubscribe { println(\"1 Subscribed\") }.doOnCancel { println(\"1 Cancelled\") }\r\n        val publisher2 = _publisher2.doOnSubscribe { println(\"2 Subscribed\") }.doOnCancel { println(\"2 Cancelled\") }\r\n\r\n        assertFalse(_publisher1.hasSubscribers())\r\n        assertFalse(_publisher2.hasSubscribers())\r\n\r\n        val testSubscriber = Flowable.concat(Flowable.just(publisher1, publisher2))\r\n            .subscribe()\r\n\r\n        assertTrue(_publisher1.hasSubscribers())\r\n        assertFalse(_publisher2.hasSubscribers())\r\n\r\n        testSubscriber.dispose()\r\n\r\n        assertFalse(_publisher1.hasSubscribers())\r\n        assertFalse(_publisher2.hasSubscribers())\r\n    }\r\n\r\n    @Test\r\n    fun concatEager() {\r\n        val _publisher1 = PublishProcessor.create<Unit>()\r\n        val _publisher2 = PublishProcessor.create<Unit>()\r\n        val publisher1 = _publisher1.doOnSubscribe { println(\"1 Subscribed\") }.doOnCancel { println(\"1 Cancelled\") }\r\n        val publisher2 = _publisher2.doOnSubscribe { println(\"2 Subscribed\") }.doOnCancel { println(\"2 Cancelled\") }\r\n\r\n        assertFalse(_publisher1.hasSubscribers())\r\n        assertFalse(_publisher2.hasSubscribers())\r\n\r\n        val testSubscriber = Flowable.concatEager(Flowable.just(publisher1, publisher2))\r\n            .subscribe()\r\n\r\n        assertTrue(_publisher1.hasSubscribers())\r\n        assertTrue(_publisher2.hasSubscribers())\r\n\r\n        testSubscriber.dispose()\r\n\r\n        assertFalse(_publisher1.hasSubscribers())\r\n        assertFalse(_publisher2.hasSubscribers())\r\n    }\r\n```\r\n\r\nThe first test (concat) completes successfully with the following output:\r\n```\r\n1 Subscribed\r\n1 Cancelled\r\n```\r\nAs we expected, `_publisher1` was unsubscribed from when the `testSubscriber` is disposed.\r\n\r\nThe second test (concatEager) fails however with the following output:\r\n```\r\n1 Subscribed\r\n2 Subscribed\r\n2 Cancelled\r\n```\r\nThis doesn't behave as we expected, with the current active publisher `_publisher1` not having been unsubscribed from when the `testSubscriber` is disposed.\r\n\r\nNow the wording on the documentation is different - concat:\r\n\r\n> Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source Publisher, one after the other, without interleaving them.\r\n\r\nvs concatEager:\r\n\r\n> The operator buffers the values emitted by these Publishers and then drains them in order, each one after the previous one completes.\r\n\r\nBut this was not enough to convey the rather large difference in behaviour with the upstream dispose, to us at least, if this is indeed what it was attempting to convey.\r\n\r\nSo my questions really are\r\nIs this behaviour expected, or should concatEager dispose all of the upstream sources, including the active one, when it is itself disposed?\r\nIf this is the expected behaviour, do you think the documentation should/could be improved here?", "closed": "2019-02-12 22:24:47", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6404", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "concatEager does not unsubscribe from sources"}, {"created": "2019-02-05 18:02:23", "user": "vganin", "body": "Hi,\r\n\r\nI believe I encountered `window` operator leaking observable subscriptions. Here is a small test to reproduce the issue:\r\n```\r\nfun main(args: Array<String>) {\r\n    observable(1).window(observable(2).filter { it == 1 }, Function { _: Int -> observable(3).filter { it == 1 } }, 1)\r\n            .subscribe()\r\n            .dispose()\r\n}\r\n\r\nprivate fun observable(n: Int): Observable<Int> {\r\n    return Observable.create<Int> { emitter ->\r\n        println(\"Subscribed! $n\")\r\n        emitter.onNext(1)\r\n        emitter.onNext(2)\r\n        emitter.onNext(3)\r\n        emitter.setCancellable { println(\"Cancelled! $n\") }\r\n    }\r\n}\r\n```\r\n\r\nThe output is:\r\n```\r\nSubscribed! 2\r\nSubscribed! 3\r\nCancelled! 3\r\nSubscribed! 1\r\n```\r\n\r\nFrom the output you can see that cancellables for `observable(1)` and `observable(2)` are never called.\r\n\r\nThis may be severe if cancellables are used to dispose some (possibly) critical resources upon subscription disposal.", "closed": "2019-02-13 08:51:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6397", "ttf": 7.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[2.2.6] window() operator leaks subscriptions"}, {"created": "2019-01-17 04:50:51", "user": "ArtemShaban", "body": "I tested issue on RxJava 2.2.5\r\n\r\nI encountered the issue when Single.observeOn interrupt the thread, that performs downstream operation.\r\n\r\nBelow code of unit test and a slightly modified for test purposes \"SingleObserveOn\" class.\r\n\r\n```\r\n@Test\r\npublic void test() throws InterruptedException\r\n{\r\n    Single.ambArray\r\n            (\r\n                    Single\r\n                            .fromCallable(() ->\r\n                            {\r\n                                System.out.println(System.currentTimeMillis() + \" \" + \"Callable1! \" + Thread.currentThread());\r\n                                return \"Qqq\";\r\n                            })\r\n                            .subscribeOn(Schedulers.newThread())\r\n                            .observeOn(Schedulers.newThread())\r\n                    ,\r\n                    Single.never()\r\n            )\r\n          .subscribe((s, throwable) ->\r\n          {\r\n              System.out.println(System.currentTimeMillis() + \" \" + \"Subscribe1 and blocking await! \" + Thread.currentThread());\r\n\r\n              Completable.timer(1000, TimeUnit.MILLISECONDS).blockingAwait();\r\n\r\n              System.out.println(System.currentTimeMillis() + \" \" + \"Subscribe2! \" + Thread.currentThread());\r\n              System.out.println(s);\r\n          });\r\n\r\n    Thread.sleep(10000);\r\n}\r\n```\r\n\r\n```\r\npublic final class SingleObserveOn<T> extends Single<T>\r\n{\r\n\r\n    final SingleSource<T> source;\r\n\r\n    final Scheduler scheduler;\r\n\r\n    public SingleObserveOn(SingleSource<T> source, Scheduler scheduler)\r\n    {\r\n        this.source = source;\r\n        this.scheduler = scheduler;\r\n    }\r\n\r\n    @Override\r\n    protected void subscribeActual(final SingleObserver<? super T> observer)\r\n    {\r\n        source.subscribe(new ObserveOnSingleObserver<T>(observer, scheduler));\r\n    }\r\n\r\n    static final class ObserveOnSingleObserver<T> extends AtomicReference<Disposable>\r\n            implements SingleObserver<T>, Disposable, Runnable\r\n    {\r\n        private static final long serialVersionUID = 3528003840217436037L;\r\n\r\n        final SingleObserver<? super T> downstream;\r\n\r\n        final Scheduler scheduler;\r\n\r\n        T value;\r\n        Throwable error;\r\n\r\n        ObserveOnSingleObserver(SingleObserver<? super T> actual, Scheduler scheduler)\r\n        {\r\n            this.downstream = actual;\r\n            this.scheduler = scheduler;\r\n        }\r\n\r\n        @Override\r\n        public void onSubscribe(Disposable d)\r\n        {\r\n            if (DisposableHelper.setOnce(this, d))\r\n            {\r\n                downstream.onSubscribe(this);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onSuccess(T value)\r\n        {\r\n            this.value = value;\r\n\r\n            System.out.println(System.currentTimeMillis() + \" \" + \"ObserveOnSingleObserver.onSuccess1! \" + Thread.currentThread());\r\n\r\n            Disposable d = scheduler.scheduleDirect(this);\r\n            //I added this loop for simulate \"busy\" thread situation.\r\n            for (int i = 0; i < 1_000_000; i++)\r\n            {\r\n            }\r\n\r\n            System.out.println(System.currentTimeMillis() + \" \" + \"ObserveOnSingleObserver.onSuccess2! \" + Thread.currentThread());\r\n\r\n            DisposableHelper.replace(this, d);\r\n        }\r\n\r\n        @Override\r\n        public void onError(Throwable e)\r\n        {\r\n            this.error = e;\r\n            Disposable d = scheduler.scheduleDirect(this);\r\n            DisposableHelper.replace(this, d);\r\n        }\r\n\r\n        @Override\r\n        public void run()\r\n        {\r\n            System.out.println(System.currentTimeMillis() + \" \" + \"ObserveOnSingleObserver.run! \" + Thread.currentThread());\r\n\r\n            Throwable ex = error;\r\n            if (ex != null)\r\n            {\r\n                downstream.onError(ex);\r\n            }\r\n            else\r\n            {\r\n                downstream.onSuccess(value);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void dispose()\r\n        {\r\n            System.out.println(System.currentTimeMillis() + \" \" + \"ObserveOnSingleObserver.dispose! \" + Thread.currentThread());\r\n            DisposableHelper.dispose(this);\r\n        }\r\n\r\n        @Override\r\n        public boolean isDisposed()\r\n        {\r\n            return DisposableHelper.isDisposed(get());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nResult of run this test next:\r\n```\r\n1547699583389 Callable1! Thread[RxNewThreadScheduler-1,5,main]\r\n1547699583389 ObserveOnSingleObserver.onSuccess1! Thread[RxNewThreadScheduler-1,5,main]\r\n1547699583390 ObserveOnSingleObserver.run! Thread[RxNewThreadScheduler-2,5,main]\r\n1547699583390 ObserveOnSingleObserver.dispose! Thread[RxNewThreadScheduler-2,5,main]\r\n1547699583390 Subscribe1 and blocking await! Thread[RxNewThreadScheduler-2,5,main]\r\n1547699583393 ObserveOnSingleObserver.onSuccess2! Thread[RxNewThreadScheduler-1,5,main]\r\nio.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | java.lang.RuntimeException: java.lang.InterruptedException\r\n\tat io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\r\n\tat io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:60)\r\n\tat io.reactivex.internal.operators.single.SingleAmb$AmbSingleObserver.onSuccess(SingleAmb.java:110)\r\n\tat io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:112)\r\n\tat io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nCaused by: java.lang.RuntimeException: java.lang.InterruptedException\r\n\tat io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:46)\r\n\tat io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:93)\r\n\tat io.reactivex.Completable.blockingAwait(Completable.java:1219)\r\n\tat com.multibrains.InterruptedExceptionTest.lambda$test$1(InterruptedExceptionTest.java:44)\r\n\tat io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:57)\r\n\t... 11 more\r\nCaused by: java.lang.InterruptedException\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)\r\n\tat java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\r\n\tat io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:90)\r\n\t... 14 more\r\nException in thread \"RxNewThreadScheduler-2\" io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | java.lang.RuntimeException: java.lang.InterruptedException\r\n\tat io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)\r\n\tat io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:60)\r\n\tat io.reactivex.internal.operators.single.SingleAmb$AmbSingleObserver.onSuccess(SingleAmb.java:110)\r\n\tat io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:112)\r\n\tat io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nCaused by: java.lang.RuntimeException: java.lang.InterruptedException\r\n\tat io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:46)\r\n\tat io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:93)\r\n\tat io.reactivex.Completable.blockingAwait(Completable.java:1219)\r\n\tat com.multibrains.InterruptedExceptionTest.lambda$test$1(InterruptedExceptionTest.java:44)\r\n\tat io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:57)\r\n\t... 11 more\r\nCaused by: java.lang.InterruptedException\r\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)\r\n\tat java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\r\n\tat io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:90)\r\n\t... 14 more\r\n```\r\n\r\n\r\n**explanation:**\r\n\r\n```Callable1! Thread[RxNewThreadScheduler-1,5,main]``` - just return value\r\n\r\n```ObserveOnSingleObserver.onSuccess1! Thread[RxNewThreadScheduler-1,5,main]``` - after this line value scheduled to ```RxNewThreadScheduler-2```, and sometime in the future will be excuted. And current thread  ```RxNewThreadScheduler-1``` stuck for any reason.\r\n\r\n``` ObserveOnSingleObserver.run! Thread[RxNewThreadScheduler-2,5,main]``` - scheduled value ecxecuting\r\n\r\n```ObserveOnSingleObserver.dispose! Thread[RxNewThreadScheduler-2,5,main]``` - ObserveOnSingleObserver is disposing, cause value was throw to the donwstream\r\n\r\n```Subscribe1 and blocking await! Thread[RxNewThreadScheduler-2,5,main]``` - we get value in subscribe callback and do some long operaion (for example blocking await)\r\n\r\n```ObserveOnSingleObserver.onSuccess2! Thread[RxNewThreadScheduler-1,5,main]``` - ```RxNewThreadScheduler-1``` revive and continue do his work...so it replace disposable, and see than current disposable have already disposed...and he cancel future (that related long operation started in ```RxNewThreadScheduler-2```), and interrupt ```RxNewThreadScheduler-2``` thread.\r\n\r\n\r\n\r\n", "closed": "2019-01-17 14:28:31", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6373", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Single.observeOn wrongly interrupt thread"}, {"created": "2019-01-14 11:02:14", "user": "Whathecode", "body": "For some time, I [have been investigating a deadlock that occurs in my codebase](https://stackoverflow.com/q/54116679/590790), seemingly after the default backbuffer size has been filled. While trying to create a repro, I ran into a similar issue which shows the same symptoms with a minimum amount of code. I see no obvious cause, and therefore believe this might be a potential RxJava 2.x bug (reproducible so far on 2.2.0 and 2.2.5).\r\n\r\n```\r\nfun main( args: Array<String> )\r\n{\r\n    // Override the default buffer size of 128 to 10 for easier testing.\r\n    System.setProperty( \"rx2.buffer-size\", \"10\" )\r\n\r\n    val numbers = Flowable\r\n        .range( 0, Int.MAX_VALUE )\r\n        // Commenting out '.doOnSubscribe' here prevents the deadlock.\r\n        .doOnSubscribe { println( \"Subscribed.\" ) }\r\n        .share()\r\n    val evenNumbers = numbers\r\n        .filter { number -> number % 2 == 0 }\r\n    val oddNumbers = numbers\r\n        .filter { number -> number % 2 != 0 }\r\n    val getNextOdd = oddNumbers.first( 0 )\r\n    evenNumbers\r\n        .concatMap { even ->\r\n            Single.zip(\r\n                Single.just( even ), getNextOdd,\r\n                BiFunction { a: Int, b: Int -> Pair( a, b ) }\r\n            ).toFlowable()\r\n        }\r\n        .takeWhile { it.first < 1000 }\r\n        .doOnComplete { println( \"Done.\" ) }\r\n        .subscribe { println( it ) }\r\n\r\n    readLine()\r\n}\r\n```\r\nThis halts depending on the backbuffer size. In the code example at:\r\n\r\n> Subscribed.\r\n> (0, 1)\r\n> (2, 3)\r\n> (4, 5)\r\n> (6, 7)\r\n> (8, 9)\r\n\r\nAs commented in the above code, commenting out the `doOnSubscribe` line will prevent the deadlock from occurring.\r\n\r\nIs this a bug, or am I doing something inherently wrong? E.g., I imagine things get complicated the way I reuse the same stream to 'zip', but this is the use case which also is needed in my actual codebase. Regardless, I do not understand what `doOnSubscribe` would have to do with anything here.", "closed": "2019-01-15 10:37:22", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6363", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Deadlock when adding doOnSubscribe to Flowable"}, {"created": "2019-01-04 19:42:16", "user": "eleventigers", "body": "Issue encountered in: io.reactivex.rxjava2:rxjava:2.2.4\r\n\r\nWhen using a combination of takeUntil/repeatWhen operators on an Observable with delaySubscription operator applied, it is possible to encounter a ProtocolViolationException: Disposable already set! thrown by RepeatWhenObserver#onSubscribe. It appears that if delaySubscription uses an ObservableSource which rapidly/concurrently emits multiple notifications a rare race condition leads to a double subscription issue.\r\n\r\nI am not sure if this issue is a user error (take(1) on ObservableSource supplied to delaySubscription alleviates it) or a bug in RxJava however the following, slow unit test demonstrates it:\r\n\r\n```java\r\n\r\n    @Test\r\n    public void delaySubscriptionWithRepeatWhen() {\r\n        List<Throwable> errors = TestHelper.trackPluginErrors();\r\n\r\n        ExecutorService executor = Executors.newFixedThreadPool(2);\r\n        try {\r\n            Observable<Object> subscriptionSignal = Observable.merge(\r\n                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS),\r\n                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS)\r\n            );\r\n\r\n            final Subject<Boolean> boolStream = PublishSubject.<Boolean>create().toSerialized();\r\n\r\n            Observable<Boolean> brokenStream = boolStream\r\n                    .delaySubscription(subscriptionSignal)\r\n                    .takeUntil(new Predicate<Boolean>()  {\r\n                        @Override\r\n                        public boolean test(Boolean state) throws Exception {\r\n                            return state;\r\n                        }\r\n                    })\r\n                    .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {\r\n                        @Override\r\n                        public ObservableSource<?> apply(Observable<Object> objectObservable) throws Exception {\r\n                            return boolStream.filter(new Predicate<Boolean>() {\r\n                                @Override\r\n                                public boolean test(Boolean state) throws Exception {\r\n                                    return !state;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n\r\n            final Random random = new Random();\r\n            for (int i = 0; i < 1000000; i++) {\r\n                final TestObserver<Boolean> testObserver = brokenStream.test();\r\n                executor.execute(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        boolStream.onNext(random.nextBoolean());\r\n                        testObserver\r\n                                .assertNoErrors()\r\n                                .dispose();\r\n                    }\r\n                });\r\n                if (!errors.isEmpty()) {\r\n                    fail(\"Uncaught fatal errors: \" + errors);\r\n                }\r\n            }\r\n        } finally {\r\n            executor.shutdown();\r\n            try {\r\n                executor.awaitTermination(30, TimeUnit.SECONDS);\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n    }\r\n```", "closed": "2019-01-04 23:39:21", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6358", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Disposable already set! using delaySubscription with takeUntil/repeatWhen"}, {"created": "2018-11-08 22:49:04", "user": "akarnokd", "body": "The following tests fail because the cancel/dispose from the downstream comes before the actual connection is established which leaves the connectable source in a disposed state, refusing to take in new subscribers/observers:\r\n\r\n```java\r\n@Test\r\npublic void test() {\r\n    BehaviorSubject<Integer> subject = BehaviorSubject.create();\r\n\r\n    Observable<Integer> observable = subject\r\n            .replay(1)\r\n            .refCount();\r\n\r\n    observable.takeUntil(Observable.just(1)).test();\r\n\r\n    subject.onNext(2);\r\n\r\n    observable.take(1).test().assertResult(2);\r\n}\r\n\r\n\r\n@Test\r\npublic void test2() {\r\n    BehaviorProcessor<Integer> processor = BehaviorProcessor.create();\r\n\r\n    Flowable<Integer> flowable = processor\r\n            .replay(1)\r\n            .refCount();\r\n\r\n    // This line causes the test to fail.\r\n    flowable.takeUntil(Flowable.just(1)).test();\r\n\r\n    processor.onNext(2);\r\n\r\n    flowable.take(1).test().assertResult(2);\r\n}\r\n```", "closed": "2018-11-12 09:26:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6296", "ttf": 3.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: refCount doesn't reset its source if one of its subscribers cancels immediately"}, {"created": "2018-11-01 21:55:15", "user": "yklymenko", "body": "RxJava 2.2.3\r\n\r\nFollowing code reproduces the problem:\r\n\r\n```java\r\npublic class TestObs {\r\n\r\n    static public void main(String[] args) {\r\n\r\n        AtomicInteger count = new AtomicInteger();\r\n\r\n        Scheduler scheduler = Schedulers.from(Executors.newCachedThreadPool());\r\n        Observable.range(0, 400)\r\n                .flatMap(i -> Observable.just(i).subscribeOn(scheduler).map(x -> {\r\n                     System.out.println(\"Start \" + Thread.currentThread().getName()\r\n                        + \" \" + x + \" concurrent \" + count.incrementAndGet());\r\n                     Thread.sleep(1000);\r\n                     System.out.println(\"End \" + Thread.currentThread().getName()\r\n                        + \" \" + x + \" concurrent \" + count.decrementAndGet());\r\n\r\n                     return x;\r\n                  }),\r\n                  30\r\n                ).ignoreElements().blockingGet();\r\n    }\r\n}\r\n```\r\n\r\nAt the end you will see that only 1 child will be executed concurrently. At the beginning it is 30. \r\n\r\nIt is about flatMap operator with concurrency argument. In the case if you use concurrency Integer.MAX_VALUE with fixed pool is everything ok. \r\nThe problem happens in the case if more than one inner process are done in the same drainLoop. \r\nI think it is here (io.reactivex.internal.operators.observable.ObservableFlatMap 448)\r\n\r\n```java\r\n                        SimpleQueue<U> innerQueue = is.queue;\r\n                        if (innerDone && (innerQueue == null || innerQueue.isEmpty())) {\r\n                            removeInner(is);\r\n                            if (checkTerminate()) {\r\n                                return;\r\n                            }\r\n                            innerCompleted = true;\r\n                        }\r\n```\r\nMore then one will be removed, but innerCompleted pulls only one as replacement (io.reactivex.internal.operators.observable.ObservableFlatMap 468) \r\n\r\n\r\n", "closed": "2018-11-05 10:34:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6282", "ttf": 3.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "flatMap concurrency decrease in case of simultaneous finishing in the child observables"}, {"created": "2018-08-30 08:40:48", "user": "BernhardReu", "body": "First, I want to thank you for this wonderful library which I gladly use in many professional applications!\r\n\r\nWhile I was writing a component for one of our company applications, I wrote a multithreaded stress test, because the component itself introduces shared state. Sometimes the test failed. Of course, I suspected my component to be the culprit. After further investigation I could completely rule out my own component and still reproduce the problem. \r\nI think there could be a problem with the `refCount()` operator.\r\n\r\nLess words, more code:\r\n\r\nThe problem is reproducible with the following unit test (well, at least as reproducible as a test in a multithreaded manner can be...)\r\n\r\n```\r\npublic void replayRefCountShallBeThreadSafe() {\r\n        for (int i = 0; i < 10000; i++) {\r\n            Observable<Object> observable = Observable.just(new Object()).replay(1).refCount();\r\n\r\n            TestObserver<Object> observer1 = observable\r\n                    .subscribeOn(Schedulers.io())\r\n                    .test();\r\n\r\n            TestObserver<Object> observer2 = observable\r\n                    .subscribeOn(Schedulers.io())\r\n                    .test();\r\n\r\n            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));\r\n            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));\r\n        }\r\n}\r\n```\r\n\r\nAs you can see, I am repeating the logic 10000 times. This (mostly) guarantees that the test fails on my environment. One of the observers does NOT receive the completed event and therefore the `awaitTerminalEvent` times out.\r\n\r\nOn the other hand, the following unit test where I manually `.connect()` the `ConnectableObservable`  returned vom `.replay(1)` passes:\r\n\r\n```\r\npublic void replayShallBeThreadSafe() {\r\n        for (int i = 0; i < 10000; i++) {\r\n            ConnectableObservable<Object> observable = Observable.just(new Object()).replay(1);\r\n            Disposable connection = observable.connect();\r\n\r\n            TestObserver<Object> observer1 = observable\r\n                    .subscribeOn(Schedulers.io())\r\n                    .test();\r\n\r\n            TestObserver<Object> observer2 = observable\r\n                    .subscribeOn(Schedulers.io())\r\n                    .test();\r\n\r\n            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));\r\n            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));\r\n            connection.dispose();\r\n        }\r\n}\r\n```\r\n\r\nPlease tell me if I am missing something...\r\n\r\nVersion: RxJava 2.2.0\r\nTests are JUnit tests, with hamcrest assertions.\r\n\r\nThanks!\r\n\r\n", "closed": "2018-08-30 13:29:59", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6185", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Possible concurrency issue with .refCount()? (2.2.0)"}, {"created": "2018-08-07 18:35:19", "user": "damianw", "body": "There appears to be a bug, or at the very least an undocumented and unexpected case,  where `FlowablePublish` causes upstream operators to be applied on the subscription scheduler rather than the upstream observation scheduler (due to `poll`ing). This is reproducible at least in `2.1.x` and `2.2.0`.\r\n\r\n#### Sample (Kotlin)\r\n```Kotlin\r\n    val scheduler1 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->\r\n        Thread(runnable, \"scheduler1\")\r\n    })\r\n\r\n    val scheduler2 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->\r\n        Thread(runnable, \"scheduler2\")\r\n    })\r\n\r\n    val flowable: Flowable<Long> = Flowable.interval(1L, TimeUnit.MILLISECONDS)\r\n            .onBackpressureLatest()\r\n            .take(10_000)\r\n            .observeOn(scheduler1)\r\n            .map {\r\n                val threadName = Thread.currentThread().name\r\n                if (threadName != \"scheduler1\") {\r\n                    throw AssertionError(\"Wrong thread: $threadName\")\r\n                }\r\n                it\r\n            }\r\n            .share()\r\n\r\n    flowable\r\n            .observeOn(scheduler2)\r\n            .doOnNext { Thread.sleep(10L) }\r\n            .subscribe {\r\n                println(\"onNext on ${Thread.currentThread().name}: $it\")\r\n            }\r\n```\r\n\r\n#### Expected Behavior\r\nIt should be expected that the `.map` operator is applied on the `scheduler1` scheduler since it is the scheduler supplied to `observeOn` immediately upstream.\r\n\r\n#### Actual Behavior\r\nAfter about ~100 emissions, the `map` operator is applied on the `scheduler2` scheduler. I'm not an expert in the details, but it seems to have something to do with backpressure, buffering, and polling for items upon subscription?\r\n\r\n#### Output\r\n```\r\nonNext on scheduler2: 0\r\nonNext on scheduler2: 1\r\nonNext on scheduler2: 2\r\nonNext on scheduler2: 3\r\nonNext on scheduler2: 4\r\nonNext on scheduler2: 5\r\nonNext on scheduler2: 6\r\nonNext on scheduler2: 7\r\nonNext on scheduler2: 8\r\nonNext on scheduler2: 9\r\nonNext on scheduler2: 10\r\nonNext on scheduler2: 11\r\nonNext on scheduler2: 12\r\nonNext on scheduler2: 13\r\nonNext on scheduler2: 14\r\nonNext on scheduler2: 15\r\nonNext on scheduler2: 16\r\nonNext on scheduler2: 17\r\nonNext on scheduler2: 18\r\nonNext on scheduler2: 19\r\nonNext on scheduler2: 20\r\nonNext on scheduler2: 21\r\nonNext on scheduler2: 22\r\nonNext on scheduler2: 23\r\nonNext on scheduler2: 24\r\nonNext on scheduler2: 25\r\nonNext on scheduler2: 26\r\nonNext on scheduler2: 27\r\nonNext on scheduler2: 28\r\nonNext on scheduler2: 29\r\nonNext on scheduler2: 30\r\nonNext on scheduler2: 31\r\nonNext on scheduler2: 32\r\nonNext on scheduler2: 33\r\nonNext on scheduler2: 34\r\nonNext on scheduler2: 35\r\nonNext on scheduler2: 36\r\nonNext on scheduler2: 37\r\nonNext on scheduler2: 38\r\nonNext on scheduler2: 39\r\nonNext on scheduler2: 40\r\nonNext on scheduler2: 41\r\nonNext on scheduler2: 42\r\nonNext on scheduler2: 43\r\nonNext on scheduler2: 44\r\nonNext on scheduler2: 45\r\nonNext on scheduler2: 46\r\nonNext on scheduler2: 47\r\nonNext on scheduler2: 48\r\nonNext on scheduler2: 49\r\nonNext on scheduler2: 50\r\nonNext on scheduler2: 51\r\nonNext on scheduler2: 52\r\nonNext on scheduler2: 53\r\nonNext on scheduler2: 54\r\nonNext on scheduler2: 55\r\nonNext on scheduler2: 56\r\nonNext on scheduler2: 57\r\nonNext on scheduler2: 58\r\nonNext on scheduler2: 59\r\nonNext on scheduler2: 60\r\nonNext on scheduler2: 61\r\nonNext on scheduler2: 62\r\nonNext on scheduler2: 63\r\nonNext on scheduler2: 64\r\nonNext on scheduler2: 65\r\nonNext on scheduler2: 66\r\nonNext on scheduler2: 67\r\nonNext on scheduler2: 68\r\nonNext on scheduler2: 69\r\nonNext on scheduler2: 70\r\nonNext on scheduler2: 71\r\nonNext on scheduler2: 72\r\nonNext on scheduler2: 73\r\nonNext on scheduler2: 74\r\nonNext on scheduler2: 75\r\nonNext on scheduler2: 76\r\nonNext on scheduler2: 77\r\nonNext on scheduler2: 78\r\nonNext on scheduler2: 79\r\nonNext on scheduler2: 80\r\nonNext on scheduler2: 81\r\nonNext on scheduler2: 82\r\nonNext on scheduler2: 83\r\nonNext on scheduler2: 84\r\nonNext on scheduler2: 85\r\nonNext on scheduler2: 86\r\nonNext on scheduler2: 87\r\nonNext on scheduler2: 88\r\nonNext on scheduler2: 89\r\nonNext on scheduler2: 90\r\nonNext on scheduler2: 91\r\nonNext on scheduler2: 92\r\nonNext on scheduler2: 93\r\nonNext on scheduler2: 94\r\nonNext on scheduler2: 95\r\nio.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread: scheduler2\r\n\tat io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)\r\n\tat io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)\r\n\tat io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)\r\n\tat io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)\r\n\tat io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)\r\n\tat io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.AssertionError: Wrong thread: scheduler2\r\n\tat RxTestKt$main$flowable$1.apply(RxTest.kt:22)\r\n\tat RxTestKt$main$flowable$1.apply(RxTest.kt)\r\n\tat io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.poll(FlowableMap.java:81)\r\n\tat io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:510)\r\n\tat io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)\r\n\tat io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)\r\n\t... 6 more\r\nException in thread \"scheduler2\" io.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread: scheduler2\r\n\tat io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)\r\n\tat io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)\r\n\tat io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)\r\n\tat io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)\r\n\tat io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)\r\n\tat io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.AssertionError: Wrong thread: scheduler2\r\n\tat RxTestKt$main$flowable$1.apply(RxTest.kt:22)\r\n\tat RxTestKt$main$flowable$1.apply(RxTest.kt)\r\n\tat io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.poll(FlowableMap.java:81)\r\n\tat io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:510)\r\n\tat io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)\r\n\tat io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)\r\n\tat io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)\r\n\t... 6 more\r\n```", "closed": "2018-08-08 07:42:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6144", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Using publish/share/etc leads to upstream operator running on unexpected scheduler"}, {"created": "2018-06-22 11:41:02", "user": "boris-petrov", "body": "I have something like:\r\n\r\n```java\r\nobservable.concatMapMaybe(...).map(x -> ...);\r\n```\r\n\r\nThis `x` is `null` sometimes (our tests reproduce it consistently in one case). Didn't happen on `2.1.14`. I can't give more information for now, just to let you know there is a problem. If you can't figure it out soon, I'll try to create some reproduction.", "closed": "2018-06-22 13:58:45", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6059", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[2.1.15] map method called with null"}, {"created": "2018-05-28 09:14:39", "user": "yunikkk", "body": "Library verision : 2.1.7\r\n\r\nThe following code will silently swallow thrown exception without signalling to RxPlugins. \r\n```\r\n        val subject = PublishSubject.create<Unit>()\r\n\r\n        var disposable: Disposable? = null\r\n        disposable = subject.subscribe(\r\n                {\r\n                    disposable?.dispose()\r\n                    throw Exception(\"test\")\r\n                }\r\n        )\r\n\r\n        subject.onNext(Unit)\r\n```\r\n\r\nThe same applies to BehaviourSubject, *Processor, but not SingleSubject or Observable.just (.range etc. ). Though sections about error handling are almost equal in [PublishSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html) and [SingleSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/SingleSubject.html).\r\n\r\nThe reason seems to be located in [LambdaObserver](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/observers/LambdaObserver.java), which doesn't signal onError if is disposed already.\r\n\r\nIs it expected behaviour?", "closed": "2018-06-09 11:25:55", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6025", "ttf": 12.000277777777777, "commits": {}, "labels": ["2.x", "Bug", "PR welcome"], "title": "2.x: error handling - exception swallowed after explicit .dispose()."}, {"created": "2018-05-24 22:59:51", "user": "damianw", "body": "Using `Single.takeUntil` does not dispose the subscription it makes to `other` when the main subscription is disposed. RxJava Version: `2.1.13`\r\n\r\n#### Sample\r\n```Kotlin\r\nval control = Single.never<Nothing>()\r\n        .doOnSubscribe { println(\"Subscribe control\") }\r\n        .doOnDispose { println(\"Dispose control\") }\r\nval disposable = Single.never<Nothing>()\r\n        .doOnSubscribe { println(\"Subscribe main\") }\r\n        .doOnDispose { println(\"Dispose main\") }\r\n        .takeUntil(control)\r\n        .subscribe()\r\ndisposable.dispose()\r\n```\r\nprints only:\r\n```\r\nSubscribe control\r\nSubscribe main\r\nDispose main\r\n```\r\n\r\n#### Comparison with Observable\r\nFor comparison, `Observable.takeUntil`:\r\n```Kotlin\r\nval control = Observable.never<Nothing>()\r\n        .doOnSubscribe { println(\"Subscribe control\") }\r\n        .doOnDispose { println(\"Dispose control\") }\r\nval disposable = Observable.never<Nothing>()\r\n        .doOnSubscribe { println(\"Subscribe main\") }\r\n        .doOnDispose { println(\"Dispose main\") }\r\n        .takeUntil(control)\r\n        .subscribe()\r\ndisposable.dispose()\r\n```\r\n\r\nprints:\r\n```\r\nSubscribe control\r\nSubscribe main\r\nDispose main\r\nDispose control\r\n```", "closed": "2018-05-25 10:35:35", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/6018", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Single.takeUntil does not dispose subscription to 'other' upon disposal"}, {"created": "2018-05-02 19:02:08", "user": "AlecStrong", "body": "Here is the test case I've created\r\n\r\n```\r\nval testThread = Thread.currentThread();\r\n\r\nrx.Observable.fromCallable { 10 }\r\n        .toV2()\r\n        .switchMap { original -> BehaviorSubject.createDefault(2)\r\n            .observeOn(Schedulers.io())\r\n            .map { multiplier ->\r\n              if (Thread.currentThread() == testThread) throw AssertionError()\r\n              original * multiplier\r\n            }\r\n        }\r\n        .subscribe { throw IllegalStateException(\"nice\") }\r\n\r\nThread.sleep(1000)\r\n```\r\n\r\nThis hits the assertion error as `SwitchMapObserver` `poll`s the inner query inside its drain method, running the `poll` method on `MapObserver` which ends up running on the thread the switchmap was subscribed to on (i think?). \r\n\r\nI dont think the interop part is necessary to reproduce this bug, but was the consistent way I was able to get the `drain` method to poll the inner query as `fromCallable` emits a completion after the relay has emitted but before the mapper has received the event.", "closed": "2018-05-04 15:47:22", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5990", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Drain applies mappers without scheduling."}, {"created": "2018-04-23 23:12:08", "user": "acadet", "body": "**Version used: 2.1.12**\r\n\r\nI have a collection of interfaces. They all define a method fetching a collection of items: `Single<List<Integer>> fetchItems()`. \r\nSome of them perform local computations, others a network call. When concatening using `concatMapSingle`, some of the singles are not subscribed at all.\r\n\r\nHere is a test I do think should pass. A network call is faked here using a timer. If the timer is replaced with `Single.just` instead, the test is passing.\r\n\r\n```java\r\n@Test\r\npublic void test() {\r\n  TestScheduler testScheduler = new TestScheduler();\r\n\r\n  final Single<List<Integer>> first = Single.timer(2, TimeUnit.SECONDS, testScheduler).map(u -> Arrays.asList(1, 2, 3));\r\n  final Single<List<Integer>> second = Single.just(Collections.emptyList());\r\n  final Single<List<Integer>> third = Single.just(Collections.singletonList(4));\r\n  final Single<List<Integer>> fourth = Single.just(Collections.singletonList(5));\r\n\r\n  Single<List<Integer>> subject = Observable\r\n    .fromIterable(Arrays.asList(first, second, third, fourth))\r\n    .concatMapSingle(single -> single)\r\n    .reduce(new ArrayList<>(), (seed, items) -> {\r\n      seed.addAll(items);\r\n      return seed;\r\n    });\r\n\r\n    TestObserver<List<Integer>> testObserver = subject.test();\r\n    testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\r\n\r\n    testObserver.assertValue(list -> list.equals(Arrays.asList(1, 2, 3, 4, 5))); \r\n    // 5 is currently missing ; fourth was never subscribed in the first place\r\n}\r\n```\r\n\r\n*It is my first issue on this repo, feel free to edit my PR if I am not respecting the contribution guidelines.*", "closed": "2018-04-24 08:06:16", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5971", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "concatMapSingle ignores some onNext events"}, {"created": "2018-03-26 09:52:24", "user": "awenger", "body": "We have a Observable that is transformed into a Single. Some unrelated changes caused a Exception in the `onSuccess` Action of the Subscriber. This exception seems to get lost. It neither gets propagated to the `onError` Action, nor to the `RxJavaHooks.setOnError` Action.\r\n\r\nSample that reproduces the problem:\r\n\r\n```java\r\nRxJavaHooks.setOnError(error -> System.out.println(\"got global error \" + error));\r\nObservable.just(\"1\")\r\n        .first()\r\n        .toSingle()\r\n        .subscribe(\r\n                it -> {\r\n                    System.out.println(\"going to throw\");\r\n                    throw new NullPointerException(\"bla\");\r\n                },\r\n                error -> System.out.println(\"got error \" + error)\r\n        );\r\n\r\n// Output:\r\n\r\ngoing to throw\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\nIf I change the sample to this it does propagate the error (removed the `first()` call):\r\n```java\r\nRxJavaHooks.setOnError(error -> System.out.println(\"got global error \" + error));\r\nObservable.just(\"1\")\r\n        .toSingle()\r\n        .subscribe(\r\n                it -> {\r\n                    System.out.println(\"going to throw\");\r\n                    throw new NullPointerException(\"bla\");\r\n                },\r\n                error -> System.out.println(\"got error \" + error)\r\n        );\r\n\r\n// Output\r\n\r\ngoing to throw\r\ngot error java.lang.NullPointerException: bla\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\nThis is what I found out while debugging.\r\nException is caught here:\r\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeLift.java#L49-L55\r\n\r\n`st` is in this case the OperatorTake:\r\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorTake.java#L60-L70\r\nit is already `completed`. So the `Throwable` is just ignored.\r\n\r\nCould be related/the same as #3571.", "closed": "2018-03-31 06:39:17", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5934", "ttf": 4.000277777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "1.x OperatorTake seem to swallow Exceptions"}, {"created": "2018-03-24 22:05:12", "commits": {"6fefdc6e6ca253f4fea2a576a0e6e93ee340491e": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2018-05-29 12:14:33", "filteredCommits": [], "commitsDetails": [{"nameRev": "6fefdc6e6ca253f4fea2a576a0e6e93ee340491e tags/v2.1.15~17", "commitMessage": "2.x fix group-by eviction so that source is cancelled and reduce volatile reads (#5933) (#5947)\n\n", "commitParents": ["43ceedf41839c7e2253c91f15204da8718b0c133"], "spoonStatsSkippedReason": "", "commitHash": "6fefdc6e6ca253f4fea2a576a0e6e93ee340491e", "authoredDateTime": "2018-05-29 22:14:32", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 24, "deletions": 11, "lines": 35, "filePath": "src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java"}, {"insertions": 122, "deletions": 0, "lines": 122, "filePath": "src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java"}], "commitDateTime": "2018-05-29 14:14:32", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.onError(java.lang.Throwable)"}, {"UPD": 0, "TOT": 2, "MOV": 0, "INS": 2, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.completeEvictions()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.cancel()"}, {"UPD": 0, "TOT": 5, "MOV": 3, "INS": 1, "DEL": 1, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.onNext(java.lang.Object)"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.drainNormal()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.onComplete()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber.drainFused()"}, {"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber"}], "spoonFilePath": "FlowableGroupBy.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.createEvictingMapFactorySynchronousOnly(int).100"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.createEvictingMapFactoryGuava(int).99"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.TestTicker"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupByEvictionCancellationOfSource5933()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testCancellationOfUpstreamWhenGroupedFlowableCompletes()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.createEvictingMapFactoryGuava(int).99.apply(io.reactivex.internal.operators.flowable.Consumer)"}], "spoonFilePath": "FlowableGroupByTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/5933", "ttf": 65.00027777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "2.x -- groupBy with evicting map -- seeing inconsistent behavior when eviction occurs", "statsSkippedReason": "", "user": "sfitts", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "I am using version 2.1.11.  I'm seeing what I believe to be a bug in the groupBy operator when configured to use an evicting map.  Here is a test that demonstrates what I'm seeing:\r\n\r\n```java\r\n    private static class TestTicker extends Ticker {\r\n        long tick = 0;\r\n\r\n        @Override\r\n        public long read() {\r\n            return tick;\r\n        }\r\n    }\r\n    \r\n    @Test\r\n    public void testGroupByEviction() {\r\n        FlowableProcessor<Integer> source = PublishProcessor.create();\r\n        TestSubscriber<Integer> subscriber1 = new TestSubscriber<>();\r\n        TestTicker testTicker = new TestTicker();\r\n\r\n        Function<Consumer<Object>, Map<Object, Object>> mapFactory = action -> {\r\n            return CacheBuilder.newBuilder()\r\n                    .expireAfterAccess(5, TimeUnit.SECONDS)\r\n                    .removalListener(notification -> {\r\n                        try {\r\n                            action.accept(notification.getValue());\r\n                        } catch (Exception ex) {\r\n                            throw new RuntimeException(ex);\r\n                        }\r\n                    }).ticker(testTicker).build().asMap();\r\n        };\r\n\r\n        final List<String> list = Collections.synchronizedList(new ArrayList<String>());\r\n        Flowable<Integer> stream = source.doOnCancel(() -> list.add(\"Source canceled\"))\r\n                .groupBy(v -> v, Functions.identity(), false, Flowable.bufferSize(), mapFactory)\r\n                .flatMap(group -> {\r\n            return group\r\n                    .doOnComplete(() -> list.add(\"Group completed\"))\r\n                    .doOnCancel(() -> list.add(\"Group canceled\"));\r\n        });\r\n        stream.doOnCancel(() -> list.add(\"Outer group by canceled.\")).subscribe(subscriber1);\r\n        \r\n        // Send 3 in the same group and wait for them to be seen\r\n        source.onNext(1);\r\n        source.onNext(1);\r\n        source.onNext(1);\r\n        subscriber1.awaitCount(3);\r\n        \r\n        // Advance time far enough to evict the group.\r\n        // NOTE -- Comment this line out to make the test \"pass\".\r\n        testTicker.tick = TimeUnit.SECONDS.toNanos(6);\r\n        \r\n        // Send more data in the group (triggering eviction and recreation)\r\n        source.onNext(1);\r\n        source.onNext(1);\r\n\r\n        // Wait for the last 2 and then cancel the subscription\r\n        subscriber1.awaitCount(5);\r\n        subscriber1.cancel();\r\n\r\n        // Observe the result.  Note that right now the result differs depending on whether eviction occurred or\r\n        // not.  The observed sequence in that case is:  Group completed, Outer group by canceled., Group canceled.\r\n        // The addition of the \"Group completed\" is actually fine, but the fact that the cancel doesn't reach the\r\n        // source seems like a bug.  Commenting out the setting of \"tick\" above will produce the \"expected\" sequence.\r\n        assertEquals(Arrays.asList(\r\n                // \"Group completed\", -- this is here when eviction occurs\r\n                \"Outer group by canceled.\", \r\n                \"Group canceled\",\r\n                \"Source canceled\"  // This is *not* here when eviction occurs\r\n        ), list);\r\n    }\r\n```\r\n\r\nAs you can see from this when a group eviction occurs and the root subscription is canceled, the cancel dose not propagate beyond the `groupBy` (it does when there is no eviction).  I think the reason for this is that after the eviction processing (line 188 of FlowableGroupBy) the groupCount is 3 when I believe it should be 2).  This leads the groupBy to conclude that there are 2 active groups when the cancel occurs, when in fact there is only one.  This doesn't happen when there is no eviction (you can see this by commenting out the line that updates \"tick\").", "labels": ["2.x", "Bug"]}, {"created": "2018-03-23 09:24:22", "user": "boris-petrov", "body": "I've seen already a couple of those after upgrading. Unfortunately I cannot give you any reproduction as I have zero idea where it might come from but here are a couple of stacktraces:\r\n\r\n```\r\njava.lang.NullPointerException\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement(SpscLinkedArrayQueue.java:249)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll(SpscLinkedArrayQueue.java:154)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll(SpscLinkedArrayQueue.java:144)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear(SpscLinkedArrayQueue.java:184)\r\n at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.dispose(ObservableConcatMapMaybe.java:152)\r\n at io.reactivex.internal.observers.BasicFuseableObserver.dispose(BasicFuseableObserver.java:152)\r\n at io.reactivex.internal.observers.BasicFuseableObserver.dispose(BasicFuseableObserver.java:152)\r\n at io.reactivex.internal.operators.observable.ObservableTake$TakeObserver.dispose(ObservableTake.java:90)\r\n at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\r\n at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)\r\n at java.util.HashMap$Values.forEach(HashMap.java:981)\r\n```\r\n\r\n```\r\njava.lang.NullPointerException\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement(SpscLinkedArrayQueue.java:249)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll(SpscLinkedArrayQueue.java:154)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll(SpscLinkedArrayQueue.java:144)\r\n at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear(SpscLinkedArrayQueue.java:184)\r\n at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.drain(ObservableConcatMapMaybe.java:200)\r\n at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.innerSuccess(ObservableConcatMapMaybe.java:165)\r\n at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver$ConcatMapMaybeObserver.onSuccess(ObservableConcatMapMaybe.java:290)\r\n at io.reactivex.internal.operators.single.SingleFlatMapMaybe$FlatMapMaybeObserver.onSuccess(SingleFlatMapMaybe.java:117)\r\n at io.reactivex.internal.operators.maybe.MaybeJust.subscribeActual(MaybeJust.java:36)\r\n at io.reactivex.Maybe.subscribe(Maybe.java:4065)\r\n```\r\n\r\nThis didn't happen on `2.1.10` or any of the previous versions. Please tell me if I can help more.", "closed": "2018-03-23 10:31:48", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5927", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[2.1.11] NPE in SpscLinkedArrayQueue.lvElement"}, {"created": "2018-03-08 20:53:37", "user": "jblatt1", "body": "The following code demonstrates the expected behavior of Flowable.singleOrError() (as I understand it):\r\n```\r\nFlowable.empty()\r\n    .singleOrError()\r\n    .blockingGet(); // NoSuchElementException is thrown, as expected\r\n```\r\n    \r\nHowever, if singleOrError() is immediately followed by Single.flatMapPublisher(...), the exception is lost:\r\n```\r\nFlowable.empty()\r\n    .singleOrError()\r\n    .flatMapPublisher(Flowable::just)\r\n    .blockingSubscribe(); // No exception is thrown\r\n```\r\n    \r\nStrangely, if anything is done between Flowable.singleOrError() and Single.flatMapPublisher(...), the exception is thrown as expected:\r\n```\r\nFlowable.empty()\r\n    .singleOrError()\r\n    .map(x -> x)\r\n    .flatMapPublisher(Flowable::just)\r\n    .blockingSubscribe(); // NoSuchElementException is thrown, as expected\r\n```\r\n    \r\nThis is with RxJava 2.1.10 and Reactive Streams 1.0.2.", "closed": "2018-03-09 08:43:45", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5903", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Flowable.singleOrError() does not signal an exception if followed by flatMapPublisher"}, {"created": "2018-03-03 21:57:31", "user": "akarnokd", "body": "While working on coverage improvements, I've noticed `Flowable.window(Publisher<B>)` and `Flowable.window(Callable<Publisher<B>>)` (plus their `Observable` counterpart) manage the upstream incorrectly as they don't cancel it when both the main output and the current window have been cancelled.", "closed": "2018-03-04 18:19:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5881", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Incorrect upstream management in window(Observable) and window(Callable)"}, {"created": "2018-02-01 17:22:01", "user": "ykinuse", "body": "Hi, I'm facing an issue with Observable's switchMap/switchMapSingle where the inner source does not get disposed if the upstream emits an error. Happens on both version 2.1.6 and 2.1.9. Is this the expected behavior?\r\n\r\nObservable version does not dispose the inner source\r\n```        \r\n        Observable\r\n                .create(e -> {\r\n                    e.onNext(true);\r\n                    e.onError(new Throwable());\r\n                })\r\n                .switchMap(__ -> Observable\r\n                        .timer(500L, TimeUnit.MILLISECONDS)\r\n                        .doOnNext(System.out::println))\r\n                .subscribe(__->{}, __->{});\r\n        Thread.sleep(1000L);\r\n```\r\n\r\n\r\nWhile the Flowable version does dispose the inner source.\r\n\r\n```        \r\n        Flowable\r\n                .create(e -> {\r\n                    e.onNext(true);\r\n                    e.onError(new Throwable());\r\n                }, BackpressureStrategy.BUFFER)\r\n                .switchMap(__ -> Flowable\r\n                        .timer(500L, TimeUnit.MILLISECONDS)\r\n                        .doOnNext(System.out::println))\r\n                .subscribe(__->{}, __->{});\r\n        Thread.sleep(1000L);\r\n```", "closed": "2018-02-02 09:56:25", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5832", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x Observable onError does not dispose switchMap's inner ObservableSource"}, {"created": "2018-01-16 11:13:17", "user": "simonbasle", "body": "Consider an `open` source for `FlowableBufferBoundary` that never stops, like a `Flowable.interval`. In the case where the buffer opening and closing signal overlap, the opening of new windows never stops even when the source of data completes.\r\n\r\nThe second test below times out as a result:\r\n\r\n```java\r\n@Test\r\n    public void bufferedCanCompleteIfOpenNeverCompletesDropping() {\r\n        Flowable.range(1, 200)\r\n                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),\r\n                        new BiFunction<Integer, Long, Integer>() {\r\n                            @Override\r\n                            public Integer apply(Integer integer, Long aLong) {\r\n                                return integer;\r\n                            }\r\n                        })\r\n                .buffer(Flowable.interval(0,200, TimeUnit.MILLISECONDS),\r\n                        new Function<Long, Publisher<?>>() {\r\n                            @Override\r\n                            public Publisher<?> apply(Long a) {\r\n                                return Flowable.just(a).delay(100, TimeUnit.MILLISECONDS);\r\n                            }\r\n                        })\r\n                .test()\r\n                .assertSubscribed()\r\n                .awaitDone(3, TimeUnit.SECONDS)\r\n                .assertComplete();\r\n    }\r\n\r\n    @Test\r\n    public void bufferedCanCompleteIfOpenNeverCompletesOverlapping() {\r\n        Flowable.range(1, 200)\r\n                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),\r\n                        new BiFunction<Integer, Long, Integer>() {\r\n                            @Override\r\n                            public Integer apply(Integer integer, Long aLong) {\r\n                                return integer;\r\n                            }\r\n                        })\r\n                .buffer(Flowable.interval(0,100, TimeUnit.MILLISECONDS),\r\n                        new Function<Long, Publisher<?>>() {\r\n                            @Override\r\n                            public Publisher<?> apply(Long a) {\r\n                                return Flowable.just(a).delay(200, TimeUnit.MILLISECONDS);\r\n                            }\r\n                        })\r\n                .test()\r\n                .assertSubscribed()\r\n                .awaitDone(3, TimeUnit.SECONDS)\r\n                .assertComplete();\r\n    }\r\n```", "closed": "2018-01-19 09:36:39", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5809", "ttf": 2.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: FlowableBufferBoundary doesn't stop opening new windows in overlapping case"}, {"created": "2018-01-05 15:03:41", "user": "artur-jablonski", "body": "Given an `Iterable<T>` that always fails on `next()`:\r\n\r\n```\r\npublic Iterable<String> iterableThatThrowsException()\r\n    {\r\n        return () -> new Iterator<String>()\r\n        {\r\n            @Override\r\n            public boolean hasNext() { true; }\r\n\r\n            @Override\r\n            public String next()\r\n            {\r\n                throw new RuntimeException(\"kaboom, kaboom\");\r\n            }\r\n        };\r\n    }\r\n```\r\n\r\nand this stream:\r\n\r\n```\r\nFlowable.fromIterable(Arrays.asList(1, 2))\r\n                  .doOnNext(i -> out.println(\"fromIterable onNext() -> \" + i))\r\n                  .doOnComplete(() -> out.println(\"fromIterable onComplete()\"))\r\n                  .map(i -> iterableThatThrowsException())\r\n                  .flatMap(l -> Flowable.fromIterable(l))\r\n                  .doOnError(t -> out.println(\"flatMap onError()\"))\r\n                  .subscribe(\r\n                    i -> out.println(\"subscriber onNext() -> \" + i),\r\n                    t -> out.println(\r\n                        \"subscriber onError() -> \" + t.getClass().getName() +\r\n                        \" \" + t.getMessage()),\r\n                    () -> out.println(\"subscriber onComplete()\")\r\n                );\r\n```\r\nthe `Flowable.fromIterable(Arrays.asList(1, 2))` continues to emit items after `flatMap(l -> Flowable.fromIterable(l))` signals error.\r\n\r\nThis is the output:\r\n```\r\nfromIterable onNext() -> 1\r\nflatMap onError()\r\nsubscriber onError() -> java.lang.RuntimeException kaboom, kaboom\r\nfromIterable onNext() -> 2\r\nfromIterable onComplete()\r\n```\r\n\r\nPlease note that:\r\n\r\n1. When I substitute Flowable with Observable, then it outputs what **I** think is the correct behaviour\r\n```\r\nfromIterable onNext() -> 1\r\nflatMap onError()\r\nsubscriber onError() -> java.lang.RuntimeException kaboom, kaboom\r\n```\r\n2. When I add a \"dummy\"`doOnError()` to the inner `fromIterable` it also produces \"correct\" output like in 1\r\n```\r\n.flatMap(l -> Flowable.fromIterable(l).doOnError(t -> {}))\r\n```\r\n3. The \"incorrect\" behaviour is consistent all the way down to version 2.0.0\r\n\r\n\r\n", "closed": "2018-01-05 23:26:30", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5791", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: part of the stream continues after error in Flowable but not Observable."}, {"created": "2017-11-25 13:18:21", "commits": {"9564121e09616df909c2d23c4bba62734217bdd6": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2017-11-25 17:38:03", "filteredCommits": [], "commitsDetails": [{"nameRev": "9564121e09616df909c2d23c4bba62734217bdd6 tags/v2.1.7~1", "commitMessage": "Check isDisposed before emitting in SingleFromCallable (#5743)\n\nPreviously SingleFromCallable did not check if the subscriber was\r\nunsubscribed before emitting onSuccess or onError. This fixes that\r\nbehavior and adds tests to SingleFromCallable, CompletableFromCallable,\r\nand MaybeFromCallable.\r\n\r\nFixes #5742", "commitParents": ["e25be7c048f874814e1f940fa5dcd62724cc95bd"], "spoonStatsSkippedReason": "", "commitHash": "9564121e09616df909c2d23c4bba62734217bdd6", "authoredDateTime": "2017-11-25 18:38:02", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 227, "deletions": 1, "lines": 228, "filePath": "src/test/java/io/reactivex/internal/operators/single/SingleFromCallableTest.java"}, {"insertions": 23, "deletions": 10, "lines": 33, "filePath": "src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java"}, {"insertions": 58, "deletions": 0, "lines": 58, "filePath": "src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java"}, {"insertions": 65, "deletions": 0, "lines": 65, "filePath": "src/test/java/io/reactivex/internal/operators/completable/CompletableFromCallableTest.java"}], "commitDateTime": "2017-11-25 18:38:02", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.noErrorLoss()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.shouldNotInvokeFuncUntilSubscription()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.disposedOnArrival()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.shouldAllowToThrowCheckedException()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.toObservableTake()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.toObservableAndBack()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.fromCallableTwice()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallableTest.disposedOnCall()"}], "spoonFilePath": "SingleFromCallableTest.java"}, {"spoonMethods": [{"UPD": 9, "TOT": 26, "MOV": 7, "INS": 7, "DEL": 3, "spoonMethodName": "io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(io.reactivex.internal.operators.single.SingleObserver)"}], "spoonFilePath": "SingleFromCallable.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.maybe.MaybeFromCallableTest.shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission()"}], "spoonFilePath": "MaybeFromCallableTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "io.reactivex.internal.operators.completable.CompletableFromCallableTest.shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission()"}], "spoonFilePath": "CompletableFromCallableTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/5742", "ttf": 0.0002777777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "2.x: SingleFromCallable doesn't check isDisposed before calling onError or onSuccess.", "statsSkippedReason": "", "user": "runningcode", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "I was investigating a bug and I noticed that `SingleFromCallable` doesn't check `isDisposed()` before calling `onError` or `onSuccess` when comparing it to `ObservableFromCallable`.\r\n\r\nShould it be checking `isDisposed()`? If not, why not? Or is this a bug?\r\n\r\nMy code example where I'm getting this error is Android based:\r\nI have a HomePresenter with this code:\r\n```\r\nvoid setActivity(Activity activity) {\r\n\tTimber.d(\u201cHomePresenter attachActivity\u201d);\r\n\tthis.activity = activity;\r\n}\r\n```\r\n\r\n```\r\nvoid onStart() {\r\n\tTimber.d(\u201cHomePresenter onStart\u201d);\r\n\tdisposables.add(api.getEmail()\r\n\t\t.subscribeOn(Schedulers.io())\r\n\t\t.observeOn(AndroidSchedulers.mainThread())\r\n\t\t.subscribe(email -> {\r\n\t\t\tTimber.d(\u201cemail was %s\u201d, email);\r\n\t\t\tactivity.setEmail(email);\r\n\t\t})\r\n\t);\r\n```\r\n```\r\nvoid onStop() {\r\n\tTimber.d(\u201cHomePresenter onStop\u201d);\r\n\tdisposables.clear();\r\n\tactivity = null;\r\n}\r\n```\r\n\r\nin the logs I see:\r\n```\r\nLifecycle onStart HomeActivity\r\nHomePresenter attachActivity\r\nHomePresenter onStart\r\nLifecycle onStop HomeActivity\r\nHomePresenter onStop\r\nemail was foo@bar.com\r\nNullPointerException: attempt to invoke virtual method Activity.setEmail(String) on null object reference\r\n```\r\n\r\nIt seems the subscription to the observable was cleared before the `onSuccess` method was called.\r\n\r\nOr maybe I'm missing something else completely, anyways, thanks for the help :)\r\n\r\n", "labels": ["2.x", "Bug", "PR welcome", "Question"]}, {"created": "2017-11-15 12:10:43", "user": "chugai", "body": "lib version 1.3.3\r\n\r\nsample:\r\n``` \r\n       Observable.range(0, 20)\r\n                .doOnRequest(n -> System.out.println(\"req B \" + n))\r\n                .unsubscribeOn(io())\r\n                .doOnRequest(n -> System.out.println(\"req A \" + n))\r\n                .observeOn(computation(), 10)\r\n                .toBlocking()\r\n                .subscribe();\r\n```\r\n\r\noutput is:\r\n```\r\nreq A 10\r\nreq B 9223372036854775807\r\nreq A 8\r\njava.lang.RuntimeException: rx.exceptions.MissingBackpressureException\r\n...\r\n```\r\n\r\nwithout unsubscribeOn():\r\n```\r\nreq A 10\r\nreq B 10\r\nreq A 8\r\nreq B 8\r\nreq A 8\r\nreq B 8\r\n```", "closed": "2017-11-22 14:30:37", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5725", "ttf": 7.000277777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "1.x: unsubscribeOn overrides downstream backpressure requests"}, {"created": "2017-10-31 05:59:23", "user": "stannnous", "body": "Hi,\r\n\r\nThe following test shows the use of `observeOn` in an observable chain interrupts the thread, cancelling child observables.\r\n\r\n    import org.junit.Test;\r\n    import rx.Completable;\r\n    import rx.schedulers.Schedulers;\r\n\r\n    import java.util.concurrent.CountDownLatch;\r\n\r\n    public class InterruptTest {\r\n        @Test\r\n        public void testInterrupt() throws InterruptedException {\r\n           final int count = 1000;\r\n           CountDownLatch latch = new CountDownLatch(count);\r\n\r\n            for (int i = 0; i < count; i++) {\r\n                Completable.complete()\r\n                    .subscribeOn(Schedulers.io())\r\n                    .observeOn(Schedulers.io()) // The problem does not occur if you comment out this line\r\n                    .andThen(Completable.fromAction(() -> {\r\n                        try {\r\n                            Thread.sleep(3000);\r\n                        } catch (InterruptedException e) {\r\n                            System.out.println(\"Interrupted!\"); // This is output periodically\r\n                        }\r\n                    }))\r\n                    .subscribe(() -> latch.countDown());\r\n            }\r\n\r\n            latch.await();\r\n            testInterrupt();\r\n        }\r\n    }\r\n\r\nThe sleep is interrupted periodically printing \"Interrupted!\" while the test is running. The problem does not occur when the `observeOn` line is commented out.\r\n\r\nWe've tested this in RxJava 1.3.2 and 2.1.6 with the same results.", "closed": "2017-11-08 11:06:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5694", "ttf": 8.000277777777777, "commits": {}, "labels": ["2.x", "Bug"], "title": "observeOn unsubscribes child observables/interrupts the thread"}, {"created": "2017-10-17 11:13:23", "user": "dbakr", "body": "Operators fusion  in RxJava 2 is a really nice feature but I have found a case when an implementation of Flowable.rangeLong (and I assume there is similar behavior in neighbor standard flowables) fused together with operator observeOn() breaks the semantics of the operator observeOn().\r\nBasically, no emissions from FlowableRangeLong flowable is done on the scheduler provided in observeOn() but rather on the thread which calls request() in the chain.\r\nHere is the code snipped which reproduces the issue.\r\n\r\n```java\r\nimport io.reactivex.Flowable;\r\nimport io.reactivex.FlowableSubscriber;\r\nimport io.reactivex.plugins.RxJavaPlugins;\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport org.reactivestreams.Subscription;\r\n\r\npublic class RxJavaFuseTest {\r\n    public static void main(String[] args) {\r\n        FlowableSubscriber sequentialSubscriber = new FlowableSubscriber() {\r\n            private Subscription s;\r\n\r\n            @Override\r\n            public void onSubscribe(Subscription s) {\r\n                this.s = s;\r\n                this.s.request(1);\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object x) {\r\n                s.request(1);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                e.printStackTrace();\r\n                System.exit(0);\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                System.out.println(\"Completed\");\r\n                System.exit(0);\r\n            }\r\n        };\r\n\r\n        Flowable.rangeLong(0, 10)\r\n                .observeOn(RxJavaPlugins.createSingleScheduler(r -> new Thread(r, \"producer\")), false, 1)\r\n                .doOnNext(aLong -> {\r\n                    System.out.println(aLong + \" emitting on \" + Thread.currentThread().getName());\r\n                })\r\n                .parallel(2, 1)\r\n                .runOn(Schedulers.computation(), 1)\r\n                .doOnNext(aLong -> System.out.println(aLong + \" processing on \" + Thread.currentThread().getName()))\r\n                .sequential()\r\n                .subscribe(sequentialSubscriber);\r\n    }\r\n}\r\n```\r\n\r\nOutput is as follows:\r\n\r\n```\r\n0 emitting on main\r\n0 processing on RxComputationThreadPool-1\r\n1 emitting on main\r\n2 emitting on main\r\n1 processing on RxComputationThreadPool-2\r\n2 processing on RxComputationThreadPool-1\r\n3 emitting on main\r\n4 emitting on main\r\n3 processing on RxComputationThreadPool-2\r\n5 emitting on RxComputationThreadPool-2\r\n5 processing on RxComputationThreadPool-2\r\n4 processing on RxComputationThreadPool-1\r\n6 emitting on RxComputationThreadPool-2\r\n7 emitting on RxComputationThreadPool-2\r\n6 processing on RxComputationThreadPool-2\r\n7 processing on RxComputationThreadPool-1\r\n8 emitting on RxComputationThreadPool-2\r\n9 emitting on RxComputationThreadPool-2\r\n8 processing on RxComputationThreadPool-2\r\n9 processing on RxComputationThreadPool-1\r\nCompleted\r\n```\r\n\r\nMaybe I don't get something and have not read documentation carefully enough, but to me it looks like the fusion between operators breaks semantics of ObserveOn.\r\n\r\nMoreover, while digging in the source code of related classes in RxJava, I have found suspicious code in the FlowableRangeLong.BaseRangeSubscription.poll() method: it's potentially can be called from different threads but field \"index\" is not guarded anyhow from contended access so can produce wrong values if instructions reordering or caching is in place on a processor.", "closed": "2017-10-17 20:00:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5676", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "observeOn on Flowable.rangeLong does not emit values on provided scheduler"}, {"created": "2017-10-11 00:36:50", "user": "sfitts", "body": "Version -- 1.3.0 (did not see any release notes in the subsequent 1.3.x releases about this).\r\n\r\nNot sure if this is the expected behavior or not, but when I use the operator:\r\n\r\n```\r\ntimeout(long timeout, TimeUnit timeUnit, Observable<? extends T> other)\r\n```\r\n\r\nit seems that if the timeout occurs and we switch to mirroring the `other` observable the operator does not unsubscribe from the original observable.  Based on the documentation I was expecting that this would essentially execute a \"switch\" like behavior, which would result in the original observable being unsubscribed.\r\n\r\nHere is some code that demonstrates what I'm seeing:\r\n\r\n```\r\n        Subject<Long, Long> subject = PublishSubject.create();\r\n        Observable<Long> initialObservable = subject.share().map(value -> {\r\n            System.out.println(\"Received value \" + value);\r\n            return value;\r\n        });\r\n\r\n        Observable<Long> timeoutObservable = initialObservable.map(value -> {\r\n           System.out.println(\"Timeout received value \" + value);\r\n           return value;\r\n        });\r\n\r\n        TestSubscriber<Long> subscriber = new TestSubscriber<>();\r\n        initialObservable.timeout(1, TimeUnit.SECONDS, timeoutObservable).subscribe(subscriber);\r\n        subject.onNext(5L);\r\n        Thread.sleep(1500);\r\n        subject.onNext(10L);\r\n        subject.onCompleted();\r\n\r\n        subscriber.awaitTerminalEvent();\r\n        subscriber.assertNoErrors();\r\n        subscriber.assertValues(5L, 10L);\r\n```\r\n\r\nHere is the output:\r\n\r\n```\r\nReceived value 5\r\nReceived value 10\r\nReceived value 10\r\nTimeout received value 10\r\n```\r\n\r\nI was only expecting one `Received value 10`.", "closed": "2017-10-13 19:11:46", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5657", "ttf": 2.000277777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "RxJava 1.3 -- timeout not unsubscribing from original observable"}, {"created": "2017-09-18 14:55:05", "user": "Aschraf", "body": "Hello,\r\n\r\nI've got some issues with ConcatMapEager prefetch value. \r\n\r\nIt seems that concatMapEager stops before the end of the Observable.\r\n\r\nHere is a small example showing the issue : \r\n\r\n```java\r\nObservable.range(1, 100000)\r\n        .buffer(10)\r\n        .concatMapEager(value -> Observable.just(value)\r\n                .subscribeOn(Schedulers.io())\r\n                .doOnNext(it -> Thread.sleep(ThreadLocalRandom.current().nextLong(10, 100))),\r\n            6, 4)\r\n        .blockingSubscribe(it -> System.out.println(\"Received : \" + it));\r\n```\r\n\r\nThis small code is supposed to write list of ints till 100000. It stops before finishing.\r\n\r\nThe code doesn't work for the default ConcatMapEager function either (prefetch = 128)\r\n\r\n", "closed": "2017-09-18 17:43:59", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5608", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.1.3 Observable#concatMapEager queue size issue"}, {"created": "2017-09-14 20:16:12", "user": "artem-zinnatullin", "body": "Follow up after https://github.com/artem-zinnatullin/RxJavaProGuardRules/issues/62 once we've figured out that issue caused by changes in RxJava, specifically [switch to jdk8 from jdk7 on Travis CI](https://github.com/ReactiveX/RxJava/commit/ed35a14b8b8c5899f292e60905e082563d516539).\r\n\r\n", "closed": "2017-09-15 07:58:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5601", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "1.x: RxJava v1.3.1 references method not present in JRE < 8 (NewThreadWorker.purgeExecutors)"}, {"created": "2017-08-22 14:49:23", "user": "saiimons", "body": "I am working on a piece of code where I basically have a cached value, which I want to combine with other data and update from the network.\r\n\r\nMy thought was using combineLatestDelayError and magic would happen! Except when the network is down... Even though I have valid values in both my observables I only end up getting the error.\r\n\r\nI narrowed it down to a simple test case:\r\n```java\r\n    @Test\r\n    public void combineLatestDelayErrorFailure() {\r\n        final int result = Observable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        Observable.just(41).concatWith(Observable.error(new Exception(\"Failure\"))),\r\n                        Observable.just(1).delay(1, TimeUnit.SECONDS)\r\n                ),\r\n                ints -> ((int) ints[0]) + ((int) ints[1])\r\n        ).blockingFirst();\r\n        assertThat(result).isEqualTo(42);\r\n    }\r\n```\r\n\r\nIt always throws the Exception.\r\n\r\nThere is one point in the documentation about the calls being synchronous, though it is not clear to me how I could make changes to my observables to avoid that situation \ud83d\ude3f", "closed": "2017-08-22 17:00:14", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5558", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x - CombineLatestDelayError throwing error before subscribing other observables"}, {"created": "2017-07-06 07:57:05", "commits": {"b8f3cedefb350091d3daf53aa3dfabe2da5ae17d": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2017-07-19 09:58:57", "filteredCommits": [], "commitsDetails": [{"nameRev": "b8f3cedefb350091d3daf53aa3dfabe2da5ae17d tags/v1.3.1~3", "commitMessage": "fix #5468: eager hooks onError call (#5470)\n\n* fix #5468: eager hooks onError call\r\n\r\nMove the call to RxJavaHooks into the catch block, so we only report it if the underlying subscriber throws in its onError method.\r\nThis brings the behaviour in line with that of SafeSubscriber, which only call Hooks.onError inside the catch\r\n\r\n*  #5468 move hooks OnError into correct if block\r\n", "commitParents": ["3e5b117fbfd8ef5fecc7869b84e7f6c794b1d399"], "spoonStatsSkippedReason": "", "commitHash": "b8f3cedefb350091d3daf53aa3dfabe2da5ae17d", "authoredDateTime": "2017-07-06 19:54:00", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 1, "deletions": 1, "lines": 2, "filePath": "src/main/java/rx/observers/SafeCompletableSubscriber.java"}], "commitDateTime": "2017-07-06 11:54:00", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.observers.SafeCompletableSubscriber.onError(java.lang.Throwable)"}], "spoonFilePath": "SafeCompletableSubscriber.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/5468", "ttf": 13.000277777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "1.x Single#flatMapCompletable calls hooks onError when mapping to an error completeable", "statsSkippedReason": "", "user": "DeepSpawn", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "If you flatmap a Single into a Completeable, and the Completeable is an error, you will have the exception passed into the RxJavaHooks.onError global catch function as well as ending up with the Completeable Error you expect to see.\r\n\r\nI have managed to get is down to the follow test case highlighting the problem,\r\n\r\n```\r\n@Test\r\n    public void flatMapCompletableErrorCallsHooksErrorHandler() {\r\n        AtomicBoolean wasHooksHandlerCalled = new AtomicBoolean();\r\n        RxJavaHooks.setOnError(t -> wasHooksHandlerCalled.set(true));\r\n\r\n        Completable c3  = Single.just(1)\r\n                .flatMapCompletable(i -> Completable.error(new RuntimeException(\"some exception\")));\r\n\r\n        c3.get();\r\n\r\n        assertThat(wasHooksHandlerCalled.get(), is(false)); //fails\r\n    }\r\n```\r\n\r\nI did some digging and I think this is happening due to a bug in SafeCompletableSubscriber, where it calls  RxJavaHooks.onError(e) before it attempts to pass the error in to the wrapped subscribers onError method. ie\r\n\r\n```\r\npublic void onError(Throwable e) {\r\n        RxJavaHooks.onError(e);\r\n        if (done) {\r\n            return;\r\n        }\r\n        done = true;\r\n        try {\r\n            actual.onError(e);\r\n        } catch (Throwable ex) {\r\n            Exceptions.throwIfFatal(ex);\r\n\r\n            throw new OnErrorFailedException(new CompositeException(e, ex));\r\n        }\r\n    }\r\n```\r\n\r\nLooking at SafeSubscriber, I think the correct behaviour is to only have the call to ` RxJavaHooks.onError(e);` happen inside the catch block, as no exception has leaked at the point where it is currently being called.\r\n", "labels": ["1.x", "Bug"]}, {"created": "2017-06-21 13:05:33", "user": "nathankooij", "body": "Affects 2.1.1.\r\n\r\nThe Javadoc for ReplaySubject::getValue states the following:\r\n> Returns a single value the Subject currently has or null if no such value exists.\r\n\r\nIn combination with a time bounded replay subject I would expect `null` if either:\r\n* there has not yet been an emission\r\n* the emitted item's age is too old\r\n\r\nCurrently this is not the case as demonstrated by the following test: https://github.com/nathankooij/RxJava/commit/6afa40c0493bd90f012a91f2c20ce4cc2695826e\r\nHowever, getValues() does return `null` (that is, old items are evicted), which is also demonstrated by the aforementioned test. To me it seems that either the implementation of `getValue/getValues` is inconsistent with each other, and the current behavior is not obvious to me from the documentation.\r\n\r\nI've added what I think could be the fix in: https://github.com/nathankooij/RxJava/commit/bf1c1895f5fb66fdb38f1ad9d09212b3462a1ffd", "closed": "2017-07-05 22:08:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5433", "ttf": 14.000277777777777, "commits": {}, "labels": ["2.x", "Bug", "PR welcome"], "title": "2.x Time bounded replaySubject getValue() unexpected behavior"}, {"created": "2017-06-21 06:32:28", "commits": {"1dd023f073548f977ea8d199fa2151279078a340": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 1, "changesInPackagesSPOON": ["rx.observables.AsyncOnSubscribe.AsyncOuterManager.tryEmit(long)"], "closed": "2017-07-05 22:26:03", "filteredCommits": ["1dd023f073548f977ea8d199fa2151279078a340"], "commitsDetails": [{"nameRev": "1dd023f073548f977ea8d199fa2151279078a340 tags/v1.3.1~5", "commitMessage": "fix for https://github.com/ReactiveX/RxJava/issues/5429 (#5430)\n\n", "commitParents": ["433b099c2d97cc24a2e7d2041755bbe5a8ddd5a0"], "spoonStatsSkippedReason": "", "commitHash": "1dd023f073548f977ea8d199fa2151279078a340", "authoredDateTime": "2017-06-23 02:16:13", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 34, "deletions": 0, "lines": 34, "filePath": "src/test/java/rx/observables/AsyncOnSubscribeTest.java"}, {"insertions": 5, "deletions": 2, "lines": 7, "filePath": "src/main/java/rx/observables/AsyncOnSubscribe.java"}], "commitDateTime": "2017-06-23 11:16:13", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.observables.AsyncOnSubscribeTest.testMergeDelayedWithScalar()"}], "spoonFilePath": "AsyncOnSubscribeTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.observables.AsyncOnSubscribe.AsyncOuterManager.tryEmit(long)"}], "spoonFilePath": "AsyncOnSubscribe.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/5429", "ttf": 14.000277777777777, "gitStatsSummary": {"insertions": 5, "deletions": 2, "lines": 7, "gitFilesChange": 1}, "title": "1.x - AsyncOnSubscribe may never complete due to premature unsubscribe from requested observables when onCompleted is emitted from the callback.", "statsSkippedReason": "", "user": "yurgisbaykshtis", "changesInPackagesGIT": ["src/main/java/rx/observables"], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 1, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonFilesChanged": 1}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 0, "alsoFixesPhrase": 0}, "body": "The problem can be reproduced using a variety of downstream operators such as zip, zipWith, mergeWith, concatEager, but only if the requested observable is delayed (simulating an async source).  Zip and mergeWith use cases require at least 90 items to be emitted (likely related to a buffer size and request-more threshold)\r\n\r\nBelow is the list of test case with delay on/off, and different item counts.\r\n\r\n```java\r\n private Observable<Integer> createAsyncOnSubscribe(int count, boolean delay, Scheduler scheduler) {\r\n    return Observable.create(AsyncOnSubscribe.<Integer,Integer>createStateful(()->0,(state, requested, emitter)->{\r\n      if (state == 0) {\r\n        Observable<Integer> items = Observable.range(0, count);\r\n        emitter.onNext(delay? items.delay(1, TimeUnit.SECONDS, scheduler) : items);\r\n      } else {\r\n        emitter.onCompleted();\r\n      }\r\n      return state + 1;\r\n    }))\r\n    .timeout(1, TimeUnit.MINUTES, scheduler);\r\n  }\r\n  \r\n  @Test\r\n  public void testConcatEagerSingleNoDelay() {\r\n    System.out.println(\"\\nconcatEager single no delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concatEager(Observable.just(createAsyncOnSubscribe(1, false, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testConcatEagerSingleDelay() {\r\n    System.out.println(\"\\nconcatEager single with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concatEager(Observable.just(createAsyncOnSubscribe(1, true, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testConcatEager100Delay() {\r\n    System.out.println(\"\\nconcatEager 100 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concatEager(Observable.just(createAsyncOnSubscribe(100, true, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testConcatEager50Delay() {\r\n    System.out.println(\"\\nconcatEager 50 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concatEager(Observable.just(createAsyncOnSubscribe(50, true, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testConcatEagerEmptyDelay() {\r\n    System.out.println(\"\\nconcatEager empty with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concatEager(Observable.just(createAsyncOnSubscribe(0, true, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testConcatSingleDelay() {\r\n    System.out.println(\"\\nconcat single with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.concat(Observable.just(createAsyncOnSubscribe(1, true, sched))).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZip100NoDelay() {\r\n    System.out.println(\"\\nzip 100 no delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.zip(Observable.just(createAsyncOnSubscribe(100, false, sched)), items->items[0]).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZip100Delay() {\r\n    System.out.println(\"\\nzip 100 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.zip(Observable.just(createAsyncOnSubscribe(100, true, sched)), items->items[0]).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZip50Delay() {\r\n    System.out.println(\"\\nzip 50 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    Observable.zip(Observable.just(createAsyncOnSubscribe(50, true, sched)), items->items[0]).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZipWith100Delay() {\r\n    System.out.println(\"\\nzipWith 100 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(100, true, sched).zipWith(Observable.range(0,Integer.MAX_VALUE), (x,y)->x).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZipWith100NoDelay() {\r\n    System.out.println(\"\\nzipWith 100 no delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(100, false, sched).zipWith(Observable.range(0,Integer.MAX_VALUE), (x,y)->x).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testZipWith50Delay() {\r\n    System.out.println(\"\\nzipWith 50 no delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(50, true, sched).zipWith(Observable.just(0), (x,y)->x).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testMergeWith100Delay() {\r\n    System.out.println(\"\\nmergeWith 100 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(100, true, sched).mergeWith(Observable.just(0)).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n\r\n  @Test\r\n  public void testMergeWith100NoDelay() {\r\n    System.out.println(\"\\nmergeWith 100 no delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(100, false, sched).mergeWith(Observable.just(0)).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n  @Test\r\n  public void testMergeWithRange50Delay() {\r\n    System.out.println(\"\\nmergeWith 50 with delay:\");\r\n    TestScheduler sched = Schedulers.test();\r\n    TestSubscriber<Object> ts = new TestSubscriber<>(); \r\n    createAsyncOnSubscribe(50, true, sched).mergeWith(Observable.just(0)).subscribe(ts);\r\n    sched.advanceTimeBy(1, TimeUnit.HOURS);\r\n    System.out.println(\"errors:\" + ts.getOnErrorEvents());\r\n    ts.assertCompleted();\r\n  }\r\n\r\n\r\n```\r\n\r\nThis is the test output:\r\n\r\n\r\nzipWith 100 with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nmergeWith 100 with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nconcatEager single no delay:\r\nerrors:[]\r\n\r\nconcatEager 50 with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nzip 50 with delay:\r\nerrors:[]\r\n\r\nconcatEager single with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nmergeWith 50 with delay:\r\nerrors:[]\r\n\r\nconcatEager empty with delay:\r\nerrors:[]\r\n\r\nzip 100 with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nzipWith 50 no delay:\r\nerrors:[]\r\n\r\nzipWith 100 no delay:\r\nerrors:[]\r\n\r\nconcat single with delay:\r\nerrors:[]\r\n\r\nconcatEager 100 with delay:\r\nerrors:[java.util.concurrent.TimeoutException]\r\n\r\nzip 100 no delay:\r\nerrors:[]\r\n\r\nmergeWith 100 no delay:\r\nerrors:[]\r\n", "labels": ["1.x", "Bug"]}, {"created": "2017-06-19 17:59:45", "user": "loneid", "body": "The following code:\r\n\r\n```\r\nimport io.reactivex.Observable;\r\nimport org.junit.Test;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class BufferTest {\r\n    @Test\r\n    public void testBuffer() {\r\n        Observable.range(0, 10)\r\n                .map(n -> {\r\n                    Thread.sleep(100);\r\n                    return n;\r\n                })\r\n                .buffer(1, TimeUnit.SECONDS, 5)\r\n                .subscribe(System.out::println);\r\n    }\r\n}\r\n\r\n```\r\nis expected to print something like:\r\n[0, 1, 2, 3, 4]\r\n[5, 6, 7, 8]\r\n[9]\r\n\r\nbut try to run it several times and you can see that sometimes it prints out:\r\n[0, 1, 2, 3, 4]\r\n[5, 6, 7, 8, 9]\r\n[5, 6, 7, 8, 9]\r\n[]\r\nwhere one of the bunches is duplicated.", "closed": "2017-06-20 08:03:37", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5426", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[2.1.0] buffer(timespan, unit, count) emits duplicated items"}, {"created": "2017-05-30 05:11:27", "user": "kojilin", "body": "RxJava 2.0.8\r\n\r\nFound code like below can works\r\n```\r\nSingle.just(\"1234\").map(s -> null)\r\n              .subscribe(s -> {\r\n                  System.out.println(s);\r\n              });\r\n```\r\n\r\nBecause Single#just not allow null, so SingleMap should not allow it?\r\nshould like this? https://github.com/ReactiveX/RxJava/compare/2.x...kojilin:FIX-NPE?expand=1", "closed": "2017-05-30 08:30:39", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5376", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Rx 2.x SingleMap should not allow null mapper?"}, {"created": "2017-04-15 12:46:21", "user": "akarnokd", "body": " - [x] `ConnectableObservable` talks about `Flowable` and `Subscriber`, remnants of copy-paste\r\n - [x] `FlowableFlattenIterable` `it.next()` is not checked for `null`\r\n - [x] `Maybe` links to `Subscriber`", "closed": "2017-04-15 20:30:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5285", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug", "Documentation", "PR welcome"], "title": "2.x: minor mistakes to be fixed"}, {"created": "2017-04-12 09:25:17", "user": "davidschreiber", "body": "RxJava 2.0.8\r\n\r\nSetting the terminal event of the `BehaviorProcessor` and replaying it to late subscribers is not an atomic action, and causes a `NullPointerException` in certain racy situations.\r\n\r\nThe root cause seems to be the non-atomicity of marking the processor terminated, and setting the terminal event, inside the `BehaviorProcessor#terminate` method, [here](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/processors/BehaviorProcessor.java#L411).\r\n\r\nFollowing is a minimal example which helps reproducing the race condition.\r\n\r\n```\r\npackage com.example;\r\n\r\nimport io.reactivex.processors.BehaviorProcessor;\r\nimport io.reactivex.subscribers.TestSubscriber;\r\n\r\npublic class BehaviorProcessorRaceExample {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i <= 100000; i++) {\r\n            final TestSubscriber<Object> s = TestSubscriber.create();\r\n            final BehaviorProcessor<Boolean> bp = BehaviorProcessor.create();\r\n\r\n            final Thread t1 = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bp.onComplete();\r\n                }\r\n            });\r\n\r\n            final Thread t2 = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bp.subscribe(s);\r\n                }\r\n            });\r\n\r\n            t1.setDaemon(true);\r\n            t2.setDaemon(true);\r\n\r\n            t1.start();\r\n            t2.start();\r\n        }\r\n    }\r\n}\r\n``` \r\n\r\nRunning this will result in exceptions like this.\r\n\r\n```\r\nException in thread \"Thread-1279\" java.lang.NullPointerException\r\n\tat io.reactivex.internal.util.NotificationLite.getError(NotificationLite.java:189)\r\n\tat io.reactivex.processors.BehaviorProcessor.subscribeActual(BehaviorProcessor.java:162)\r\n\tat io.reactivex.Flowable.subscribe(Flowable.java:12970)\r\n\tat com.example.BehaviorProcessorRaceExample$2.run(BehaviorProcessorRaceExample.java:24)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n", "closed": "2017-04-12 13:25:02", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5280", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x NullPointerException while subscribing to BehaviorProcessor"}, {"created": "2017-04-10 10:45:52", "user": "qwert2603", "body": "I noticed that ```Disposable``` returned from ```Single::subscribe(final BiConsumer<? super T, ? super Throwable> onCallback)``` returns ```false``` from ```Disposable::isDisposed``` even after ```onCallback``` was called. Version of RxJava is 2.0.8. Code sample:\r\n````\r\nimport io.reactivex.Single\r\nimport io.reactivex.disposables.Disposable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    var disposable: Disposable? = null\r\n    disposable = Single.just(34)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { item, throwable ->\r\n                println(\"1 ${disposable?.isDisposed}\")\r\n            }\r\n\r\n    println(\"2 ${disposable?.isDisposed}\")\r\n    Thread.sleep(1000)\r\n    println(\"3 ${disposable?.isDisposed}\")\r\n\r\n}\r\n\r\n````\r\n\r\nOutput is:\r\n````\r\n2 false\r\n1 false\r\n3 false\r\n````", "closed": "2017-04-10 12:44:53", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5276", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Single's Disposable is not disposing."}, {"created": "2017-03-31 08:07:37", "user": "dvasko", "body": "Notices few of this crashes, is there any way to find from where they are coming?\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke interface method 'boolean java.util.Collection.add(java.lang.Object)' on a null object reference\r\n       at io.reactivex.internal.operators.flowable.FlowableToList$ToListSubscriber.onNext(FlowableToList.java:71)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext(FlowableFilter.java:73)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext(FlowableFilter.java:51)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.innerNext(FlowableConcatMap.java:215)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onNext(FlowableConcatMap.java:592)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable$IteratorSubscription.fastPath(FlowableFromIterable.java:181)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable$BaseRangeSubscription.request(FlowableFromIterable.java:123)\r\n       at io.reactivex.internal.subscriptions.SubscriptionArbiter.setSubscription(SubscriptionArbiter.java:96)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onSubscribe(FlowableConcatMap.java:585)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribe(FlowableFromIterable.java:69)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribeActual(FlowableFromIterable.java:47)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:12901)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.drain(FlowableConcatMap.java:343)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$BaseConcatMapSubscriber.onNext(FlowableConcatMap.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.onNext(FlowableSubscribeOn.java:97)\r\n       at io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:133)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromCallable.subscribeActual(FlowableFromCallable.java:44)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:12901)\r\n       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n       at java.lang.Thread.run(Thread.java:761)\r\n```", "closed": "2017-03-31 17:33:29", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5246", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: NullPointerException in FlowableToList$ToListSubscriber.onNext"}, {"created": "2017-03-24 15:54:07", "user": "4xes", "body": "I have completable that contains `merge` or `andThen`. \r\nThen I add `onErrorResumeNext` into sequence. In this case, If we unsubscribe the whole `subscription` when `com1` is not completed yet then `com2` won't be unsubscribed.\r\n\r\nCode sample:\r\n```java\r\n        Completable com1 = Completable\r\n                .fromAction(() -> {\r\n                    try {\r\n                        Thread.sleep(3000);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    Log.d(TAG, \"c1\");\r\n                })\r\n                .doOnSubscribe(s1 -> Log.d(TAG, \"com1 subscribe\"))\r\n                .doOnUnsubscribe(() -> Log.d(TAG, \"com1 unsubscribe\"));\r\n\r\n        Completable com2 = Completable\r\n                .fromAction(() -> {\r\n                    try {\r\n                        Thread.sleep(6000);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    Log.d(TAG, \"c2\");\r\n                })\r\n                .doOnSubscribe(s2 -> Log.d(TAG, \"com2 subscribe\"))\r\n                .doOnUnsubscribe(() -> Log.d(TAG, \"com2 unsubscribe\"));\r\n\r\n        Subscription subscription =\r\n                Completable.merge(\r\n                        com1,\r\n                        com2\r\n                )\r\n                        .subscribeOn(Schedulers.from(Executors.newSingleThreadExecutor()))\r\n                        .onErrorResumeNext(throwable ->\r\n                                Completable\r\n                                        .fromAction(() -> Log.d(TAG, \"error happened\"))\r\n                        )\r\n                        .doOnSubscribe(s -> Log.d(TAG, \"subscribe\"))\r\n                        .doOnUnsubscribe(() -> Log.d(TAG, \"unsubscribe\"))\r\n                        .subscribe(\r\n                                () -> Log.d(TAG, \"onComplete \"),\r\n                                throwable -> Log.d(TAG, \"onError \" + throwable)\r\n                        );\r\n\r\n        Completable\r\n                .fromAction(() -> {\r\n                    subscription.unsubscribe();\r\n                    Log.d(TAG,\"whole subscription unsubscribe\");\r\n                })\r\n                .delay(2, TimeUnit.SECONDS)\r\n                .subscribe();\r\n```\r\nResult:\r\n```\r\nD: subscribe\r\nD: com1 subscribe\r\nD: whole subscription unsubscribe\r\nD: c1\r\nD: com2 subscribe\r\nD: c2\r\nD: onComplete \r\n```\r\n\r\nCase without operator `onErrorResumeNext` :\r\n```\r\nD: subscribe\r\nD: com1 subscribe\r\nD: unsubscribe\r\nD: com1 unsubscribe\r\nD: whole subscription unsubscribe\r\nD: c1\r\n```", "closed": "2017-03-27 07:34:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5224", "ttf": 2.000277777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "1.2.9: Completable not unsubscribe with onErrorResumeNext"}, {"created": "2017-03-20 16:11:07", "user": "hkurokawa", "body": "I ran the below test code with RxJava 2.0.7 and got a failure which succeeded with RxJava 1.x.\r\n\r\n```java\r\n    final TestObserver<Boolean> observer = TestObserver.create();\r\n    Observable.<Boolean>create(emitter -> {\r\n      emitter.onNext(Thread.interrupted());\r\n      emitter.onComplete();\r\n    })\r\n        .delaySubscription(100, TimeUnit.MICROSECONDS)\r\n        .subscribe(observer);\r\n    observer.awaitTerminalEvent();\r\n    observer.assertValue(false);\r\n  }\r\n```\r\n\r\nIf I put `subscribeOn()` before `delaySubscription()`, it does not fail.\r\n\r\nI am not sure if it is as expected so want to know if it is the expected behaviour.\r\n\r\nHere is some background of my issue: I am using RxJava 2.0.7 with Retrofit 2.2.0 and it seems Retrofit (precisely speaking, Okio, which is being used in OkHttp) throws an error when the thread is interrupted while it tries to read the HTTP response. I am trying to delay the HTTP call to achieve something like debounce() with delaySubscription() operator and encountered this issue. I have a workaround so just want to know if it is the expected behaviour.\r\n\r\nThank you for your support in advance.", "closed": "2017-03-27 07:35:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5203", "ttf": 6.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Is delaySubscription() interrupts the thread immediately as expected?"}, {"created": "2017-03-09 14:30:17", "user": "janbols", "body": "Hi, I'm running `io.reactivex.rxjava2:rxjava:2.0.6` .\r\n\r\nWhen doing the following, the thread running the otherSingleSource has its interrupted flag set. This throws` java.lang.InterruptedException`s. Below, you can find an example:\r\n````\r\nSingle.timer(3, TimeUnit.SECONDS)\r\n                .timeout(1, TimeUnit.SECONDS, Single.fromCallable { return Long.MAX_VALUE })\r\n                .blockingGet()\r\n````\r\n\r\nThe thread that runs `return Long.MAX_VALUE` is interrupted.  You can find a unit test using spock on https://gist.github.com/janbols/e97ceb349641f58895379ff562aab59b\r\n\r\nThe same effect is observed when we call `timeout `with an explicit scheduler. The only way I could make this working is by subscribing the otherSingleSource on another thread like the following:\r\n````\r\nSingle.timer(3, TimeUnit.SECONDS)\r\n                .timeout(1, TimeUnit.SECONDS, Single.fromCallable { return Long.MAX_VALUE }).subscribeOn(io())\r\n                .blockingGet()\r\n````\r\n\r\n\r\nI tried to debug the code and I think it has something to do with the call to `set.clear()` inside the runnable when the timer expires in `io.reactivex.internal.operators.single.SingleTimeout#subscribeActual`. At that time `set` contains the `timer` disposable and by clearing it, you're also interrupting the thread that's running the task in `io.reactivex.internal.schedulers.ScheduledRunnable#dispose`.\r\n\r\nOf course I could be completely wrong as well since thread scheduling isn't really my cup of tea :-).", "closed": "2017-03-29 09:07:49", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5169", "ttf": 19.00027777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Thread running otherSingleSource of a timeout is interrupted before running"}, {"created": "2017-03-08 09:15:56", "user": "kxfeng", "body": "When using Single.subscribe(onSuccess, onError) , the returned Disposable is not disposed after terminal event. However , for Observable, Flowable, Maybe and Completable , the results are all disposed.\r\n\r\nHere is the test code: \r\n```java\r\n@Test\r\npublic void testDisposable() throws Exception {\r\n\r\n\tDisposable disposable;\r\n\r\n\tdisposable = Single.just(1).subscribe(\r\n\t\tnext -> System.out.println(\"Single Success\"),\r\n\t\terror -> System.out.println(\"Single Error\")\r\n\t);\r\n\r\n\tSystem.out.println(\"Single Disposed: \" + disposable.isDisposed());\r\n\r\n\tdisposable = Observable.just(1).subscribe(\r\n\t\tnext -> System.out.println(\"Observable Next\"),\r\n\t\terror -> System.out.println(\"Observable Error\"),\r\n\t\t() -> System.out.println(\"Observable Complete\")\r\n\t);\r\n\r\n\tSystem.out.println(\"Observable Disposed: \" + disposable.isDisposed());\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\nSingle Success\r\nSingle Disposed: false\r\n\r\nObservable Next\r\nObservable Complete\r\nObservable Disposed: true\r\n```\r\n\r\nI found the Disposeable not lazySet to DISPOSED in  ConsumerSingleObserver compared with LambdaObserver. Is this a bug or there are some special reasons to do this?\r\n\r\n\r\n```java\r\nConsumerSingleObserver\r\n\r\n@Override\r\npublic void onSuccess(T value) {\r\n\ttry {\r\n\t\tonSuccess.accept(value);\r\n\t} catch (Throwable ex) {\r\n\t\tExceptions.throwIfFatal(ex);\r\n\t\tRxJavaPlugins.onError(ex);\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\nLambdaObserver\r\n\r\n@Override\r\npublic void onComplete() {\r\n\tif (!isDisposed()) {\r\n\t\tlazySet(DisposableHelper.DISPOSED);\r\n\t\ttry {\r\n\t\t\tonComplete.run();\r\n\t\t} catch (Throwable e) {\r\n\t\t\tExceptions.throwIfFatal(e);\r\n\t\t\tRxJavaPlugins.onError(e);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nRxJava 2.0.6", "closed": "2017-03-08 17:05:41", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5160", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Disposable returned from Single.subscribe() is not disposed after terminal event"}, {"created": "2017-02-27 13:34:03", "user": "adevhere", "body": " - Using RxJava 2.0.6\r\n\r\nIt seems [this issue](https://github.com/ReactiveX/RxJava/issues/3917) is still present in RxJava 2. When late subscribers `subscribe()` to a source with `replay(time, unit)` that has already expired, the source still emits the \"expired emission\" if `onNext()` is not called.\r\n\r\nPosted this originally on [StackOverflow](http://stackoverflow.com/questions/42486432/rxjavas-replaytime-unit-is-replaying-expired-emissions-is-that-the-expect) but I'm now referencing it here because it seems to be an issue with the library.", "closed": "2017-02-27 18:26:41", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5139", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: replay() seems to be still replaying old data for late subscribers"}, {"created": "2017-02-24 19:56:59", "user": "HolySamosa", "body": "When I attempt to use `retryWhen` to delay a retry with `Completable` or `Single` I receive an _incompatible types_ error, as demonstrated in the following code:\r\n            \r\n            Completable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {\r\n                        @Override\r\n                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS); // <- Incompatible type error\r\n                        }\r\n                    });\r\n            \r\n            Single.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {\r\n                        @Override\r\n                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS); // <- Incompatible type error\r\n                        }\r\n                    });\r\n\r\n\r\nHowever, there are no issues with `Observable` or `Flowable`:\r\n\r\n            Observable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {\r\n                        @Override\r\n                        public ObservableSource<?> apply(@io.reactivex.annotations.NonNull Observable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS);\r\n                        }\r\n                    });\r\n            Flowable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<?>>() {\r\n                        @Override\r\n                        public Publisher<?> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS);\r\n                        }\r\n                    });\r\n\r\nLooks like there is an issue with the return types for `apply`?", "closed": "2017-02-25 20:48:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5135", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "retryWhen method signature for with Completable and Single"}, {"created": "2017-02-24 07:33:43", "user": "stepango", "body": "Sorry for code in kotlin.\r\n\r\n```\r\n    @Test fun singleMergeTest() {\r\n        val illegalAccessError = IllegalAccessError()\r\n        Single.merge<String>(listOf(\r\n                Single.error(illegalAccessError),\r\n                Single.error(illegalAccessError),\r\n                Single.error(illegalAccessError)\r\n        )).test().await().assertError(illegalAccessError)\r\n    }\r\n\r\n    @Test fun observableMergeTest() {\r\n        val illegalAccessError = IllegalAccessError()\r\n        Observable.merge<String>(listOf(\r\n                Observable.error(illegalAccessError),\r\n                Observable.error(illegalAccessError),\r\n                Observable.error(illegalAccessError)\r\n        )).test().await().assertError(illegalAccessError)\r\n    }\r\n```\r\n\r\nFirst test produces `UndeliverableError` after execution but second one completes successfully without errors. Is it expected behaviour or a bug?", "closed": "2017-02-24 14:40:23", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5132", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x v2.0.6 Single.merge produce UndeliverableError [Question]"}, {"created": "2017-02-20 00:42:48", "user": "juhwan-jeong", "body": "I used throttleFirst operator for prevening duplicated click event like below\r\n```\r\nRxView.clicks(v).throttleFirst(500, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread())\r\n```\r\n\r\nIt works well in general case. But if user changed system time as past after click view, thrrottleFist doesn't emit item. (In the android, user can change system time using settings application.)\r\nBecause, OperatorThrottleFirst's below routine. \r\n```\r\n    @Override\r\n    public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\r\n        return new Subscriber<T>(subscriber) {\r\n\r\n            private long lastOnNext = -1;\r\n            // ...\r\n            @Override\r\n            public void onNext(T v) {\r\n                long now = scheduler.now();\r\n                if (lastOnNext == -1 || now - lastOnNext >= timeInMilliseconds) {\r\n                    lastOnNext = now;\r\n                    subscriber.onNext(v);\r\n                }\r\n            }\r\n```\r\nI think (now - lastOnNext) become negative value, item should be emitted too. ", "closed": "2017-02-24 14:26:21", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5120", "ttf": 4.000277777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "[1.2.6] throttleFirst doesn't emit item if user changed system time as past"}, {"created": "2017-02-17 23:20:08", "user": "jbarr21", "body": "When a ObservableCombineLatest is disposed, is there any particular reason why it does not dispose all of it's observers? i'm seeing `getAndIncrement()` be non-zero and that observer is not receiving any more events, so a memory leak is caused\r\n\r\nhttps://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java#L128", "closed": "2017-02-18 20:29:30", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5111", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Disposal of ObservableCombineLatest's observers?"}, {"created": "2017-02-17 02:14:45", "user": "xiemeilong", "body": "This code will print nothing all the time.\r\n\r\n```java\r\nPublishSubject<String> vehicleToFetch = PublishSubject.create();\r\n        vehicleToFetch\r\n                .delay(2,TimeUnit.SECONDS)\r\n                .window(10, TimeUnit.SECONDS, 5)\r\n                .observeOn(Schedulers.io())\r\n                .subscribe(w-> w.toList().subscribe(ws-> {\r\n                    ws.forEach(v -> {\r\n                        System.out.println(String.format(\"%s %d\", v, Thread.currentThread().getId()));\r\n                        vehicleToFetch.onNext(v);\r\n                    });\r\n                }));\r\n\r\n\r\n        Observable.just(\"v1\",\"v2\",\"v3\",\"v4\")\r\n                .subscribe(v->{\r\n                    vehicleToFetch.onNext(v);\r\n                });\r\n\r\n```\r\n\r\nI am using rxjava:2.0.6.\r\n", "closed": "2017-02-18 20:30:57", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5104", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x : window(timespan, unit, count) always emit empty observable if not reach max count"}, {"created": "2017-02-16 14:51:37", "user": "ekosuhariyadi", "body": "Hi, I'm relatively new to RxJava.\r\n\r\nI tried RxJava 2.0.6 (previously 2.0.5) to check if it still produces the same result.\r\n\r\nHere my code (still using Java 6)\r\n\r\n```\r\nMaybe<String> m1 = Maybe.create(new MaybeOnSubscribe<String>() {\r\n\r\n    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {\r\n        System.out.println(\"m1 called\");\r\n        e.onSuccess(\"m1\");\r\n    }\r\n});\r\nMaybe<String> m2 = Maybe.create(new MaybeOnSubscribe<String>() {\r\n\r\n    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {\r\n        System.out.println(\"m2 called\");\r\n        e.onSuccess(\"m2\");\r\n    }\r\n});\r\nDisposable subscribe = Maybe.concat(m1, m2)\r\n        .firstElement()\r\n        .subscribe(new Consumer<String>() {\r\n\r\n            @Override public void accept(String t) throws Exception {\r\n                System.out.println(t);\r\n            }\r\n        });\r\n```\r\n\r\nthe output :\r\nm1 called\r\nm1\r\nm2 called\r\n\r\nIs it correct or not? Because while using Observable, the second Observable is not called when the first one already emit value\r\n\r\nThanks", "closed": "2017-02-16 17:22:20", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5100", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Maybe concat with firstElement still call second Maybe although the first emit value"}, {"created": "2017-02-10 04:56:03", "user": "lambdas", "body": "Hi guys! \r\n\r\nI'm using `Flowable.scan(seed)` to accumulate values of infinite sequence(stream of updates from server that comes not so often). The problem is that whenever FlowableScanSeed receives new value it publishes previous one. I guess it's not a problem with a finite sequence(at completion all values will be published anyway), but with infinite seq the last value is held until next comes.\r\n\r\nI wrote test case to demonstrate the issue\r\n```\r\n    @Test\r\n    public void testScanWithSeedEmitsAllItemsOnInfiniteSequence() {\r\n        Flowable.concat(Flowable.just(1, 2, 3), Flowable.<Integer>never()).scan(0, SUM)\r\n                .test(4)\r\n                .assertValues(0, 1, 3, 6);\r\n    }\r\n```\r\n\r\nHere seed+3 values are expected, but since sequence is infinite last value never comes.\r\n\r\nI don't have much experience with rx so can't provide you with a patch, sorry ;)", "closed": "2017-02-11 18:07:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5089", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.0.4 FlowableScanSeed introduces delay"}, {"created": "2017-02-03 15:40:04", "user": "hvisser", "body": "Stack trace below shows a crash that I unfortunately can't reproduce currently. I've checked the source for `ObservableReplay.ReplayObserver` and it looks like this can only happen if it's being disposed before being subscribed which sounds odd to me? What might be relevant is that `unsubscribeOn()` is used on the observable.\r\n\r\n```\r\njava.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n    at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:361)\r\n    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:216)\r\n    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:79)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$2.run(ObservableRefCount.java:126)\r\n    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:28)\r\n    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:18)\r\n    at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:42)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:181)\r\n    at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:79)\r\n    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onSubscribe(ObservableSubscribeOn.java:58)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount.doSubscribe(ObservableRefCount.java:113)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:98)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:92)\r\n    at io.reactivex.internal.operators.observable.ObservableReplay.connect(ObservableReplay.java:305)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n    at io.reactivex.Observable.subscribe(Observable.java:10514)\r\n    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n    at io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n    at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n    at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n    at java.lang.Thread.run(Thread.java:761)\r\n```", "closed": "2017-02-03 18:41:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5060", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: NPE at ObservableReplay.ReplayObserver.dispose()"}, {"created": "2017-01-27 22:24:33", "user": "sbarlabanov", "body": "There are a plenty of issues fixing some sorts of backpressure problems in groupBy (e.g. #3428, #3425).\r\nBut nevertheless when I try the following code it requests all 10000 values from the source at once without waiting for processing of single items (example running with rxjava 1.2.x):\r\n\r\n```\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\n\r\nimport java.util.Random;\r\n\r\nimport static rx.Observable.range;\r\n\r\npublic class GroupByTest {\r\n    public static void main(String[] args) throws Exception {\r\n        Observable<Integer> source = range(1, 10000);\r\n        source\r\n                .doOnNext(i -> System.out.println(\"Requested \" + i))\r\n                .groupBy(v -> v % 5)\r\n                .flatMap(g -> g.observeOn(Schedulers.io()).map(GroupByTest::calculation))\r\n                .subscribe(i -> System.out.println(\"Got \" + i));\r\n        Thread.sleep(100000);\r\n    }\r\n\r\n    private static Integer calculation(Integer i) {\r\n        sleep();\r\n        System.out.println(\"Processing \" + i);\r\n        return i * 20;\r\n    }\r\n\r\n    private static void sleep() {\r\n        try {\r\n            Thread.sleep(new Random().nextInt(1000));\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen running the code I see 10000 \"Requested X\" messages getting printed immediately and afterwards messages \"Processing X\" coming after some timeout.\r\nWith this behavior it does not seem to be possible to parallelize processing of single groups in rxjava  in any useful way when working with large or unlimited sources.", "closed": "2017-01-28 18:17:51", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5029", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "GroupBy with flatMap and observeOn does not seem to support backpressure in 1.2.x"}, {"created": "2017-01-18 14:38:44", "user": "konmik", "body": "\r\nThis fails:\r\n\r\n    @Test\r\n    public void directScheduleOnSingleThreadExecutor() {\r\n        Scheduler scheduler = Schedulers.from(Executors.newSingleThreadExecutor());\r\n\r\n        Disposable disposable = scheduler.scheduleDirect(() -> {\r\n        });\r\n\r\n        long start = nanoTime();\r\n        while (!disposable.isDisposed()) {\r\n            assertTrue(nanoTime() - start < SECONDS.toNanos(10));\r\n        }\r\n    }\r\n\r\nwhile replacing `from(...)` with `io()` works\r\n\r\nI can't find where the error exactly is, my debugger can't jump in to the right source code line.\r\n", "closed": "2017-01-18 19:35:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/5004", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.0.4: an infinite disposable"}, {"created": "2017-01-13 09:47:52", "user": "loongee", "body": "Exception unhandled if dispose() called.\r\nDid I used it in a wrong way ?\r\n\r\nerror stack:\r\n```\r\njava.lang.IllegalStateException: example\r\n\tat com.example.MyClass$2.apply(MyClass.java:31)\r\n\tat com.example.MyClass$2.apply(MyClass.java:23)\r\n\tat io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:63)\r\n\tat io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:246)\r\n\tat io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10179)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nException in thread \"RxCachedThreadScheduler-1\" java.lang.IllegalStateException: illegal\r\n\tat com.example.MyClass$2.apply(MyClass.java:31)\r\n\tat com.example.MyClass$2.apply(MyClass.java:23)\r\n\tat io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:63)\r\n\tat io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:246)\r\n\tat io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10179)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n\r\n\r\nsample code:\r\n\r\n```\r\n\r\npublic class MyClass {\r\n\r\n    static Disposable disposable = null;\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Observable.just(1)\r\n                .subscribeOn(Schedulers.io())\r\n                .flatMap(new Function<Integer, ObservableSource<Integer>>() {\r\n                    @Override\r\n                    public ObservableSource<Integer> apply(Integer integer) throws Exception {\r\n                        long endTime = System.currentTimeMillis() + 500;\r\n                        while (System.currentTimeMillis() < endTime) {\r\n                        }\r\n                        return Observable.error(new IllegalStateException(\"example\"));\r\n                    }\r\n                })\r\n                .subscribe(new Observer<Integer>() {\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onComplete() {}\r\n\r\n                    @Override\r\n                    public void onSubscribe(Disposable d) {\r\n                        disposable = d;\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer integer) {}\r\n                });\r\n\r\n\r\n        try {\r\n            Thread.sleep(50);\r\n            disposable.dispose();\r\n            Thread.sleep(500000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n}\r\n```", "closed": "2017-01-17 09:54:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4991", "ttf": 4.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x Exception unhandled after dispose()"}, {"created": "2017-01-12 16:11:19", "user": "StanislavChumarin", "body": "Observable.combineLatestDelayError sends error event after complete event happened and treated as unhandled.\r\nChecked on ```rx.Observable```, ```io.reactivex.Observable``` and ```Flowable```\r\n\r\n``` Java\r\n    @Test\r\n    public void testCombine() {\r\n        rx.observers.TestSubscriber<Integer> testSubscriber = rx.observers.TestSubscriber.create();\r\n\r\n        rx.Observable<Long> emptyObservable = rx.Observable.empty();\r\n        rx.Observable<Object> errorObservable = rx.Observable.error(new Exception());\r\n\r\n        rx.Observable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyObservable: \" + integerNotification))\r\n                                .doOnTerminate(() -> System.out.println(\"emptyObservable: doFinally\")),\r\n                        errorObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorObservable: \" + integerNotification))\r\n                                .doOnTerminate(() -> System.out.println(\"errorObservable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doOnTerminate(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testSubscriber);\r\n\r\n        testSubscriber.awaitTerminalEvent();\r\n    }\r\n\r\n    @Test\r\n    public void testCombine2() {\r\n        TestObserver<Integer> testObserver = TestObserver.create();\r\n\r\n        Observable<Long> emptyObservable = Observable.empty();\r\n        Observable<Object> errorObservable = Observable.error(new Exception());\r\n\r\n        Observable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyObservable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"emptyObservable: doFinally\")),\r\n                        errorObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorObservable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"errorObservable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doFinally(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testObserver);\r\n\r\n        testObserver.awaitTerminalEvent();\r\n    }\r\n\r\n    @Test\r\n    public void testCombine2Flowable() {\r\n        TestSubscriber<Integer> testObserver = TestSubscriber.create();\r\n\r\n        Flowable<Integer> emptyFlowable = Flowable.empty();\r\n        Flowable<Object> errorFlowable = Flowable.error(new Exception());\r\n\r\n        Flowable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"emptyFlowable: doFinally\")),\r\n                        errorFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"errorFlowable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doFinally(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testObserver);\r\n\r\n        testObserver.awaitTerminalEvent();\r\n    }\r\n```\r\n\r\nOutput:\r\ntestCombine\r\n```\r\nemptyObservable: [rx.Notification@2b4a2ec7 OnCompleted]\r\nemptyObservable: doFinally\r\ncombineLatestDelayError: [rx.Notification@2b4a2ec7 OnCompleted]\r\ncombineLatestDelayError: doFinally\r\n```\r\ntestCombine2\r\n```\r\nemptyObservable: OnCompleteNotification\r\ncombineLatestDelayError: OnCompleteNotification\r\ncombineLatestDelayError: doFinally\r\nemptyObservable: doFinally\r\nerrorObservable: OnErrorNotification[java.lang.Exception]\r\nerrorObservable: doFinally\r\njava.lang.Exception\r\n\tat com.myproject.Test.testCombine2(Test.java:298)\r\n\t// not really important Stacktrace\r\nException in thread \"main\" java.lang.Exception\r\n\tat com.myproject.Test.testCombine2(Test.java:298)\r\n\t// repeat of not important Stacktrace\r\n```\r\ntestCombine2Flowable\r\n```\r\nemptyFlowable: OnCompleteNotification\r\ncombineLatestDelayError: OnCompleteNotification\r\ncombineLatestDelayError: doFinally\r\nemptyFlowable: doFinally\r\n```\r\n\r\nIf error emitter goes first or add some timer instead of empty, then everything is ok. \r\n\r\nAlso noticed difference in events order between 1.x and 2.x. Is it correct?", "closed": "2017-01-19 14:01:31", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4986", "ttf": 6.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x Observable.combineLatestDelayError delivers Error after completion"}, {"created": "2017-01-11 12:01:35", "user": "ansman", "body": "Sample code (using RxJava 2.0.4):\r\n```java\r\nObservable.just(1, 2, 3, 4, 5)\r\n        .concatMapEager(i -> {\r\n            System.out.println(\"Processing \" + i);\r\n            return i == 3 ? Observable.just(i) : Observable\r\n                    .just(i)\r\n                    .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());\r\n        })\r\n        .observeOn(Schedulers.io())\r\n        .subscribe(i -> System.out.println(\"Value: \" + i));\r\n```\r\n\r\nExpected output:\r\n```\r\nProcessing 1\r\nProcessing 2\r\nProcessing 3\r\nProcessing 4\r\nProcessing 5\r\nValue: 1\r\nValue: 2\r\nValue: 3\r\nValue: 4\r\nValue: 5\r\n```\r\n\r\nActual output:\r\n```\r\nProcessing 1\r\nProcessing 2\r\nProcessing 3\r\nProcessing 4\r\nProcessing 5\r\nValue: 3\r\nValue: 1\r\nValue: 2\r\nValue: 4\r\nValue: 5\r\n```\r\n\r\nAs you can see the order is incorrect. This is due to the fact that the item `3` is mapped to a `Callable` source which won't wait for the previous observables.", "closed": "2017-01-11 19:35:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4981", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x Observable#concatMapEager doesn't always preserve order"}, {"created": "2017-01-08 02:48:39", "user": "ZacSweers", "body": "We're seeing an NPE from the `s` field of `SerializedObserver` not being set when used with `.withLatestFrom()`. Digging around in the source, it looks like it internally is not calling `onSubscribe()` to the `actual` observer field.\r\n\r\nExample trace looks like this:\r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat io.reactivex.observers.SerializedObserver.onNext(SerializedObserver.java:91)\r\n\tat io.reactivex.internal.operators.observable.ObservableWithLatestFrom$WithLatestFromObserver.onNext(ObservableWithLatestFrom.java:101)\r\n\tat io.reactivex.internal.operators.observable.ObservableFilter$FilterObserver.onNext(ObservableFilter.java:51)\r\n\tat io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:63)\r\n\tat io.reactivex.subjects.PublishSubject$PublishDisposable.onNext(PublishSubject.java:263)\r\n\tat io.reactivex.subjects.PublishSubject.onNext(PublishSubject.java:182)\r\n```\r\n\r\nThe snippet in `SerializedObserver` that corresponds to\r\n\r\n```java\r\n    @Override\r\n    public void onNext(T t) {\r\n        if (done) {\r\n            return;\r\n        }\r\n        if (t == null) {\r\n            s.dispose();  // <----- this line, \"s\" is null because onSubscribe was never called\r\n            onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\r\n            return;\r\n        }\r\n```", "closed": "2017-01-09 06:29:50", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4969", "ttf": 1.0002777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: WithLatestFrom not calling onSubscribe() on `actual` observer"}, {"created": "2017-01-06 05:35:54", "user": "skgmn", "body": "```java\r\nSingle<T> main;\r\nFlowable<T> other;\r\n\r\nmain.takeUntil(other.take(1)).subscribe(...);\r\n```\r\n\r\nThis pseudo-code crashes when `other` emits an item. `SingleTakeUntil.TakeUntilOtherSubscriber.onCompleted()` is called twice and second call generate a crash. Please fix this.", "closed": "2017-01-06 23:09:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4961", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.0.3 Single.takeUntil() crashes "}, {"created": "2017-01-04 13:43:13", "user": "StanislavChumarin", "body": "Recently discovered behaviour that brings incorrect order for Observable.doFinally\r\n\r\nHere is code to check\r\n``` Java\r\n    @Test\r\n    public void operationFinallyOrder() throws Exception {\r\n        Single.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Single.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Single.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Single.onSuccess\"),\r\n                        t -> System.out.println(\"Single.onError\"));\r\n        System.out.println();\r\n\r\n        Completable.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Completable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Completable.doFinally\"))\r\n                .subscribe(() -> System.out.println(\"Completable.onComplete\"),\r\n                        t -> System.out.println(\"Completable.onError\"));\r\n        System.out.println();\r\n\r\n        Observable.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Observable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Observable.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Observable.onNext\"),\r\n                        t -> System.out.println(\"Observable.onError\"),\r\n                        () -> System.out.println(\"Observable.onComplete\"));\r\n        System.out.println();\r\n\r\n        Observable.just(new Object())\r\n                .doOnDispose(() -> System.out.println(\"Observable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Observable.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Observable.onNext\"),\r\n                        t -> System.out.println(\"Observable.onError\"),\r\n                        () -> System.out.println(\"Observable.onComplete\"));\r\n    }\r\n```\r\nOutput:\r\n```\r\nSingle.onError\r\nSingle.doFinally\r\n\r\nCompletable.onError\r\nCompletable.doFinally\r\n\r\nObservable.doOnDispose\r\nObservable.doFinally\r\nObservable.onError\r\n\r\nObservable.onNext\r\nObservable.doOnDispose\r\nObservable.doFinally\r\nObservable.onComplete\r\n```\r\nAs you can see, order and amount of messages for Single and Completable are correct, but ```LambdaObserver``` calls dispose before terminal event. That triggers doFinally too early. \r\nAccording to new lifecycle (confirmed here https://github.com/ReactiveX/RxJava/issues/4811) no messages Observable.doOnDispose should be there.\r\n", "closed": "2017-01-04 15:22:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4956", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "RxJava 2.0.4 Observable calls dispose before terminal event."}, {"created": "2016-12-29 17:42:35", "user": "mbezzubenko", "body": "Please have a look at this sample:\r\n\r\n    public void testSubject() {\r\n        io.reactivex.subjects.PublishSubject<Integer> subject = io.reactivex.subjects.PublishSubject.create();       \r\n        subject\r\n                .timeout(10, TimeUnit.SECONDS, io.reactivex.Observable.error(new RuntimeException()))\r\n                .takeWhile(integer -> integer < 3)\r\n                .toList()\r\n                .subscribe(integers -> System.out.println(integers), throwable -> System.out.println(\"throwable\"));\r\n\r\n        subject.onNext(0);\r\n        subject.onNext(1);\r\n        subject.onNext(2);\r\n        subject.onNext(3);\r\n\r\n        subject.onError(new RuntimeException());\r\n    }\r\n`\r\nIt is expected, that after posting value '3' chain emits result [0, 1, 2] and unsubscribes from the subject and subsequent posting of RuntimeException doesn't push it anywhere and doesn't throw it.\r\n\r\nBut on v2.0.3 it crashes with RuntimeException\r\n\r\nThe same test with rx.subjects.PublishSubject on v1.2.4 works as expected\r\n\r\nIf remove timeout from the chain everything works as expected.\r\n\r\nThanks", "closed": "2016-12-29 19:38:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4944", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Using Observable.timeout could cause uncaught exception in RxJava 2.x"}, {"created": "2016-12-28 19:13:59", "user": "mstrdev", "body": " - version 1.2.4\r\n\r\nIssue reproduced with android app on device \"Lenovo IdeaTab s6000-H\". I solve many problems with Unsafe by setting \"rx.unsafe-disable\" flag. But BaseLinkedQueueProducerNodeRef ignored this flag. And I received this:\r\n\r\n\r\n```\r\nE/AndroidRuntime: FATAL EXCEPTION: RxIoScheduler-7\r\nava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234)\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\r\n   at java.lang.Thread.run(Thread.java:838)\r\nCaused by: java.lang.ExceptionInInitializerError\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:56)\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:27)\r\n   at rx.Completable.unsafeSubscribe(Completable.java:2037)\r\n   at rx.Completable$31$1.call(Completable.java:2149)\r\n   at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:230)\r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\u00a0\r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234)\u00a0\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\u00a0\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\u00a0\r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\u00a0\r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\u00a0\r\n   at java.lang.Thread.run(Thread.java:838)\u00a0\r\nCaused by: java.lang.NullPointerException\r\n   at rx.internal.util.unsafe.UnsafeAccess.addressOf(UnsafeAccess.java:113)\r\n   at rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef.<clinit>(BaseLinkedQueue.java:33)\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:56)\u00a0\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:27)\u00a0\r\n   at rx.Completable.unsafeSubscribe(Completable.java:2037)\u00a0\r\n   at rx.Completable$31$1.call(Completable.java:2149)\u00a0\r\n   at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:230)\u00a0\r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\u00a0\r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\u00a0\r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234)\u00a0\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\u00a0\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\u00a0\r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\u00a0\r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\u00a0\r\n   at java.lang.Thread.run(Thread.java:838)\u00a0\r\n```\r\n\r\nI think that problem with line 33 which directly invoke  Unsafe methods:\r\n```\r\n  protected final static long P_NODE_OFFSET = UnsafeAccess.addressOf(BaseLinkedQueueProducerNodeRef.class, \"producerNode\");\r\n```\r\n", "closed": "2016-12-28 21:04:06", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4940", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "BaseLinkedQueueProducerNodeRef  ignored flag rx.unsafe-disable"}, {"created": "2016-12-20 17:22:55", "user": "smiklos", "body": "I'm using RxJava version 2.0.2 and wanted to implement a some logic using `Flowable.generate`.\r\n\r\nBased on the documentation, if I emit more than one item in when calling onNext on the emitter instance, I should get an `IllegalStateException`, but in reality I experience a different behavior:\r\n\r\nTaking this example:\r\n\r\n```\r\n Flowable<Object> test = Flowable.generate(emitter -> {\r\n            emitter.onNext(\"test\");\r\n            emitter.onNext(\"test more\");\r\n        }).observeOn(Schedulers.io(), false,5)\r\n          .doOnNext(System.out::println);\r\n        test.blockingSubscribe();\r\n```\r\n\r\nI get this error: `io.reactivex.exceptions.MissingBackpressureException: Queue is full?!`\r\n\r\nand if I just try: \r\n```\r\n    Flowable<Object> test = Flowable.generate(emitter -> {\r\n            emitter.onNext(\"test\");\r\n            emitter.onNext(\"test more\");\r\n        })\r\n       .doOnNext(System.out::println);\r\n        test.subscribe();\r\n```\r\nthen it just pushes the values indefinitely.\r\n", "closed": "2016-12-21 09:08:21", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4931", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Problem with Flowable.generate() (RxJava 2)"}, {"created": "2016-12-19 07:48:07", "user": "nhaarman", "body": "- Library version 2.0.3\r\n\r\nThe following test occasionally fails (about 200 out of 1000 fail):\r\n\r\n```kotlin\r\n@Test\r\nfun test() {\r\n    var t: Throwable? = null\r\n    RxJavaPlugins.setErrorHandler { t = it }\r\n    Observable.timer(0L, MILLISECONDS).blockingFirst()\r\n    t?.let { throw it }\r\n}\r\n```\r\n\r\nStacktrace:\r\n\r\n```\r\njava.lang.IllegalStateException: Disposable already set!\r\n\r\n\tat io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:144)\r\n\tat io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:70)\r\n\tat io.reactivex.internal.operators.observable.ObservableTimer$IntervalOnceObserver.setResource(ObservableTimer.java:74)\r\n\tat io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:40)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10514)\r\n\tat io.reactivex.Observable.blockingFirst(Observable.java:4535)\r\n\tat myapp.MyTest.test(MyTest.kt:15)\r\n```\r\n\r\nWhenever the test fails, [IntervalOnceObserver#setResource](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java#L40) is called _after_ it is disposed.", "closed": "2016-12-21 09:08:33", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4926", "ttf": 2.000277777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "[2.x] IllegalStateException on Observable.timer with 0 milliseconds"}, {"created": "2016-12-16 12:33:15", "user": "vanniktech", "body": "The signature looks like this:\r\n\r\n`final Function<? super T, ? extends Completable> mapper`\r\n\r\nalthough it should be \r\n\r\n`final Function<? super T, ? extends CompletableSource> mapper`", "closed": "2016-12-16 17:25:44", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4923", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug", "PR welcome"], "title": "2.x Single.flatMapCompletable expects Completable instead of CompletableSource"}, {"created": "2016-12-14 14:56:00", "user": "akarnokd", "body": "TestSubscriber:210 `onNext received a null Subscription`\r\nTestSubscriber:229 `onError received a null Subscription`\r\nTestObserver:152  `onNext received a null Subscription` \r\n\r\n", "closed": "2016-12-16 17:26:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4920", "ttf": 2.000277777777778, "commits": {}, "labels": ["2.x", "Bug", "PR welcome"], "title": "2.x: TestSubscriber/TestObserver wrong error message"}, {"created": "2016-12-11 10:27:04", "user": "davidmoten", "body": "The `retryWhen` signature doesn't look right:\r\n\r\n```java\r\npublic final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler); \r\n```\r\nThe function should be able to return any `Flowable` for instance but at the moment has to be cast to `Flowable<Object>`. I think the signature should be:\r\n\r\n```java\r\npublic final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler);\r\n```", "closed": "2016-12-12 06:27:33", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4916", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: retryWhen signature"}, {"created": "2016-12-09 01:11:36", "user": "otal1105", "body": "I tried below\r\n```java\r\nObservable.range(1, 3).repeatWhen(handler -> handler.take(2))\r\n    .subscribe(\r\n        System.out::println, \r\n        e -> e.printStackTrace(),\r\n        () -> System.out.println(\"completed\"));\r\n```\r\n\r\nIt dodin't call onComplete. I got this.\r\n```\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\n```\r\n\r\nHowever, I tried Flowable, it called onComplete.\r\n\r\n```java\r\nFlowable.range(1, 3).repeatWhen(handler -> handler.take(2))\r\n    .subscribe(\r\n        System.out::println, \r\n        e -> e.printStackTrace(),\r\n        () -> System.out.println(\"completed\"));\r\n```\r\n\r\nThe result was below.\r\n```\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\ncompleted\r\n```\r\n\r\nI tried on 2.0.2.", "closed": "2016-12-09 17:25:13", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4909", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Observable.repeatWhen doesn't call onComplete"}, {"created": "2016-11-28 10:00:50", "user": "dittos", "body": "Following code prints `completed`, instead of expected `error`.\r\n\r\n```java\r\nObservable.empty().firstOrError().toObservable()\r\n                .subscribe(\r\n                        v -> {},\r\n                        e -> System.out.println(\"error\"),\r\n                        () -> System.out.println(\"completed\")\r\n                );\r\n```\r\n\r\nBut this code works fine (prints `error`):\r\n\r\n```java\r\nSingle.error(new Exception()).toObservable()\r\n                .subscribe(\r\n                        v -> {},\r\n                        e -> System.out.println(\"error\"),\r\n                        () -> System.out.println(\"completed\")\r\n                );\r\n```", "closed": "2016-11-28 12:06:49", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4889", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "2.x: Converting `firstOrError` to Observable swallows error"}, {"created": "2016-11-25 01:29:03", "user": "piotrturski", "body": "when millisecond resolution is used, everything works correctly. but the same test fails when all units are changed to nanosecond. the following test fails but should pass\r\n\r\n``` \r\nimport org.junit.Test;\r\nimport rx.Observable;\r\nimport rx.observers.TestSubscriber;\r\nimport rx.schedulers.TestScheduler;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class NanosecondTest {\r\n\r\n    @Test\r\n    public void shoud_schedule_correctly_with_nanosecond_resolution() {\r\n\r\n        TestScheduler scheduler = new TestScheduler();\r\n        TestSubscriber<Long> testSubscriber = new TestSubscriber<>();\r\n\r\n        TimeUnit unit = TimeUnit.NANOSECONDS; // change to TimeUnit.MILLISECONDS and test will pass\r\n\r\n        Observable.interval(30, unit, scheduler).subscribe(testSubscriber);\r\n        scheduler.advanceTimeTo(60, unit);\r\n\r\n        testSubscriber.assertValues(0L, 1L);\r\n    }\r\n}\r\n```\r\n\r\n`compile 'io.reactivex:rxjava:1.2.2'`", "closed": "2016-12-05 11:23:47", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4883", "ttf": 10.000277777777777, "commits": {}, "labels": ["1.x", "Bug"], "title": "TestScheduler and/or TestSubscriber doesn't work for nanoseconds"}, {"created": "2016-11-22 15:51:27", "user": "vanniktech", "body": "The following test case fails:\r\n\r\n```java\r\nfinal AtomicBoolean atomicBoolean = new AtomicBoolean();\r\n\r\nassertThat(atomicBoolean.get()).isFalse();\r\n\r\nCompletable.complete()\r\n    .doOnDispose(() -> atomicBoolean.set(true))\r\n    .test()\r\n    .assertResult()\r\n    .dispose();\r\n\r\nassertThat(atomicBoolean.get()).isTrue(); // Fails\r\n```\r\n\r\nIn my opinion this is a bit misleading and probably should not be the case. Is this working as intended?", "closed": "2016-11-23 08:27:18", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4872", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["2.x", "Bug"], "title": "Completable.doOnDipose() not called when disposing with TestObserver"}, {"created": "2016-11-14 17:27:39", "user": "dbakr", "body": "Hi\r\n\r\nLoving playing with new Completables and Singles! But seems that we have found a bug running them on our production server,\r\nand after fighting for 30 minutes with and not being able to find the exact cause, we have written a simple test which is attached here and proves the issue.\r\n\r\nBy executing it you can see that old good Observables.concat works perfectly, but it's younger brother Completable.concat does not.\r\n\r\nWe observe that it ubsubscribes somewhere in the chain from child completables, and by executing the test several times you can see that sequence is uneven and order of processing/ubsubscribed messages changes from time to time.\r\n\r\nThe file attached:\r\n\r\n[Test.zip](https://github.com/ReactiveX/RxJava/files/589964/Test.zip)\r\n\r\nI believe it's not how it should work - I expect that all child completables complete before they are unsubscribed from by the upstream operator.\r\n\r\nThe sample code that does not work as I expect:\r\n\r\n`\r\n\r\n        System.out.println(\"Testing Completable.concat\");\r\n        System.out.println();\r\n        Completable.concat(\r\n                Observable.range(1, 5).map(integer -> Completable.fromAction(() -> {\r\n                    try {\r\n                        System.out.println(\"Processing \" + integer + \"...\");\r\n                        Thread.sleep(100);\r\n                        System.out.println(\"Processing \" + integer + \" finished\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                })\r\n                        .doOnUnsubscribe(() -> System.out.println(\"Unsubscribed from \" + integer))\r\n                        .subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()))\r\n                        .doOnUnsubscribe(() -> System.out.println(\"Unsubscribed from parent observable\"))\r\n        ).subscribe(() -> {\r\n                    System.out.println(\"Finished Completable.concat\");\r\n                }, Throwable::printStackTrace\r\n        );\r\n \r\n\r\n`", "closed": "2016-11-14 19:43:43", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4848", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["1.x", "Bug"], "title": "Completable.concat(Obsevable<Completable>..) unsubscribes  from child completables not in time"}, {"created": "2016-11-08 14:04:36", "user": "StanislavChumarin", "body": "Completable.doAfterTerminate is called only \"after this Completable completes normally\" but that is differ from Observable/Single implementation of same operation.\r\n\r\nI think that this method must be reimplemented to be similar to those in Observable/Single and current implementation to be renamed to `doAfterCompleted`. \r\n\r\nI know that there is `doOnTerminate` (same operation was deprecated in Observable). I just what to have predictable API with need to dig into documentation word by word.", "closed": "2016-11-11 14:43:50", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4822", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug"], "title": "1.2.2 Please implement Completable.doAfterTerminate to be called after onError also"}, {"created": "2016-11-07 16:27:33", "user": "ychescale9", "body": "In 2.X repeatWhen can't seem to be terminated (onError) by throwing an exception from the observable:\r\n```\r\nprivate int count = 0;\r\nprivate Observable<Integer> getTestObservable() {\r\n    return Observable.fromCallable(new Callable<Integer>() {\r\n        @Override\r\n        public Integer call() throws Exception {\r\n            count++;\r\n            if (count == 5) {\r\n                throw new Exception(\"Some exception\");\r\n            }\r\n            return count;\r\n        }\r\n    });\r\n}\r\n\r\n@Test\r\npublic void testRepeatWhen() {\r\n    getTestObservable()\r\n            .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {\r\n                @Override\r\n                public ObservableSource<?> apply(Observable<Object> objectObservable) throws Exception {\r\n                    return objectObservable.delay(1, TimeUnit.SECONDS);\r\n                }\r\n            })\r\n            .subscribe(new Observer<Integer>() {\r\n                @Override\r\n                public void onSubscribe(Disposable d) {\r\n                    System.out.println(\"onSubscribe\");\r\n                }\r\n\r\n                @Override\r\n                public void onNext(Integer value) {\r\n                    System.out.println(\"onNext: \" + value);\r\n                }\r\n\r\n                @Override\r\n                public void onError(Throwable e) {\r\n                    System.out.println(\"onError\");\r\n                }\r\n\r\n                @Override\r\n                public void onComplete() {\r\n                    System.out.println(\"onComplete\");\r\n                }\r\n            });\r\n}\r\n```\r\nOutput:\r\n```\r\nonSubscribe\r\nonNext: 1\r\nonNext: 2\r\nonNext: 3\r\nonNext: 4\r\nonNext: 6\r\nonNext: 7\r\n...\r\n```\r\nWhen the exception is thrown, neither onNext nor onError is called on the subscription, then repeatWhen continues.\r\n\r\nThis behavior is different to the equivalence in 1.x.\r\n\r\nHow can repeatWhen be terminated in 2.x?\r\n\r\nThanks.", "closed": "2016-11-07 19:02:03", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4818", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "2.x: terminating repeatWhen"}, {"created": "2016-10-30 15:59:13", "user": "nsk-mironov", "body": "The following test case fails with `RxJava-2.0.0`, but works fine with `1.2.1`:\n\n``` java\npublic class RepeatWhenTest {\n  @Test\n  public void shouldDisposeInnerObservable() {\n    final PublishSubject<String> subject = PublishSubject.create();\n    final Disposable disposable = Observable.just(\"Leak\")\n        .repeatWhen(completions -> completions.switchMap(ignore -> subject))\n        .subscribe();\n\n    assertTrue(subject.hasObservers());\n    disposable.dispose();\n    assertFalse(subject.hasObservers());\n  }\n}\n```\n", "closed": "2016-11-03 08:49:52", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4782", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug"], "title": "[2.0.0] repeatWhen/retryWhen memory leak"}, {"created": "2016-10-24 18:32:01", "commits": {"c65b3db77f56001e5f160b699e3cad9737df1e31": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-11-07 08:18:22", "filteredCommits": [], "commitsDetails": [{"nameRev": "c65b3db77f56001e5f160b699e3cad9737df1e31 tags/v1.2.2~1", "commitMessage": "1.x: Add null check to Observable.switchIfEmpty (#4791)\n\n* Add null check to switchIfEmpty (#4762)\r\n\r\n* Add null check to switchIfEmpty (#4762); add test\r\n", "commitParents": ["57470176b1f1d68904544fce92de3f52ea645300"], "spoonStatsSkippedReason": "", "commitHash": "c65b3db77f56001e5f160b699e3cad9737df1e31", "authoredDateTime": "2016-11-01 17:32:04", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 5, "deletions": 0, "lines": 5, "filePath": "src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java"}, {"insertions": 5, "deletions": 0, "lines": 5, "filePath": "src/main/java/rx/Observable.java"}], "commitDateTime": "2016-11-01 15:32:04", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.Observable.switchIfEmpty(rx.Observable)"}], "spoonFilePath": "Observable.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSwitchIfEmptyTest.testAlternateNull()"}], "spoonFilePath": "OperatorSwitchIfEmptyTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/4762", "ttf": 13.000277777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "No subscriber methods are called at all, when having npe because of illegal switchIfEmpty usage", "statsSkippedReason": "", "user": "dbakr", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "The following code consists obvious error: null is passed to switchIfEmpty (actually it's a common mistake to use switchIfEmpty instead of defaultIfEmpty).\nBut the problem is that the consequent NPE is not emitted to subscribers. Actually, none of the subscirber's methods is called: neither onNext, nor onError or onCompleted. This code does not produce any output to the system.out!\n\nThat of course could be fixed by simple null verification on the switchIfEmpty operator creation.\nBut probably its worth looking more deep into the sequence of producers in this chain, and something could be improved?\nThis situation caused by the described behavior, when no Observable's events are raised on the event loop,  was quite difficult to find and costed us few nervous cells :)\n\nI guess its worth investigating and fixing.\n\n```\n// problematic code\n\nObservable.just(null)\n        .filter(Objects::nonNull)\n        .flatMap(o -> Observable.just(1))\n        .switchIfEmpty(null)\n        .subscribe(o -> System.out.println(o)\n                , Throwable::printStackTrace\n                , () -> System.out.println(\"completed\"));\n\n```\n", "labels": ["Bug", "PR welcome"]}, {"created": "2016-10-21 14:42:38", "user": "nsk-mironov", "body": "``` java\npublic class Main {\n  static class Header {\n    String name = \"key\";\n    String value = \"one\";\n  }\n\n  public static void main(String[] args) {\n    final Header header = new Header();\n    final BehaviorSubject<Header> subject = BehaviorSubject.createDefault(header);\n\n    subject.distinctUntilChanged(new Function<Header, Object>() {\n      @Override\n      public Object apply(final Header header) throws Exception {\n        return header.value;\n      }\n    }).subscribe(new Consumer<Header>() {\n      @Override\n      public void accept(final Header header) throws Exception {\n        System.out.println(\"Name = \" + header.name + \", Value = \" + header.value);\n      }\n    });\n\n    header.value = \"two\";\n    subject.onNext(header);\n  }\n}\n```\n\nOutput:\n\n```\nName = key, Value = one\n```\n\nExpected output:\n\n```\nName = key, Value = one\nName = key, Value = two\n```\n\nThe same code used to work as expected with 2.0.0-RC4 and all previous RxJava versions.\n", "closed": "2016-10-21 19:18:01", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4743", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "[2.0.0-RC5] distinctUntilChanged doesn't work nicely with mutable objects"}, {"created": "2016-10-20 17:02:27", "commits": {"5e3f6c4141f0e2b10765270d0faf83de014ec804": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-10-25 13:21:22", "filteredCommits": [], "commitsDetails": [{"nameRev": "5e3f6c4141f0e2b10765270d0faf83de014ec804 tags/v1.2.2~5", "commitMessage": "#4737 Error when tracking exception with unknown cause (#4740)\n\n", "commitParents": ["61a5976e3dacbbf0e6a4bbfbaf3a11cc3d335b70"], "spoonStatsSkippedReason": "", "commitHash": "5e3f6c4141f0e2b10765270d0faf83de014ec804", "authoredDateTime": "2016-10-22 10:58:53", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 42, "deletions": 0, "lines": 42, "filePath": "src/test/java/rx/plugins/RxJavaHooksTest.java"}, {"insertions": 9, "deletions": 1, "lines": 10, "filePath": "src/main/java/rx/exceptions/AssemblyStackTraceException.java"}], "commitDateTime": "2016-10-22 19:58:53", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.clearIsPassthrough().20"}, {"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onXError()"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onSchedule(rx.Scheduler.Worker).15.call()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onErrorNoHandler().17"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXLift().32"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXLift().34"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onXLift().28"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.lockdown().5"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError().24.call(java.lang.Throwable)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.completableStart().12"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.clearIsPassthrough().22"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.singleReturn().10"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onError().16"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onSchedule(rx.Scheduler.Worker).15"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onErrorCrashes()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.assemblyTrackingObservableUnknownCause()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.TestExceptionWithUnknownCause"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onSchedule(rx.Scheduler.Worker).13"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onSchedule(rx.Scheduler.Worker).14"}, {"UPD": 0, "TOT": 9, "MOV": 7, "INS": 1, "DEL": 1, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onSchedule(rx.Scheduler.Worker)"}, {"UPD": 0, "TOT": 2, "MOV": 2, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onXLift()"}, {"UPD": 4, "TOT": 6, "MOV": 1, "INS": 0, "DEL": 1, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.lockdown().6"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.observableReturn().7"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.createObservableThrowingUnknownCause()"}, {"UPD": 4, "TOT": 7, "MOV": 3, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXLift()"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onErrorNoHandler()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.singleStart().9"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.completableCreate().11"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError().24"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError().25"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.clearIsPassthrough().21"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onErrorCrashes().18"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.createSingle().3"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError().26"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.createCompletable().4"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.noCallToHooksOnPlainError().35"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXError().27"}, {"UPD": 1, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onPluginsXLift().33"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.singleCreate().8"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onXError().23"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.plugins.RxJavaHooksTest.onXLift().29"}], "spoonFilePath": "RxJavaHooksTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.exceptions.AssemblyStackTraceException.attachTo(java.lang.Throwable)"}], "spoonFilePath": "AssemblyStackTraceException.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/4737", "ttf": 4.000277777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "AssemblyStackTraceException doesn't account for unknown causes", "statsSkippedReason": "", "user": "pyricau", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "[AssemblyStackTraceException#attachTo](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/exceptions/AssemblyStackTraceException.java) method does this:\n\n```\n    /**\n     * Finds an empty cause slot and assigns itself to it.\n     * @param exception the exception to start from\n     */\n    public void attachTo(Throwable exception) {\n        Set<Throwable> memory = new HashSet<Throwable>();\n\n        for (;;) {\n            if (exception.getCause() == null) {\n                exception.initCause(this);\n                return;\n            }\n\n            exception = exception.getCause();\n            if (!memory.add(exception)) {\n                // in case we run into a cycle, give up and report this to the hooks\n                RxJavaHooks.onError(this);\n                return;\n            }\n        }\n    }\n```\n\nThis assumes that there are two types of exceptions: either it doesn't have a cause and we can set one, or there is a cycle in the chain and it bails.\n\nHowever, if you look at the JDK Throwable implementation, you'll see this:\n\n```\npublic class Throwable  {\n\n    /**\n     * The throwable that caused this throwable to get thrown, or null if this\n     * throwable was not caused by another throwable, or if the causative\n     * throwable is unknown.  If this field is equal to this throwable itself,\n     * it indicates that the cause of this throwable has not yet been\n     * initialized.\n     */\n    private Throwable cause = this;\n\n   public Throwable(String message, Throwable cause) {\n        fillInStackTrace();\n        detailMessage = message;\n        this.cause = cause;\n    }\n\n    /**\n     * Initializes the <i>cause</i> of this throwable to the specified value.\n     * (The cause is the throwable that caused this throwable to get thrown.)\n     *\n     * <p>This method can be called at most once.  It is generally called from\n     * within the constructor, or immediately after creating the\n     * throwable.  If this throwable was created\n     * with {@link #Throwable(Throwable)} or\n     * {@link #Throwable(String,Throwable)}, this method cannot be called\n     * even once.\n     *\n     * @param  cause the cause (which is saved for later retrieval by the\n     *         {@link #getCause()} method).  (A {@code null} value is\n     *         permitted, and indicates that the cause is nonexistent or\n     *         unknown.)\n     * @return  a reference to this {@code Throwable} instance.\n     * @throws IllegalArgumentException if {@code cause} is this\n     *         throwable.  (A throwable cannot be its own cause.)\n     * @throws IllegalStateException if this throwable was\n     *         created with {@link #Throwable(Throwable)} or\n     *         {@link #Throwable(String,Throwable)}, or this method has already\n     *         been called on this throwable.\n     */\n    public synchronized Throwable initCause(Throwable cause) {\n        if (this.cause != this)\n            throw new IllegalStateException(\"Can't overwrite cause with \" +\n                                            Objects.toString(cause, \"a null\"), this);\n        if (cause == this)\n            throw new IllegalArgumentException(\"Self-causation not permitted\", this);\n        this.cause = cause;\n        return this;\n    }\n```\n\nSo, if you do `new Throwable(\"\", null)`, then the cause is set, and it is null. `Throwable.getCause()` will return null, but `Throwable.initCause()` will throw. And we just saw that `attachTo` does this:\n\n```\n            if (exception.getCause() == null) {\n                exception.initCause(this);\n                return;\n            }\n```\n\nThis was introduced when fixing #4212 .\n\nThis is going to be tricky to fix, because there is no easy to know \"this exception does have a cause and it is set to null\".\n\nIt's ugly, but we could catch `IllegalStateException` when calling `initCause()`. And even then, I'm not sure what we should do. Reporting to `RxJavaHooks.onError();` seems wrong, this isn't necessarily an incorrect exception.\n\nFYI, Retrofit 1 has this exact issue ([RetrofitError](https://github.com/square/retrofit/blob/parent-1.9.0/retrofit/src/main/java/retrofit/RetrofitError.java))\n", "labels": ["Bug", "PR welcome"]}, {"created": "2016-10-20 08:59:44", "user": "akarnokd", "body": "This affects both 1.x and 2.x.\n\nThere is a question on [StackOverflow](http://stackoverflow.com/questions/40145203/rxjava-observable-fromemitter-odd-backpressure-behaviour) where the example program hangs after it delivered the default bufferSize elements until the `fromEmitter` source completes.\n\nThe problem is that `subscribeOn` schedules the downstream's replenishing `request` on the same thread that is busy/sleeping and has no opportunity to update its internal requested amount. We had similar problems with `onBackpressureBlock` which had to be dropped.\n\nWe could introduce a `subscribeOn` mode in which it doesn't reschedule the `request` from downstream but it will confuse some and make wonder others.\n", "closed": "2017-02-11 18:08:07", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4735", "ttf": 114.00027777777778, "commits": {}, "labels": ["1.x", "2.x", "Bug", "Discussion"], "title": "fromEmitter same-pool deadlock"}, {"created": "2016-10-17 08:01:57", "user": "chibatching", "body": "I updated from 1.2.0 to 1.2.1.\n\nUntil 1.2.0, `Subscription#isUnsubscribed` return `true` after `onSuccess`.\nBut from 1.2.1, `Subscription#isUnsubscribed` keeps `false` even if `onSuccess` / `onError` is called.\n\nIs this a expected behavior change? If so, sorry to file rude issue.\n\nThis can reproduce with below simple code. \n\n``` java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        final Subscription subscription = Single.create(new Single.OnSubscribe<Boolean>() {\n            @Override\n            public void call(SingleSubscriber<? super Boolean> singleSubscriber) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    singleSubscriber.onSuccess(true);\n                }\n            }\n        })\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(\n                        new Action1<Boolean>() {\n                            @Override\n                            public void call(Boolean aBoolean) {\n                                Toast.makeText(MainActivity.this, \"success\", Toast.LENGTH_SHORT).show();\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                Toast.makeText(MainActivity.this, \"error\", Toast.LENGTH_SHORT).show();\n                            }\n                        }\n                );\n\n        findViewById(R.id.check_subscription_button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                boolean status = subscription.isUnsubscribed();\n                Toast.makeText(MainActivity.this, \"unsubscribed status: \" + status,\n                        Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n}\n```\n\nThanks\n", "closed": "2016-10-17 18:39:53", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4715", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Subscription#isUnsubscribed of Single keep false after onSuccess/onError"}, {"created": "2016-10-09 09:44:52", "user": "falcon71", "body": "Try the following code:\n\n```\npublic static void main(final String[] args) {\n        Observable.fromArray(new String[]{\"1\",\"a\",\"2\"}).flatMapSingle(new Function<String, SingleSource<Integer>>() {\n            @Override\n            public SingleSource<Integer> apply(final String s) throws NumberFormatException {\n                //return Single.just(Integer.valueOf(s)); //This works\n                return Single.fromCallable(new Callable<Integer>() {\n                    @Override\n                    public Integer call() throws NumberFormatException {\n                        return Integer.valueOf(s);\n                    }\n                });\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(final Disposable d) {\n                System.out.println(\"Subscribe\");\n            }\n\n            @Override\n            public void onNext(final Integer value) {\n                System.out.println(\"Value: \" + value);\n            }\n\n            @Override\n            public void onError(final Throwable e) {\n                System.out.println(\"Error: \" + e);\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"Complete\");\n            }\n        });\n    }\n```\n\nThe program will only output the Value 1, the NumberFormatException gets lost. If I were to use Single.just, the exception gets printed correctly.\n", "closed": "2016-10-10 16:11:25", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4684", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "2.0.0 RC4 Errors get lost with flatMapSingle and Single.fromCallable"}, {"created": "2016-10-07 08:20:55", "user": "vanniktech", "body": "`elementAtOrError(1)` on an empty source just leaves the new Single hanging without signalling `onError()`:\n\n``` java\nObservable.empty()\n    .elementAtOrError(1)\n    .test()\n    .assertFailure(NoSuchElementException.class);\n```\n\n`elementAt(1)` on an empty source just leaves the Maybe hanging without signalling `onComplete()`:\n\n```\nObservable.empty()\n    .elementAt(1)\n    .test()\n    .assertResult();\n```\n\nJust tested this against RC4. Happy to fix this.\n", "closed": "2016-10-07 09:48:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4680", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "2.x: ElementAt Operators in Observable and Flowable don't behave correctly on empty sources"}, {"created": "2016-10-01 09:00:37", "commits": {"56123c9e9f0152922efd31badfde22a690e5159b": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-10-01 09:46:29", "filteredCommits": [], "commitsDetails": [{"nameRev": "56123c9e9f0152922efd31badfde22a690e5159b tags/v2.0.0-RC4~11", "commitMessage": "Upcast ConcurrentHashMap to Map to avoid compatibility issue (#4654)\n\n* Upcast ConcurrentHashMap to Map to avoid compatibility issue\r\n\r\nResovles #4653\r\n\r\nSee http://stackoverflow.com/a/32955708/61158\r\n\r\n* Fix imports, remove now-unnecessary animalsniffer suppression\r\n", "commitParents": ["5ad1c046da45a69817b643eb0c6602ddab1b112c"], "spoonStatsSkippedReason": "", "commitHash": "56123c9e9f0152922efd31badfde22a690e5159b", "authoredDateTime": "2016-10-01 04:42:59", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 4, "deletions": 4, "lines": 8, "filePath": "src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java"}], "commitDateTime": "2016-10-01 11:42:59", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 1, "spoonMethodName": "io.reactivex.internal.schedulers.SchedulerPoolFactory.start().1.run()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "io.reactivex.internal.schedulers.SchedulerPoolFactory"}], "spoonFilePath": "SchedulerPoolFactory.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/4653", "ttf": 0.0002777777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "2.x: Possible 6.x/Android compatibility issue", "statsSkippedReason": "", "user": "ZacSweers", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "If I have an Android app targeting source compatibility 1.8, I get the following exception at runtime on a 7.0 device:\n\n```\nFATAL EXCEPTION: RxSchedulerPurge-1\n     Process: io.sweers.catchup.debug, PID: 29250\n     java.lang.NoSuchMethodError: No virtual method keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView; in class Ljava/util/concurrent/ConcurrentHashMap; or its super classes (declaration of 'java.util.concurrent.ConcurrentHashMap' appears in /system/framework/core-libart.jar)\n         at io.reactivex.internal.schedulers.SchedulerPoolFactory$1.run(SchedulerPoolFactory.java:69)\n         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428)\n         at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278)\n         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273)\n         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n         at java.lang.Thread.run(Thread.java:761)\n```\n\nThe exact line is:\n\n``` java\nfor (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {  // CHM.keySet returns KeySetView in Java 8+; false positive here\n```\n\nWhen I look at it in the debugger, it is indeed a KeySetView, but I'm not sure what the issue is here. Let me know if this would be better served posting in RxAndroid.\n\nCC @JakeWharton \n", "labels": ["Bug"]}, {"created": "2016-09-29 20:17:16", "user": "VictorAlbertos", "body": "I was working on #4633 and I found this behaviour, which is not consistent with the current implementation of Maybe::ambIterable, Single::ambIterable and Completable::ambIterable.\n\nThe next tests throws NP\n\n``` java\n@Test\npublic void Verify_Flowable_Amb_Iterable() throws InterruptedException {\n  List<Flowable<String>> flowables = Arrays.asList(null, null, null);\n  Flowable.amb(flowables).test();\n}\n\n@Test\npublic void Verify_Observable_Amb_Iterable() throws InterruptedException {\n  List<Observable<String>> observables = Arrays.asList(null, null, null);\n  Observable.amb(observables).test();\n}\n```\n\nBut for Maybe, Single and Completable the exception is catched and passed to the pipeline error.\n\nBecase I'm using Flowable::amb(Iterable) and Observable::amb(Iterable) as a model to merge Maybe::ambIterable, Single::ambIterable and Completable::ambIterable into a single amb operator, I thought that Flowable::amb(Iterable) and Observable::amb(Iterable) should catch the error too. Doing something like [this](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/completable/CompletableAmbIterable.java#L130). \n", "closed": "2016-09-30 10:42:13", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4640", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "2.x Flowable::amb(Iterable) and Observable::amb(Iterable) throw NP"}, {"created": "2016-09-15 19:29:35", "user": "saharh", "body": "when throwing a runtime exception during OnNext, the exception is wrapped within OnErrorThrowable$OnNextValue, which features access to the value emitted in OnNext. this feature comes at a cost - If one would wish to serialize/deserialize the exception or any object containing that exception, one would also be required to have the type of item emitted by OnNext also implement Serializable (which could lead to whole hierarchy of objects be serializable). While the original runtime exception thrown is serializable, the OnErrorThrowable$OnNextValue which includes reference to the onnext emitted item, isn't.\nThis leads to java.io.NotSerializableException thrown when trying to serialize the exception:\n\n```\nCaused by: java.io.NotSerializableException: com.example.SomeUnserializableObject\n        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)\n        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n        at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\n        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\n        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n        at java.lang.Throwable.writeObject(Throwable.java:436)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at java.io.ObjectO\n```\n\nI dont see any way around it other than avoiding throwing of RuntimeException during onNext, and instead move to flatmap and return Observable.error(exception).\n", "closed": "2016-11-12 18:31:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4562", "ttf": 57.000277777777775, "commits": {}, "labels": ["1.x", "Bug", "PR welcome"], "title": "throwing a Serializable RuntimeException in OnNext requires OnNext value to be Serializable as well"}, {"created": "2016-09-10 01:17:24", "user": "dynaxis", "body": "http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-\n\nThe `zipper` signature is `Function<? super T[]>, ? extends R> zipper`, where use of `T[]` breaks it. Just invoke it with non `Object` T, and a `ClassCastException` is thrown.\n\nI checked with `Single` and `Flowable`, they have different signatures for the comparable `zip` operators. They use `Object[]` where `T[]` is used for `Observable`, which are also consistent with the 1.x zip operator.\n\nI think this is just a bug in the signature.\n", "closed": "2016-09-12 14:27:45", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4524", "ttf": 2.000277777777778, "commits": {}, "labels": ["Bug", "PR welcome"], "title": "RxJava2 `Observable.zip` taking `Iterable` and a `zipper` is broken"}, {"created": "2016-09-08 16:15:45", "user": "VictorAlbertos", "body": "With 1.x this test pass:\n\n``` java\n@Test\n  public void subscriberShouldBeUnsubscribed() {\n    rx.observers.TestSubscriber subscriber = new rx.observers.TestSubscriber();\n    rx.Observable.just(\"\").subscribe(subscriber);\n    subscriber.awaitTerminalEvent();\n\n    subscriber.assertNoErrors();\n    subscriber.assertCompleted();\n    subscriber.assertUnsubscribed();\n  }\n```\n\nBut with 2.x this test does not pass:\n\n``` java\n  @Test\n  public void observerShouldBeDisposed()  {\n    TestObserver observer = new TestObserver();\n    Observable.just(\"\").subscribe(observer);\n    observer.awaitTerminalEvent();\n\n    observer.assertNoErrors();\n    observer.assertComplete();\n    assertThat(observer.isDisposed(), is(true));\n  }\n```\n\nI think that dispose is similar to unsubscribe (but maybe I'm wrong). So I was wondering if this is the expected behaviour.\n\n  Thanks.\n", "closed": "2016-09-08 19:49:48", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4514", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "2.x Should observer be disposed after the source observable has finished emitting items?"}, {"created": "2016-09-08 15:08:12", "user": "nsk-mironov", "body": "``` java\npublic class SwitchMapBug {\n  public static void main(String[] args) throws Exception {\n    final Disposable disposable = Observable.just(true)\n        .subscribeOn(Schedulers.io())\n        .switchMap(value -> Observable.timer(1000, TimeUnit.MILLISECONDS)\n            .compose(new TraceComposer<>(\"inner\"))\n        )\n        .compose(new TraceComposer<>(\"outer\"))\n        .subscribe();\n\n    Thread.sleep(500);\n    disposable.dispose();\n    Thread.sleep(2000);\n  }\n\n  private static class TraceComposer<T> implements Function<Observable<T>, Observable<T>> {\n    private final String prefix;\n\n    private TraceComposer(final String prefix) {\n      this.prefix = prefix;\n    }\n\n    @Override\n    public Observable<T> apply(Observable<T> observable) throws Exception {\n      return observable\n          .doOnSubscribe(disposable -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnSubscribe\"))\n          .doOnDispose(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnDispose\"))\n          .doOnNext(value -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnNext\" + \" \" + value))\n          .doOnError(error -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnError\" + \" \" + error))\n          .doOnComplete(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnComplete\"))\n          .doOnTerminate(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnTerminate\"))\n          .doAfterTerminate(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doAfterTerminate\"));\n\n    }\n  }\n}\n```\n\nOutput:\n\n```\n[outer] doOnSubscribe\n[inner] doOnSubscribe\n[outer] doOnDispose\n[inner] doOnNext 0\n[inner] doOnComplete\n[inner] doOnTerminate\n[inner] doAfterTerminate\n```\n\nExpected output:\n\n```\n[outer] doOnSubscribe\n[inner] doOnSubscribe\n[inner] doOnDispose\n[outer] doOnDispose\n```\n", "closed": "2016-09-08 16:13:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4512", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "[RxJava 2.0.0-RC2] Observable.switchMap doesn't unsubscribe from inner Observable"}, {"created": "2016-08-31 03:37:50", "user": "amitshekhariitbhu", "body": "The below code gives the exception - (IllegalStateException: Disposable already set!):\n\n```\nSingle.just(\"Amit\")\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new SingleObserver<String>() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                    }\n\n                    @Override\n                    public void onSuccess(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n                });\n```\n\nBut when I remove subscribeOn and observeOn like below it works : \n\n```\nSingle.just(\"Amit\")\n                .subscribe(new SingleObserver<String>() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                    }\n\n                    @Override\n                    public void onSuccess(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n                });\n```\n", "closed": "2016-08-31 14:20:43", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4448", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "2.x: IllegalStateException: Disposable already set!"}, {"created": "2016-08-30 23:06:43", "user": "robeden", "body": "(Sorry if this isn't the best place for this feedback.)\n\nDisposables.from() in 2.0 (RC-1) is annoying to use with a lambda because both Runnable and Action match. Example: \n\n```\nDisposables.from( () -> {} );             // This won't compile\nDisposables.from( (Runnable) () -> {} );  // This compiles\n```\n\nPerhaps one form should have different name?\n", "closed": "2016-08-31 14:08:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4446", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug", "Cleanup"], "title": "Disposables.from annoying to use with lambda"}, {"created": "2016-07-23 08:22:17", "commits": {"99abbf982fdadf9ff1cff9fa7ff79e8e72a212bd": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-07-23 12:24:03", "filteredCommits": [], "commitsDetails": [{"nameRev": "99abbf982fdadf9ff1cff9fa7ff79e8e72a212bd tags/v1.1.9~34", "commitMessage": "CachedThreadScheduler should wait until the previous action (if any) \u2026 (#4231)\n\n* CachedThreadScheduler should wait until the previous action (if any) completes before releasing a worker to the pool. Fixes #4230.\r\n\r\n* Modified EventLoopWorker to implement Action0 and schedule itself to release. This saves an allocation.\r\n", "commitParents": ["cbec342278eddc94d58a590ee45e272d07018049"], "spoonStatsSkippedReason": "", "commitHash": "99abbf982fdadf9ff1cff9fa7ff79e8e72a212bd", "authoredDateTime": "2016-07-23 21:24:03", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 69, "deletions": 0, "lines": 69, "filePath": "src/test/java/rx/schedulers/IoSchedulerTest.java"}, {"insertions": 9, "deletions": 2, "lines": 11, "filePath": "src/main/java/rx/internal/schedulers/CachedThreadScheduler.java"}], "commitDateTime": "2016-07-23 14:24:03", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.schedulers.IoSchedulerTest.testUninterruptibleActionDoesNotBlockOtherAction()"}], "spoonFilePath": "IoSchedulerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.schedulers.CachedThreadScheduler.EventLoopWorker.call()"}, {"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.schedulers.CachedThreadScheduler.EventLoopWorker.unsubscribe()"}], "spoonFilePath": "CachedThreadScheduler.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/4230", "ttf": 0.0002777777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "Schedulers.io() reuses blocked threads", "statsSkippedReason": "", "user": "csabakos-zz", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "Some actions are not interruptible. Since Schedulers.io() reuses threads after unsubscribe, a previous uninterruptible action might block execution of new actions, causing unexpected delays or in some cases, deadlocks.\n", "labels": ["Bug"]}, {"created": "2016-07-22 17:26:10", "user": "ntoskrnl", "body": "We use `replay(1)` a lot in our Android projects. All subscriptions are kept in `CompositeSubscription` and, of course, we always clear it when we don't need it anymore.\n\nEven though we unsubscribe from observable, subscriber won't get collected by GC, because it is referenced by `OperatorReplay`, which prevents Activity or Fragment from being garbage collected. We do need to keep observable alive and resubscribe to it from new Activity instance, but now we can't use replay() as all our Activities are leaked.\n\nRight now we downgraded back to 1.1.5. Alternatively, one can use `publish()` with behavior subject to work around this issue. I believe the issue was introduced in one of the latest versions of the library (perhaps 1.1.6, not sure though).\n", "closed": "2016-07-23 07:15:42", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4228", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorReplay leaks its subscribers"}, {"created": "2016-07-19 11:10:20", "user": "artem-zinnatullin", "body": "Problem:\n\nIf user enables assembly tracking then **ALL** exceptions get wrapped into `AssemblyStackTraceException` which breaks all error handling code that expects particular exceptions.\n\nSolution:\n\nDo not change type of original exception and modify its stacktrace directly. I'll work on that soon, both for 1.x and 2.x.\n\n// Spent an hour today trying to figure out what was causing app misbehave, glad we have `git bisect`, was very surprised to see commit where I enabled assembly tracking\u2026\n", "closed": "2016-07-20 21:17:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4212", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "RxJavaHooks.enableAssemblyTracking() breaks error handling"}, {"created": "2016-06-23 04:30:40", "user": "JakeWharton", "body": "All of the methods doing this are at present unused. If they're for public consumption we need `DisposableSubscriber` and `NbpDisposableSubscriber` (or equivalent) to be in a public package.\n", "closed": "2016-08-16 08:45:16", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4082", "ttf": 54.000277777777775, "commits": {}, "labels": ["Bug"], "title": "2.x: Subscribers, Observables classes leak internal types into the public API"}, {"created": "2016-06-17 21:13:08", "user": "vanniktech", "body": "I was just browsing some of the source code to get a better understanding and I stumbled upon [https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Completable.java#L1666](this line). Isn't there a call to `s.onError(e)` missing?\n", "closed": "2016-06-18 15:21:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4025", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Question about onError propagation in Completable#onErrorComplete"}, {"created": "2016-06-13 06:48:26", "user": "artem-zinnatullin", "body": "Reported from app version with RxJava 1.1.3, but `OperatorSwitch` was not changed since 1.1.3 so it still looks actual.\n\n``` java\nCaused by java.lang.NullPointerException\nrx.internal.operators.OperatorSwitch$SwitchSubscriber.drain (OperatorSwitch.java:316)\nrx.internal.operators.OperatorSwitch$SwitchSubscriber.childRequested (OperatorSwitch.java:266)\nrx.internal.operators.OperatorSwitch$SwitchSubscriber$2.request (OperatorSwitch.java:124)\nrx.Subscriber.request (Subscriber.java:157)\nrx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call (OperatorObserveOn.java:220)\nrx.internal.schedulers.ScheduledAction.run (ScheduledAction.java:55)\n```\n\nOn the line: [`if (localIndex.get() == inner.id) {`](https://github.com/ReactiveX/RxJava/blob/v1.1.3/src/main/java/rx/internal/operators/OperatorSwitch.java#L316)\n\n`localIndex` is `final`, so looks like `inner` is null.\n\n// JFYI it was on Samsung with Android 6.0.1.\n", "closed": "2016-06-17 08:01:21", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/4004", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "1.x: NullPointerException in OperatorSwitch"}, {"created": "2016-05-13 22:21:46", "commits": {"4a6441ce8d49ed9084ca968a7163dbf3b759827b": {"commitGHEventType": "closed", "commitUser": "zsxwing"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-05-17 19:57:50", "filteredCommits": [], "commitsDetails": [{"nameRev": "4a6441ce8d49ed9084ca968a7163dbf3b759827b tags/v1.1.6~22", "commitMessage": "1.x: fix Single.flatMap not composing subscription through (#3941)\n\nCloses  #3940.", "commitParents": ["d43c05cb0f011e7647cdf176fcd2620bb4a95e8e"], "spoonStatsSkippedReason": "", "commitHash": "4a6441ce8d49ed9084ca968a7163dbf3b759827b", "authoredDateTime": "2016-05-17 21:57:36", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 40, "deletions": 0, "lines": 40, "filePath": "src/test/java/rx/SingleTest.java"}, {"insertions": 4, "deletions": 2, "lines": 6, "filePath": "src/main/java/rx/Single.java"}], "commitDateTime": "2016-05-17 12:57:36", "commitUser": "zsxwing", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.SingleTest.unsubscribeComposesThroughAsync()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.SingleTest.unsubscribeComposesThrough()"}], "spoonFilePath": "SingleTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "MOV": 1, "INS": 3, "DEL": 0, "spoonMethodName": "rx.Single.merge(rx.Single).3.call(rx.SingleSubscriber)"}], "spoonFilePath": "Single.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/3940", "ttf": 3.000277777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "toSingle() leaks subscriber if followed by flatmap.", "statsSkippedReason": "", "user": "RoryKelly", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "Not sure this is a correct test, let me know if I can provide any extra information.\n\n```\n    private Subscriber<? super Object> subscriber;\n\n    @Test public void thisTestPasses() throws Exception {\n\n        final Subscription subscribe = Observable.create(subscriber -> {\n            this.subscriber = subscriber;\n        }).subscribeOn(Schedulers.io()).flatMap(o -> Observable.just(\"\")).toSingle().subscribe();\n\n        subscribe.unsubscribe();\n\n        assertThat(subscriber.isUnsubscribed()).isTrue();\n    }\n\n    @Test public void thisTestFails() throws Exception {\n\n        final Subscription subscribe = Observable.create(subscriber -> {\n            this.subscriber = subscriber;\n        }).subscribeOn(Schedulers.io()).toSingle().flatMap(o -> Single.just(\"\")).subscribe();\n\n        subscribe.unsubscribe();\n\n        assertThat(subscriber.isUnsubscribed()).isTrue();\n    }\n```\n", "labels": ["Bug"]}, {"created": "2016-05-09 20:14:31", "user": "jnlopar", "body": "I just helped debug an issue where some Android robolectric tests timed out after upgrading from 1.1.1 to 1.1.5 due to https://github.com/ReactiveX/RxJava/commit/ef1d418f43e55eafb1cf9f09d13f37afb5b80b84\n\nAs it turned out, they were replacing the computation scheduler with immediate via RxJavaPlugins. The new commit caused RxRingBuffer.SIZE to load the RxRingBuffer class in any call to observeOn, which in turn created its ObjectPools, which in turn ran their start() which sets up a periodic scheduling on the computation thread. This caused the tests to hang indefinitely because of the repeated SleepingActions triggered by the validation tasks.\n\nSo, since RxRingBuffer can be loaded in various places by Rx internally, that seems to make it a lot more difficult to reliably replace the computation scheduler, particularly with immediate. I recommended against the immediate override in this case, but using a test scheduler wasn't really helping in this scenario either, although I am unfamiliar with that codebase and didn't have time to dive too deep into why. Short term fix for this particular case was to call observeOn with a size constant to sidestep the RxRingBuffer load in these tests, until we can clean up the underlying scheduler plugin overrides. However, I'm wondering if maybe internal scheduling things like this should have their own scheduler? Maybe an internal computation scheduler that could be an additional override in the schedulers hook. That would allow them to run unhindered in most cases despite computation being overridden, but in extreme cases they could be overridden as well.\n", "closed": "2016-05-10 20:50:01", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3923", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "Should RxRingBuffer's validator really be on the computation scheduler?"}, {"created": "2016-05-09 12:28:28", "user": "dimas", "body": "Hi.\nI am considering using of RxJava to represent REST API responses so was looking into the sources to understand how stuff works. In the OnSubscribeUsing operator there is something that looks like a logic error to me that may lead to leaking resources.\n\n(I am reporting \"theoretical\" issue, I have not tried actually making it happen. Also, I have almost zero knowledge on how RxJava works so can be really missing something. Sorry about that in advance)\n\nSo in https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeUsing.java the call() method allocates resource the first thing and then creates Observable, attaches dispose handler etc. In the end it calls unsafeSubscribe handling for the potential exception.\nBut what if exception happens earlier? Imagine the resource was allocated successfully but observableFactory.call(resource) throws for example. There seems to be nothing to dispose the resource in that case.\n\nAgain. I have no deep understanding of RxJava but it looks to me that resource disposal should be happening in the top level try/finally block if resource was allocated but doOnTerminate has not been installed yet (or failed to install). I would probably just remove the inner try/catch and did all the handling at the top level (possibly setting some boolean to indicate that stuff actually started so no cleanup needed).\n\nCheers\n", "closed": "2016-05-10 21:31:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3921", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "Possible resource leak in OnSubscribeUsing"}, {"created": "2016-05-05 16:16:55", "user": "FranciscoE-Hudl", "body": "After updating to RxJava 1.1.4 some of my chains have started throwing MissingBackpressureException for some operations.\n\nCode:\n\n```\nObservable.zip(\n            mFirstObs.first(), mSecondObs.first(), mThirdObs.first(), mFourthObs.first(),\n            zipLatestState())\n    .doOnNext(logPreAggregation())\n    .map(applyAggregation());\n\n\nFunc4<A, B, C, D> zipLatestState() {\n    return (one, two, three, four) -> Quartet.with(one, two, three, four);\n}\n```\n\nError:\n\n```\nrx.exceptions.MissingBackpressureException caused by:\n\nOnError while emitting onNext value: org.javatuples.Quartet.class\n```\n\nStacktrace:\n\n```\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: org.javatuples.Quartet.class\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:192)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:264)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.onNext(OperatorZip.java:335)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:111)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.accept(RelaySubscriptionManager.java:311)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitLoop(RelaySubscriptionManager.java:282)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitFirst(RelaySubscriptionManager.java:259)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.BehaviorRelay$1.call(BehaviorRelay.java:81)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.BehaviorRelay$1.call(BehaviorRelay.java:79)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.add(RelaySubscriptionManager.java:100)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(RelaySubscriptionManager.java:59)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(RelaySubscriptionManager.java:36)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.423 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:8452)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:214)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:268)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:209)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:79)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:75)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:8452)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:145)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorMap$MapSubscriber.onNext(OperatorMap.java:74)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OnSubscribeRefCount$2.onNext(OnSubscribeRefCount.java:124)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorPublish$PublishSubscriber.dispatch(OperatorPublish.java:587)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at rx.internal.operators.OperatorPublish$PublishSubscriber.onNext(OperatorPublish.java:285)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at com.jakewharton.rxbinding.view.ViewClickOnSubscribe$1.onClick(ViewClickOnSubscribe.java:23)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.view.View.performClick(View.java:5242)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.widget.TextView.performClick(TextView.java:10540)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.view.View$PerformClick.run(View.java:21179)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.os.Handler.handleCallback(Handler.java:739)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:95)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.os.Looper.loop(Looper.java:145)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6873)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at java.lang.reflect.Method.invoke(Native Method)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at java.lang.reflect.Method.invoke(Method.java:372)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1404)\n05-05 11:15:31.428 19767-19767/com.my.app W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1199)\n```\n", "closed": "2016-05-06 21:07:51", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3911", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "RxJava 1.1.4 regression crash"}, {"created": "2016-05-05 16:11:59", "user": "boris-petrov", "body": "The following code:\n\n``` java\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscription;\n\npublic class Test {\n    public static void main(String[] arguments) throws InterruptedException {\n        new Test().test();\n    }\n\n    void test() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        Subscription subscription = createBackpressuredObservable()\n            .filter(item -> true)\n            .mergeWith(createBackpressuredObservable())\n            .subscribe(\n                item -> {},\n                e -> {\n                    e.printStackTrace();\n                    latch.countDown();\n                },\n                latch::countDown);\n        latch.await(7, TimeUnit.SECONDS);\n        subscription.unsubscribe();\n    }\n\n    private Observable<Integer> createBackpressuredObservable() {\n        return Observable\n            .<Integer> create(subscriber -> {\n                new Thread(() -> {\n                    while (!subscriber.isUnsubscribed()) {\n                        subscriber.onNext(0);\n                    }\n                    if (!subscriber.isUnsubscribed()) {\n                        subscriber.onCompleted();\n                    }\n                }).start();\n            })\n            .onBackpressureBuffer();\n    }\n}\n```\n\nWorks with RxJava version 1.1.3, but breaks in 1.1.4 with a `rx.exceptions.MissingBackpressureException`. If you remove the `filter` on line 16, it works fine on both versions. I'm not sure I understand everything about how backpressure works, but I think this is a bug. Please correct me if I'm wrong.\n\nAs a side note, the documentation on backpressure, how it is propagated and which operators use reactive pull backpressure internally is really scarce and difficult to follow.\n", "closed": "2016-05-05 20:11:33", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3910", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Filter breaks backpressure"}, {"created": "2016-04-28 17:08:58", "commits": {"04ef4e6faadfa1475e26d9c61f74d2e6293a3d06": {"commitGHEventType": "referenced", "commitUser": "zsxwing"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-05-02 22:51:06", "filteredCommits": [], "commitsDetails": [{"nameRev": "04ef4e6faadfa1475e26d9c61f74d2e6293a3d06 tags/v1.1.4~3", "commitMessage": "1.x: fix singleOrDefault() backpressure if source is empty (#3905)\n\nIssue #3892 is a goldmine for missing backpressure problems. This PR fixes the case when singleOrDefault encounters an empty source and has to emit some default value. Fixed via setting the SingleProducer on the child on termination.", "commitParents": ["3721666912bd4b76f308d48467192e02f7df2408"], "spoonStatsSkippedReason": "", "commitHash": "04ef4e6faadfa1475e26d9c61f74d2e6293a3d06", "authoredDateTime": "2016-05-03 00:50:48", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 15, "deletions": 25, "lines": 40, "filePath": "src/main/java/rx/internal/operators/OperatorSingle.java"}, {"insertions": 16, "deletions": 0, "lines": 16, "filePath": "src/test/java/rx/internal/operators/OperatorSingleTest.java"}], "commitDateTime": "2016-05-02 15:50:48", "commitUser": "zsxwing", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 5, "MOV": 2, "INS": 1, "DEL": 2, "spoonMethodName": "rx.internal.operators.OperatorSingle.ParentSubscriber"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingle.ParentSubscriber.onError(java.lang.Throwable)"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 1, "spoonMethodName": "rx.internal.operators.OperatorSingle.call(rx.Subscriber)"}, {"UPD": 2, "TOT": 10, "MOV": 6, "INS": 0, "DEL": 2, "spoonMethodName": "rx.internal.operators.OperatorSingle.ParentSubscriber.onCompleted()"}, {"UPD": 0, "TOT": 2, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingle.ParentSubscriber.onNext(java.lang.Object)"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 1, "spoonMethodName": "rx.internal.operators.OperatorSingle.ParentSubscriber.requestMore(long)"}], "spoonFilePath": "OperatorSingle.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingleTest.defaultBackpressure()"}], "spoonFilePath": "OperatorSingleTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/3892", "ttf": 4.000277777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "java.lang.IllegalStateException: more items arrived than were requested", "statsSkippedReason": "", "user": "vadims", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "We're seeing this exception for a small percent of our users. We haven't been able to reproduce this ourselves so providing a sample might not be feasible. Any idea what could be causing this based on the stacktrace alone?\n\n``` java\nNon-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested\n       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n", "labels": ["Bug"]}, {"created": "2016-04-27 13:12:40", "user": "dlew", "body": "I was fairly surprised by the behavior of this stream:\n\n``` java\nObservable.empty()\n    .subscribe(\n        System.out::println, \n        System.err::println,\n        () -> { throw new RuntimeException(); }\n    );\n```\n\nWhat I expected to see was the thread crashing due to the exception; instead absolutely nothing happens because `onCompleted` swallows the exception entirely.\n", "closed": "2016-04-29 05:56:57", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3885", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug", "PR welcome"], "title": "onCompleted swallows all exceptions"}, {"created": "2016-04-26 22:14:37", "user": "solcott", "body": "I've noticed that when I return a Single from a flatMap and that Single calls doAfterTerminate(Action0) the Action0's call method is never called.  This behaviour is not consistent with what happens when you do the same thing with an Observable.  I am using 1.1.3\n\nWhen I run:\n\n``` java\nSingle.just(\"Test\")\n    .flatMap(s -> \n        Single.just(\"Test2\")\n            .doAfterTerminate(() -> System.out.println(\"singleFlatMapDoAfterTerminate\"))\n        )\n.doAfterTerminate(() -> System.out.println(\"singleDoAfterTerminate\"))\n.subscribe(new TestSubscriber<String>());\n```\n\nI would expect the following to be printed to the console:\n\n> singleDoAfterTerminate\n> singleFlatMapDoAfterTerminate\n\nHowever only the following is printed to the console\n\n> singleDoAfterTerminate\n\nWhen I do the same with an Observable\n\n``` java\nObservable.just(\"Test\")\n    .flatMap(s -> Observable.just(\"Test2\")\n        .doAfterTerminate(() -> System.out.println(\"observableFlatMapDoAfterTerminate\"))\n     )\n.doAfterTerminate(() -> System.out.println(\"observableDoAfterTerminate\"))\n.subscribe(new TestSubscriber<String>());`\n```\n\nI see the following printed to the console:\n\n> observableDoAfterTerminate\n> observableFlatMapDoAfterTerminate\n", "closed": "2016-04-29 21:43:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3881", "ttf": 2.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Single not calling doAfterTerminate when used in flatMap"}, {"created": "2016-04-17 19:47:11", "user": "Hezj", "body": "When trying to pass an Iterable to Observable.from() and it's Iterator.next() throws an exception, the observer subscribed or doOnError() method can't catch the exception\n", "closed": "2016-04-17 23:23:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3863", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Exceptions thrown by Iterator.next() cannot be caught by the observer whe"}, {"created": "2016-04-07 09:59:15", "user": "cy6erGn0m", "body": "See\n\nrx.internal.operators.OperatorTakeLast\nrx.internal.operators.TakeLastQueueProducer\n\nWhat if there is `OperatorTakeLast.onCompleted` has already started emit loop and there is `TakeLastQueueProducer.request(n)` trying to run this loop as well. Shouldn't it cause concurrent access to `ArrayDeque.poll/clear`?\n", "closed": "2016-04-11 06:02:31", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3838", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Concurrency against ArrayDeque?"}, {"created": "2016-03-31 09:04:02", "user": "Thomvis", "body": "Hi & thanks for this amazing library!\n\nFor the past few days I've been confused by some memory leaks that caused by RxJava or, more likely, my misunderstanding of RxJava. I've reduced the issue to a very simple test case that you can find here: https://gist.github.com/Thomvis/18474b51b1b4dff79191f93330ae627e.\n\nThe issue has to do with `switchMap`. I'd expect that when the source Observable emits an onNext event (containing a new Observable), the operator will unsubscribe from the previous Observable and release all references to that Observable. The unsubscribing part is happening, but the releasing is not. Because the Observable is not released, any upstream operators, anonymous inner classes and their captures are also not released and subsequently not garbage collected.\n\nI've read https://github.com/ReactiveX/RxJava/issues/1292 and https://github.com/ReactiveX/RxJava/issues/3074, but I'm not sure if they're related.\n\nSo what I'm hoping to get from this issue is one of the following:\n- My test is wrong\n- I'm using `switchMap` wrong / have wrong assumptions on the memory model\n- (There's a bug in OperatorSwitch)\n\nThanks in advance,\nThomas\n", "closed": "2016-04-07 07:26:36", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3812", "ttf": 6.000277777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorSwitch keeping reference to previous Observable longer than expected"}, {"created": "2016-03-29 14:53:49", "user": "dlew", "body": "Take a look at this (admittedly somewhat wonky) sample stream:\n\n``` java\nObservable.range(0, 2)\n    .flatMap(__ -> Observable.just(null))\n    .subscribe(new Subscriber<Object>() {\n      @Override public void onNext(Object o) {\n        System.out.println(\"onNext(\" + o + \")\");\n      }\n\n      @Override public void onError(Throwable e) {\n        e.printStackTrace();\n      }\n\n      @Override public void onStart() {\n        request(1);\n      }\n\n      @Override public void onCompleted() { }\n    });\n```\n\nIn this sample I'm purposefully only requesting one item so that the second one ends up getting queued in the internal `OperatorMerge`. As a result of passing `null` to the queue, though, I end up getting this in `onError`:\n\n``` java\njava.lang.NullPointerException\n    at rx.internal.util.atomic.SpscUnboundedAtomicArrayQueue.offer(SpscUnboundedAtomicArrayQueue.java:71)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:465)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:437)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:228)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:142)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n    at rx.internal.operators.OnSubscribeRange$RangeProducer.fastpath(OnSubscribeRange.java:126)\n    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:38)\n    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:26)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at net.danlew.experiments.Tester.main(Tester.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: 1\n    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:109)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n    ... 18 more\n```\n\nI'm running into in more complex code where the requests # is different than the # items pushed and seeing the same problem.\n", "closed": "2016-04-02 23:15:56", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3808", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "NullPointerException caused by null elements in merge() queue"}, {"created": "2016-03-23 22:25:43", "user": "akarnokd", "body": "There [was a post](http://psy-lob-saw.blogspot.hu/2016/03/gc-nepotism-and-linked-queues.html) just recently by @nitsanw warning about the problem called GC nepotism.\n\nThis affects our older copies of the JCTools queues, `MpscLinkedQueue` and `SpscLinkedArrayQueue`. There is an issue, #1735, about shading which would fix it, but that could happen in any time, even after some more small version changes.\n\nIn addition, the issue affects both the bounded versions of `replay()` and `ReplaySubject`. The problem there is that individual subscribers could be at any point in the linked-node sequence we can't just null out links when the operators move their head forward (trimming).\n\nIt might be possible to null out the right node by scanning the known child subscribers and chosing the earliest node any of them knows about. Unfortunately, this also requires back-references between nodes as well as node indexing, taking extra time and extra concurrency considerations.\n", "closed": "2018-05-26 23:41:46", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3794", "ttf": 794.0002777777778, "commits": {}, "labels": ["2.x", "Bug", "PR welcome"], "title": "GC nepotism in linked data structures"}, {"created": "2016-03-20 12:33:02", "user": "Centaur", "body": "``` java\nSingle.zip(new ArrayList<Single<Integer>>(), i -> i)\n          .doAfterTerminate(() -> System.out.println(\"terminated\"))\n          .subscribe();\n```\n\nthis behavior is different from `Observable.zip`\n\n``` java\nObservable.zip(new ArrayList<Observable<Integer>>(), i -> i)\n                   .doAfterTerminate(() -> System.out.println(\"terminated\"))\n                   .subscribe();\n```\n", "closed": "2016-03-23 22:33:02", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3784", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug", "PR welcome"], "title": "Single.zip on empty collection never terminate"}, {"created": "2016-03-17 07:16:38", "user": "lvzhitingzhou", "body": "Here are the code I\u2018m using to test\uff1a\n\n``` java\n        final Observable<GroupedObservable<String, AppInfo>> groupBy = Observable.from(appInfoList)\n                .groupBy(appInfo -> {\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"MM/yyyy\");\n                    String groupedStr = sdf.format(new Date(appInfo.getLastUpdateTime()));\n                    return groupedStr;\n                });\n        Observable.concat(groupBy)\n                .subscribe(mSubscriber);\n```\n\nand the library is :\n\n```\n    compile 'io.reactivex:rxjava:1.1.1'\n    compile 'io.reactivex:rxandroid:1.1.0'`\n```\n\n I got this result which apparently is not correct,  I only got three results!:\n![device-2016-03-17-151005](https://cloud.githubusercontent.com/assets/10875078/13838994/e1f62658-ec52-11e5-93c7-f3c726af5bc8.png)\n\nbut it should be like this as shown on the Rxjava-essential-code.\n![image](https://cloud.githubusercontent.com/assets/10875078/13839031/283c1870-ec53-11e5-8da5-57add00c3b35.png)\n\nThis problem never occurs on Version 1.1.0.\n", "closed": "2016-04-02 23:15:25", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3775", "ttf": 16.00027777777778, "commits": {}, "labels": ["Bug"], "title": "concat can't display all the groupedBy observers on version 1.1.1"}, {"created": "2016-03-16 18:30:02", "user": "passsy", "body": "``` java\npublic void testSingleErrorWithRetry() throws Exception {\n    TestSubscriber testSubscriber = new TestSubscriber();\n\n    final RuntimeException myError = new RuntimeException(\"my error\");\n    Single.error(myError)\n            .retryWhen(errorObservable -> Observable.empty())\n            .subscribe(testSubscriber);\n\n    testSubscriber.assertError(myError);\n}\n```\n\nThis test fails with the following exception:\n\n```\njava.lang.AssertionError: Exceptions differ; expected: java.lang.RuntimeException: my error, actual: java.util.NoSuchElementException: Observable emitted no items\n\n    at rx.observers.TestSubscriber.assertError(TestSubscriber.java:464)\n    at com.example.ExampleTest.testSingleErrorWithRetry(ExampleTest.java:77)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    ... 17 more\nCaused by: java.util.NoSuchElementException: Observable emitted no items\n    at rx.internal.operators.OnSubscribeSingle$1.onCompleted(OnSubscribeSingle.java:59)\n    at rx.internal.operators.OnSubscribeRedo$4$1.onCompleted(OnSubscribeRedo.java:326)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1123)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1120)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OnSubscribeRedo$4.call(OnSubscribeRedo.java:323)\n    at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)\n    at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)\n    at rx.internal.operators.OnSubscribeRedo.call(OnSubscribeRedo.java:320)\n    at rx.internal.operators.OnSubscribeRedo.call(OnSubscribeRedo.java:55)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OnSubscribeSingle.call(OnSubscribeSingle.java:83)\n    at rx.internal.operators.OnSubscribeSingle.call(OnSubscribeSingle.java:29)\n    at rx.Single$1.call(Single.java:93)\n    at rx.Single$1.call(Single.java:73)\n    at rx.Single.subscribe(Single.java:1665)\n    at com.example.ExampleTest.testSingleErrorWithRetry(ExampleTest.java:67)\n    ... 22 more\n```\n\nThis is the correct behavior as written in the documentation \n\n> If that Observable calls `onComplete` or `onError` then retry will call onCompleted or onError on the child subscription.\n\nThe child subscription here is the subscriber in `OnSubscribeSingle#call()` which converts an `Observable` to a `Single`. It throws this error in `onCompleted`.\n\n``` java\n            @Override\n            public void onCompleted() {\n                if (emittedTooMany) {\n                    // Don't need to do anything here since we already sent an error downstream\n                } else {\n                    if (itemEmitted) {\n                        child.onSuccess(emission);\n                    } else {\n                        child.onError(new NoSuchElementException(\"Observable emitted no items\"));\n                    }\n                }\n            }\n```\n\nThe behavior should be changed. The real child subscription before the `Observable -> Single` conversion is a `SingleSubscriber` which doesn't have the method `onCompleted()`. Better `onError` is called instead with the latest emitted error instead of the current `NoSuchElementException`.\n\nThe docs should be updated to: \n\n> If that Observable calls `onComplete` or `onError` then retry will call `onError` on the child subscription.\n", "closed": "2016-05-13 12:16:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3774", "ttf": 57.000277777777775, "commits": {}, "labels": ["Bug", "Documentation", "PR welcome"], "title": "Single#retryWhen allows Observable#complete() and throws"}, {"created": "2016-03-10 22:56:06", "user": "Dirk-c-Walter", "body": "So I'm getting MissingBackpressureExceptions, and I have been trying to litter my code with onBackPressureBuffer calls, which cuts down on their numbers but that doesn't seem like an efficient or streamlined solution. On the other hand a stacktrace like the following tells me nothing about where the problem is.\n\n```\nCaused by: rx.exceptions.MissingBackpressureException: null\nat rx.internal.operators.OperatorMapNotification$SingleEmitter.offer(OperatorMapNotification.java:165)\nat rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.onNext(OperatorMapNotification.java:98)\nat rx.internal.operators.OnSubscribeFromIterable$IterableProducer.slowpath(OnSubscribeFromIterable.java:97)\nat rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:73)\nat rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\nat rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.setProducer(OperatorMapNotification.java:74)\nat rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\nat rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable.subscribe(Observable.java:8407) \nat rx.Observable.subscribe(Observable.java:8374)\nat rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:433)\n... 8 common frames omitted\n```\n\nIf there was some indication of exactly where in the chain the problem was that would be helpfull. Instead I just know there is an issue somewhere in my stream, and I have not been able to narrow it down. Are there any techniques or teicks that help with that?\n\nJust in case it helps here is the code generating that exception, though I am more interested in being able to solve the general case.\n\n```\n`//'final Collection<String> ids' contains ~500 string ids\n\nrx.Observable\n    .from(ids)\n    .flatMap(\n        (Fnuc1<String, Observable<LoaderValue<V>>>) id -> fetchFromCouchbase(id),\n        (Func1<Throwable, Observable<LoaderValue<V>>>) err -> (Observable<LoaderValue<V>>) handleError(err),\n        () -> (Observable<LoaderValue<V>>) handleCompletion(),\n        100\n    )\n    .timeout(10000, MILLISECONDS) \n    .onBackpressureBuffer(1000, () -> logOverflow())\n    .toList()\n    .toBlocking().single();\n\n\n  private Observable<LoaderValue<V>> fetchFromCouchbase(String id) {\n    if(id == null) {\n    return Observable.<LoaderValue<V>>empty().onBackpressureDrop();\n    }\n    return couchbaseBucket.async().get(id, conf.getCouchbaseDocumentImplClass())\n        .cacheWithInitialCapacity(1)\n        .singleOrDefault(null)\n        .map((Func1<Document, LoaderValue<V>>) val -> transform(id, val));\n  }\n```\n\nhandleCompletion and logOverflow just log that the event happened, handleCompletion returns an empty Observable.\nhandleError logs the error and returns a sentinel value indicating an error occurred.`\n", "closed": "2016-03-11 15:54:34", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3746", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "How to track down a MissingBackpressureException?"}, {"created": "2016-02-14 10:10:47", "user": "ZacSweers", "body": "I've come across a couple of differences in the subscription behavior of `Observable`, `Single`, and `Completable` that I was hoping I could get clarification on or bring up for discussion. The examples specifically revolve around converting an observable to those types and how its events are propagated.\n\nIn a normal `Observable`, an `onCompleted()` event automatically unsubscribes.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nObservable observable = stringSubject.asObservable();\nSubscription observableSubscription = observable.subscribe();\nstringSubject.onCompleted();\nassertTrue(observableSubscription.isUnsubscribed());\n```\n\nThis still holds true in `Single`, but with the added caveat that an `onCompleted` event actually propagates to `onError()` if no event has been emitted prior for `onSuccess()`. This would be sort of ok considering the `Single` contract, but things get a little muddled in the sense that `onSuccess()` does _not_ actually unsubscribe despite being considered a terminal event (or so I thought). What this means is that `onCompleted()` has to be called manually after `onSuccess()`\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nSingle single = stringSubject.toSingle();\nSubscription singleSubscription = single.subscribe();\nstringSubject.onNext(\"This is necessary\");\nstringSubject.onCompleted();    // This is necessary too\nassertTrue(singleSubscription.isUnsubscribed());\n```\n\nThings get more confusing in `Completable`, which offers no auto-unsubscribe after `onComplete()` is called as far as I can tell.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nCompletable completable = stringSubject.toCompletable();\nSubscription completableSubscription = completable.subscribe();\nstringSubject.onCompleted();\nassertTrue(completableSubscription.isUnsubscribed());    // This fails\n```\n\nThis would imply that you _always_ need to save the subscription and manually unsubscribe in `onComplete()` or `doOnComplete()`.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nCompletable completable = stringSubject.toCompletable();\nfinal CompositeSubscription set = new CompositeSubscription();\nset.add(completable\n        .doOnComplete(new Action0() {\n            @Override\n            public void call() {\n                // Kludge\n                set.unsubscribe();\n            }\n        })\n        .subscribe());\nstringSubject.onCompleted();\nassertTrue(set.isUnsubscribed());    // Now it works\n```\n\nI'm not sure if this behavior still holds true when dealing with \"pure\" `Single` and `Completable` subscriptions, I can investigate more if need be.\n\nIt does seem inconsistent to me, or at the very least prone to causing passive leaks or unexpected behavior due to subscriptions living on past \"terminal\" events. Maybe some clarification is needed on what constitutes a \"terminal\" event in `Single` and `Completable`. Would love to get some more insight from the collaborators that have worked on these.\n", "closed": "2016-02-15 09:22:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3706", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Inconsistent behavior between Observable, Single, and Completable subscriptions when propagating from a source Observable."}, {"created": "2016-02-09 14:31:16", "user": "jkettmann", "body": "I get crashreports caused by a NullPointerException in OperatorZip's tick() method. You find the stacktrace and my code, causing the problem below.\n\nThe responsible line in tick() method is\n\n``` java\nRxRingBuffer buffer = ((InnerSubscriber) observers[i]).items;\n```\n\nwhere observers[i] seems to be null. \n\nThe app crashes only rarely on one device, which I don't have acces to (Samsung S3, Android 4.3).  The reason seems to be, that  the property `missedProducer` in `ProducerArbiter` must be set, which is never the case on my devices.\n\nWe're not in production yet, so I can not tell how many other devices will show this error. \n\nStacktrace:\n\n```\n0 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n1   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n2   at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:98)\n3   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n4   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n5   at java.lang.Thread.run(Thread.java:841)\n6 Caused by: java.lang.NullPointerException\n7   at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:237)\n8   at rx.internal.operators.OperatorZip$ZipProducer.request(OperatorZip.java:175)\n9   at rx.internal.producers.ProducerArbiter.emitLoop(ProducerArbiter.java:181)\n10  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:69)\n11  at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:118)\n12  at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:79)\n13  at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:74)\n14  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:66)\n15  at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)\n16  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n17  ... 4 more\n```\n\nThis is the code causing the problem: Get `Observable<List<ContainerEntity>>`, map each container entity to my actual container model. flatmap is used to split my list into single items.\n\n``` java\ngetContainerEntities()\n.flatMap(containerEntities ->\n            Observable.from(containerEntities))\n    .concatMap(containerEntity ->\n            mDashboardMapper.mapContainerEntity(containerEntity))\n    .onErrorResumeNext(throwable -> {\n        Log.e(TAG, throwable);\n        return Observable.empty();\n    });\n```\n", "closed": "2016-03-14 01:08:00", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3687", "ttf": 33.000277777777775, "commits": {}, "labels": ["Bug"], "title": "NullPointerException on OperatorZip"}, {"created": "2016-02-05 19:33:40", "user": "akarnokd", "body": "The following unit test fails because the sequence doesn't complete:\n\n``` java\n    public void publishConcat() {\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n\n        Observable.range(1, 3)\n        .publish(o -> o.take(5).concatWith(o.takeLast(5)))\n        .subscribe(ts);\n\n        ts.assertValues(1, 2, 3);\n        ts.assertNoErrors();\n        ts.assertCompleted();\n    }\n```\n\n The problem lies in operator `publish()`. When a published source completes, the operator switches back to a ready state where more subscribers can be subscribed to it and they all receive values from the upstream on the next `connect()`. Otherwise, it wouldn't be possible to observe the sequence again from the beginning by more than one subscriber.\n\nIn the test, the source is sort and by the time take(5) completes and makes `concat` subscribe to `o`, the published source, the underlying OperatorPublish is already in the ready state and awaits another connect, which will never arrive, thus leaving the second takeLast hang forever.\n\nThis anomaly is there since the rewrite of `publish()` to support backpressure, namely when it doubles as a multicast source. Previously, a PublishSubject was the mediator between the upstream and the use places in the lambda. PublishSubject, when completed will complete any latecommer subscriber such as the one by `takeLast()` thus the unit test passes.\n\nThe solution would be to write a request-coordinating internal PublishSubject variant and dispatch upstream values over it in the multicast scenario.\n\n(Note that unbounded `replay` has no such problem because it stays in the completed state until the next `connect()` call, thus latecommers still receive the orignal sequence. Because it buffers all values, there is no penalty for latecommers after a new `connect()` call.)\n", "closed": "2016-03-14 01:07:17", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3673", "ttf": 37.000277777777775, "commits": {}, "labels": ["Bug"], "title": "publish(Func1) may leave operators hang"}, {"created": "2016-01-21 09:47:54", "user": "Petikoch", "body": "While flatMap and concatMap are fine with flattening null values, concatMapEager blows up.\n\n```\nimport rx.Observable;\n\npublic class RxJavaNullValueTolerance {\n\n    public static void main(String[] args) {\n        Observable.just(\"just me\")\n                .flatMap(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"flatMap is fine with null values\");\n\n        Observable.just(\"just me\")\n                .concatMap(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"concatMap is fine with null values\");\n\n        Observable.just(\"just me\")\n                .concatMapEager(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"concatMapEager is fine with null values\");\n    }\n}\n```\n\n(RxJava 1.1.0)\n\nOutput:\n\n```\nGot: null\nflatMap is fine with null values\nGot: null\nconcatMap is fine with null values\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: null elements not allowed\n    at rx.Observable$27.onError(Observable.java:7923)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:159)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.drain(OperatorEagerConcatMap.java:216)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onError(OperatorEagerConcatMap.java:302)\n    at rx.Observable.unsafeSubscribe(Observable.java:8105)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:144)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at rx.Observable.subscribe(Observable.java:7914)\n    at RxJavaNullValueTolerance.main(RxJavaNullValueTolerance.java:18)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: java.lang.NullPointerException: null elements not allowed\n    at rx.internal.util.unsafe.SpscArrayQueue.offer(SpscArrayQueue.java:104)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onNext(OperatorEagerConcatMap.java:294)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8098)\n    ... 14 more\n```\n\nThis is IMO critical, since these three operators are closely related and often replaced thru each other, depending on the concrete \"flattening\" requirements.\n", "closed": "2016-01-22 06:18:13", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3629", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "concatMapEager blows up on null values"}, {"created": "2016-01-05 14:31:54", "user": "emilianogc", "body": "The following example throws a NPE\n\n``` java\npublic class Test {\n    public static class CustomException extends Throwable {\n        public synchronized Throwable initCause(Throwable cause) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    public static void main(String ... args) {\n        new CompositeException(Arrays.asList(\n                new CustomException(),\n                new UnsupportedOperationException(),\n                new IllegalStateException())).getCause();\n    }\n}\n```\n\nThe stacktrace is the following:\n\n```\nException in thread \"main\" java.lang.NullPointerException\n    at rx.exceptions.CompositeException.getCause(CompositeException.java:126)\n    at Test.main(Test.java:18)\n```\n", "closed": "2016-02-09 14:18:02", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3599", "ttf": 34.000277777777775, "commits": {}, "labels": ["Bug"], "title": "NPE in CompositeException when nested throws on initCause"}, {"created": "2015-12-03 08:24:58", "user": "vyadh", "body": "Hi,\n\nWhen I try to use toMap() where my value selector may throw an exception, the error only seems to be propagated via the Observable error stream if the observable is with running single threaded or subscribeOn is being used, but not when observeOn is being used.\n\nHere is a unit test to illustrate the problem, where the test \"onErrorCalledWhenObserveOnUsed\" fails:\n\n``` java\npublic class RxJavaToMapWithErrorBehaviourTest {\n\n  @Test\n  public void onErrorCalledForSingleThread() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .toMap(n -> n, n -> {\n            throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  @Test\n  public void onErrorCalledWhenSubscribeOnUsed() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .subscribeOn(Schedulers.computation())\n          .toMap(n -> n, n -> {\n            throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  @Test\n  public void onErrorCalledWhenObserveOnUsed() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .observeOn(Schedulers.computation())\n          .toMap(n -> n, n -> {\n              throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  private <T> void assertOnErrorCalled(Observable<T> observable) {\n    TestSubscriber<T> subscriber = new TestSubscriber<>();\n    observable.subscribe(subscriber);\n\n    subscriber.awaitTerminalEvent(2, TimeUnit.SECONDS);\n    subscriber.assertError(IllegalStateException.class);\n  }\n\n}\n```\n\nThe error thrown is:\n\n```\nException in thread \"RxComputationThreadPool-3\" java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.IllegalStateException\n    at RxJavaToMapWithErrorBehaviourTest.lambda$onErrorCalledWhenObserveOnUsed$5(RxJavaToMapWithErrorBehaviourTest.java:47)\n    at RxJavaToMapWithErrorBehaviourTest$$Lambda$2/431687835.call(Unknown Source)\n    at rx.internal.operators.OperatorToMap$1.onNext(OperatorToMap.java:90)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:208)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 7 more\n\n```\n\nThe observeOn() case seems to make make sense for my use-case at least (where I used subscribeOn to do a database call, followed by observeOn for subsequent calculations).\n\nI think I can probably workaround this problem by first doing a map() to do the calculation and then the toMap(), but I wondered whether this was a bug or expected behaviour?\n\nThanks.\n", "closed": "2015-12-03 10:19:17", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3555", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Exceptions not being propagated via onError when using toMap with observeOn"}, {"created": "2015-11-09 16:28:30", "user": "jjvargas", "body": "I am using a Tablet with Android 4.2  using 'io.reactivex:rxjava:1.0.15'\n\nIn Android 5.1 it works fine, but not it 4.2\n\n```\npublic Observable<Artist[]> batchGetArtistsById(ArtistIdList artistIdList) {\n        return Observable.from(artistIdList.getArtistIds())\n                .concatMapEager(artist -> getArtistById(artist))\n                .subscribeOn(Schedulers.io())\n                .toList()\n                .observeOn(AndroidSchedulers.mainThread())\n                .doOnError(e ->\n                        {\n                            System.out.println(\"Error what to do? \" + e);\n                        }\n                )\n                .flatMap(artistList -> {\n                    Artist[] artistsArray = artistList.toArray(new Artist[artistList.size()]);\n                    return Observable.just(artistsArray);\n                });\n}\n```\n\n11-09 16:23:01.485 6762-6782/? E/AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-1\n                                                 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n                                                     at java.lang.Thread.run(Thread.java:856)\n                                                  Caused by: java.lang.ExceptionInInitializerError\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281)\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130)\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127)\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n                                                     at rx.Subscriber.setProducer(Subscriber.java:209)\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n                                                     at rx.Observable$2.call(Observable.java:162)\n                                                     at rx.Observable$2.call(Observable.java:154)\n                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171)\n                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\u00a0\n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\u00a0\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\u00a0\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\u00a0\n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\u00a0\n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\u00a0\n                                                     at java.lang.Thread.run(Thread.java:856)\u00a0\n                                                  Caused by: java.lang.NullPointerException\n                                                     at rx.internal.util.unsafe.ConcurrentCircularArrayQueue.<clinit>(ConcurrentCircularArrayQueue.java:51)\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281)\u00a0\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130)\u00a0\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127)\u00a0\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\u00a0\n                                                     at rx.Subscriber.setProducer(Subscriber.java:209)\u00a0\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\u00a0\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\u00a0\n                                                     at rx.Observable$2.call(Observable.java:162)\u00a0\n                                                     at rx.Observable$2.call(Observable.java:154)\u00a0\n                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171)\u00a0\n                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\u00a0\n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\u00a0\n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\u00a0\n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\u00a0\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\u00a0\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\u00a0\n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\u00a0\n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\u00a0\n                                                     at java.lang.Thread.run(Thread.java:856)\u00a0\n", "closed": "2015-11-10 21:03:31", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3508", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "Null pointer using ConcatMapEager on Android 4.2"}, {"created": "2015-11-04 17:19:06", "user": "dlew", "body": "This is the simplest reproduction I could conjure up of this problem:\n\n``` java\n    Observable.just(1)\n        .flatMap(n -> {\n          return Observable.just(null, null)\n              .filter(o -> o != null)\n              .switchIfEmpty(Observable.empty().switchIfEmpty(Observable.just(\"Hello\")));\n        })\n        .subscribe(System.out::println);\n```\n\nThis will spit out `onError` with the error message \"more items arrived than were requested\".\n\nThis appears to be a regression. It works on RxJava 1.0.11 but fails on every version since then (including 1.0.15, the latest).\n\nAdding in a `take(1)` seems to fix the problem (as a workaround).\n\nFor completeness, here is the exception:\n\n```\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: more items arrived than were requested\n    at rx.Observable$27.onError(Observable.java:7996)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:158)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:119)\n    at rx.internal.util.ScalarSynchronousObservable$2$1.onError(ScalarSynchronousObservable.java:140)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.Observable.unsafeSubscribe(Observable.java:8178)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1073)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1070)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:129)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.setProducer(OperatorSwitchIfEmpty.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:133)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:125)\n    at rx.Observable.subscribe(Observable.java:8266)\n    at rx.Observable.subscribe(Observable.java:8233)\n    at rx.Observable.subscribe(Observable.java:7987)\n    at net.danlew.experiments.Tester.main(Tester.java:40)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onNext(OperatorSwitchIfEmpty.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    ... 33 more\n```\n", "closed": "2016-02-09 14:04:00", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3494", "ttf": 96.00027777777778, "commits": {}, "labels": ["Bug", "Question"], "title": "switchIfEmpty() causes \"more items arrived than were requested\" in bizarre case"}, {"created": "2015-11-04 13:56:44", "user": "maltalex", "body": "I've written an \"SortedMerge\" operator, which is used to orderly merge several ordered observables. The operator is based on [OperatorZip](https://github.com/ReactiveX/RxJava/blob/f2410f88dc28c1013f48754606e38507e493245f/src/main/java/rx/internal/operators/OperatorZip.java) except for several key differences:\n1. Instead of passing an array of items into a zip function the items are compared using a comparator and only the smallest one is emitted.\n2. After emissions, `requestMore` is called only on the observable from which the minimum was taken, and only its buffer's head is removed. The others are left untouched for future comparison. So no items are lost.\n3. Additional type safety is added since the types of the incoming observables is known.\n\n(I can contribute the operator to the project if anyone's interested).\n\nDuring testing, I stumbled upon a use case that failed for my operator, and it turns out that the same problem exists in the original Zip.\n\nTake a look at the following observables. First, o1:\n\n```\nObservable<Integer>[] osArray = new Observable[] { Observable.range(0, 10), Observable.range(0, 10) };\nObservable<Observable<Integer>> os = (Observable<Observable<Integer>>) Observable.from(osArray);\nObservable<Integer> o1 = Observable.zip(os, (a) -> 0);\n```\n\nSecond, o2:\n\n```\nObservable<Integer> o2 = Observable.zip(Observable.range(0, 10), Observable.range(0, 10), (a, b) -> 0);\n```\n\nAccording to my understanding, both should work in exactly the same way. However, their response to requests from the subscriber is different:\n\n```\nTestSubscriber<Integer> sub1 = new TestSubscriber<>(5);\nTestSubscriber<Integer> sub2 = new TestSubscriber<>(5);\n\no1.subscribe(sub1);\no2.subscribe(sub2);\n\nsub1.requestMore(5);\nsub2.requestMore(5);\n\nsub1.awaitTerminalEvent(1, TimeUnit.SECONDS);\nsub2.awaitTerminalEvent(1, TimeUnit.SECONDS);\n\nSystem.out.println(sub1.getOnNextEvents().size());\nSystem.out.println(sub2.getOnNextEvents().size());\n```\n\nproduces this response:\n     5\n     10\n\nWhich is exactly what happened to my SortedMerge operator. After poking at the operator for a while, it turned out that the issue can be solved by changing the construction of the Zip subscriber ZipSubscriber from this:\n\n```\npublic ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {\n        super(child);\n        this.child = child;\n        this.zipper = zipper;\n        this.producer = producer;\n    }\n```\n\nto this:\n\n```\npublic ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {\n        super();\n        this.child = child;\n        this.zipper = zipper;\n        this.producer = producer;\n    }\n```\n\nWhich seems to make sense, but I'm not sure that I understand Rx's backpressure well enough to know whether that's indeed the right solution.\n", "closed": "2015-11-12 08:55:31", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3492", "ttf": 7.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Backpressure on OperatorZip doesn't work when the observable is created using toList()"}, {"created": "2015-11-03 22:58:54", "user": "davidmoten", "body": "The following test fails in 1.x (and 1.0.15):\n\n``` java\n    @Test(timeout=1000)\n    public void testScanDoesNotHang() {\n        Observable.range(0, Integer.MAX_VALUE)\n                //\n                .scan(1, new Func2<Integer, Integer, Integer>() {\n\n                    @Override\n                    public Integer call(Integer t1, Integer t2) {\n                        return t1;\n                    }\n                })\n                //\n                .subscribe(new Subscriber<Integer>() {\n\n                    int count = 0;\n\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        count++;\n                        if (count == 2)\n                            unsubscribe();\n                    }\n                });\n    }\n```\n\n@akarnokd  I've stepped through in a debugger and in `OperatorScan` L284 initiates a fast path emission in `OnSubscriberRange` which calls `OperatorScan.emit()` L289 but because the method containing L284 has set `emitting` to true the emission goes no further and an a loop occurs that fills the heap.\n\nThough the test might look a bit contrived I just isolated the behaviour to `scan` for the test. I encountered the bug when this hung:\n\n``` java\nobservable.scan(..).elementAt(n); //where n > 1\n```\n\nI'd rank this bug as nasty (not an improbable edge case like some concurrency bugs) and possibly deserving of a new release quickly.\n", "closed": "2015-12-02 19:36:49", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3490", "ttf": 28.00027777777778, "commits": {}, "labels": ["Bug"], "title": "scan infinite loop"}, {"created": "2015-11-02 15:24:00", "user": "renaudcerrato", "body": "Since I switched to 1.0.15, one of my observable is throwing an NPE - if I'm revert back to 1.0.14, everything is fine.\n\nIt seems the `reduce` operator does'nt accept `null` for initial value anymore.\n\n```\nFatal Exception: java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at android.os.Handler.handleCallback(Handler.java)\n       at android.os.Handler.dispatchMessage(Handler.java)\n       at android.os.Looper.loop(Looper.java)\n       at android.app.ActivityThread.main(ActivityThread.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java)\nCaused by rx.exceptions.OnErrorNotImplementedException: null elements not allowed\n       at rx.Observable$27.onError(Observable.java)\n       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java)\n       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at android.os.Handler.handleCallback(Handler.java)\n       at android.os.Handler.dispatchMessage(Handler.java)\n       at android.os.Looper.loop(Looper.java)\n       at android.app.ActivityThread.main(ActivityThread.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java)\nCaused by java.lang.NullPointerException: null elements not allowed\n       at rx.internal.util.unsafe.SpscLinkedQueue.offer(SpscLinkedQueue.java)\n       at rx.internal.operators.OperatorScan$InitialProducer.<init>(OperatorScan.java)\n       at rx.internal.operators.OperatorScan.call(OperatorScan.java)\n       at rx.internal.operators.OperatorScan.call(OperatorScan.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable.unsafeSubscribe(Observable.java)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java)\n       at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java)\n       at rx.observers.SerializedObserver.onNext(SerializedObserver.java)\n       at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java)\n       at rx.internal.operators.OperatorDebounceWithTime$DebounceState.emit(OperatorDebounceWithTime.java)\n       at rx.internal.operators.OperatorDebounceWithTime$1$1.call(OperatorDebounceWithTime.java)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java)\n       at java.util.concurrent.FutureTask.run(FutureTask.java)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java)\n       at java.lang.Thread.run(Thread.java)\n```\n", "closed": "2015-11-09 21:20:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3484", "ttf": 7.000277777777778, "commits": {}, "labels": ["Bug"], "title": "[reduce] initial value not allowed to be null anymore"}, {"created": "2015-10-19 14:28:11", "user": "tehmur", "body": "On Android using this library, if the user changes the system time, there is a huge spike in the CPU usage emanating from the RXComputationThreadPool, without any expensive calls being made to the RX library.\n", "closed": "2016-02-09 14:01:07", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3461", "ttf": 112.00027777777778, "commits": {}, "labels": ["Bug"], "title": "High CPU usage after time changed on device"}, {"created": "2015-10-16 19:25:30", "user": "akarnokd", "body": "Replay works by requesting as many items as the largest requester subscriber does. So if there is one with `request(2)` and another with `request(5)`, replay will `request(5)` from the upstream. To be precise, subscriber requests are accumulated and the operator requests the difference between the last known max and the latest known max. This way, if there is an additional `request(10)` from the first subscriber above, `replay` will request only 5 additional elements.\n\nThis works for the unbounded `replay()` because all subscribers start from the very beginning. However, if the buffer is bounded, this differencing doesn't work anymore. The following unit test fails with both 1.x and 2.x implementations.\n\n``` java\n@Test\npublic void testSubscribersComeAndGoAtRequestBoundaries() {\n    ConnectableObservable<Integer> source = Observable.range(1, 10).replay(1);\n    source.connect();\n\n    TestSubscriber<Integer> ts1 = TestSubscriber.create(2);\n\n    source.subscribe(ts1);\n\n    ts1.assertValues(1, 2);\n    ts1.assertNoErrors();\n    ts1.unsubscribe();\n\n    TestSubscriber<Integer> ts2 = TestSubscriber.create(2);\n\n    source.subscribe(ts2);\n\n    ts2.assertValues(2, 3);\n    ts2.assertNoErrors();\n    ts2.unsubscribe();\n\n    TestSubscriber<Integer> ts3 = TestSubscriber.create();\n\n    source.subscribe(ts3);\n\n    ts3.assertNoErrors();\n    ts3.assertValues(3, 4, 5, 6, 7, 8, 9, 10);\n    ts3.assertCompleted();\n}\n```\n\nWhat happens here is that even though `ts2` subscribes after 2 elements were requested from source, it only receives the very last and `replay()` doesn't request 1 more.\n\nThe idea about fixing this is that the total requested amount of late subscribers would start from a \"current index\", i.e., the number of items received by `replay()` so far. \n\nThis approach would work in this synchronous test but may not work with asynchronous subscribers. The problem is that the start node and the index has to be atomically updated together so a subscriber \"pins\" both at the same time: the continuous delivery is guaranteed as well as the proper total requested amount. I'll investigate to make this happen.\n\nLet me emphasize again that the unbounded `replay()` works properly and the v2 `ReplaySubject` isn't affected because it is unbounded-in.\n", "closed": "2016-02-09 13:56:48", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3452", "ttf": 115.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Bounded replay() request coordination doesn't work properly with latecommers"}, {"created": "2015-10-10 17:10:02", "user": "artem-zinnatullin", "body": "While I was implementing #3434 I've found two problems with `OperatorFinally`.\n\nI'll call `OperatorFinally.action` as `finallyAction` for better readability.\n1. If `finallyAction` is `null` \u2014 `NullPointerException` will be swallowed by `SafeSubscriber`, this can be solved via `action != null` check in the `OperatorFinally` (I'll make PR).\n2. If `finallyAction` throws exception, `lift` calls `onError()` and `OperatorFinally` invokes `finallyAction` again (this may brake user-defined logic)! And second exception is swallowed by the `SafeSubscriber` (see problem 1).\n\nI vote for solving both of these problems before 1.0.15/1.1.10.\n", "closed": "2016-04-14 18:15:24", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3435", "ttf": 187.00027777777777, "commits": {}, "labels": ["Bug"], "title": "OperatorFinally calls action twice if action throws exception. Exception thrown by action is swallowed"}, {"created": "2015-10-09 06:54:00", "user": "abersnaze", "body": "Someone here brought by some code that was throwing a MissingBackpressureException. Aaron and I narrowed it down to this snippet.\n\n`merge(range(0, 500).groupBy(i -> i % (RxRingBuffer.SIZE + 2)).observeOn(computation())).toBlocking().last()`\n\nit comes down observeOn requesting 128 Observables from groupBy and groupBy hard coded to request 1024 from range.\n\nWe fixed his problem changing the `observeOn(computation())` to `flatMap(grp -> grp.subscribeOn(computation()))`2\n", "closed": "2015-12-14 18:50:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3425", "ttf": 66.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Outer groupBy doesn't obey backpressure"}, {"created": "2015-09-29 23:53:16", "user": "mbrandonw", "body": "Consider the following observable:\n\n``` java\nObservable.just(1)\n  .delay(10, TimeUnit.Seconds)\n  .scan(2, (accum, x) -> accum + x)\n```\n\nI would expect this to emit `2` immediately, and then 10 seconds later emit `3`. Instead it waits 10 seconds, and then emits `2` and `3` immediately.\n\nAm I interpreting this incorrectly?\n", "closed": "2015-09-30 13:57:54", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3387", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Applying `scan` after `delay` will delay the initial value "}, {"created": "2015-09-16 04:32:19", "user": "mgp", "body": "From its Javadoc:\n\n> Represents a `Throwable` that an `Observable` might notify its subscribers of, but that then can be handled by an operator that is designed to recover from or react appropriately to such an error.\n\nFrom this description I was thinking that operators like `onErrorResumeNext` might wrap emitted `Throwables` in an `OnErrorThrowable` instance using its `from` static factory method, and then pass that `OnErrorThrowable` instance to the global error handler. But the `onError` method of `OperatorOnErrorResumeNextViaFunction` looks like:\n\n``` java\n@Override\npublic void onError(Throwable e) {\n    if (done) {\n        Exceptions.throwIfFatal(e);\n        return;\n    }\n    done = true;\n    try {\n        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);\n\n        ...\n```\n\nAnd so the \"raw\" `Throwable` is passed to the global error handler instead.\n\nThe problem we're trying to solve is this: the global error handler in our app forwards errors to Crashlytics. But we want to only forward `Throwable` instances that we're not already recovering from by methods like `onErrorResumeNext`. I was hoping that `onErrorResumeNext` would wrap such errors in `OnErrorThrowable` or something equivalent and our global error handler could only forward errors if they are not of this type.\n\nAny thoughts on how we can achieve this behavior? Thanks!\n", "closed": "2016-03-14 00:01:14", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3347", "ttf": 179.00027777777777, "commits": {}, "labels": ["Bug"], "title": "When is OnErrorThrowable created and received?"}, {"created": "2015-09-15 17:50:44", "user": "mgp", "body": "This can happen if a `doOnNext` action downstream can cause the observable upstream to emit another value. Here's a test that demonstrates this behavior:\n\n``` java\n@Test\npublic void testEmittingMoreValuesThanLimit() {\n    final AtomicBoolean emittedFirstValue = new AtomicBoolean(false);\n    final PublishSubject<Integer> subject = PublishSubject.create();\n    final int firstValue = 1;\n    final int secondValue = 2;\n\n    // Record emitted values with this action.\n    Action1<Integer> record = mock(Action1.class);\n    InOrder inOrder = inOrder(record);\n\n    subject\n            .take(1)\n            .doOnNext(record)\n            .doOnNext(new Action1<Integer>() {\n                @Override\n                public void call(final Integer integer) {\n                    // As the first value passes through, emit the second value.\n                    if (!emittedFirstValue.getAndSet(true)) {\n                        subject.onNext(secondValue);\n                    }\n                }\n            })\n            .subscribe();\n\n    inOrder.verifyNoMoreInteractions();\n\n    // Will record both values even though take(1) is upstream.\n    subject.onNext(firstValue);\n    subject.onCompleted();\n    inOrder.verify(record).call(firstValue);\n    inOrder.verify(record).call(secondValue);\n    inOrder.verifyNoMoreInteractions();\n}\n```\n\nI first noticed this in a project that uses RxJava 1.1.10. The `onNext` implementation of `OperatorTake` has changed a bit in master. Before I go ahead and submit a PR that fixes this behavior, I just wanted to ensure that it wasn't deliberate? Thanks!\n", "closed": "2015-10-01 10:38:51", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3346", "ttf": 15.000277777777777, "commits": {}, "labels": ["Bug"], "title": "1.x Take operator can emit more values than its limit"}, {"created": "2015-09-02 20:32:43", "user": "akarnokd", "body": "The following program demonstrates the issue. If a request runs in parallel with a cancellation, both may end up calling the unsubscription callback, which I believe should't happen with the operator.\n\n``` java\npublic class SyncOnSubscribeRace {\n    public static void main(String[] args) throws Exception {\n        final AtomicInteger wip = new AtomicInteger();\n\n        Func0<AtomicInteger> func0 = new Func0<AtomicInteger>() {\n            @Override\n            public AtomicInteger call() {\n                return wip;\n            }\n        };\n        Func2<AtomicInteger, Observer<? super Integer>, AtomicInteger> func2 = \n                new Func2<AtomicInteger, Observer<? super Integer>, AtomicInteger>() {\n            @Override\n            public AtomicInteger call(AtomicInteger s, Observer<? super Integer> o) { \n                o.onNext(1); \n                return s; \n            }\n        };\n        Action1<? super AtomicInteger> action1 = new Action1<AtomicInteger>() {\n            @Override\n            public void call(AtomicInteger s) {\n                s.getAndIncrement();\n            }\n        };\n        Observable<Integer> source = Observable.create(\n                SyncOnSubscribe.createStateful( \n                func0, \n                func2, action1\n        ));\n\n        ExecutorService exec = Executors.newSingleThreadExecutor();\n\n        try {\n            for (int i = 0; i < 100_000; i++) {\n                if (i % 1 == 0) {\n                    System.out.println(\">> \" + i);\n                }\n                int j = wip.get();\n                TestSubscriber<Integer> ts = TestSubscriber.create(0);\n                source.subscribe(ts);\n\n                final CyclicBarrier cb = new CyclicBarrier(2);\n\n                Future<?> f = exec.submit(new Callable<Object>() {\n                    @Override\n                    public Object call() throws Exception {\n                        cb.await();\n                        ts.requestMore(1);\n                        return null;\n                    }\n                });\n\n                cb.await();\n                ts.unsubscribe();\n                f.get();\n\n                if (j + 1 != wip.get()) {\n                    throw new AssertionError(\"Unsubscribe called multiple times: \"\n                         + (wip.get() - j));\n                }\n            }\n        } finally {\n            exec.shutdownNow();\n        }\n    }\n}\n```\n", "closed": "2015-09-09 14:14:51", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3287", "ttf": 6.000277777777778, "commits": {}, "labels": ["Bug"], "title": "SyncOnSubscribe can call the unsubscription callback multiple times"}, {"created": "2015-08-28 07:04:06", "user": "rayshih", "body": "I am not sure my implementation is good. But I notice that given the following code (in scala):\n\n``` scala\nval password = BehaviorSubject[String](\"\")\nval passwordIsValid = (false +: password.map(s => s.length >= 8)).\n  doOnSubscribe(println(\"on subscribe\")).\n  doOnNext(v => println(s\"do on next => $v\")).\n  replay(1)\n\npasswordIsValid.connect\n\npassword.onNext(\"1\")\npassword.onNext(\"12\")\npassword.onNext(\"12345678\")\n\npasswordIsValid.subscribe(v => println(s\"another password => $v\"))\n```\n\nthe output by RxJava 1.0.13 is:\n\n```\non subscribe\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => true\nanother password => true\n```\n\nwhich is what I want.\n\nhowever the output by RxJava 1.0.14 is different.\n\n```\non subscribe\ndo on next => false\nanother password => false\ndo on next => true\nanother password => true\n```\n\nwhich doesn't make sense to me.\n", "closed": "2016-02-09 13:36:53", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3219", "ttf": 165.00027777777777, "commits": {}, "labels": ["Bug", "Question"], "title": "Different behaviour of replay between 1.0.13 and 1.0.14"}, {"created": "2015-08-24 19:21:37", "user": "konmik", "body": "The test:\n\n```\n@Test(expected = Throwable.class)\npublic void testThrowDuringOnNext() throws Exception {\n    Observable\n        .just(1)\n        .filter(new Func1<Integer, Boolean>() {\n            @Override\n            public Boolean call(Integer integer) {\n                return true;\n            }\n        })\n        .first()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer integer) {\n                throw new RuntimeException();\n            }\n        });\n}\n```\n\nIf I remove `filter` or `first` the test gets passed.\n", "closed": "2015-09-03 07:33:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3182", "ttf": 9.000277777777777, "commits": {}, "labels": ["Bug"], "title": ".just(1).filter().first().subscribe(throw) swallows the exception"}, {"created": "2015-08-24 15:01:13", "user": "mikegr", "body": "The following code works with RxJava 1.0.12, but throws a NullPointerException with 1.0.13 and 1.0.14\n\n```\nObservable.just(1)\n                .flatMap(\n                        item -> Observable.just(item + 1),\n                        e -> Observable.error(e),\n                        () -> Observable.never())\n                .subscribe(\n                        i -> {\n                            Log.d(TAG, \"Got \" + i);\n                        },\n                        e -> {\n                            Log.d(TAG, \"RxJava ERROR\", e);\n                        });\n\n```\n\n```\njava.lang.NullPointerException: Attempt to invoke virtual method 'void rx.internal.operators.OperatorMapNotification$SingleEmitter.offer(java.lang.Object)' on a null object reference\nat rx.internal.operators.OperatorMapNotification$1.onNext(OperatorMapNotification.java:82)\nat rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\nat rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\nat rx.Observable$1.call(Observable.java:145)\nat rx.Observable$1.call(Observable.java:137)\nat rx.Observable$1.call(Observable.java:145)\nat rx.Observable$1.call(Observable.java:137)\nat rx.Observable.subscribe(Observable.java:7803)\nat rx.Observable.subscribe(Observable.java:7579)\n```\n\nFurther notice: Observable.just(1,2,3) works fine on all versions.\n", "closed": "2015-09-09 14:32:55", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3180", "ttf": 15.000277777777777, "commits": {}, "labels": ["Bug"], "title": "NullPointerException with flatMap version that handles notification handling"}, {"created": "2015-08-22 10:34:36", "user": "akarnokd", "body": "The following test fails because Window forgets to request the 'gaps' between elements if skip > size:\n\n``` java\n@Test\npublic void testBackpressureWithLargeSkip() {\n    TestSubscriber<Observable<Integer>> ts = new TestSubscriber<Observable<Integer>>(2) {\n        @Override\n        public void onNext(Observable<Integer> t) {\n            AsyncSubject<Integer> as = AsyncSubject.create();\n            t.subscribe(as);\n            super.onNext(as);\n        }\n    };\n\n    Observable.just(1, 2, 3)\n    .window(1, 2)\n    .subscribe(ts);\n\n    ts.assertCompleted();\n    ts.assertNoErrors();\n    ts.assertValueCount(2);\n}\n```\n\nNote that due to potential conflict with #3150, I won't create a PR to fix this right now but will post a PR that adds some helper methods to BackpressureUtils to deal with add/multiply overflows.\n", "closed": "2016-02-09 13:37:32", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3176", "ttf": 171.00027777777777, "commits": {}, "labels": ["Bug"], "title": "Window with skip > size doesn't request enough"}, {"created": "2015-08-20 18:57:18", "user": "mbrandonw", "body": "I would expect this:\n\n```\nfinal Observable<Void> ob = BehaviorSubject.create();\nob.scan(0, (accum, x) -> 123)\n  .subscribe(x -> {\n    Timber.d(\"Hit!\");\n  });\n```\n\nto emit a value (and indeed it does in the equivalent RxJS code).\n\nIs this a bug?\n", "closed": "2015-08-28 17:27:44", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3168", "ttf": 7.000277777777778, "commits": {}, "labels": ["Bug"], "title": "BehaviorSubject.scan not picking up initial value"}, {"created": "2015-08-20 16:15:20", "user": "danhawkes", "body": "Saw this exception in crash logs, but haven't been able to reproduce it. Any ideas what the cause is?   \n\n```\njava.lang.IllegalArgumentException: n >= 0 required\nat rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:128)\nat rx.internal.operators.OperatorReplay$ReplaySubscriber.manageRequests(OperatorReplay.java:521)\nat rx.internal.operators.OperatorReplay$InnerProducer.unsubscribe(OperatorReplay.java:716)\nat rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)\nat rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)\nat rx.Subscriber.unsubscribe(Subscriber.java:98)\nat rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)\nat rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)\nat rx.Subscriber.unsubscribe(Subscriber.java:98)\n```\n\nhttps://github.com/ReactiveX/RxJava/blob/v1.0.14/src/main/java/rx/internal/operators/OperatorMerge.java#L128\n", "closed": "2015-09-03 07:34:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3166", "ttf": 13.000277777777777, "commits": {}, "labels": ["Bug"], "title": "\"java.lang.IllegalArgumentException: n >= 0 required\" when unsubscribing"}, {"created": "2015-08-14 16:05:29", "user": "benjchristensen", "body": "Since the `merge` changes in 1.0.13 we now have a bug in `merge` that limits concurrency and can cause an async \"deadlock\" since not all `Observable`s being merged will be subscribed to. \n\nThese unit tests show the issue:\n\n``` java\n    @Test\n    public void testUnboundedDefaultConcurrency() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n        Observable.merge(os).take(1).subscribe(ts);\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n\n    @Test\n    public void testConcurrencyLimit() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n        Observable.merge(os, Integer.MAX_VALUE).take(1).subscribe(ts);\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n```\n\nSurprisingly, even when providing the `maxConcurrent` value the issue still happens.\n\nWe have bounded **vertical** buffers, but always must default to unbounded **horizontal** buffers, since it is the code that defines how many items are horizontally buffered. This affects both `merge` and `groupBy`. The `maxConcurrent` overload allows a developer to limit the horizontal buffering, and a developer controls the `groupBy` selector.\n", "closed": "2015-11-10 21:39:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3156", "ttf": 88.00027777777778, "commits": {}, "labels": ["Bug", "Enhancement"], "title": "Merge Limiting Concurrency - Can Deadlock"}, {"created": "2015-08-03 18:20:03", "user": "dfjones", "body": "In some production code, I noticed that it is possible to create a situation where the retry method that accepts a predicate produces a MissingBackpressureException. However, other retry methods do not produce such an exception.\n\nI've created a small test case here:\nhttps://github.com/dfjones/RxJava/blob/67a18a453616539faf16204637b9399057e0bf8e/src/test/java/rx/RetryBackpressureTest.java\n\nApologies for this being a non-deterministic test, but on my laptop the `testBackpressurePredicateRetry` test will reliably fail due to MissingBackpressureException with the trace below. \n\nHowever, the `testBackpressureNormalRetry` test will run for 1 minute without producing this exception.\n\nAdmittedly, this might be a convoluted setup, but it reflects a situation I had in some production code. Essentially, I have a flow where for each event produced by an Observable, I need to perform some IO with retries. So, I've spread that IO work over a Scheduler. The IO work produces many individual events. In my test case, imagine this inner Observable is performing IO:\n\n``` java\nAbstractOnSubscribe.create((state) ->\n            state.onNext(2L))\n```\n\nEverything in this flow should respond to back-pressure through the use of `AbstractOnSubscribe`, however I'm running into the issue described here when using retry with a predicate function.\n\n```\nrx.exceptions.MissingBackpressureException\n        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:345)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:328)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:802)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1$1.onNext(OperatorRetryWithPredicate.java:113)\n        at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:535)\n        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:369)\n        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:340)\n        at rx.Subscriber.setProducer(Subscriber.java:209)\n        at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:192)\n        at rx.observables.AbstractOnSubscribe$LambdaOnSubscribe.call(AbstractOnSubscribe.java:275)\n        at rx.Observable.unsafeSubscribe(Observable.java:7689)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:120)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:77)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n        at rx.Observable$1.call(Observable.java:144)\n        at rx.Observable$1.call(Observable.java:136)\n        at rx.Observable.unsafeSubscribe(Observable.java:7689)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n```\n", "closed": "2015-09-03 07:38:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3128", "ttf": 30.00027777777778, "commits": {}, "labels": ["Bug"], "title": "MissingBackpressureException when using Retry with Predicate"}, {"created": "2015-07-29 22:13:27", "user": "gdela", "body": "Recently I stumbled upon issue, where `.toBlocking().single()` hanged forever. After painful debugging I traced it down to issue during our build/deploy pipeline which resulted in `NoSuchMethodError` thrown from one of the libraries. This error was swallowed completely by RxJava, and the end result was a hanging thread.\n\nHere is a minimal test case to reproduce the issue:\n\n```\nObject result = Observable\n    .create(subscriber -> {\n        subscriber.onNext(\"item 1\");\n        if (true) throw new NoSuchMethodError();\n        subscriber.onCompleted();\n    })\n    .delaySubscription(() -> Observable.just(\"delay\"))\n    .toBlocking()\n    .single();\nSystem.out.println(result);\n```\n\nThis will hang like that:\n\n```\n\"main\" #1 prio=5 os_prio=0 tid=0x000000000217e000 nid=0x1d80 waiting on condition [0x000000000207e000]\njava.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    ...\n    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:461)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:341)\n    at Sandbox.main(Sandbox.java:14)\n```\n\nOf course I've fixed it by fixing our build/deploy pipeline, but I'm reporting it because the swallowed exception makes such issues really hard to debug. If the RxJava could somehow report it and/or not hang, it would be nice.\n", "closed": "2016-02-09 13:32:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3122", "ttf": 194.00027777777777, "commits": {}, "labels": ["Bug", "Question"], "title": "NoSuchMethodError + delaySubscription() causes BlockingObservable hang forever"}, {"created": "2015-07-29 14:21:49", "user": "digitalbuddha", "body": "I was  analyzing startup time in the NY Times Android app and started method profiling on startup using Android Device Monitor.  Total time from the beginning of the application class to end of onCreate for first activity is roughly  2.2seconds. Diving deeper I was able to observe that `NewThreadWorker.tryEnableCancelPolicy`\n was taking 1200ms to execute with the offending line being  \n`for (Method m : exec.getClass().getMethods())` (1017ms)\nDiving deeper shows a call to \n`CollectionUtils.removeDuplicates (992 ms)`  \nwhich will call \n`collection.sort` (719ms)\n & \n`reflect.compare`(259ms).\n\ntryEnableCancelPolicy has the following comment: \n\n``` /**\n     * Tries to enable the Java 7+ setRemoveOnCancelPolicy.\n     * <p>{@code public} visibility reason: called from other package(s) within RxJava.\n     * If the method returns false, the {@link #registerExecutor(ScheduledThreadPoolExecutor)} may\n     * be called to enable the backup option of purging the executors.\n     * @param exec the executor to call setRemoveOnCaneclPolicy if available.\n     * @return true if the policy was successfully enabled \n     */ \n```\n\nI tried creating a Scheduler from an Executor but still hit the offending code.  Is there a way to avoid this code or fix the large performance hit that it is causing?\n", "closed": "2015-08-01 10:58:18", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3119", "ttf": 2.000277777777778, "commits": {}, "labels": ["Bug"], "title": "NewThreadWorker.tryEnableCancelPolicy doing costly reflection on Android"}, {"created": "2015-07-21 17:19:17", "user": "mikebaum", "body": "It seems that if your subscriber throws a \"fatal\" exception when subscribing to a BehaviorSubject chained with just, the fatal there error is swallowed and nothing is logged. See the following example:\n\n```\n    public static void main( String[] args )\n    {\n        BehaviorSubject<String> strings = BehaviorSubject.create( \"First\" );\n\n        RxJavaPlugins.getInstance().registerErrorHandler( new RxJavaErrorHandler()\n        {\n            public void handleError( Throwable throwable )\n            {\n                System.err.println( throwable );\n            };\n        } );\n\n        strings.take( 1 ).subscribe( string -> { throw new NoClassDefFoundError(); },\n                                     System.err::println );\n    }\n```\n\nIf the error thrown from the subscribe function is anything but a \"fatal\" error as determined by `Exceptions.throwIfFatal(Throwable)` an error is properly propagated.\n", "closed": "2015-08-12 23:20:23", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3095", "ttf": 22.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Observable.take() on a BehaviorSubject swallows \"fatal\" errors."}, {"created": "2015-07-13 02:35:26", "user": "davidmoten", "body": "There is a race condition in `OperatorSwitch` that may cause requests to be lost:\n1. `onNext` proceeds to just before [L137](https://github.com/ReactiveX/RxJava/blob/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b/src/main/java/rx/internal/operators/OperatorSwitch.java#L137) \n2. on a different thread `request` proceeds to just before [L112](https://github.com/ReactiveX/RxJava/blob/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b/src/main/java/rx/internal/operators/OperatorSwitch.java#L112)\n3. `onNext` continues and exits method\n4. `request` continues and requests from unsubscribed subscriber\n5. At this point stream could stall because requests were lost \n\nLooks like a candidate for `ProducerArbiter` help. I'll work on a PR if no-one else has started on this issue yet (let me know if you have). There may be other race conditions as well that turn up which I'll document in the PR.\n", "closed": "2015-08-12 23:31:02", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3073", "ttf": 30.00027777777778, "commits": {}, "labels": ["Bug"], "title": "switchOnNext() can lose requests"}, {"created": "2015-07-07 23:17:52", "user": "davidmoten", "body": "These lines\n\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorGroupBy.java#L262-L264\n\nare redundant. I'm concerned that there is some intent behind placing these lines here that is not honoured.  @akarnokd looks like you put these lines here, what do you think?\n\nThe same goes for `OperatorDoOnUnbsubscribe`.\n", "closed": "2015-11-09 21:21:24", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3067", "ttf": 124.00027777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorGroupBy - redundant onStart implementation"}, {"created": "2015-07-07 13:36:47", "user": "Froussios", "body": "The marble diagram in the documentation for the buffer operator\n\n``` java\nbuffer(long timespan, \n          java.util.concurrent.TimeUnit unit,\n          int count)\n```\n\nshows that the duration of a window can be reset if it emits the buffer due to being full.\n_(edit: the linked imaged has been updated)_\n![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png)\nAfter running a few experiments, this is not the case. Here I replicate the example shown in the marble diagram.\n\n``` java\nTestScheduler scheduler = Schedulers.test();\nScheduler.Worker worker = scheduler.createWorker();\n\nPublishSubject<Integer> subject = PublishSubject.create();\nsubject\n    .buffer(100, TimeUnit.MILLISECONDS, 2, scheduler)\n    .timestamp(scheduler)\n    .subscribe(System.out::println);\n\nworker.schedule(() -> subject.onNext(0), 0, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(1), 0, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(2), 50, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(3), 150, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(4), 201, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(5), 250, TimeUnit.MILLISECONDS);\nscheduler.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n```\n\ngives\n\n```\nTimestamped(timestampMillis = 0, value = [0, 1])\nTimestamped(timestampMillis = 100, value = [2])\nTimestamped(timestampMillis = 200, value = [3])\nTimestamped(timestampMillis = 250, value = [4, 5])\nTimestamped(timestampMillis = 300, value = [])\nTimestamped(timestampMillis = 400, value = [])\nTimestamped(timestampMillis = 500, value = [])\n```\n\nWe can see that it continues to emit at multiples of 100, after emiting a full buffer early at 250\n", "closed": "2016-06-27 09:45:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3066", "ttf": 355.0002777777778, "commits": {}, "labels": ["Bug", "PR welcome", "Question"], "title": "Marble diagram for buffer doesn't match actual behaviour"}, {"created": "2015-06-24 17:03:07", "user": "wujek-srujek", "body": "It seems, by reading the introtorx.com book and the docs (and testing out) that the buffer and window overloads which take an Observable windowCloseSelector might not be behaving as they do in .NET.\n\nThe original SO topic is here: http://stackoverflow.com/questions/30963993/rxjava-window-buffer-overload-questions-incompatibility-with-rx-net\n", "closed": "2015-08-12 23:49:06", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3053", "ttf": 49.000277777777775, "commits": {}, "labels": ["Bug"], "title": "window/buffer overload questions, incompatibility with Rx.NET?"}, {"created": "2015-06-23 12:54:15", "user": "sgonchar", "body": "I use RxAndroid library in my project and I have next exception :\n\nE/AndroidRuntime(27849): Error reporting crash\nE/AndroidRuntime(27849): java.lang.NullPointerException\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getCause(CompositeException.java:100)\nE/AndroidRuntime(27849): at android.util.Log.getStackTraceString(Log.java:454)\nE/AndroidRuntime(27849): at android.util.Slog.e(Slog.java:151)\nE/AndroidRuntime(27849): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\nE/AndroidRuntime(27849): at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\nE/AndroidRuntime(27849): at android.os.Handler.handleCallback(Handler.java:733)\nE/AndroidRuntime(27849): at android.os.Handler.dispatchMessage(Handler.java:95)\nE/AndroidRuntime(27849): at android.os.Looper.loop(Looper.java:146)\nE/AndroidRuntime(27849): at android.app.ActivityThread.main(ActivityThread.java:5653)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invokeNative(Native Method)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invoke(Method.java:515)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)\nE/AndroidRuntime(27849): at dalvik.system.NativeStart.main(Native Method)\n\nSomebody know how can I fix it ?\nThank you\n", "closed": "2015-08-12 23:50:50", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3046", "ttf": 50.000277777777775, "commits": {}, "labels": ["Bug", "Question"], "title": "NullPointerException at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)"}, {"created": "2015-06-05 18:18:35", "user": "stealthcode", "body": "The following test fails once when mapping 3 values. The subscribe only receives 2 values. \n\n``` java\nfinal AtomicBoolean isFirst = new AtomicBoolean(true);\nObservable.<Long> just(1L, 2L, 3L).map((Long x) -> {\n    System.out.println(\"map \" + x);\n    if (x == 2 && isFirst.getAndSet(false)) {\n        throw new RuntimeException(\"retryable error\");\n    }\n    return x;\n})\n.retry((i, t) -> {return true;})\n.forEach(System.out::println);\n```\n\n**output**\n\n```\nmap 1\n1\nmap 2\nmap 3\n3\n```\n\nWhen you replace `.retry((i, t) -> {return true;})` with the retry infinite `retry()` then the output looks like this...\n\n```\nmap 1\n1\nmap 2\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n", "closed": "2015-08-03 19:33:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3008", "ttf": 59.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Data loss with RetryWithPredicate as compared to Retry Infinite"}, {"created": "2015-06-02 19:32:13", "user": "benjchristensen", "body": "Need to explore the unsubscribe of `recursiveScheduler`: https://github.com/ReactiveX/RxJava/blob/34dce48b4d591a2c574839b4527cbc30cb69e5a2/src/main/java/rx/internal/operators/OperatorObserveOn.java#L122\n\nIt seems to wrap with `child.add(scheduledUnsubscribe)` and then defeat that with `child.add(recursiveScheduler)`.\n", "closed": "2016-03-13 23:55:42", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/3002", "ttf": 285.0002777777778, "commits": {}, "labels": ["Bug"], "title": "ObserveOn: Unsubscribe of RecursiveScheduler"}, {"created": "2015-06-01 20:57:33", "user": "gdela", "body": "This issue is related to #969, where it has been said that following code should throw exception:\n\n```\nObservable.error(new Exception())\n  .subscribe(new Observer<Object>() {\n    public void onCompleted() {\n      // noop\n    }\n    public void onError(Throwable e) {\n      throw new IllegalStateException(\"This should crash the app\");\n    }\n    public void onNext(Object o) {\n      // noop\n    }\n  });\n```\n\nAnd it does throw exception, but when you add `groupBy`/`flatMap` like that:\n\n```\nObservable.error(new Exception())\n  .groupBy(o -> o)\n  .flatMap(g -> g)\n  .subscribe(new Observer<Object>() {\n    public void onCompleted() {\n      // noop\n    }\n    public void onError(Throwable e) {\n      throw new IllegalStateException(\"This should crash the app\");\n    }\n    public void onNext(Object o) {\n      // noop\n    }\n  });\n```\n\nThen the exception is silently swallowed. I tried to debug it a little bit, and seems that it could be because `OnErrorFailedException` is wrapped with `CompositeException`, so `Exceptions.throwIfFatal()` doesn't recognize it as fatal.\n", "closed": "2015-11-09 21:30:50", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2998", "ttf": 161.00027777777777, "commits": {}, "labels": ["Bug"], "title": "Exception thrown from onError() is swallowed when using groupBy/flatMap"}, {"created": "2015-05-22 20:14:43", "user": "headinthebox", "body": "https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n\nThread A calls w.schedule(\u2026), passes the test on line 151, then sits at line 153\nThread B calls w.unsubscribe() and sits at line 213\nThread A enters scheduleActual and executes until line 169 where it calls schedule on an executor that has been shut down.\n", "closed": "2015-05-22 21:15:43", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2980", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Race condition in NewThreadWorker"}, {"created": "2015-05-22 11:09:00", "user": "ibaca", "body": "This test shows the onStart called twice problem. It is a clone of SubscriberTest.testOnStartCalledOnceViaUnsafeSubscribe but adding the defer operator which calls unsafeSubscribe resulting in a nested call to unsafeSubscribe, the one from the test and the second one from OnSubscribeDefer.\n\n``` java\n@Test\npublic void testOnStartCalledOnceViaNestedUnsafeSubscribe() {\n    final AtomicInteger c = new AtomicInteger();\n    Observable.defer(new Func0<Observable<Integer>>() {\n        @Override public Observable<Integer> call() {\n            return Observable.just(1, 2, 3, 4).take(2);\n        }\n    }).unsafeSubscribe(new Subscriber<Integer>() {\n        @Override public void onStart() {\n            c.incrementAndGet();\n            request(1);\n        }\n\n        @Override public void onCompleted() { }\n\n        @Override public void onError(Throwable e) { }\n\n        @Override public void onNext(Integer t) {\n            request(1);\n        }\n    });\n\n    assertEquals(1, c.get());\n}\n```\n\nTwo proposed solutions (first one looks ugly, second one adds more code to Subscriber)\n1. Add a parameter to subscription calls to transfer the 'onStart called' state.\n2. Modify Subscriber so .subscribe() .unsafeSubscribe() calls Subscriber.start() which delegates to the  actual .onStart() protecting for duplicate calls.\n", "closed": "2015-07-07 18:59:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2979", "ttf": 46.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Subscriber.onStart is called twice on nested unsafeSubscription"}, {"created": "2015-05-13 03:22:12", "user": "psliwowski", "body": "Scheduler.schedulePeriodically can potentially get into busy loop if you set your system time into the future due to using System.currentTimeMillis() to calculate the next delay.\n", "closed": "2016-02-09 13:14:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2943", "ttf": 272.0002777777778, "commits": {}, "labels": ["Bug"], "title": "Scheduler.schedulePeriodically is sensitive to system time changes"}, {"created": "2015-04-18 13:17:08", "user": "ashish-tyagi", "body": "The following test code eventually fails with a StackOverFlowException, provided a sufficient large value of n.\n\n``` java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.functions.Func1;\nimport rx.internal.operators.BufferUntilSubscriber;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.Subject;\n\n\n/**\n * @author Ashish.Tyagi\n */\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        final ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        Func1<Integer, Observable<Integer>> func = new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer t) {\n                Observable<Integer> observable = Observable.just(t).subscribeOn(Schedulers.from(executor));\n                Subject<Integer, Integer> subject = BufferUntilSubscriber.create();\n                observable.subscribe(subject);\n                return subject;\n            }\n        };\n\n        int n = 10000;\n\n        Observable.range(1, n).concatMap(func).subscribe(new Subscriber<Integer>() {\n            @Override\n            public void onNext(Integer t) {\n                // Consume after sleep for 1 ms\n                sleep();\n                System.out.println(t);\n            }\n\n            @Override\n            public void onCompleted() {\n                executor.shutdown();\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                executor.shutdown();\n            }\n        });\n\n        executor.awaitTermination(1, TimeUnit.MINUTES);\n    }\n\n    private static void sleep() {\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {\n            // Ignore\n        }\n    }\n}\n```\n", "closed": "2015-04-21 07:17:20", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2890", "ttf": 2.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Stack overflow with a combination of BufferTillSubscriber, subscribeOn and concatMap"}, {"created": "2015-04-17 06:28:23", "user": "davidmoten", "body": "What is the _preferred_ behaviour for an observable that supports backpressure but emits nothing when it has been subscribed to with an initial request of 0? Should it report completion as soon as it knows it is empty or wait for a positive request? \n\nI notice that reactive-streams-jvm 2.9 says\n\n> A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription.request(long n) call.\n\nThis allows us to go either way when developing an `Operator` for instance but perhaps RxJava wants to proffer a preferred or mandated direction for it's internal operators? @benjchristensen \n\nFYI @viktorklang \n", "closed": "2015-05-20 07:55:09", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2884", "ttf": 33.000277777777775, "commits": {}, "labels": ["Bug", "Enhancement"], "title": "Backpressure and onComplete from an empty observable"}, {"created": "2015-04-14 18:52:27", "user": "akarnokd", "body": "The following test eventually times out and rarely, it fails to deliver all 1000 elements per loop even though it terminates:\n\n``` java\n@Test//(timeout = 100000)\npublic void concatMapRangeAsyncLoop() {\n    for (int i = 0; i < 1000000; i++) {\n        if (i % 100 == 0) {\n            System.out.println(\"concatMapRangeAsyncLoop > \" + i);\n        }\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.range(0, 1000)\n        .concatMap(new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer t) {\n                return Observable.just(t);\n            }\n        })\n        .observeOn(Schedulers.computation()).subscribe(ts);\n\n        ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);\n        ts.assertTerminalEvent();\n        ts.assertNoErrors();\n        assertEquals(1000, ts.getOnNextEvents().size());\n        assertEquals((Integer)999, ts.getOnNextEvents().get(999));\n    }\n}\n```\n\nI've looked at the code of `concatMap` but couldn't figure out why it stops emitting values. I've tried interleaving the method executions via debug-stepping but no luck.\n", "closed": "2015-08-13 00:41:26", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2876", "ttf": 120.00027777777778, "commits": {}, "labels": ["Bug"], "title": "concatMap hangs"}, {"created": "2015-04-14 08:48:32", "user": "ashish-tyagi", "body": "It is difficult to produce this one. It occurs in our production service, which has a code almost like this:\n\n``` java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.PublishSubject;\nimport rx.subjects.Subject;\n\n/**\n * @author Ashish.Tyagi\n */\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        Subject<Integer, Integer> subject = PublishSubject.create();\n        ExecutorService executor = Executors.newFixedThreadPool(1);\n\n        subject.concatMap(new Func1<Integer, Observable<? extends Integer>>() {\n            @Override\n            public Observable<? extends Integer> call(Integer t) {\n                return Observable.just(t);\n            }\n        }).observeOn(Schedulers.from(executor)).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t) {\n                if (t % 1000 == 0) {\n                    System.out.println(t);\n                }\n            }\n        });\n\n        for (int i = 0; i < 10000000; i++) {\n            subject.onNext(i);\n        }\n        subject.onCompleted();\n\n        executor.shutdown();\n        executor.awaitTermination(5, TimeUnit.MINUTES);\n    }\n}\n\n```\n\n```\nFoolowing is the exception thrown:\nException in thread \"serviceExecutor-1\" java.lang.NullPointerException\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:129)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:78)\n    at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:73)\n    at rx.Subscriber.request(Subscriber.java:141)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:207)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:65)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:155)\n    at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:745)\n```\n", "closed": "2015-04-14 10:27:27", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2874", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "concatMap + observeOn throws a NullPointerException sometimes"}, {"created": "2015-04-03 01:54:22", "user": "davidmoten", "body": "`AbstractOnSubscribe` improperly throws an exception when the `onNext` method in a subscriber makes a call to `request` (all calls synchronous). The error thrown is this:\n\n```\njava.lang.IllegalStateException: This is not reentrant nor threadsafe!\n    at rx.observables.AbstractOnSubscribe$SubscriptionState.use(AbstractOnSubscribe.java:590)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:360)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:345)\n    at rx.Subscriber.request(Subscriber.java:145)\n    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:541)\n    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:1)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:130)\n    at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:533)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:367)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:337)\n    at rx.Subscriber.setProducer(Subscriber.java:175)\n    at rx.Subscriber.setProducer(Subscriber.java:171)\n    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:191)\n    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:1)\n    at rx.Observable.subscribe(Observable.java:7585)\n    at rx.observables.AbstractOnSubscribeTest.testCanRequestInOnNext(AbstractOnSubscribeTest.java:527)\n```\n\nHere's a failing unit test:\n\n``` java\n    @Test\n    public void testCanRequestInOnNext() {\n        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {\n            @Override\n            protected void next(SubscriptionState<Integer, Void> state) {\n                state.onNext(1);\n                state.onCompleted();\n            }\n        };\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        aos.toObservable().subscribe(new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                exception.set(e);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                request(1);\n            }\n        });\n        if (exception.get()!=null)\n            exception.get().printStackTrace();\n        assertNull(exception.get());\n    }\n```\n", "closed": "2015-04-07 17:14:21", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2853", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "AbstractOnSubscribe throws exception when onNext contains a request for more "}, {"created": "2015-03-31 21:49:18", "user": "marshallpierce", "body": "Repro: https://bitbucket.org/marshallpierce/rxjava-merge-backpressure\n\nIn text, here's what I'm doing: I have two observables: `Observable.never()`, and another that emits every 200ms. I `merge()` those two and `throttleWithTimeout()` the result with a long timeout. In a few seconds, I'll get this:\n\n```\nrx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:224)\n    at rx.subjects.PublishSubject.onNext(PublishSubject.java:114)\n    at org.mpierce.rxjava.merge.ExperimentMain.lambda$main$0(ExperimentMain.java:25)\n    at org.mpierce.rxjava.merge.ExperimentMain$$Lambda$1/1685538367.call(Unknown Source)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nInstead, I would expect that the combo of merge & throttle should simply result in throttle working as expected (never emitting, in this case).\n", "closed": "2015-04-02 16:24:48", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2850", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "Using merge() with throttleWithTimeout() leads to MissingBackpressureException"}, {"created": "2015-03-30 13:17:50", "user": "YannRobert", "body": "I get the following stacktrace in one of my test output.\n\n```\njava.lang.NullPointerException: null\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Subscriber.setProducer(Subscriber.java:177) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173) [rxjava-1.0.8.jar:1.0.8]\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99) [rxjava-1.0.8.jar:1.0.8]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_25]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_25]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_25]\n```\n\nI found it is because I am using the merge operator with a mocked Subject instance.\n\nPlease see the following gist that describe the problem.\nhttps://gist.github.com/YannRobert/a07ed294dbaccd4c3705\nIf you run it, you will get the following stracktrace\n\n```\njava.lang.NullPointerException: null\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Subscriber.setProducer(Subscriber.java:177) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.subscribe(Observable.java:7585) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.subscribe(Observable.java:7454) [rxjava-1.0.8.jar:1.0.8]\n    at IssueInRxJavaDefensiveCodeTest.shouldThrowIllegalStateExceptionOnMockSubjectSubscribeByMerge(IssueInRxJavaDefensiveCodeTest.java:86) [test-classes/:na]\n```\n\nIt seems that we could use some defensive code in the merge operator, that would detect and report this, so that's it's easier to find where the problem is.\n", "closed": "2015-08-13 00:44:42", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2848", "ttf": 135.00027777777777, "commits": {}, "labels": ["Bug"], "title": "Improve defensive code in merge when onSubscribe function is null"}, {"created": "2015-03-24 14:41:31", "user": "DaGenix", "body": "The following code:\n\n``` java\npublic class Test {\n    public static void main(final String[] arg) throws Exception {\n        Observable.just(1)\n                .repeat()\n                .concatMap(x -> {\n                    System.out.println(x);\n                    return Observable.empty()\n                            .delay(1, TimeUnit.SECONDS);\n                })\n                .subscribe();\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n```\n\nPrints out two \"1\"s quickly, and then another \"1\" every second afterward.\n\nIf you change that code just slightly two use the two argument form of `just()` as in:\n\n``` java\npublic class Test {\n    public static void main(final String[] arg) throws Exception {\n        Observable.just(1, 2)\n                .repeat()\n                .concatMap(x -> {\n                    System.out.println(x);\n                    return Observable.empty()\n                            .delay(1, TimeUnit.SECONDS);\n                })\n                .subscribe();\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n```\n\nThen, it prints \"1\", then \"2\", and then hangs and doesn't do anything afterward.\n\nI have no idea whats going on, but, I don't think that the 2nd piece of code should hang if the first one doesn't.\n\nI tested with 1.0.8 and didn't find any similar looking issue with a quick look.\n", "closed": "2015-03-25 15:55:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2844", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "ConcatMap combined with Delay causes a hang"}, {"created": "2015-03-15 19:15:47", "user": "fatroom", "body": "Hi, can somebody explain me why following piece of code printing only two times message \"Retrying\"? And not 5 times as specified in predicate?\nBTW if i uncomment doOnError line in this sample - i got 5 times message \"Retrying\".\nAny ideas what's going on here?\n\n```\nObservable.just(1)\n                .map(value -> { throw new RuntimeException(\"You shall not pass\"); })\n//                .doOnError(t -> System.out.println(\"Handling error\"))\n                .retry((counter, throwable) -> {\n                    System.out.println(\"Retrying\");\n                    return counter < 5;\n                })\n                .toBlocking()\n                .single();\n```\n", "closed": "2015-05-20 08:26:34", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2826", "ttf": 65.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Why retry method with predicate only retries 2 times?"}, {"created": "2015-03-06 08:16:50", "user": "akarnokd", "body": "##### Reconnect issue\n\nThe following test fails because in OperatorPublish, the `state.getOrigin()` still holds the subscriber of a previous connection:\n\n``` java\n@Test\npublic void testSubscribeAfterDisconnectThenConnect() {\n    ConnectableObservable<Integer> source = Observable.just(1).publish();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts1);\n\n    Subscription s = source.connect();\n\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n\n    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts2);\n\n    Subscription s2 = source.connect();\n\n    ts2.assertReceivedOnNext(Arrays.asList(1));\n    ts2.assertNoErrors();\n    ts2.assertTerminalEvent();\n\n    System.out.println(s);\n    System.out.println(s2);\n}\n```\n\nHowever, it works with `share()`:\n\n``` java\n@Test\npublic void testShareReconnect() {\n    Observable<Integer> source = Observable.just(1).share();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts1);\n\n    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts2);\n\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n\n    ts2.assertNoErrors();\n    ts2.assertTerminalEvent();\n    ts2.assertReceivedOnNext(Arrays.asList(1));\n}\n```\n##### connect() is racy\n\nIn addition, the `OperatorPublish.connect()` method is inherently racy: two concurrent connect calls may succeed, one kicking out the upstream subscriber of the other.\n##### OriginSubscriber.requestMore may overflow\n\n`originOutstanding.addAndGet()` may turn negative\n##### Retention of subscribers after completion event.\n\nAfter making all relevant fields and classes package-private, the following test fails:\n\n``` java\n@Test\npublic void testNoSubscriberRetentionOnCompleted() {\n    OperatorPublish<Integer> source = (OperatorPublish<Integer>)Observable.just(1).publish();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.unsafeSubscribe(ts1);\n\n    source.connect();\n\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n\n    assertTrue(source.requestHandler.state.subscribers.length == 0 \n            && source.requestHandler.state.ss.isEmpty());\n}\n```\n\nNote that blindly evicting values from ss while completing in drainQueues() is wrong too, because if there is a concurrent subscription in the works, its tracking recod in state.ss and subscribers may get deleted as well, instead of letting it wait for the next connect().\n\n/cc @davidmoten: please look at these issues while you fix OperatorPublish for #2803.\n", "closed": "2015-05-20 08:27:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2810", "ttf": 75.00027777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorPublish bugs"}, {"created": "2015-03-05 10:29:41", "user": "davidmoten", "body": "This is outstanding work from #2774.  I can have a go at it next week if no-one in a rush.\n", "closed": "2015-05-20 08:27:57", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2803", "ttf": 75.00027777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorPublish connect(connection) should not return null"}, {"created": "2015-03-04 16:40:15", "user": "wendigo", "body": "Given this piece of code:\n\n```\n        Observable.create(subscriber -> {\n            long counter = 0;\n\n            while (counter++ < Long.MAX_VALUE) {\n                System.out.println(\"onNext(\" + counter + \")\");\n\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onNext(counter);\n                } else {\n                    break;\n                }\n\n                System.out.println(\"Subscribe.onNext(\" + value + \")\");\n            }\n        })\n        .onBackpressureBlock(2)\n        .subscribeOn(Schedulers.newThread())\n        .observeOn(Schedulers.computation())\n        .subscribe(System.out::println);\n```\n\nOn version 1.0.7 above code will hang on producing element on position RxRingBuffer.SIZE + 2 (maxQueueLength):\n\n```\n...\nafterOnNext(127)\nonNext(128)\nafterOnNext(128)\nSubscribe.onNext(128)\nonNext(129)\nafterOnNext(129)\nonNext(130)\nafterOnNext(130)\nonNext(131)\n```\n\nIf we switch order of subscribe/observeOn (observeOn before subscribeOn) - it will work as expected :)\n\nAlso it will throw _MissingBackpressureException_ without onBackpressure\\* (as expected).\n", "closed": "2015-08-28 17:10:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2799", "ttf": 177.00027777777777, "commits": {}, "labels": ["Bug"], "title": "onBackpressureBlock() causes hangs"}, {"created": "2015-02-25 16:06:35", "user": "lopespm", "body": "Any posterior `connect()` calls to an already connected `ConnectableObservable` return `null`, but I believe the expected behaviour would be for it to return the subscription created for the first connection\n", "closed": "2015-03-05 06:06:18", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2774", "ttf": 7.000277777777778, "commits": {}, "labels": ["Bug"], "title": "ConnectableObservable.connect() returns a null subscription if already connected"}, {"created": "2015-02-13 21:49:39", "commits": {"3ea9265dcd63add0ba32eff1c75629f03c1a0443": {"commitGHEventType": "referenced", "commitUser": "zsxwing"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2016-05-23 23:15:57", "filteredCommits": [], "commitsDetails": [{"nameRev": "3ea9265dcd63add0ba32eff1c75629f03c1a0443 tags/v1.1.6~18", "commitMessage": "1.x: just() construction to call the onCreate execution hook (#3958)\n\nThis PR adds the call to RxJavaObservableExecutionHook.onCreate() to the just() - ScalarSynchronousObservable construction.\r\n\r\nRelated: #2656.", "commitParents": ["d24c395f9ed8507d6df0b469ac9727729c07f671"], "spoonStatsSkippedReason": "", "commitHash": "3ea9265dcd63add0ba32eff1c75629f03c1a0443", "authoredDateTime": "2016-05-24 01:15:32", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 24, "deletions": 8, "lines": 32, "filePath": "src/main/java/rx/internal/util/ScalarSynchronousObservable.java"}, {"insertions": 68, "deletions": 2, "lines": 70, "filePath": "src/test/java/rx/internal/util/ScalarSynchronousObservableTest.java"}], "commitDateTime": "2016-05-23 16:15:32", "commitUser": "zsxwing", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.hookCalled()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapJust().1"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.syncFlatMapJustObserverNextThrows()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.hookChangesBehavior()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapJust()"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.syncFlatMapJustObserverNextThrows().6.call(java.lang.Integer)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.emptiesAndJust()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureObserveOn()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapRange().2"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapJust().1.call(java.lang.Integer)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.syncObserverNextThrows()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.emptiesAndJust().3"}, {"UPD": 2, "TOT": 2, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapRange().2.call(java.lang.Integer)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.syncFlatMapJustObserverNextThrows().6"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureSubscribeOn()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.asyncObserverNextThrows()"}, {"UPD": 4, "TOT": 4, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.emptiesAndJust().3.call(java.lang.Integer)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressure()"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservableTest.testBackpressureFlatMapRange()"}], "spoonFilePath": "ScalarSynchronousObservableTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.scalarFlatMap(rx.internal.util.Func1).4"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.JustOnSubscribe.call(rx.internal.util.Subscriber)"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.scalarScheduleOn(rx.internal.util.Scheduler).3"}, {"UPD": 0, "TOT": 6, "MOV": 3, "INS": 2, "DEL": 1, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable"}, {"UPD": 0, "TOT": 2, "MOV": 1, "INS": 0, "DEL": 1, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.1.call(rx.internal.util.Subscriber)"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.JustOnSubscribe"}, {"UPD": 1, "TOT": 1, "MOV": 0, "INS": 0, "DEL": 0, "spoonMethodName": "rx.internal.util.ScalarSynchronousObservable.scalarScheduleOn(rx.internal.util.Scheduler).2"}], "spoonFilePath": "ScalarSynchronousObservable.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/2656", "ttf": 465.0002777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "just(T) : RxJavaObservableExecutionHook not called", "statsSkippedReason": "", "user": "ronanM", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "When using rx.Observable.just(T) the RxJavaObservableExecutionHook is not call.\n\nThis is not like other just(T,...) that call rx.Observable.from(Iterable<? extends T>).\n", "labels": ["Bug"]}, {"created": "2015-02-13 18:08:43", "user": "angrycamel", "body": "The first example uses switchMap and fails with the exception below after 128 events, whereas the second example uses flatMap and does not fail. The third example shows that switchMap does not fail if the nested observable is not a product of of the merge operator. \n\nHowever the other variable is the share() on the mainObservable. _Without this, Example 1 works_ (I have called this case Example 4). So you might wonder if it has anything to do with switchMap at all - maybe just sharing a merged observable will also fail (Example 5) - however, this case works fine.\n\nSo we're left with \"sharing a switchMap which produces its result via merge, will stop producing after 128 events\". But why?\n\n_(using rxjava 1.0.4, rxscala 0.23.1, scala 2.11.4)_\n\n<pre>\nrx.exceptions.MissingBackpressureException: null\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:338) ~[rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:680) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:657) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:545) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [rxjava-1.0.4.jar:1.0.4]\n</pre>\n\n_Example 1 : This Fails After 128 events_\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 2 : This Works Fine_\nNote this is precisely the same code as Example 1, except I've changed  switchMap to flatMap\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.flatMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 3 : This also works fine_\nChanging example 1 again but this time not using merge within the switchMap.\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 4 : This also works fine_\nChanging example 1 again but this time not share()ing the mainObservable\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 5 : This also works fine_\nExperiment to find out if the problem is simply sharing a merged observable.... seems not\n\n``` scala\ndef main(args:Array[String]) = {\n    val mainObservable = Observable.just(1).merge(Observable.interval(20 milliseconds))\n        .share\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n", "closed": "2015-02-22 18:28:28", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2654", "ttf": 9.000277777777777, "commits": {}, "labels": ["Bug"], "title": "sharing a switchMap which produces its result via merge, will stop producing after 128 events"}, {"created": "2015-02-10 21:11:57", "user": "benjchristensen", "body": "The following code hangs forever as it doesn't emit a terminal event:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class IntervalTakeWhileExample {\n\n    public static void main(String... args) {\n        Observable\n                .interval(1, TimeUnit.MILLISECONDS)\n                .doOnEach(a -> System.out.println(\"A ==> \" + a))\n                .takeWhile(aLong -> aLong < 1)\n                .doOnEach(b -> System.out.println(\"B ==> \" + b))\n                .flatMap(aLong -> {\n                    return Observable\n                            .timer(30, TimeUnit.MILLISECONDS)\n                            .doOnUnsubscribe(() -> System.out.println(\"unsubscribed timer?\"))\n                            .doOnEach(c -> System.out.println(\"C ==> \" + c))\n                            .map(aLong1 -> aLong1 + aLong);\n                })\n                .doOnEach(d -> System.out.println(\"D ==> \" + d))\n                .toBlocking().forEach(System.out::println);\n    }\n}\n```\n\nThis emits:\n\n```\nA ==> [rx.Notification@f6adcf11 OnNext 0]\nB ==> [rx.Notification@f6adcf11 OnNext 0]\nA ==> [rx.Notification@f6adcf12 OnNext 1]\nB ==> [rx.Notification@5b2cf4de OnCompleted]\nunsubscribed timer?\n```\n", "closed": "2015-02-11 21:12:39", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2647", "ttf": 1.0002777777777778, "commits": {}, "labels": ["Bug"], "title": "flatMap doesn't propagate onComplete with unsubscribe of child"}, {"created": "2015-02-05 00:01:09", "user": "davidmoten", "body": "With 1.0.5, I'm getting an `IllegalStateException` from `OperatorMerge`. This is repeatable for me but involves a big input data set being processed in chunks using flatMap/onSubscribe so I can't give you a quick test case yet. Hopefully just this description is enough otherwise I'll try and distill a test. I think it is happening close to completion.\n\n```\njava.lang.IllegalStateException: This instance has been unsubscribed and the queue is no longer usable.\n        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:346)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainScalarValueQueue(OperatorMerge.java:396)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:343)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.Subscriber.request(Subscriber.java:130)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.Subscriber.request(Subscriber.java:130)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: au.gov.amsa.ais.Timestamped.class\n        at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:58)\n        ... 27 more\n```\n", "closed": "2015-03-11 14:03:37", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2604", "ttf": 34.000277777777775, "commits": {}, "labels": ["Bug", "Discussion"], "title": "OperatorMerge - RxRingBuffer throws IllegalStateException again"}, {"created": "2015-02-04 13:08:16", "user": "mttkay", "body": "So this might be a debatable one, but I thought it's worth pointing out because it really leads to surprising and (I think) unexpected behavior on one of the key methods on Observable (`subscribe`).\n\nTo illustrate, consider this:\n\n``` java\n    @Test\n    public void shouldUnsubscribe() {\n        TestSubscriber subscriber = new TestSubscriber();\n        final Subscription subscription = Observable.just(\"item\").subscribe(subscriber);\n        subscription.unsubscribe();\n        expect(subscriber.isUnsubscribed()).toBeTrue();\n    }\n\n```\n\nThis test passes. If I change line 2 of the test to this:\n\n``` java\n        ...\n        final Subscription subscription = Observable.just(\"item\").subscribe((Observer) subscriber);\n        ...\n```\n\nThe test fails. The reason is the widening cast to `Observer`: this causes an overload of `subscribe` to be called which wraps away the observer into another Subscriber, without checking whether the observer isn't also a Subscriber and therefore has a Subscription that must be unsubscribed from. Since it uses the default constructor of Subscriber to perform the composition, no link will be established between the parent and child subscription, thus changing the behavior of the composition. \n\nI find this to be very surprising. The example is contrived, but this widening cast is actually very likely to happen whenever you're keeping a list of observers somewhere that can either be Subscribers or Observers. Doesn't this also mean that it will lead to very subtle bugs, because we're effectively disregarding the Subscription wrapped by the subscriber, which may want to call important cleanup logic in `unsubscribe`?\n\nA simple but arguably not pretty fix for this would be to change the `subscribe` overload in a manner where it first tests whether the Observer is actually a Subscriber, and downcasts it safely, then only wrapping it in a Subscriber if necessary.\n", "closed": "2015-03-11 13:52:17", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2599", "ttf": 35.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Widening cast from Subscriber to Observer changes behavior of subscription chain"}, {"created": "2015-02-04 07:51:34", "user": "FinalVersion", "body": "I have experienced some unexpected behaviors of publish() and connect() in my project. \nHopefully it's not my misunderstanding since I'm a newbie to Rx.\n\nI will use an Observer that simply print onNext, onError, onCompleted.\n\n``` Java\n    public static class PrintObserver<T> implements Observer<T> {\n        @Override\n        public void onCompleted() {\n            System.out.println(\"onCompleted\");\n        }\n        @Override\n        public void onError(Throwable e) {\n            System.out.println(\"onError: \" + e);\n        }\n        @Override\n        public void onNext(T t) {\n            System.out.println(\"onNext: \" + t);\n        }\n    }\n```\n\nThe simplified scenarios are as follows:\n\n1) **ConnectableObservable stops emitting without unsubscribing from source.**\n\n``` Java\n    Observable<Integer> source = Observable.range(0, 1000);\n    ConnectableObservable<Integer> pub1 = source.publish();\n    ConnectableObservable<Integer> pub2 = pub1.publish();\n    pub2.connect();\n    //pub2.subscribe();\n    pub1.subscribe(new PrintObserver<Integer>());\n    pub1.connect();\n```\n\nI expected the output to be 'onNext: 0' up to 'onNext: 999', then 'onCompleted', but it stops at onNext: 127 in my test.\nBut if I uncomment `//pub2.subscribe();`, namely have something subscribe to pub2, it will work as expected. Or else if I do not `pub2.connect()`, it will also work.\n\nThe code may looks silly, but it may not if I put some operator which does expensive computations before publishing as pub2. BTW, what I want is to do some intermediate computations only once if pub2 is subscribed by many subscribers or piped to different downstream operators. If there're better ways to do that, please kindly let me know.\n\n2) **`publish()` behaves like `replay()`**\n\n``` Java\n    try {\n        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS).take(10);\n        ConnectableObservable<Long> pub = source.publish();\n        pub.connect();\n\n        Thread.sleep(2500);\n\n        pub.subscribe(new PrintObserver<Long>());\n\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n```\n\nI expected that after `pub.connect()`, source will start emitting, and when `pub` is subscribed after 2.5 sec, 'onNext: 0' and 'onNext: 1' will be missed by this subscriber. However, I got them all together at 2.5 sec, and from 3rd second, I got the following onNext: 2 and so on. This looks like a `replay()` behavior to me. \n", "closed": "2015-05-20 11:54:27", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2596", "ttf": 105.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Unexpected behavior of publish() and connect()"}, {"created": "2015-02-03 17:36:31", "user": "pradhakrishnan", "body": "I have an issue with zip operator, I have few observables which execute asynchronously. And finally I am zipping all the results from each observable. It works fine, but sometime zip operator is waiting for long time to get the value from one of the observable.\n\n```\n List<Observable<Set<Item>>> observableList = new ArrayList<Observable<Set<Item>>>();\nfor (ItemProvider ep : itemList) {\n          ItemStrategy strategey = (ItemStrategy) ep.strategy();\n          observableList.add(strategey.determineItems(message).subscribeOn(Schedulers.io()));\n      }\n }\n\nSet<Item> items = Observable.zip(observableList, new FuncN<Set<Item>>() {\n  Set<Item> returnSet = new HashSet<Item>();\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Item> call(Object... args) {\n      for (int i = 0; i < args.length; i++) {\n        Set<Item> items = (Set<Item>) args[i];\n          returnSet.addAll(items);\n      }\n      return returnSet;\n  }\n}).toBlocking().singleOrDefault(Collections.<Item> emptySet());\n\nThis is the code to get the items in Strategy class\n@Override\n    public Observable<Set<Item>> determineItems(final ItemsMessageExchange message) {\n      return Observable.create(new OnSubscribe<Set<Item>>() {\n\n            @Override\n            public void call(Subscriber<? super Set<Item>> subscriber) {\n                checkPreconditions(message);\n                Set<Record> records = getRecordsOfQuery(message.toRecordQuery());\n                Set<Item> items = new HashSet<Item>();\n                for (Record record : records) {\n                    try {\n                        items.addAll(record.determineItems());\n                    } catch (Exception ex) {\n                        subscriber.onError(ex);\n                    }\n                }\n                subscriber.onNext(items);\n                subscriber.onCompleted();\n            }\n\n        });\n    }\n```\n\nCan anyone help me to fix this.\n", "closed": "2015-02-04 05:50:22", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2588", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Questions about Zip operator"}, {"created": "2015-02-03 16:22:46", "user": "hamen", "body": "Hi all\nI'm having a hard time trying to figure this out:\n\n``` java\nObservable<AppInfo> sequence = Observable.from(apps)\n                .take(3)\n                .repeat(3);\n\n        sequence.subscribe(new Observer<AppInfo>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"RXJAVA1\", \"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(\"RXJAVA1\", \"Error\");\n            }\n\n            @Override\n            public void onNext(AppInfo appInfo) {\n                Log.d(\"RXJAVA1\", appInfo.getName());\n            }\n        });\n\n        sequence.distinct()\n                .subscribe(new Observer<AppInfo>() {\n                    @Override\n                    public void onCompleted() {\n                        Log.d(\"RXJAVA2\", \"Completed\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.e(\"RXJAVA2\", \"Error\");\n                    }\n\n                    @Override\n                    public void onNext(AppInfo appInfo) {\n                        Log.d(\"RXJAVA2\", appInfo.getName());\n                    }\n                });\n```\n\ngives me\n\n```\nD/RXJAVA1\ufe55 9GAG\nD/RXJAVA1\ufe55 AdSense\nD/RXJAVA1\ufe55 AirDroid\nD/RXJAVA1\ufe55 9GAG\nD/RXJAVA1\ufe55 AdSense\nD/RXJAVA1\ufe55 AirDroid\nD/RXJAVA1\ufe55 9GAG\nD/RXJAVA1\ufe55 AdSense\nD/RXJAVA1\ufe55 AirDroid\nD/RXJAVA1\ufe55 Completed\nD/RXJAVA2\ufe55 9GAG\nD/RXJAVA2\ufe55 AdSense\nD/RXJAVA2\ufe55 AirDroid\n```\n\nand the sequence never completes. If I only repeat it twice:\n\n``` java\nObservable<AppInfo> sequence = Observable.from(apps)\n                .take(3)\n                .repeat(2);\n\n        sequence.subscribe(new Observer<AppInfo>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"RXJAVA1\", \"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(\"RXJAVA1\", \"Error\");\n            }\n\n            @Override\n            public void onNext(AppInfo appInfo) {\n                Log.d(\"RXJAVA1\", appInfo.getName());\n            }\n        });\n\n        sequence.distinct()\n                .subscribe(new Observer<AppInfo>() {\n                    @Override\n                    public void onCompleted() {\n                        Log.d(\"RXJAVA2\", \"Completed\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.e(\"RXJAVA2\", \"Error\");\n                    }\n\n                    @Override\n                    public void onNext(AppInfo appInfo) {\n                        Log.d(\"RXJAVA2\", appInfo.getName());\n                    }\n                });\n```\n\nI get\n\n```\nD/RXJAVA1\ufe55 9GAG\nD/RXJAVA1\ufe55 AdSense\nD/RXJAVA1\ufe55 AirDroid\nD/RXJAVA1\ufe55 9GAG\nD/RXJAVA1\ufe55 AdSense\nD/RXJAVA1\ufe55 AirDroid\nD/RXJAVA1\ufe55 Completed\nD/RXJAVA2\ufe55 9GAG\nD/RXJAVA2\ufe55 AdSense\nD/RXJAVA2\ufe55 AirDroid\nD/RXJAVA2\ufe55 Completed\n```\n\nand everything is fine.\nI'm working on some examples and I spotted this weird scenario and it's driving me crazy. Am I missing something or there is actually something wrong with this?\nThanks\n", "closed": "2015-02-04 07:19:41", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2587", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "take + repeat + distinct not completing"}, {"created": "2015-01-29 11:17:29", "user": "david-hoze", "body": "Hi, I noticed some behavior I don't fully understand.\n\nWhen I run this:\n\n``` java\nObservable<String> interval =\n        Observable.interval(1,TimeUnit.SECONDS)\n                .doOnSubscribe(() -> System.out.println(\"subscribe interval\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe interval\"))\n                .flatMap(onClickEvent -> Observable.defer(() -> Observable.<String>error(new Exception(\"Some exception\"))))\n                .onErrorResumeNext(Observable::error)\n                .publish()\n                .refCount()\n                .doOnSubscribe(() -> System.out.println(\"subscribe refCount\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe refCount\"));\n\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 1 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 1: \" + s));\n```\n\nI get:\n\n```\nsubscribe refCount\nsubscribe interval\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscribe interval\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\n...\n```\n\nThe three dots indicate that it continues infinitely.\nNow when I add a second subscriber:\n\n``` java\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 2 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 2: \" + s));\n```\n\nI get:\n\n```\nsubscribe refCount\nsubscribe interval\nsubscribe refCount\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\n```\n\nand that's it, it doesn't retry. More specifically, it unsubscribes from interval and does not resubscribe. When I remove the `onErrorResumeNext` it's working fine like this:\n\n```\nsubscribe refCount\nsubscribe interval\nsubscribe refCount\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\n...\n```\n\nWhere the three dots indicate it goes on infinitely. As you notice it doesn't unsubscribe from interval. I'm using `onErrorResumeNext` to \"map\" the error (in this example it's a trivial mapping), maybe I shouldn't use it like this. Still, I don't understand what's going on..\n", "closed": "2015-02-04 07:18:57", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2564", "ttf": 5.000277777777778, "commits": {}, "labels": ["Bug"], "title": "onErrorResumeNext, refCount and retry"}, {"created": "2015-01-28 00:14:31", "user": "abersnaze", "body": "This may be related to #1845 but @neerajrj and I were able to create a unit test that causes an NPE in merge.\n\n```\nException in thread \"RxComputationThreadPool-1\" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:52)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$31.onError(Observable.java:7126)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.innerError(OperatorMerge.java:463)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$6(OperatorMerge.java:442)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:586)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.innerError(OperatorMerge.java:463)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$6(OperatorMerge.java:442)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:586)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:672)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:579)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n    at rx.internal.operators.TakeLastQueueProducer.emit(TakeLastQueueProducer.java:100)\n    at rx.internal.operators.TakeLastQueueProducer.startEmitting(TakeLastQueueProducer.java:45)\n    at rx.internal.operators.OperatorTakeLast$1.onCompleted(OperatorTakeLast.java:59)\n    at rx.internal.operators.OperatorScan$2.onCompleted(OperatorScan.java:121)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber.emit(BufferUntilSubscriber.java:151)\n    at rx.internal.operators.BufferUntilSubscriber.onCompleted(BufferUntilSubscriber.java:164)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber.replaceSubject(OperatorWindowWithTime.java:200)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber.nextWindow(OperatorWindowWithTime.java:308)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber$1.call(OperatorWindowWithTime.java:282)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n    ... 7 more\nCaused by: java.lang.NullPointerException\n    at rx.internal.util.RxRingBuffer.poll(RxRingBuffer.java:397)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.drainAll(OperatorMerge.java:754)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.drainQueue(OperatorMerge.java:775)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.access$1(OperatorMerge.java:771)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:420)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:1)\n    at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:471)\n    at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:437)\n    at rx.internal.util.SubscriptionIndexedRingBuffer.forEach(SubscriptionIndexedRingBuffer.java:131)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainChildrenQueues(OperatorMerge.java:376)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:351)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$2(OperatorMerge.java:344)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:705)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:579)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:669)\n    ... 21 more\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: java.lang.Long.class\n    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:672)\n    ... 21 more\n```\n\nunit test that causes the error\n\n```\n    @Test\n    public void test() {\n        Observable<Long> src = Observable.create(new OnSubscribe<Long>() {\n            @Override\n            public void call(Subscriber<? super Long> t1) {\n                Random rand = new Random();\n                while (true) {\n                    t1.onNext(rand.nextLong());\n                }\n            }\n        });\n\n        Observable<Long> x = src.groupBy(new Func1<Long, Long>() {\n            @Override\n            public Long call(Long t1) {\n                return t1 % 100000;\n            }\n        }).flatMap(new Func1<GroupedObservable<Long, Long>, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(GroupedObservable<Long, Long> group) {\n                return group.observeOn(Schedulers.computation()).timeout(1, TimeUnit.SECONDS, Observable.empty()).window(100, 100, TimeUnit.MILLISECONDS).flatMap(new Func1<Observable<Long>, Observable<Long>>() {\n                    @Override\n                    public Observable<Long> call(Observable<Long> window) {\n                        return window.countLong();\n                    }\n                });\n            }\n        });\n\n        x.subscribe(new Action1<Long>() {\n            @Override\n            public void call(Long t1) {\n                System.out.println(t1);\n            }\n        });\n    }\n```\n", "closed": "2015-01-29 00:08:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2542", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "NullPointerException in merge"}, {"created": "2015-01-21 22:55:44", "user": "davidmoten", "body": "`OperatorMergeTest.testBackpressureUpstream2` fails 2 out of 3 times when running the whole suite in Eclipse on an old 2 core laptop. The test passes every time if run singly. \n\nSee also discussion about test isolation #1624\n", "closed": "2015-03-11 14:12:42", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2480", "ttf": 48.000277777777775, "commits": {}, "labels": ["Bug", "Test-Failures"], "title": "Non deterministic test: OperatorMergeTest.testBackpressureUpstream2"}, {"created": "2015-01-19 13:04:18", "user": "grzechum", "body": "Below test, when run, quickly goes out of requests, merge operator is quite complex and it is difficult to say what exactly causes the problem but it looks like race condition, because each run gives different results.\n\nThis may be related to #1941 but scenario is different.\n\n``` java\n    private final class OnSubscribeImpl implements OnSubscribe<String> {\n        private final int id;\n        private final Semaphore requested = new Semaphore(0); // back pressure control\n\n        public OnSubscribeImpl(int id) {\n            this.id = id;\n        }\n\n        @Override\n        public void call(Subscriber<? super String> s) {\n            s.setProducer(new Producer() {\n                @Override\n                public void request(long n) {\n                    System.out.println(id + \" - REQUESTED: \" + n);\n                    requested.release((int) n);\n                }\n            });\n\n            try {\n                long counter = 0;\n                while (true) {\n                    requested.acquire();\n                    System.out.println(id + \" - REMAININIG: \" + requested.availablePermits());\n\n                    s.onNext(id + \" - \" + (counter++));\n                }\n            } catch (InterruptedException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testX() throws InterruptedException {\n\n        Observable<String> obs0 = Observable.create(new OnSubscribeImpl(0)).subscribeOn(Schedulers.io());\n        Observable<String> obs1 = Observable.create(new OnSubscribeImpl(1)).subscribeOn(Schedulers.io());\n\n        Observable.merge(obs0, obs1).observeOn(Schedulers.computation()).forEach(s -> System.out.println(s));\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n```\n", "closed": "2015-02-23 14:43:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2466", "ttf": 35.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Out of requests in merge"}, {"created": "2015-01-16 07:56:11", "user": "zsxwing", "body": "Found some race conditions in `OperatorOnBackpressureBuffer`. Here is the test: https://github.com/zsxwing/RxJava/commit/66737b4544d9218e5121e8e65962f7843cba14ee\n\nBecause it's hard to write a test to reproduce it, I have to add `Thread.sleep(...)` in `OperatorOnBackpressureBuffer`.\n\nWe are using the following pattern in `OperatorOnBackpressureBuffer`:\n\n``` Java\n0 Update some state\n1 if (wip.getAndIncrement() == 0) {\n2    while(true) {\n3       // do something\n4       if (some_condition_about_state is false) {\n5             wip.decrementAndGet();\n6       }\n7    }\n8 }\n```\n\nAssume thread T1 and thread T2 runs the above codes at the same time. At first, T2 is suspended in L0  and T1 runs normally. However, when T1 reaches L5 (before decreasing wip), it's suspended. Then T2 starts to run, it will update the state, and some_condition_about_state becomes true. However, T2 finds wip is not 0, so it won't enter the while loop. T2 will exit. Now T1 is back, it doesn't know some_condition_about_state becomes true, it will directlly desceases `wip` and exits.\n\nIf there is no thread enters the above codes after T1 and T2, `OperatorOnBackpressureBuffer` will swallows the values in the queue.\n", "closed": "2015-02-05 15:55:56", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2459", "ttf": 20.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Race conditions in `OperatorOnBackpressureBuffer`"}, {"created": "2014-12-28 06:21:15", "user": "benjchristensen", "body": "The `merge(Observable/Iterable o, int maxConcurrent)` overloads do not support backpressure. They were missed when implementing the normal `merge`. \n\nThis was first brought up in https://github.com/ReactiveX/RxJava/issues/1927#issuecomment-66885487\n\nThis code shows the problem:\n\n``` java\nimport static rx.Observable.*;\nimport rx.Observable;\nimport rx.schedulers.Schedulers;\n\npublic class MergeMaxConcurrent {\n\n    public static void main(String[] args) {\n        Observable<Observable<Integer>> asyncWork = range(1, 1000000)\n                //      .doOnNext(i -> System.out.println(\"Value: \" + i))\n                .doOnRequest(r -> System.out.println(\"request1 \" + r))\n                .map(item -> {\n                    return just(item)\n                            .doOnNext(MergeMaxConcurrent::sleep)\n                            .subscribeOn(Schedulers.io());\n                })\n                .doOnRequest(r -> System.out.println(\"request2 \" + r));\n        merge(asyncWork, 10).toBlocking().forEach(System.out::println);\n    }\n\n    public static void sleep(int value) {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nRelated to this, we should have a `flatMap` overload that accepts a `maxConcurrent` parameter so that the `merge(o, maxConcurrent)` can be used like this with backpressure:\n\n``` java\n        Observable.range(0, Integer.MAX_VALUE).map(i -> \"lineOfData-\" + i) // simulate the file with many lines\n                .buffer(100) // buffer up chunks of work before processing them\n                .flatMap(chunk -> {\n                    return Observable.just(chunk).subscribeOn(Schedulers.io()) // put each group on a new thread (io scheduler for blocking IO) \n                            .doOnNext(t -> {\n                                // do work here\n                                try {\n                                    Thread.sleep(1000);\n                                } catch (Exception e) {\n                                }\n                                // write out on blocking IO as a side-effect\n                                System.out.println(\"Emitting to IO: \" + t);\n                            });\n                }).toBlocking().forEach(System.out::println);\n```\n\nRight now an awkward use of `groupBy` can be used to avoid using `merge` but it is inefficient since it calls the `groupBy` function on every item instead of being able to do the buffering before `flatMap` and just using backpressure to only `merge` the `maxConcurrent` as they are processed.\n\nHere is the `groupBy` approach:\n\n``` java\n        Observable.range(0, Integer.MAX_VALUE).map(i -> \"lineOfData-\" + i) // simulate the file with many lines\n                .zipWith(Observable.range(0, Integer.MAX_VALUE), (d, i) -> new Object[] { d, i }) // index it so we can use the index position\n                .groupBy(pair -> (int) pair[1] % 4) // mod on index for parallelism\n                .flatMap(g -> {\n                    return g.observeOn(Schedulers.computation()) // put each group on a new CPU \n                            .map(pair -> pair[0]) // extract just the value\n                            .buffer(100) // buffer up chunks of work before processing them\n                            .map(t -> {\n                                // do work here\n                                try {\n                                    Thread.sleep(1000);\n                                } catch (Exception e) {\n                                }\n                                // generally just pure processing goes in a map function\n                                // so if IO side-effects are being done here, then it is idiomatic to instead\n                                // use doOnNext which returns Void. \n                                // If doing blocking IO here, then use Schedulers.io() instead of computation() above. \n                                return \"processed \" + t;\n                            });\n                }).toBlocking().forEach(System.out::println);\n```\n\nThese last 2 solutions are variants for splitting up a long file of data, processing them in multiple threads and emitting the results over network IO. It is not important whether the IO is blocking or non-blocking. It is not even all that important whether the IO is done as a side-effect on each thread, or the results are merged back into 1 thread and then emitted. The important part is that right now it's not obviously simple to use `flatMap` and achieve backpressured, async parallelism. \n", "closed": "2015-02-05 16:15:54", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2291", "ttf": 39.000277777777775, "commits": {}, "labels": ["Bug", "Enhancement"], "title": "Backpressure: flatMap/merge with maxConcurrent"}, {"created": "2014-12-27 22:52:27", "user": "benjchristensen", "body": "This code only emits 1 window. \n\n``` java\n        Observable.range(0, 10000).window(1, TimeUnit.SECONDS, 20).flatMap(o -> {\n            System.out.println(\"window\");\n           return o.count(); \n        }).toBlocking().forEach(System.out::println);\n```\n\nThere are 2 issues I have with it:\n\n1) Why are there 21 instead of 20 elements in it?\n2) Why does this only emit 1 window? Why does this not just behave like `window(20)` since the time never triggers?\n", "closed": "2015-01-21 14:08:20", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2290", "ttf": 24.00027777777778, "commits": {}, "labels": ["Bug"], "title": "window time+size emits only 1 window"}, {"created": "2014-12-22 12:48:26", "user": "daschl", "body": "Hi folks,\n\nI'm again hunting lost performance and this time it seems that `observeOn` is a major contributor. I think the workload itself is not so important, but I'm fetching 5 docs in a batch from the server, wait and then the next one.  Something like:\n\n``` java\nwhile(true) {\n\n    Observable\n        .range(1, 5)\n        .flatMap(new Func1<Integer, Observable<GetResponse>>() {\n            @Override\n            public Observable<GetResponse> call(Integer i) {\n                return core.<GetResponse>send(new GetRequest(\"\" + i, \"default\"));\n            }\n        })\n        .doOnNext(new Action1<GetResponse>() {\n            @Override\n            public void call(GetResponse getResponse) {\n                getResponse.content().release();\n            }\n        })\n        .toBlocking()\n        .last();\n}\n```\n\nNow when I run it like this, I get 30k ops/s against my Couchbase Server cluster, which seems fair relatively. Now when I change the code to:\n\n``` java\n.flatMap(new Func1<Integer, Observable<GetResponse>>() {\n    @Override\n    public Observable<GetResponse> call(Integer i) {\n        return core.<GetResponse>send(new GetRequest(\"\" + i, \"default\")).observeOn(env.scheduler());\n    }\n})\n```\n\nI'm not getting over 22k ops/s, which means I'm loosing 8k ops/s just by moving it onto a different scheduler. The thing is, I need to move it somewhere else to prevent users from stalling my IO threads. I expect \"some\" loss, but not that much.\n\nI did JFR runs for both sessions over 5 minute periods. I'm not 100% sure what is causing the issues here, but one interesting thing is that with `observeOn` I get contention reported, without it there is no contention:\n\n![screen shot 2014-12-22 at 13 43 26](https://cloud.githubusercontent.com/assets/29086/5525064/9138fec8-89e0-11e4-9c23-0bb8e5f813f5.png)\n\nAlso, it looks like the Interrupt Exceptions are back with observeOn (no shown when omitted):\n\n![screen shot 2014-12-22 at 13 46 16](https://cloud.githubusercontent.com/assets/29086/5525097/ff9e1f4c-89e0-11e4-9e2c-abeafef9f015.png)\n\nSo my questions are basically:\n\n1) can we improve the observeOn performance to be mostly on-par (loosing a few 100 ops/s I'm okay with)\n2) if not, is there an alternative way to go that is faster?\n3) @akarnokd didn't you fix the interrupts?\n\nThis is on 1.0.3\n", "closed": "2015-03-11 14:17:29", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/2157", "ttf": 79.00027777777778, "commits": {}, "labels": ["Bug", "Question"], "title": "observeOn() slowing things down considerably"}, {"created": "2014-12-07 10:32:40", "user": "abersnaze", "body": "I was working on the adding back pressure logging to the debug hooks and I noticed some strange behavior in the merge operator.\n\nThe code that I'm tracing does\n\n```\nfrom(1,3).flatMap( i -> from(i*10, (i+1)*10) ).take(3).subscribe()\n```\n\nThe merge subscriber has these methods invoked\n\n```\nrx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\n[\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnNext\", \"value\": \"rx.Observable@6ed3ef1\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Request\", \"n\": 1},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnNext\", \"value\": \"rx.Observable@2437c6dc\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Unsubscribe\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Request\", \"n\": 1},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnCompleted\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n]\n```\n\nThe thing that I don't expect is the additional request(1) after the unsubscribe.  I set up a break point and the request(1) is coming from this line of code.\n\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorMerge.java#L189\n\nThere probably just needs to be a check there to see if that request(1) is necessary.\n", "closed": "2015-03-11 14:15:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1933", "ttf": 94.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Request more after unsubscription"}, {"created": "2014-12-02 09:44:16", "user": "daschl", "body": "Hi folks,\n\n(update, see below, looks like it's the timeout operator) \n\nI'm raising a ticket earlier than later, because I suspect we have a leak somewhere in the Scheduler logic. It could by in my code too, but from the characteristics it looks more like something rx internal.\n\nI've been able to generate some OOM scenarios where GC takes all the time to clean things up and it's not able to, which pointed me to a leak. A heap dump showed the leak suspect is the ScheduledFutureTask as part of the computation scheduler:\n\n![screen shot 2014-12-02 at 10 40 28](https://cloud.githubusercontent.com/assets/29086/5260491/b9420760-7a0f-11e4-874f-e8e9ad22a918.png)\n\nYou can see a full GC kicking in without actually making old gen smaller:\n\n![screen shot 2014-12-02 at 10 42 50](https://cloud.githubusercontent.com/assets/29086/5260509/044a317e-7a10-11e4-8cc3-b3a17bd1d1f6.png)\n\nThe code path uses both .observeOn() once to move it onto a scheduler and also blocks .single() at the very end. So I'll start looking in those places. But maybe @akarnokd or @benjchristensen you have an idea where I can start debugging?\n", "closed": "2015-03-11 14:22:57", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1919", "ttf": 99.00027777777778, "commits": {}, "labels": ["Bug", "Question"], "title": "(Updated): timeout() operator leaking ScheduledFutureTasks on Scheduler"}, {"created": "2014-11-25 03:06:57", "user": "neerajrj", "body": "For an operator chain like o.retry().groupBy().... if the source Observable has >= 1024 items the JVM seems to hang. Repeated unsubscribe calls seem to be sent by retry() upwards\nhttps://gist.github.com/neerajrj/8bb9106ca1b81e08a40f\n", "closed": "2014-11-29 05:07:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1900", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "retry() hangs when it is followed by a group by with >= 1024 items"}, {"created": "2014-11-18 21:38:04", "user": "vadims", "body": "While trying to narrow down #1890 we saw the following exception a couple of times (out of several hundred executions) on RxJava 1.0.0-RC12.\n\n``` java\n    Exception in thread \"RxComputationThreadPool-4\" java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:52)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.NullPointerException\n    at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:234)\n    at rx.internal.operators.OperatorZip$ZipProducer.request(OperatorZip.java:172)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.requestMore(OperatorConcat.java:191)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:116)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$000(OperatorConcat.java:65)\n    at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:60)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:310)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:93)\n    at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:502)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:310)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:93)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:687)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:541)\n    at rx.internal.operators.OperatorDelay$1$2.call(OperatorDelay.java:76)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n    ... 7 more\n```\n", "closed": "2015-01-21 12:24:47", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1891", "ttf": 63.000277777777775, "commits": {}, "labels": ["Bug"], "title": "NullPointerException"}, {"created": "2014-11-18 21:33:55", "user": "vadims", "body": "The following piece of code used to emit all 1024 items and print \"Done\" using RxJava 0.19.6 / Hystrix 1.3.18.\n\nWhen using RxJava versions 0.20 to 1.0.0 the code stops emitting after 20 items and never prints \"Done\". We tried to simplify this further, unfortunately it stops reproducing if we remove any of the operators from the chain below.\n\nWe suspect that it's due to backpressure support since it was added when this stopped working.\n\n``` java\npublic class Test {\n\n  public static void main(String[] args) {\n    Observable.range(0, 1024)\n        .buffer(20)\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .flatMap(Observable::from)\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .doOnNext(value -> System.out.println(\"value: \" + value))\n        .toBlocking().lastOrDefault(null);\n\n    System.out.println(\"Done\");\n    Hystrix.reset();\n  }\n\n  public static class EchoCommand<T> extends HystrixCommand<T> {\n\n    private final T value;\n\n    public EchoCommand(T value) {\n      super(HystrixCommandGroupKey.Factory.asKey(\"Echo\"));\n      this.value = value;\n    }\n\n    @Override\n    protected T run() throws Exception {\n      return value;\n    }\n  }\n}\n```\n", "closed": "2014-11-29 04:51:07", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1890", "ttf": 10.000277777777777, "commits": {}, "labels": ["Bug"], "title": "Backpressure issue"}, {"created": "2014-11-15 19:58:17", "user": "benjchristensen", "body": "As per discussion in https://github.com/ReactiveX/RxJava/pull/1866#issuecomment-62782835 there may be a thread-safety issue in `merge`:\n\n> I don't fully understand the OperatorMerge, but it contains a lot of mutable variables and synchronized blocks and I'm not sure but I found some anomalies in:\n> \n> https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorMerge.java#L505\n> \n> It synchronizes on the MergeProducer's this but reads the MergeSubscriber's wip field which generally is accessed through the MergeSubscriber's this. Same seems to be true for the scalarValueQueue.\n", "closed": "2015-01-21 12:24:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1885", "ttf": 66.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Possible Thread Safety Issue in Merge"}, {"created": "2014-11-15 06:36:07", "user": "benjchristensen", "body": "I think the recent additions to `scan`/`reduce` may cause issues\n\n``` java\nscan(R, Func2<R, ? super T, R>)\nscan(Func0<R>, Func2<R, ? super T, R>)\n```\n\nThe `Func0` passed in looks like it can be treated like an `Object` and considered ambiguous and match with `R` instead of `Func0`.\n\nHere is a compilation error:\n\n```\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project learnrxjava: Compilation failure: Compilation failure:\n[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,32] reference to reduce is ambiguous\n[ERROR] both method <R>reduce(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>reduce(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match\n[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,39] incompatible types: cannot infer type-variable(s) R\n[ERROR] (argument mismatch; java.lang.Object is not a functional interface)\n[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,32] reference to scan is ambiguous\n[ERROR] both method <R>scan(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>scan(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match\n[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,37] incompatible types: cannot infer type-variable(s) R\n[ERROR] (argument mismatch; java.lang.Object is not a functional interface)\n[ERROR] -> [Help 1]\n```\n\nHere is example code: https://github.com/jhusain/learnrxjava/blob/master/src/main/java/learnrxjava/examples/ScanVsReduceExample.java\n\n``` java\npackage learnrxjava.examples;\n\nimport java.util.ArrayList;\n\nimport rx.Observable;\n\npublic class ScanVsReduceExample {\n\n    public static void main(String... args) {\n        Observable.range(0, 10).reduce(() -> new ArrayList<Integer>(), (list, i) -> {\n            list.add(i);\n            return list;\n        }).forEach(System.out::println);\n\n        System.out.println(\"... vs ...\");\n\n        Observable.range(0, 10).scan(() -> new ArrayList<Integer>(), (list, i) -> {\n            list.add(i);\n            return list;\n        }).forEach(System.out::println);\n    }\n}\n```\n\nIt looks like we need to do one of 3 things:\n\n1) Remove one of several things:\n\n``` java\nscan(R, Func2<R, ? super T, R>)\nscan(Func0<R>, Func2<R, ? super T, R>)\n```\n\n2) Rename one of them\n\n3) Add an extra argument so arity solves it.\n\nI actually think the most correct thing to do is remove `scan(R, Func2<R, ? super T, R>)` since an initial value is most often intended for mutable state in `scan`/`reduce`. \n\ncc @headinthebox as this is a last minute API fix we need prior to Monday for 1.0\n", "closed": "2014-11-15 19:50:06", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1881", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Scan/Reduce Overloads & Type Erasure"}, {"created": "2014-11-14 07:34:21", "user": "benjchristensen", "body": "Something about this doesn't let the JVM exit.\n\n``` java\npackage learnrxjava.examples;\n\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.schedulers.Schedulers;\n\npublic class FlowControlWindowExample {\n\n    public static void main(String args[]) {\n        // buffer every 500ms (using 999999999 to mark start of output)\n        hotStream().window(500, TimeUnit.MILLISECONDS).take(10).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n\n        // buffer 10 items at a time (using 999999999 to mark start of output)\n        hotStream().window(10).take(2).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n\n        System.out.println(\"Done\");\n    }\n\n    /**\n     * This is an artificial source to demonstrate an infinite stream that bursts intermittently\n     */\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            while (!s.isUnsubscribed()) {\n                // burst some number of items\n                for (int i = 0; i < Math.random() * 20; i++) {\n                    s.onNext(i);\n                }\n                try {\n                    // sleep for a random amount of time\n                    // NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 1000));\n                } catch (Exception e) {\n                    // do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block\n    }\n\n}\n```\n\nYet this one does so it's not about the use of `Scheduler`s:\n\n``` java\npackage learnrxjava.examples;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.schedulers.Schedulers;\n\npublic class FlowControlThrottleExample {\n\n    public static void main(String args[]) {\n        // first item emitted in each time window\n        hotStream().throttleFirst(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);\n\n        // last item emitted in each time window\n        hotStream().throttleLast(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);\n    }\n\n    /**\n     * This is an artificial source to demonstrate an infinite stream that emits randomly\n     */\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            int i = 0;\n            while (!s.isUnsubscribed()) {\n                s.onNext(i++);\n                try {\n                    // sleep for a random amount of time\n                    // NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 100));\n                } catch (Exception e) {\n                    // do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread());\n    }\n\n}\n```\n", "closed": "2015-08-13 00:59:07", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1880", "ttf": 271.0002777777778, "commits": {}, "labels": ["Bug"], "title": "JVM Doesn't Exit On This Window Example"}, {"created": "2014-11-12 15:13:28", "user": "YannRobert", "body": "The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.\nThe observed rate will be as slow as 1 item per whatever is the second buffer timespan.\n\nPlease see the following Gist for the JUnit code demonstrating the issue.\nhttps://gist.github.com/YannRobert/32921e8e88c62c5af1f9\n", "closed": "2014-11-19 12:25:18", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1867", "ttf": 6.000277777777778, "commits": {}, "labels": ["Bug"], "title": "usage of 2 buffers with both a timespan and a count"}, {"created": "2014-11-12 12:26:45", "user": "stackfull", "body": "This little baby will grind to a halt do due never letting go of the events:\n\n``` java\nimport rx.subjects.ReplaySubject;\n\npublic class Application {\n  public static void main(String[] args) {\n    ReplaySubject<Integer> subject = ReplaySubject.createWithSize(10);\n    subject.subscribe(x -> {});\n    int ii = 0;\n    while(true) {\n      subject.onNext(ii);\n      ii++;\n    }\n  }\n}\n```\n", "closed": "2014-11-15 20:00:08", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1865", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug"], "title": "ReplaySubject memory leak"}, {"created": "2014-11-10 19:18:39", "user": "laktech", "body": "rx-java version 0.20.6\n\n```\njava.lang.NullPointerException\n        at rx.internal.util.RxRingBuffer.poll(RxRingBuffer.java:282)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainAll(OperatorMerge.java:723)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainQueue(OperatorMerge.java:744)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.access$300(OperatorMerge.java:505)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:376)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:369)\n        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:281)\n        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:247)\n        at rx.internal.util.SubscriptionIndexedRingBuffer.forEach(SubscriptionIndexedRingBuffer.java:131)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainChildrenQueues(OperatorMerge.java:331)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:308)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:96)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:674)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:528)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)\n        at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1.request(OperatorSubscribeOn.java:88)\n        at rx.Subscriber.setProducer(Subscriber.java:150)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.setProducer(OperatorSubscribeOn.java:81)\n        at rx.Subscriber.setProducer(Subscriber.java:144)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33)\n        at rx.Observable.subscribe(Observable.java:8680)\n        at ********************\n        at ********************\n        at rx.Observable.unsafeSubscribe(Observable.java:8591)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)\n        at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)\n        at java.util.concurrent.ForkJoinTask$AdaptedRunnable.exec(ForkJoinTask.java:1265)\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:334)\n        at java.util.concurrent.ForkJoinWorkerThread.execTask(ForkJoinWorkerThread.java:604)\n        at java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:784)\n        at java.util.concurrent.ForkJoinPool.work(ForkJoinPool.java:646)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:398)\n```\n", "closed": "2015-02-05 16:31:58", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1845", "ttf": 86.00027777777778, "commits": {}, "labels": ["Bug"], "title": "RxRingBuffer Concurrent Unsubscribe Non-ThreadSafe"}, {"created": "2014-11-06 00:18:19", "user": "alexwen", "body": "Although I have not been able to find a way to reproduce the issue reliably, I have seen the following stack several times now:\n\n```\n ! java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@328cda0 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@2200705d[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 3]\n ! at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_20]\n ! at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) [na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:326) ~[na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:533) ~[na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:632) ~[na:1.8.0_20]\n ! at rx.internal.schedulers.NewThreadWorker.scheduleActual(NewThreadWorker.java:66) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:149) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:139) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n```\n\nWhile auditing the CachedThreadScheduler, I noticed a potential race condition when evicting workers from the eviction queue, from CachedThreadScheduler:\n\n```\n        void evictExpiredWorkers() {\n            if (!expiringWorkerQueue.isEmpty()) {\n                long currentTimestamp = now();\n\n                Iterator<ThreadWorker> threadWorkerIterator = expiringWorkerQueue.iterator();\n                while (threadWorkerIterator.hasNext()) {\n                    ThreadWorker threadWorker = threadWorkerIterator.next();\n                    if (threadWorker.getExpirationTime() <= currentTimestamp) {\n                        threadWorkerIterator.remove();\n                        threadWorker.unsubscribe();\n                    } else {\n                        // Queue is ordered with the worker that will expire first in the beginning, so when we\n                        // find a non-expired worker we can stop evicting.\n                        break;\n                    }\n                }\n            }\n        }\n```\n\nThe evictor, uses an `iterator#remove` in order to remove the work from the queue, but it does not check that this operation actually occurred. The iterator, though thread safe, is not atomic for .next and .remove, so, the worker could be pulled from the cache by another thread between the .next and the .remove.\n\nIf this occurs then the the NewThreadWorker will be unsubscribed, its executor shutdown, and the next action that executes on that worker would cause the exception above.\n\nIn order to fix this race I believe the evictor would need to check that it removed the worker from the queue, before attempting to unsubscribe the worker.\n", "closed": "2014-11-06 07:05:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1826", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Race with CachedThreadScheduler Eviction"}, {"created": "2014-11-02 06:41:10", "user": "benjchristensen", "body": "This unit tests causes `concat` to never complete:\n\n``` java\n    @Test\n    public void testConcatWithNonCompliantSourceDoubleOnComplete() {\n        Observable<String> o = Observable.create(new OnSubscribe<String>() {\n\n            @Override\n            public void call(Subscriber<? super String> s) {\n                s.onNext(\"hello\");\n                s.onCompleted();\n                s.onCompleted();\n            }\n\n        });\n\n        TestSubscriber<String> ts = new TestSubscriber<String>();\n        Observable.concat(o, o).subscribe(ts);\n        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);\n        ts.assertTerminalEvent();\n        ts.assertNoErrors();\n        ts.assertReceivedOnNext(Arrays.asList(\"hello\", \"hello\"));\n    }\n```\n\nThis was found by @mattrjacobs \n", "closed": "2014-11-02 06:50:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1818", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Concat Breaks with Double onCompleted"}, {"created": "2014-11-02 03:57:08", "user": "benjchristensen", "body": "If an exception is thrown from a synchronous `OnSubscribe` it will skip the operators such as `onErrorResumeNext`.\n\nFor example:\n\n``` java\nObservable.create(subscriber -> {\n throw new RuntimeException(\"failed!\");\n}).onErrorResumeNext(throwable -> {\n    return Observable.just(\"fallback value\");\n}).subscribe(System.out::println, t -> System.out.println(\"ERROR: \" + t.getMessage()));\n```\n\nIn this case `onErrorResumeNext` is not called and the error passes through.\n", "closed": "2014-11-02 04:08:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1816", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Synchronous OnSubscribe Exception Skips Operators"}, {"created": "2014-10-30 17:55:57", "commits": {"c26847176479a57e221d14d7ec574e58d40d9c69": {"commitGHEventType": "referenced", "commitUser": "benjchristensen"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2014-10-31 19:28:49", "filteredCommits": [], "commitsDetails": [{"nameRev": "c26847176479a57e221d14d7ec574e58d40d9c69 tags/v1.0.0-rc.9~4", "commitMessage": "Merge pull request #1813 from zsxwing/issue1812\n\nFix issue #1812 that zip may swallow requests", "commitParents": ["002405a2fd110b23cda5b858c3a390398c65d1ae", "64bd6c1cbcefd830ad2f55491ac6a4dc257470db"], "spoonStatsSkippedReason": "", "commitHash": "c26847176479a57e221d14d7ec574e58d40d9c69", "authoredDateTime": "2014-10-31 12:28:49", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 26, "deletions": 0, "lines": 26, "filePath": "src/test/java/rx/internal/operators/OperatorZipTest.java"}, {"insertions": 3, "deletions": 1, "lines": 4, "filePath": "src/main/java/rx/internal/operators/OperatorZip.java"}], "commitDateTime": "2014-10-31 12:28:49", "commitUser": "benjchristensen", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorZipTest.testIssue1812()"}], "spoonFilePath": "OperatorZipTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 10, "MOV": 7, "INS": 2, "DEL": 1, "spoonMethodName": "rx.internal.operators.OperatorZip.Zip.tick()"}], "spoonFilePath": "OperatorZip.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/1812", "ttf": 1.0002777777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "Multiple Zipped Observers never complete", "statsSkippedReason": "", "user": "stevemenke", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "The following code never executes the onComplete if the number is greater than 1025. I think it has to due with back pressure which uses a default request of 1024. I am using Java 8 \n\n```\n    Observable merged1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),\n            (o, e) -> new int[]{o, e});\n    Observable merged2 = Observable.<int[], Integer, int[]>zip(merged1, Observable.range(0, 1026),\n            (o, e) -> new int[]{o[0], o[1], e}).serialize();\n    merged2.subscribe(\n            (o) -> System.out.println(o),\n            e -> {},\n            () -> {\n                System.out.println(\"This never prints\");\n            }\n    );\n```\n\nI am using the following version of Java.\n\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n", "labels": ["Bug"]}, {"created": "2014-10-28 14:58:17", "user": "edenman", "body": "Doesn't happen on rc7.  I can repro 100% of the time.  Happens on both KitKat and Lollipop so I don't think it's specific to any particular Android version.\n\n```\nFATAL EXCEPTION: RxCachedThreadScheduler-4\nProcess: com.mycompany.myapp.development, PID: 4413\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n        at java.lang.Thread.run(Thread.java:818)\nCaused by: rx.exceptions.OnErrorNotImplementedException: Interrupted while waiting for subscription to complete. \n        at rx.Observable$30.onError(Observable.java:7252)\n        at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)\n        at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)\n        at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:48)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n        at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitNext(SubjectSubscriptionManager.java:254)\n        at rx.subjects.BehaviorSubject.onNext(BehaviorSubject.java:166)\n        at rx.Observable$34.onNext(Observable.java:7437)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:610)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:536)\n        at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:75)\n        at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:72)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:56)\n        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:47)\n        at rx.Observable.unsafeSubscribe(Observable.java:7464)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n        ... 7 more \nCaused by: java.lang.RuntimeException: Interrupted while waiting for subscription to complete. \n        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:474)\n        at rx.observables.BlockingObservable.single(BlockingObservable.java:348)\n        at com.mycompany.myapp.data.CachedThing.buildCachedThing(CachedThing.java:66)\n        at com.mycompany.myapp.data.CachedThing.<init>(CachedThing.java:28)\n        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:189)\n        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:175)\n        at com.mycompany.myapp.data.CachedThing.merge(CachedThing.java:60)\n        at com.mycompany.myapp.data.ResponseCache.update(ResponseCache.java:80)\n        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:105)\n        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:99)\n        at com.mycompany.servercall.CallState$3.map(CallState.java:79)\n        at com.mycompany.servercall.CallState$9.call(CallState.java:195)\n        at com.mycompany.servercall.CallState$9.call(CallState.java:193)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n        ... 22 more\nCaused by: java.lang.InterruptedException\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1279)\n        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)\n        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:471)\n        ... 35 more\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: .class \n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        ... 22 more\n```\n\n`CachedThing.buildCachedThing` has this block of code that I think is the culprit:\n\n```\nList<SubThing> subThings = Observable.from(things) //\n        .map(transformFunction) //\n        .filter(not(isNullFunction)) //\n        .distinct() //\n        .toList() //\n        .toBlocking() //\n        .single();\n```\n\nI tried writing a testcase to repro but couldn't get it to fail.  I'm guessing there's something broken between the android runtime and rxjava's thread management, but I couldn't get any further than that.\n", "closed": "2014-11-08 22:29:14", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1804", "ttf": 11.000277777777777, "commits": {}, "labels": ["Bug"], "title": "\"Interrupted while waiting for subscription to complete.\" in 1.0.0-rc8"}, {"created": "2014-10-23 18:28:16", "user": "alexwen", "body": "Noticed this behavior using rx-netty as internally it does a take(1) internally:\n\n```\n    AtomicLong inc = new AtomicLong(0);\n    Observable.OnSubscribe<Long> onSubscribe = subscriber -> {\n        final long emit = inc.getAndIncrement();\n        LOGGER.info(\"Emitting: {}\", emit);\n        subscriber.onNext(emit);\n        subscriber.onCompleted();\n    };\n\n    LOGGER.info(\"DONE: {}\", Observable.create(onSubscribe)\n                    .retryWhen(attempt -> attempt.zipWith(Observable.range(1, 4), (n, i) -> i))\n                    .toBlocking()\n                    .first()\n    );\n```\n\nThe test output is:\n    Emitting: 0\n    Emitting: 1\n    DONE: 0\n\nAs you can see the observable is subscribed to twice. This is because take, in combination with single, causes the retryWhen producer to request another item.\n", "closed": "2014-10-23 21:48:27", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1791", "ttf": 0.0002777777777777778, "commits": {}, "labels": ["Bug"], "title": "Observable#first causes retryWhen to trigger retry without an exception"}, {"created": "2014-10-15 07:39:47", "user": "akarnokd", "body": "While cleaning up, I found a bug caused by too eager delegation:\n\n```\n    public synchronized Object clone() {\n        return list.clone();\n    }\n```\n\nAdding a copy constructor and using that in clone should solve the problem. I'd do it but would conflict with the cleanup changes in the class.\n", "closed": "2015-01-21 12:20:30", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1756", "ttf": 98.00027777777778, "commits": {}, "labels": ["Bug"], "title": "SynchronizedQueue.clone may cause ClassCastException"}, {"created": "2014-10-05 19:52:45", "user": "dmgd", "body": "e.g. \nrange(1, 10).delay(1, SECONDS).subscribe(System.out::println) will result in two numbers being output each second for five seconds, rather than all ten after one second\n\nsample unit test below. more tests and one way of fixing it (just using merge instead of concat) @ https://github.com/dmgd/RxJava/commit/29f0b80ef1f8ffdcddcf14c1a97d0e6d221fb7fd\n\n```\n@Test\npublic void testDelayEmitsEverything() {\n    Observable<Integer> source = Observable.range(1, 5);\n    Observable<Integer> delayed = source.delay(500L, TimeUnit.MILLISECONDS, scheduler);\n    TestObserver<Integer> observer = new TestObserver<Integer>();\n    delayed.subscribe(observer);\n    scheduler.advanceTimeBy(500L, TimeUnit.MILLISECONDS);\n    observer.assertReceivedOnNext(asList(1, 2, 3, 4, 5));\n}\n```\n", "closed": "2014-10-10 03:18:16", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1724", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "delay on a range emits two at a time rather than everything at once"}, {"created": "2014-10-03 12:56:23", "user": "flatmap13", "body": "The following program stops printing numbers around 511 where the expected behaviour is that it runs forever.\n\n``` scala\n\nimport java.util.concurrent.TimeUnit\n\nimport rx.lang.scala.Observable\nimport rx.lang.scala.schedulers.NewThreadScheduler\n\nimport scala.concurrent.duration.Duration\n\nobject CombineLatestTest {\n  def main(args: Array[String]) {\n\n    var left = Observable.timer(Duration(0, TimeUnit.MILLISECONDS), Duration(1, TimeUnit.MILLISECONDS))\n\n    left.observeOn(NewThreadScheduler()).doOnEach(println(_)).combineLatest(Observable.never).subscribe()\n\n    readLine()\n  }\n}\n\n```\n\nWithout the `observeOn` it works as expected.\n", "closed": "2014-10-07 16:20:24", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1717", "ttf": 4.000277777777778, "commits": {}, "labels": ["Bug"], "title": "combineLatest back-pressure bug"}, {"created": "2014-09-26 03:58:31", "commits": {"4fbf11a07759291862ed5bd5919b9fbf40f7d0a2": {"commitGHEventType": "referenced", "commitUser": "akarnokd"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2014-10-10 03:20:58", "filteredCommits": [], "commitsDetails": [{"nameRev": "4fbf11a07759291862ed5bd5919b9fbf40f7d0a2 tags/v1.0.5~35", "commitMessage": "Merge pull request #2471 from jnlopar/fix1702\n\nFixes NPEs reported in ReactiveX#1702 by synchronizing queue.", "commitParents": ["cf5ae70287105d0dc8b9ee1c590cd953b7880298", "63da8b19da954bc8262087cf5607276a5afcde28"], "spoonStatsSkippedReason": "", "commitHash": "4fbf11a07759291862ed5bd5919b9fbf40f7d0a2", "authoredDateTime": "2015-01-23 18:43:38", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 12, "deletions": 17, "lines": 29, "filePath": "src/main/java/rx/schedulers/TrampolineScheduler.java"}, {"insertions": 45, "deletions": 0, "lines": 45, "filePath": "src/test/java/rx/schedulers/TrampolineSchedulerTest.java"}], "commitDateTime": "2015-01-23 18:43:38", "commitUser": "akarnokd", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineSchedulerTest.testTrampolineWorkerHandlesConcurrentScheduling()"}], "spoonFilePath": "TrampolineSchedulerTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 3, "MOV": 1, "INS": 1, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.enqueue(rx.functions.Action0,long)"}, {"UPD": 1, "TOT": 3, "MOV": 2, "INS": 0, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.schedule(rx.functions.Action0)"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.schedule(rx.functions.Action0,long,java.util.concurrent.TimeUnit)"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.isUnsubscribed()"}, {"UPD": 2, "TOT": 10, "MOV": 4, "INS": 3, "DEL": 1, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler"}, {"UPD": 0, "TOT": 5, "MOV": 2, "INS": 1, "DEL": 2, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.enqueue(rx.functions.Action0,long).1.call()"}, {"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.schedulers.TrampolineScheduler.InnerCurrentThreadScheduler.unsubscribe()"}], "spoonFilePath": "TrampolineScheduler.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/1702", "ttf": 13.000277777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "TrampolineScheduler NullPointerException", "statsSkippedReason": "", "user": "DylanSale", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "There is an issue in TrampolineScheduler on 0.20.4 where it can  throw a NullPointerException in InnerCurrentThreadScheduler `enqueue(Action0 action, long execTime)`\n\n``` java\n        private Subscription enqueue(Action0 action, long execTime) {\n            if (innerSubscription.isUnsubscribed()) {\n                return Subscriptions.empty();\n            }\n            PriorityQueue<TimedAction> queue = QUEUE.get();\n            final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n            queue.add(timedAction);\n\n            if (wip.getAndIncrement() == 0) {\n                do {\n                    queue.poll().action.call();\n                } while (wip.decrementAndGet() > 0);\n                return Subscriptions.empty();\n            } else {\n                // queue wasn't empty, a parent is already processing so we just add to the end of the queue\n                return Subscriptions.create(new Action0() {\n\n                    @Override\n                    public void call() {\n                        PriorityQueue<TimedAction> _q = QUEUE.get();\n                        if (_q != null) {\n                            _q.remove(timedAction);\n                        }\n                    }\n\n                });\n            }\n        }\n```\n\nThe Exception happens on `queue.poll().action.call();`.\nFrom what I can tell, the queue is empty, and poll is returning null.\n\nThis is happening inside a nested `observable.redo().timeout().redo()` chain (the `redo().timeout()` happens earlier in the application, it isn't just one after the other like that), if that helps. I'm not in a position to create a simple replication example however.\n\nMy current theory is: One of the redos could be unsubscribing, calling `_q.remove`, while the `wip` loop is running (perhaps unsubscribe is happening on another thread?), causing the queue to become empty, and the next loop of the `wip` loop returns `null`. I think the `queue.poll()` call should check for null. \n", "labels": ["Bug"]}, {"created": "2014-09-23 17:16:21", "user": "benjchristensen", "body": "There is a hang we found when upgrading from 0.19 to 0.20. It is very non-obvious as we passed all our normal production tests for 24+ hours but found this in the TEST environment with a certain use case.\n\nWe have not yet identified the cause but this has held up adoption of 0.20 in the Netflix API. This in turn holds up 1.0 from being considered production worthy.\n\n/cc @mattrjacobs and @abersnaze \n", "closed": "2014-10-07 18:33:59", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1699", "ttf": 14.000277777777777, "commits": {}, "labels": ["Bug"], "title": "Unknown Hang in Netflix API with 0.20.x"}, {"created": "2014-09-16 18:21:04", "user": "MikolajKakol", "body": "I have failing test:\nfinal AtomicInteger count = new AtomicInteger(3);\n\n```\n    Observable.range(0, count.get())\n            .map(THROW_ON_ODD)\n            .map(i -> i) // #1\n            .flatMap(Observable::just) // #2\n            //.doOnNext(System.out::println) // #3\n            .doOnEach(System.out::println) // #4\n            .lift(OPTION_WRAP())\n            .subscribe(\n                    op -> {\n                        System.out.println(op.toString());\n                        count.decrementAndGet();\n                    },\n                    e -> System.out.println(\"It never will be printed\" + e.getClass().getSimpleName()),\n                    () -> System.out.println(\"end\")\n            );\n\n    assertEquals(0, count.get());\n```\n\nAll the magic is in `lift` in which I wanted to have error wrapping using something similar to com.google.common.base.Optional<T>. So when `onError` is emitted I wrap it to `error result` and when `onNext` is emmited I wrap it `valid result`. Whole test source is here: https://gist.github.com/novemberox/e2b1b4e289ac45162847\n\nProblem is with line marked as #3 and #4, if any of those is not commented test fails. Order of lines #1-4 doesn't matter, result is always the same. Since `doOnXXX` is side effect that shouldn't affect core observable I think is a bug.\n\n---\n\nYou might ask me while I'm trying to treat error as valid data. Common thing is to have some action triggered from UI that would trigger some IO action and display result back to the UI. \n\nI wanted have my UI to be expresed more as FRP so when UI is created I want to have few Subjects that would emit data events like text change or button clicked this way I can do all my business logic it that very moment. \n\nHowever that is not working at all with Rx paradigm that after `onError` nothing should be emitted. This paradigm doesn't work well with UI, because I want to be able do IO at every button click event if it fails, my UI can handle both error and result nicely.\n", "closed": "2014-10-08 13:20:50", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1689", "ttf": 21.00027777777778, "commits": {}, "labels": ["Bug"], "title": "OperatorDoOnEach breakes latter subscribtions after error wrapping lift"}, {"created": "2014-09-16 03:34:32", "user": "davidmoten", "body": "Given `o.publish().refCount()` on an infinite synchronous source `o`, [line 93](https://github.com/ReactiveX/RxJava/blob/0.20.x/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRefCount.java#L93) in `OnSubscribeRefCount` never completes thus `emitting` is never false and disconnect cannot happen.\n\nHere's a unit test failing on 0.20.4:\n\n``` java\npackage au.gov.amsa.ais.rx;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.Test;\n\nimport rx.Observable;\nimport rx.Observable.OnSubscribe;\nimport rx.Observable.Operator;\nimport rx.Subscriber;\nimport rx.observers.Subscribers;\nimport rx.schedulers.Schedulers;\n\npublic class RefCountTest {\n\n    @Test(timeout=3000)\n    public void testRefCountUnsubscribeForSynchronousSource() throws InterruptedException {\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable<Long> o = synchronousInterval().lift(detectUnsubscription(latch));\n        Subscriber<Long> sub = Subscribers.empty();\n        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(sub);\n        sub.unsubscribe();\n        assertTrue(latch.await(3, TimeUnit.SECONDS));\n    }\n\n    private Operator<Long, Long> detectUnsubscription(final CountDownLatch latch) {\n        return new Operator<Long,Long>(){\n            @Override\n            public Subscriber<? super Long> call(Subscriber<? super Long> subscriber) {\n                latch.countDown();\n                return Subscribers.from(subscriber);\n            }};\n    }\n\n    private Observable<Long> synchronousInterval() {\n        return Observable.create(new OnSubscribe<Long>() {\n\n            @Override\n            public void call(Subscriber<? super Long> subscriber) {\n                while (!subscriber.isUnsubscribed()) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                    }\n                    subscriber.onNext(1L);\n                }\n            }});\n    }\n}\n\n```\n", "closed": "2014-10-14 16:56:00", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1688", "ttf": 28.00027777777778, "commits": {}, "labels": ["Bug"], "title": "RefCount unsubscribe never happens for infinite synchronous source"}, {"created": "2014-09-12 03:46:40", "user": "vadims", "body": "", "closed": "2014-10-10 04:29:43", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1685", "ttf": 28.00027777777778, "commits": {}, "labels": ["Bug"], "title": "OnErrorNotImplementedException disrupts Subject event delivery "}, {"created": "2014-09-11 04:48:09", "user": "benjchristensen", "body": "ScheduledAction (used by `observeOn` and other things doing scheduling) swallows errors because `FutureTask.run()` swallows errors inside a `Future`.\n\nThis means something like `OnErrorNotImplemented` on the `Subscriber` side of an `observeOn` will throw and be swallowed and everything will fail silently.\n\nThe following code fails silently:\n\n``` java\nObservable.error(new RuntimeException()).observeOn(Schedulers.computation()).subscribe();\n```\n", "closed": "2014-10-16 16:20:34", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1682", "ttf": 35.000277777777775, "commits": {}, "labels": ["Bug"], "title": "ScheduledAction Swallows Errors"}, {"created": "2014-09-08 23:05:11", "user": "spodila", "body": "This test case brings out two problems, seemingly due to concurrency bugs. They don't happen every time, but do happen if you repeat running it a handful of times. \n1. The Observable sequence hangs and eventually times out. Assert fail gets called for innerLatch.\n2. We get one more onNext() than expected. The last line assertEquals() fails with expected=250 and actual=251.\n\nProblem 1 happens easily if you repeat the test, say, 10 times. Problem 2 is rare. Although, I am not completely sure if my expectation for problem 2 is correct. \n\n``` java\n@Test\n    public void testParallelBatch() throws Exception {\n        final AtomicLong counter = new AtomicLong();\n        final Integer[] numbers = new Integer[5000];\n        for(int i=0; i<numbers.length; i++)\n            numbers[i] = i+1;\n        final int NITERS=250;\n        final CountDownLatch latch = new CountDownLatch(NITERS);\n        for(int iters=0; iters<NITERS; iters++) {\n            final CountDownLatch innerLatch = new CountDownLatch(1);\n            final PublishSubject s = PublishSubject.create();\n            Observable.from(numbers)\n                    .takeUntil(s)\n                    .window(50)\n                    .flatMap(new Func1<Observable<Integer>, Observable<Integer>>() {\n                        @Override\n                        public Observable<Integer> call(Observable<Integer> integerObservable) {\n                            return integerObservable\n                                    .subscribeOn(Schedulers.computation())\n                                    .map(new Func1<Integer, Integer>() {\n                                        @Override\n                                        public Integer call(Integer integer) {\n                                            if (integer >= 5) {\n                                                s.onCompleted();\n                                            }\n                                            // do some work\n                                            Math.pow(Math.random(), Math.random());\n                                            return integer * 2;\n                                        }\n                                    });\n                        }\n                    })\n                    .toList()\n                    .doOnNext(new Action1<List<Integer>>() {\n                        @Override\n                        public void call(List<Integer> integers) {\n                            counter.incrementAndGet();\n                            latch.countDown();\n                            innerLatch.countDown();\n                        }\n                    })\n                    .subscribe();\n            if(!innerLatch.await(10, TimeUnit.SECONDS))\n                Assert.fail(\"Failed inner latch wait, iteration \" + iters);\n        }\n        if(!latch.await(15, TimeUnit.SECONDS))\n            Assert.fail(\"Incomplete! Went through \" + latch.getCount() + \" iterations\");\n        else\n            Assert.assertEquals(NITERS, counter.get());\n    }\n```\n", "closed": "2014-10-10 04:38:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1677", "ttf": 31.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Occasionally hanging sequence of takeUntil()+window()+flatMap()"}, {"created": "2014-09-08 17:47:14", "user": "benjchristensen", "body": "A report from RxJava 0.19.x:\n\n```\nCaused by: java.lang.NullPointerException\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:39)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:29)\n        at rx.Observable$2.call(Observable.java:159)\n```\n", "closed": "2014-10-10 04:57:30", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1676", "ttf": 31.00027777777778, "commits": {}, "labels": ["Bug"], "title": "NPE in OnSubscribeFromIterable"}, {"created": "2014-09-04 05:27:51", "user": "benjchristensen", "body": "The generics still don't work on `compose`.\n\n``` java\n    public Observable<EurekaInstance> getInstanceEvents(String appName) {\n        return Observable.\n                create((Subscriber<? super EurekaInstance> subscriber) -> {\n                    try {\n                        logger.info(\"Fetching instance list for app: \" + appName);\n                        Application app = DiscoveryManager.getInstance().getDiscoveryClient().getApplication(appName);\n                        if (app == null) {\n                            subscriber.onError(new RuntimeException(\"App not found: \" + appName));\n                            return;\n                        }\n                        System.out.println(\"App: \" + app);\n                        List<InstanceInfo> instancesForApp = app.getInstances();\n                        if (instancesForApp != null) {\n                            logger.info(\"Received instance list for app: \" + appName + \" = \" + instancesForApp.size());\n                            for (InstanceInfo instance : instancesForApp) {\n                                subscriber.onNext(EurekaInstance.create(instance));\n                            }\n                            subscriber.onCompleted();\n                        } else {\n                            subscriber.onError(new RuntimeException(\"Failed to retrieve instances for appName: \" + appName));\n                        }\n                    } catch (Throwable e) {\n                        subscriber.onError(e);\n                    }\n                })\n                .subscribeOn(Schedulers.io())\n                .compose(o -> o.map(t -> t)) // this won't let me do anything\n                .repeatWhen(a -> a.flatMap(n -> Observable.timer(30, TimeUnit.SECONDS))); // repeat after 30 second delay\n    }\n```\n", "closed": "2014-10-18 22:40:15", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1663", "ttf": 44.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Observable.compose Generics"}, {"created": "2014-08-14 20:56:37", "user": "dvtomas", "body": "Hi all,\nthis one (and probably some other similar bugs) has been biting me badly last couple of weeks.\n\nRxScala 0.20.0-RC5. Let's have\n\n``` scala\nimport rx.lang.scala.Observable\nimport scala.concurrent.duration._\ndef fail(o: Observable[Long]) = o.map(x \u21d2 if (x > 1) throw new RuntimeException(\"Bang!\"))\n```\n\nthen\n\n``` scala\nfail(Observable.items(1, 2, 3)).subscribe(println(_))\n```\n\nthrows a RuntimeException as expected, but\n\n``` scala\nfail(Observable.interval(100.milli)).subscribe(println(_))\nThread.sleep(1000)\n```\n\ndoes not. I'd expect it to throw an exception as well, albeit probably in a different thread.\n\nThank you, best regards, \n    Tom\u00e1\u0161 Dvo\u0159\u00e1k\n", "closed": "2014-10-13 16:40:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1585", "ttf": 59.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Exception not thrown from interval with blank onError"}, {"created": "2014-08-12 13:30:12", "user": "mttkay", "body": "I noticed that TestObserver was changed to always delegate calls, by default to the `EMPTY` Observer.\n\nHowever, the EMPTY Observer does not define `onError`, so any attempt to use TestObserver with an observable that's supposed to fail in a unit test crashes the test with a `OnErrorNotImplementedException`\n\nI wonder why this change was done? It adds complexity and surprise to something that should be void of behavior (mocks should record things, not perform logic IMHO)\n", "closed": "2014-10-10 03:44:23", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1571", "ttf": 58.000277777777775, "commits": {}, "labels": ["Bug"], "title": "TestObserver always delegates to EMPTY, throws exception"}, {"created": "2014-08-12 03:27:25", "user": "benjchristensen", "body": "This code throws `MissingBackpressureException`:\n\n``` java\n        Observable<Integer> o1 = Observable.from(1, 1).concatWith(Observable.just(-1).repeat());\n        Observable<Integer> o2 = Observable.from(2, 2, 2, 2);\n        Observable.zip(o1, o2, (a, b) -> a + b).forEach(System.out::println);\n```\n\nIt should emit `3, 3, 1, 1` and end correctly.\n", "closed": "2014-08-14 19:57:30", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1566", "ttf": 2.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Repeat/Concat/Zip Backpressure"}, {"created": "2014-08-04 15:36:50", "user": "benjchristensen", "body": "The following example should always have 10 items, including in the last window, but it non-deterministically has less, as if the unsubscribe from `take` is happening immediately and not letting it finish. \n\n``` java\npublic class WindowExample {\n\n    public static void main(String args[]) {\n        // buffer 10 items at a time (using 999999999 to mark start of output)\n        hotStream().window(10).take(10).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n    }\n\n    /**\n     * This is an artificial source to demonstrate an infinite stream that bursts intermittently\n     */\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            while (!s.isUnsubscribed()) {\n                // burst some number of items\n                for (int i = 0; i < Math.random() * 20; i++) {\n                    s.onNext(i);\n                }\n                try {\n                    // sleep for a random amount of time\n                    // NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 1000));\n                } catch (Exception e) {\n                    // do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block\n    }\n\n}\n```\n", "closed": "2014-11-06 06:07:05", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1546", "ttf": 93.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Window Unsubscribes Early?"}, {"created": "2014-07-30 17:29:00", "user": "benjchristensen", "body": "Three builds have hung around the same place, near here:\n- rx.exceptions.ExceptionsTest > testStackOverflowIsThrown STANDARD_OUT\n- rx.exceptions.ExceptionsTest STANDARD_OUT\n\nThe logs can be seen at:\n- https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/1456/console\n- https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/1432/console\n- https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/1461/console\n\nI have tried to replicate in the `ExceptionsTest` code but have not succeeded.\n", "closed": "2015-09-03 08:23:37", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1536", "ttf": 399.0002777777778, "commits": {}, "labels": ["Bug", "Test-Failures"], "title": "Non-deterministic Hang - ExceptionsTest?"}, {"created": "2014-07-28 12:26:20", "user": "nitsanw", "body": "https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java#L124\n", "closed": "2014-10-07 23:04:18", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1525", "ttf": 71.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Bug in Mpsc queue, should compare head to tail, not itself in peekNode"}, {"created": "2014-07-26 08:19:21", "commits": {"400a611e5665b44884493ef1013fca441aa10d06": {"commitGHEventType": "referenced", "commitUser": "benjchristensen"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2014-08-08 19:44:27", "filteredCommits": [], "commitsDetails": [{"nameRev": "400a611e5665b44884493ef1013fca441aa10d06 tags/0.20.0-RC4~5", "commitMessage": "Merge pull request #1523 from zsxwing/issue-1522\n\nFix issue #1522", "commitParents": ["efb7f796fdca0682a722dc880eaa114d5376e77b", "c1ec1f4a4ee2dad56ecd0fee959e54d72c5c9734"], "spoonStatsSkippedReason": "", "commitHash": "400a611e5665b44884493ef1013fca441aa10d06", "authoredDateTime": "2014-07-29 09:27:26", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 32, "deletions": 15, "lines": 47, "filePath": "rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java"}, {"insertions": 3, "deletions": 0, "lines": 3, "filePath": "rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java"}, {"insertions": 52, "deletions": 3, "lines": 55, "filePath": "rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java"}, {"insertions": 116, "deletions": 0, "lines": 116, "filePath": "rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTest.java"}], "commitDateTime": "2014-07-29 09:27:26", "commitUser": "benjchristensen", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingle.call(rx.Subscriber).1.onNext(java.lang.Object)"}], "spoonFilePath": "OperatorSingle.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 6, "MOV": 1, "INS": 3, "DEL": 2, "spoonMethodName": "rx.internal.operators.OperatorTakeLast.QueueProducer.request(long)"}, {"UPD": 1, "TOT": 12, "MOV": 7, "INS": 3, "DEL": 1, "spoonMethodName": "rx.internal.operators.OperatorTakeLast.QueueProducer.emit(long)"}], "spoonFilePath": "OperatorTakeLast.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingleTest.testIssue1527()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorSingleTest.testSingleWithBackpressure()"}], "spoonFilePath": "OperatorSingleTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorTakeLastTest.testIgnoreRequest2()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorTakeLastTest.testIgnoreRequest3()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorTakeLastTest.testIgnoreRequest4()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorTakeLastTest.testIgnoreRequest1()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.internal.operators.OperatorTakeLastTest.testIssue1522()"}], "spoonFilePath": "OperatorTakeLastTest.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/1522", "ttf": 13.000277777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "OperatorFilter failure", "statsSkippedReason": "", "user": "davidmoten", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "This test hangs with 0.20.0-RC3 I'm supposing because of `OperatorFilter`:\n\n``` java\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport rx.Observable;\nimport rx.functions.Functions;\n\npublic class BackpressureTest {\n\n    @Test\n    public void testDoesNotHang() {\n\n        Assert.assertEquals(0, Observable\n                .empty()\n                .count()\n                .filter(Functions.alwaysFalse())\n                .toList()\n                .toBlocking().single().size());\n    }\n\n}\n\n```\n", "labels": ["Bug"]}, {"created": "2014-07-23 05:03:25", "user": "benjchristensen", "body": "The parallel operator needs to be updated to properly support backpressure.\n", "closed": "2014-08-12 19:36:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1485", "ttf": 20.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Backpressure: parallel"}, {"created": "2014-07-16 15:50:16", "user": "atychyna", "body": "See code snippet bellow. Basically in `BlockingOperatorToIterator.toIterator()` method \"lifted\" subscriber ignores exception in `onError(..)` method what makes iterator's `hasNext(..)` method to wait forever for a notification that never arrives.\n\n``` java\nIterable<String> strings = Observable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        throw new RuntimeException(\"intentional\");\n    }\n}).toBlocking().toIterable();\nfor (String string : strings) {\n    // never reaches here\n}\n```\n", "closed": "2014-07-25 21:10:22", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1450", "ttf": 9.000277777777777, "commits": {}, "labels": ["Bug"], "title": "BlockingOperatorToIterator hanging when exception is thrown from OnSubscribe.call(..)"}, {"created": "2014-07-11 12:17:59", "user": "tomrozb", "body": "Just reporting. HEAD fc86f8c3\n\n Class `rx.internal.util.RxRingBufferWithoutUnsafeTest`\n`testConcurrency`\n\n```\njava.lang.AssertionError: expected:<94390> but was:<94389>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.internal.util.RxRingBufferWithoutUnsafeTest.testConcurrency(RxRingBufferWithoutUnsafeTest.java:166)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:62)\n```\n\n Class `rx.internal.util.RxRingBufferSpmcTest`\n`testConcurrency`\n\n```\njava.lang.AssertionError: expected:<0> but was:<530>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.internal.util.RxRingBufferSpmcTest.testConcurrency(RxRingBufferSpmcTest.java:164)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:62)\n```\n", "closed": "2014-07-25 20:39:51", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1429", "ttf": 14.000277777777777, "commits": {}, "labels": ["Bug"], "title": "RxRingBuffer test fails"}, {"created": "2014-06-17 19:43:16", "user": "tindzk", "body": "Reading the deprecation notice a developer may assume that `Observable.apply` and `Observable.create` may be equivalent. However, when changing the following example to `Observable[Unit] {...}`, the unsubscription code does not get called anymore.\n\n``` scala\ndef collision = Observable.create[Unit] { obs =>\n  val sub: Subscription = accelerometerObservable.filter(_.x < -2).subscribe(_ => {\n    obs.onNext()\n  })\n\n  Subscription {\n    sub.unsubscribe\n  }\n}\n```\n\nInstead, the developer would have to write:\n\n``` scala\ndef collision = Observable[Unit] { obs =>\n  val sub: Subscription = accelerometerObservable.filter(_.x < -2).subscribe(_ => {\n    obs.onNext()\n  })\n\n  obs.add(Subscription {\n    sub.unsubscribe\n  })\n}\n```\n\nUnfortunately, we figured out this solution only after reading the sources. The documentation should mention this way of running arbitrary code upon unsubscription.\n", "closed": "2014-07-25 20:44:12", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1370", "ttf": 38.000277777777775, "commits": {}, "labels": ["Bug"], "title": "rx.lang.scala.Observable: Misleading deprecation notice."}, {"created": "2014-06-14 16:58:17", "user": "niqo01", "body": "One of my production user got the following `NullPointerException`:\nEnvironment:\n- rxjava-android: 0.19.0\n- Android: 4.4.2\n- Device: GT-I9505\n\n```\njava.lang.NullPointerException\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:135)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:61)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$1.call(OperatorObserveOn.java:121)\n       at rx.android.schedulers.HandlerThreadScheduler$InnerHandlerThreadScheduler$1.run(HandlerThreadScheduler.java:77)\n       at android.os.Handler.handleCallback(Handler.java:733)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:157)\n       at android.app.ActivityThread.main(ActivityThread.java:5356)\n       at java.lang.reflect.Method.invokeNative(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:515)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1265)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1081)\n       at dalvik.system.NativeStart.main(NativeStart.java)\n```\n", "closed": "2014-08-08 20:50:29", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1360", "ttf": 55.000277777777775, "commits": {}, "labels": ["Bug"], "title": "NPE in OperatorObserveOn RxJava 0.19"}, {"created": "2014-06-10 11:57:00", "user": "lJoublanc", "body": "I'm on 0.16. The following code will throw an IllegalArgumentException:\n\n```\nscala> val obs = Observable.interval(100 milliseconds).buffer(3 seconds, 500 milliseconds)\nobs: rx.lang.scala.Observable[Seq[Long]] = rx.lang.scala.JavaConversions$$anon$1@6f6b1731\n\nscala> obs.subscribe{x =>println(x)}\nrx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$25.onError(Observable.java:6805)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:124)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:93)\n    at rx.Observable$2.call(Observable.java:280)\n    at rx.Observable$2.call(Observable.java:268)\n    at rx.Observable.subscribe(Observable.java:7076)\n    at rx.Observable.protectivelyWrapAndSubscribe(Observable.java:5396)\n    at rx.Observable.subscribe(Observable.java:6796)\n    at rx.lang.scala.Observable$class.subscribe(Observable.scala:132)\n    at rx.lang.scala.JavaConversions$$anon$1.subscribe(JavaConversions.scala:53)\n    at .<init>(<console>:14)\n    at .<clinit>(<console>)\n    at .<init>(<console>:7)\n    at .<clinit>(<console>)\n    at $print(<console>)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.call(IMain.scala:734)\n    at scala.tools.nsc.interpreter.IMain$Request.loadAndRun(IMain.scala:983)\n    at scala.tools.nsc.interpreter.IMain.loadAndRunReq$1(IMain.scala:573)\n    at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:604)\n    at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:568)\n    at scala.tools.nsc.interpreter.ILoop.reallyInterpret$1(ILoop.scala:756)\n    at scala.tools.nsc.interpreter.ILoop.interpretStartingWith(ILoop.scala:801)\n    at scala.tools.nsc.interpreter.ILoop.command(ILoop.scala:713)\n    at scala.tools.nsc.interpreter.ILoop.processLine$1(ILoop.scala:577)\n    at scala.tools.nsc.interpreter.ILoop.innerLoop$1(ILoop.scala:584)\n    at scala.tools.nsc.interpreter.ILoop.loop(ILoop.scala:587)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply$mcZ$sp(ILoop.scala:878)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:833)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:833)\n    at scala.tools.nsc.util.ScalaClassLoader$.savingContextLoader(ScalaClassLoader.scala:135)\n    at scala.tools.nsc.interpreter.ILoop.process(ILoop.scala:833)\n    at scala.tools.nsc.MainGenericRunner.runTarget$1(MainGenericRunner.scala:83)\n    at scala.tools.nsc.MainGenericRunner.process(MainGenericRunner.scala:96)\n    at scala.tools.nsc.MainGenericRunner$.main(MainGenericRunner.scala:105)\n    at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)\nCaused by: java.lang.IllegalArgumentException\n    at java.util.concurrent.ScheduledThreadPoolExecutor.scheduleAtFixedRate(ScheduledThreadPoolExecutor.java:562)\n    at rx.schedulers.ExecutorScheduler.schedulePeriodically(ExecutorScheduler.java:75)\n    at rx.operators.ChunkedOperation$TimeBasedChunkCreator.<init>(ChunkedOperation.java:579)\n    at rx.operators.OperationBuffer$7.onSubscribe(OperationBuffer.java:360)\n    at rx.Observable$1.call(Observable.java:235)\n    at rx.Observable$1.call(Observable.java:231)\n    at rx.Observable$2.call(Observable.java:272)\n    ... 35 more\n```\n\nLooking at the implementation of the scheduler, the error is raised when the argument is less than zero. So there appears to be a problem causing the `timeshift` to be rounded down. If you change the `timeshift` to 1 second or larger, it works fine.\n", "closed": "2014-09-23 21:56:41", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1349", "ttf": 105.00027777777778, "commits": {}, "labels": ["Bug"], "title": "RxScala: buffer(timespan,timeshift) raises IllegalArgumentException for timeshift < 1 second"}, {"created": "2014-06-09 14:11:59", "user": "headinthebox", "body": "It seems we cannot swap and curry the arguments of \n\n```\ndef publish[U >: T, R](selector: Observable[U] => Observable[R], initialValue: U): Observable[R] \n```\n\nsince that causes ambiguity with \n\n```\ndef publish[U >: T](initialValue: U): ConnectableObservable[U]\n```\n\nInterestingly .NET does not have `publish` with a function and initial value.\n", "closed": "2014-09-23 21:57:33", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1341", "ttf": 106.00027777777778, "commits": {}, "labels": ["Bug"], "title": "RxScala: Publish"}, {"created": "2014-06-04 16:44:26", "commits": {"bf29c611065894e9d383c739b93dcc48bb3bf9cb": {"commitGHEventType": "referenced", "commitUser": "DavidMGross"}, "b504e6c518e7de1b20842659b4dc12c345facd5b": {"commitGHEventType": "referenced", "commitUser": "DavidMGross"}, "e808394fd70958960228925d4d9c8eeb63c1cd50": {"commitGHEventType": "referenced", "commitUser": "DavidMGross"}, "a2701658d5f9a78eb53af594a1b509f49ca018ae": {"commitGHEventType": "closed", "commitUser": "DavidMGross"}, "2d7b9660ef2825c25f2f3fbeda9acb96c3712575": {"commitGHEventType": "referenced", "commitUser": "DavidMGross"}}, "numCommits": 3, "closed": "2014-07-24 16:55:52", "filteredCommits": ["2d7b9660ef2825c25f2f3fbeda9acb96c3712575", "e808394fd70958960228925d4d9c8eeb63c1cd50", "bf29c611065894e9d383c739b93dcc48bb3bf9cb", "b504e6c518e7de1b20842659b4dc12c345facd5b", "a2701658d5f9a78eb53af594a1b509f49ca018ae"], "commitsDetails": [{"nameRev": "bf29c611065894e9d383c739b93dcc48bb3bf9cb tags/0.19.2~9", "commitMessage": "Adding missing javadocs to TestSubscriber (#1322)\n", "commitParents": ["f4b9b5a5eaea33dc29f925848d49817dda3a5614"], "spoonStatsSkippedReason": "", "commitHash": "bf29c611065894e9d383c739b93dcc48bb3bf9cb", "authoredDateTime": "2014-06-24 09:27:46", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 37, "deletions": 12, "lines": 49, "filePath": "rxjava-core/src/main/java/rx/observers/TestSubscriber.java"}], "commitDateTime": "2014-06-24 09:27:46", "commitUser": "DavidMGross", "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "TestSubscriber.java"}]}, {"nameRev": "b504e6c518e7de1b20842659b4dc12c345facd5b tags/0.19.2~19", "commitMessage": "More work on #1322 (missing javadocs)\n", "commitParents": ["a2701658d5f9a78eb53af594a1b509f49ca018ae"], "spoonStatsSkippedReason": "", "commitHash": "b504e6c518e7de1b20842659b4dc12c345facd5b", "authoredDateTime": "2014-06-23 09:48:32", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 8, "deletions": 5, "lines": 13, "filePath": "rxjava-core/src/main/java/rx/Subscriber.java"}, {"insertions": 4, "deletions": 4, "lines": 8, "filePath": "rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java"}, {"insertions": 0, "deletions": 1, "lines": 1, "filePath": "rxjava-core/src/main/java/rx/Observable.java"}], "commitDateTime": "2014-06-23 09:48:32", "commitUser": "DavidMGross", "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "Subscriber.java"}, {"spoonMethods": [], "spoonFilePath": "SubscriptionList.java"}, {"spoonMethods": [], "spoonFilePath": "Observable.java"}]}, {"nameRev": "e808394fd70958960228925d4d9c8eeb63c1cd50 tags/0.19.2~7", "commitMessage": "Adding missing javadocs to Exceptions/OnErrorThrowable (#1322)\n", "commitParents": ["2d7b9660ef2825c25f2f3fbeda9acb96c3712575"], "spoonStatsSkippedReason": "", "commitHash": "e808394fd70958960228925d4d9c8eeb63c1cd50", "authoredDateTime": "2014-06-24 10:45:40", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 20, "deletions": 10, "lines": 30, "filePath": "rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java"}, {"insertions": 31, "deletions": 4, "lines": 35, "filePath": "rxjava-core/src/main/java/rx/exceptions/Exceptions.java"}], "commitDateTime": "2014-06-24 10:45:40", "commitUser": "DavidMGross", "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "Exceptions.java"}, {"spoonMethods": [], "spoonFilePath": "OnErrorThrowable.java"}]}, {"nameRev": "a2701658d5f9a78eb53af594a1b509f49ca018ae tags/0.19.2~20", "commitMessage": "Javadoc changes to help fix #1322\n", "commitParents": ["b76f507c3f4eeff97bf4e4dd8685ed745c1fde0d"], "spoonStatsSkippedReason": "", "commitHash": "a2701658d5f9a78eb53af594a1b509f49ca018ae", "authoredDateTime": "2014-06-20 14:02:07", "commitGHEventType": "closed", "commitGitStats": [{"insertions": 8, "deletions": 5, "lines": 13, "filePath": "rxjava-core/src/main/java/rx/subscriptions/MultipleAssignmentSubscription.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "rxjava-core/src/main/java/rx/observers/Observers.java"}, {"insertions": 3, "deletions": 4, "lines": 7, "filePath": "rxjava-core/src/main/java/rx/Observable.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "rxjava-core/src/main/java/rx/observers/Subscribers.java"}, {"insertions": 1, "deletions": 1, "lines": 2, "filePath": "rxjava-core/src/main/java/rx/subjects/Subject.java"}], "commitDateTime": "2014-06-20 14:02:07", "commitUser": "DavidMGross", "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "Observable.java"}, {"spoonMethods": [], "spoonFilePath": "Subscribers.java"}, {"spoonMethods": [], "spoonFilePath": "Subject.java"}, {"spoonMethods": [], "spoonFilePath": "MultipleAssignmentSubscription.java"}, {"spoonMethods": [], "spoonFilePath": "Observers.java"}]}, {"nameRev": "2d7b9660ef2825c25f2f3fbeda9acb96c3712575 tags/0.19.2~8", "commitMessage": "Adding missing javadocs to TestSubject (#1322)\n", "commitParents": ["bf29c611065894e9d383c739b93dcc48bb3bf9cb"], "spoonStatsSkippedReason": "", "commitHash": "2d7b9660ef2825c25f2f3fbeda9acb96c3712575", "authoredDateTime": "2014-06-24 09:53:20", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 22, "deletions": 26, "lines": 48, "filePath": "rxjava-core/src/main/java/rx/subjects/TestSubject.java"}], "commitDateTime": "2014-06-24 09:53:20", "commitUser": "DavidMGross", "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "TestSubject.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/1322", "ttf": 50.000277777777775, "gitStatsSummary": {"insertions": 77, "deletions": 36, "lines": 113, "gitFilesChange": 9}, "title": "Missing javadoc comments", "statsSkippedReason": "", "user": "DavidMGross", "changesInPackagesGIT": ["rxjava-core/src/main/java/rx/observers", "rxjava-core/src/main/java/rx/internal/util", "rxjava-core/src/main/java/rx", "rxjava-core/src/main/java/rx/subjects", "rxjava-core/src/main/java/rx/subscriptions", "rxjava-core/src/main/java/rx/exceptions"], "spoonStatsSummary": {}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 0, "alsoFixesPhrase": 0}, "body": "I've gone through those parts of the source code that are reflected in the rxjava-core javadocs and flagged those parts of the javadoc comments that are missing or that need attention.  In those areas where I felt confident enough to fill in the gaps myself, I have done so, but that still leaves some gaps unfilled.  If you are the implementer or if you have the necessary expertise, could you review the files on this list for missing javadocs?\n\nI've flagged the areas that need help with \"@warn\" tags.  That tag is not part of the javadoc standard, so it triggers a javadoc compilation warning.  Please remove those tags from the areas that you fix.\n\n<s>subscriptions/MultipleAssignmentSubscription.java\n  [set() and get()]</s>\n\n<s>subjects/Subject.java\n  [class description]</s>\n\n<s>subjects/TestSubject.java\n  [all javadocs missing except class description which seems copy-pasted]</s>\n\n<s>observers/Observers.java\n  [class description]</s>\n\n<s>observers/Subscribers.java\n  [class description]</s>\n\n<s>observers/TestSubscriber.java\n  [awaitTerminalEvent(), awaitTerminalEventAndUnsubscribeOnTimeout(), getLastSeenThread()]</s>\n\nexceptions/Exceptions.java\n  [<del>all javadocs missing</del><ins>class description & propagage()</ins>]\n\n<s>exceptions/OnErrorThrowable.java\n  [class description, getValue(), OnNextValue inner class]</s>\n\nNotification.java\n  [createOnCompleted()]\n\nObservable.java\n  [cache(), multicast(), <s>toList()</s>]\n\n<s>Subscriber.java\n  [add()]</s>\n", "labels": ["Bug"]}, {"created": "2014-05-24 19:12:57", "user": "headinthebox", "body": "In RxJava/RxScala, the following example prints 0 and then is dead:\n\n``` scala\nval delay = BehaviorSubject(0)\nval nats = delay.observeOn(rx.lang.scala.schedulers.NewThreadScheduler())\n                    .doOnEach(n => delay.onNext(n+1))\nnats.subscribe(n => println(n))\n```\n\nWhereas in Rx.NET the equivalent program works just fine, and prints `0, 1, 2, ...`\n\n``` C#\nvar delay = new BehaviorSubject<int>(0);\nvar nats = delay.ObserveOn(CurrentThreadScheduler.Instance).Do(n => delay.OnNext(n+1))\nnats.Subscribe(Console.WriteLine);\n```\n", "closed": "2014-07-24 07:24:11", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1259", "ttf": 60.000277777777775, "commits": {}, "labels": ["Bug"], "title": "Deadlock with recursive chain"}, {"created": "2014-05-22 23:50:03", "user": "headinthebox", "body": "Bindings for `mergeMap` and `concatMap` are missing in RxScala.\n\nMy proposal is to merge `mergeMap` and `flatMap`.\n", "closed": "2014-06-02 16:02:22", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/1251", "ttf": 10.000277777777777, "commits": {}, "labels": ["Bug"], "title": "RxScala mergeMap and concatMap bindings missing"}, {"created": "2013-12-12 21:36:45", "user": "abersnaze", "body": "The merge operation passes calls to the actual observer through an instance of SynchronizedObserver but merge delay error doesn't.  This is causing overlapping calls to onNext and all sorts of concurrency bugs in our server.\n", "closed": "2014-01-02 20:52:01", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/614", "ttf": 20.00027777777778, "commits": {}, "labels": ["Bug"], "title": "Merge delay error doesn't synchronize onNext calls"}, {"created": "2013-12-06 23:55:57", "user": "mattrjacobs", "body": "Here's the relevant thread dump:\n\n\"RxComputationThreadPool-8\":\n    at rx.subscriptions.CompositeSubscription.unsubscribe(CompositeSubscription.java:100)\n    - waiting to lock <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)\n    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:43)\n    - locked <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)\n    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)\n    - locked <0x00007f2a2846be60> (a rx.subscriptions.CompositeSubscription)\n    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:166)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:724)\n\"RxComputationThreadPool-7\":\n    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:40)\n    - waiting to lock <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)\n    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)\n    - locked <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)\n    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:166)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n", "closed": "2013-12-10 23:04:14", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/577", "ttf": 3.000277777777778, "commits": {}, "labels": ["Bug"], "title": "Deadlock in 0.15.x between MultipleAssignmentSubscription and CompositeSubscription"}, {"created": "2013-10-10 04:58:53", "user": "elandau", "body": "This seems to be isolated to the first chunk.\n\n```\n    @Test\n    public void testDuplicate() throws Exception {\n        final Set<Integer> unique = new HashSet<Integer>();\n        Observable.create(new OnSubscribeFunc<Integer>() {\n            @Override\n            public Subscription onSubscribe(final Observer<? super Integer> t1) {\n                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                    @Override\n                    public void run() {\n                        int count = 0;\n                        for (int i = 0; i < 11; i++) {\n                            t1.onNext(count++);\n                            try {\n                                Thread.sleep(10);\n                            } catch (InterruptedException e) {\n                            }\n                        }\n                    }\n                });\n\n                return new Subscription() {\n                    @Override\n                    public void unsubscribe() {\n                        t.cancel(true);\n                    }\n                };\n            }\n        })\n        .buffer(100, 100, TimeUnit.MILLISECONDS) \n        .subscribe(new Action1<List<Integer>>() {\n            @Override\n            public void call(List<Integer> t1) {\n                if (t1.isEmpty()) \n                    return;\n\n                LOG.info(t1.toString());\n                for (Integer i : t1) {\n                    synchronized (unique) {\n                        if (unique.contains(i)) {\n                            LOG.error(\"Duplicate for \" + i);\n                        }\n                        Assert.assertFalse(unique.contains(i));\n                        unique.add(i);\n                    }\n                }\n            }\n        });\n\n        Thread.sleep(10000);\n\n    }\n```\n", "closed": "2014-05-20 05:36:24", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/429", "ttf": 222.00027777777777, "commits": {}, "labels": ["Bug"], "title": "buffer() using TimeBasedChunks results in duplicates being sent onNext"}, {"created": "2013-10-10 03:53:37", "commits": {"fcf13c25a08d699ac222deb35d1d24c06ab43156": {"commitGHEventType": "referenced", "commitUser": "benjchristensen"}}, "numCommits": 0, "changesInPackagesSPOON": [], "closed": "2013-10-16 06:36:53", "filteredCommits": [], "commitsDetails": [{"nameRev": "fcf13c25a08d699ac222deb35d1d24c06ab43156 tags/0.14.4~3", "commitMessage": "Merge pull request #430 from zsxwing/issue-428\n\nFixed issue #428", "commitParents": ["67b3f4da50ea9205e8e25c3218f694f1f38080dd", "ede1288d35c2350a1fad1d4e9fbc610811dab953"], "spoonStatsSkippedReason": "", "commitHash": "fcf13c25a08d699ac222deb35d1d24c06ab43156", "authoredDateTime": "2013-10-15 22:29:43", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 4, "deletions": 1, "lines": 5, "filePath": "rxjava-core/src/main/java/rx/operators/ChunkedOperation.java"}, {"insertions": 38, "deletions": 0, "lines": 38, "filePath": "rxjava-core/src/main/java/rx/operators/OperationBuffer.java"}], "commitDateTime": "2013-10-15 22:29:43", "commitUser": "benjchristensen", "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 1, "INS": 0, "DEL": 0, "spoonMethodName": "rx.operators.ChunkedOperation.TimeAndSizeBasedChunks.emitChunk(rx.operators.ChunkedOperation$Chunk)"}], "spoonFilePath": "ChunkedOperation.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.operators.OperationBuffer.UnitTest.testLongTimeAction()"}, {"UPD": 0, "TOT": 1, "MOV": 0, "INS": 1, "DEL": 0, "spoonMethodName": "rx.operators.OperationBuffer.UnitTest.LongTimeAction"}], "spoonFilePath": "OperationBuffer.java"}]}], "url": "https://github.com/ReactiveX/RxJava/issues/428", "ttf": 6.000277777777778, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "buffer() using TimeAndSizeBasedChunks incorrectly forces thread into interrupted state", "statsSkippedReason": "", "user": "elandau", "changesInPackagesGIT": [], "spoonStatsSummary": {"UPD": 0, "spoonMethodsChanged": 0, "TOT": 0, "MOV": 0, "INS": 0, "DEL": 0, "spoonFilesChanged": 0}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "In TimeAndSizeBasedChunks.emitChunk, if emitChunk is called from the scheduled action in createChunk (i.e from the timeout thread), calling subscription.unsubscribe() ends up calling cancel() on the future which sets the thread's interrupted state to true.  This state has an adverse effect on any blocking call performed in that thread.  \n", "labels": ["Bug"]}, {"created": "2013-09-14 10:01:08", "commits": {"4feba311ee394300b0edcb5fef80ca9cc57397ea": {"commitGHEventType": "referenced", "commitUser": "benjchristensen"}}, "numCommits": 0, "closed": "2014-05-20 05:32:16", "filteredCommits": [], "commitsDetails": [{"nameRev": "4feba311ee394300b0edcb5fef80ca9cc57397ea tags/0.14.7~2", "commitMessage": "Merge pull request #433 from zsxwing/issue-383\n\nFixed testOnErrorViaHasNext in issue #383", "commitParents": ["7b997a86f8ba16fed287a638aa396562e3780272", "0659539b518d672c90925916069d722ab86b6376"], "spoonStatsSkippedReason": "tooManyChanges", "commitHash": "4feba311ee394300b0edcb5fef80ca9cc57397ea", "authoredDateTime": "2013-10-31 13:28:23", "commitGHEventType": "referenced", "commitGitStats": [{"insertions": 215, "deletions": 103, "lines": 318, "filePath": "rxjava-core/src/main/java/rx/operators/OperationNext.java"}], "commitDateTime": "2013-10-31 13:28:23", "commitUser": "benjchristensen", "commitSpoonAstDiffStats": []}], "url": "https://github.com/ReactiveX/RxJava/issues/383", "ttf": 247.00027777777777, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "title": "Flaky unit tests", "statsSkippedReason": "", "user": "samuelgruetter", "changesInPackagesGIT": [], "spoonStatsSummary": {}, "filteredCommitsReason": {"unavailable": 0, "moreThanOneParent": 0, "mergeCommitUsed": 0, "duplicated": 0, "multipleIssueFixes": 1, "alsoFixesPhrase": 0}, "body": "It looks like there are some flaky unit tests:\n\nOn my machine, this test failed today (but only once):\n\n```\nrx.operators.OperationNext$UnitTest.testOnErrorViaHasNext\n```\n\nOn cloudbees, these tests seem to be flaky:\n\n```\nBuild #278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime\nBuild #277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity\n```\n\nEdit: also\n\n```\nBuild #290: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity \n```\n", "labels": ["Bug"]}, {"created": "2013-07-29 15:40:11", "user": "EmteZogaf", "body": "Shouldn't all onError calls including a possible onError call of the parent observable being delayed till all child observables have successfully finished emitting items or called onError themselves?\n\nTo get my desired behaviour I changed the code so now the onError method adds the error to the error queue and calls the onCompleted method which already does the propagation of received errors.\n", "closed": "2014-11-06 06:37:38", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/313", "ttf": 464.0002777777778, "commits": {}, "labels": ["Bug"], "title": "Operation mergeDelayError(Observable<Observable<T>>) does not delay onError of parent observable"}, {"created": "2013-05-22 22:29:56", "user": "benjchristensen", "body": "Looks like `finallyDo` is behaving wrong:\n\n``` groovy\npackage rx.lang.groovy.examples\nimport rx.Observable\n\nclass Testing {\n\n    static class myActionClass implements rx.util.functions.Action0 {\n        void call() { println('Finally'); }\n     }\n\n    static main(args) {\n\n\n\n        def myAction = new myActionClass();\n        def numbers = Observable.toObservable([1, 2, 3, 4, 5]);\n\n        numbers.finallyDo(myAction).subscribe(\n          [ onNext: { println(it); },\n            onCompleted:{ println(\"Sequence complete\"); },\n            onError:{ println(\"Error encountered\"); } ]\n        );\n\n    }\n\n}\n```\n\n```\nOutput:\n\n1\n2\n3\n4\n5\nSequence complete\nFinally\n```\n\nI believe \"Finally\" should happen before \"Sequence Completed\"\n", "closed": "2013-05-31 03:51:35", "commitsDetails": [], "url": "https://github.com/ReactiveX/RxJava/issues/277", "ttf": 8.000277777777777, "commits": {}, "labels": ["Bug"], "title": "Finally Happens after onCompleted"}]}