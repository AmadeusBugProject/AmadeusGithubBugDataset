{"projectName": "INRIA/spoon", "bugLabels": ["breaking_pr", "bug"], "captureTime": "Fri Jul  3 22:50:05 2020", "issues": [{"title": "Regression of spoon-decompiler against latest snapshot", "body": "Build 'spoon-decompiler' is failing!\n\nLast 50 lines of build output:\n\n```\n[...truncated 2.11 KB...]\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO] \n[INFO] --- versions-maven-plugin:2.4:use-latest-versions (default-cli) @ spoon-decompiler ---\n[INFO] Major version changes allowed\n[INFO] artifact fr.inria.gforge.spoon:spoon-core: checking for updates from maven.inria.fr-snapshot\n[WARNING] repository metadata for: 'artifact fr.inria.gforge.spoon:spoon-core' could not be retrieved from repository: maven.inria.fr-snapshot due to an error: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.638 s\n[INFO] Finished at: 2020-06-05T14:59:10+02:00\n[INFO] Final Memory: 25M/175M\n[INFO] ------------------------------------------------------------------------\n+ mvn clean test\nPicked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8\n[INFO] Scanning for projects...\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\nDownloading: https://maven.irisa.fr/artifactory/spoon-public-snapshot/fr/inria/gforge/spoon/spoon-core/8.2.0-SNAPSHOT/spoon-core-8.2.0-20200605.121315-106.pom\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.750 s\n[INFO] Finished at: 2020-06-05T14:59:13+02:00\n[INFO] Final Memory: 15M/173M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal on project spoon-decompiler: Could not resolve dependencies for project fr.inria.gforge.spoon:spoon-decompiler:jar:0.2.0-SNAPSHOT: Failed to collect dependencies at fr.inria.gforge.spoon:spoon-core:jar:8.2.0-SNAPSHOT: Failed to read artifact descriptor for fr.inria.gforge.spoon:spoon-core:jar:8.2.0-SNAPSHOT: Could not transfer artifact fr.inria.gforge.spoon:spoon-core:pom:8.2.0-20200605.121315-106 from/to maven.inria.fr-snapshot (https://maven.irisa.fr/artifactory/spoon-public-snapshot): sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException\nBuild step 'Execute shell' marked build as failure\n\n```\n\nChanges since last successful build:\n- [github] 12d748fdec2b2eb4cfccae9af556b8f1f9d0bd4b - feat(SameFilter): add utility class SameFilter (#3391)\n\n- [github] 8ad42f8a22bdfa31d7c08a7717187f43d91d4213 - refactor(ElementSourceFragment): improve clarity (#3390)\n\n- [github] f8f3fe4966c5669d01881e0bae18a752ffe2ee36 - feat: add CtVariable#isPartOfJointDeclaration (#3392)\n\n- [github] d4129d7cf7623c6a73ff3ddeadc0fb7069426c91 - chore: allow LSIF upload action to pass even if upload fails (#3394)\n\n- [github] df73729dd3542c46658e8c1f18c5f5e0258528c7 - fix(SniperPrettyPrinter): fix pretty-printing of joint declarations (#3386) (#3387)\n\n\n\n[View full output](https://ci.inria.fr/sos/job/spoon-decompiler/319/)", "url": "https://github.com/INRIA/spoon/issues/3395", "user": "spoon-bot", "labels": ["bug"], "created": "2020-06-05 12:59:15", "closed": "2020-06-06 12:59:35", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "clone changes the order of the type members", "body": "see https://github.com/INRIA/spoon/issues/3380#issuecomment-636093292", "url": "https://github.com/INRIA/spoon/issues/3389", "user": "monperrus", "labels": ["bug"], "created": "2020-06-03 16:21:18", "closed": "2020-06-16 21:06:21", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "Regression of spoon-decompiler against latest snapshot", "body": "Build 'spoon-decompiler' is failing!\n\nLast 50 lines of build output:\n\n```\n[...truncated 2.11 KB...]\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO] \n[INFO] --- versions-maven-plugin:2.4:use-latest-versions (default-cli) @ spoon-decompiler ---\n[INFO] Major version changes allowed\n[INFO] artifact fr.inria.gforge.spoon:spoon-core: checking for updates from maven.inria.fr-snapshot\n[WARNING] repository metadata for: 'artifact fr.inria.gforge.spoon:spoon-core' could not be retrieved from repository: maven.inria.fr-snapshot due to an error: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 3.198 s\n[INFO] Finished at: 2020-05-07T14:59:10+02:00\n[INFO] Final Memory: 25M/181M\n[INFO] ------------------------------------------------------------------------\n+ mvn clean test\nPicked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8\n[INFO] Scanning for projects...\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\nDownloading: https://maven.irisa.fr/artifactory/spoon-public-snapshot/fr/inria/gforge/spoon/spoon-core/8.2.0-SNAPSHOT/spoon-core-8.2.0-20200507.112245-62.pom\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.281 s\n[INFO] Finished at: 2020-05-07T14:59:14+02:00\n[INFO] Final Memory: 15M/173M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal on project spoon-decompiler: Could not resolve dependencies for project fr.inria.gforge.spoon:spoon-decompiler:jar:0.2.0-SNAPSHOT: Failed to collect dependencies at fr.inria.gforge.spoon:spoon-core:jar:8.2.0-SNAPSHOT: Failed to read artifact descriptor for fr.inria.gforge.spoon:spoon-core:jar:8.2.0-SNAPSHOT: Could not transfer artifact fr.inria.gforge.spoon:spoon-core:pom:8.2.0-20200507.112245-62 from/to maven.inria.fr-snapshot (https://maven.irisa.fr/artifactory/spoon-public-snapshot): sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException\nBuild step 'Execute shell' marked build as failure\n\n```\n\nChanges since last successful build:\n- [github] c83e02311a9d3291ac1a28e9b91fff8ace523af0 - fix: Remove incorrect implicitness for package reference (#3357)\n\n- [github] 965d72d92f11a9d125fc283896f6400fb0f2ccc9 - fix(travis-extra.sh): download z3 lib from ow2 instead of github for CI (#3356)\n\n\n\n[View full output](https://ci.inria.fr/sos/job/spoon-decompiler/290/)", "url": "https://github.com/INRIA/spoon/issues/3361", "user": "spoon-bot", "labels": ["bug"], "created": "2020-05-07 12:59:16", "closed": "2020-05-09 12:59:35", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "noclasspath mode is used but it shouldn't be the case", "body": "Hi,\r\n\r\n1) I see that https://github.com/SpoonLabs/spoon-maven-plugin/blob/master/src/main/java/fr/inria/gforge/spoon/SpoonMojoGenerate.java#L71 sets the noclasspath mode to false by default\r\n2) I also put `<noClasspath>false</noClasspath>` in my spoon plugin config.\r\n\r\nYet I get:\r\n\r\n```\r\n[INFO] --- spoon-maven-plugin:3.2:check (spoon-main) @ xwiki-commons-component-api ---\r\n[INFO] Spoon report directory: /Users/vmassol/dev/xwiki/xwiki-commons/xwiki-commons-core/xwiki-commons-component/xwiki-commons-component-api/target/spoon-maven-plugin\r\n[INFO] Generate spoon without a spoon.xml file.\r\n[INFO] Running spoon with classpath:\r\n[INFO] file:/Applications/apache-maven-3.6.2/boot/plexus-classworlds-2.6.0.jar\r\n[INFO] Running in NOCLASSPATH mode (doc: http://spoon.gforge.inria.fr/launcher.html).\r\n[INFO] Running spoon with parameters:\r\n[INFO] [--level, INFO, -i, /Users/vmassol/dev/xwiki/xwiki-commons/xwiki-commons-core/xwiki-commons-component/xwiki-commons-component-api/src/main/java:/Users/vmassol/dev/xwiki/xwiki-commons/xwiki-commons-core/xwiki-commons-component/xwiki-commons-component-api/target/generated-sources/annotations, -o, /Users/vmassol/dev/xwiki/xwiki-commons/xwiki-commons-core/xwiki-commons-component/xwiki-commons-component-api/target/generated-sources/spoon, --compliance, 8, --source-classpath, /Users/vmassol/.m2/repository/org/xwiki/commons/xwiki-commons-stability/12.3-SNAPSHOT/xwiki-commons-stability-12.3-SNAPSHOT.jar:/Users/vmassol/.m2/repository/org/xwiki/commons/xwiki-commons-text/12.3-SNAPSHOT/xwiki-commons-text-12.3-SNAPSHOT.jar:/Users/vmassol/.m2/repository/org/apache/commons/commons-lang3/3.10/commons-lang3-3.10.jar:/Users/vmassol/.m2/repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/vmassol/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:, -p, org.xwiki.tool.spoon.ForbiddenInvocationProcessor:org.xwiki.tool.spoon.ComponentAnnotationProcessor, --output-type, nooutput]\r\n[INFO] Running in NOCLASSPATH mode (doc: http://spoon.gforge.inria.fr/launcher.html).\r\n[INFO] Spoon version 8.1.0\r\n[INFO] running Spoon...\r\n[INFO] start processing...\r\n[INFO] org.xwiki.tool.spoon.ForbiddenInvocationProcessor\r\n[INFO] org.xwiki.tool.spoon.ComponentAnnotationProcessor\r\n[INFO] end of processing: \r\n[INFO] no errors, no warnings\r\n[INFO] \r\n```\r\n\r\nAny idea?\r\n\r\nThanks", "url": "https://github.com/INRIA/spoon/issues/3325", "user": "vmassol", "labels": ["bug", "spoon-maven-plugin"], "created": "2020-04-14 08:06:36", "closed": "2020-04-16 08:34:11", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Regression of spoon-decompiler against latest snapshot", "body": "Build 'spoon-decompiler' is failing!\n\nLast 50 lines of build output:\n\n```\n[...truncated 2.10 KB...]\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[WARNING] The POM for org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 is missing, no dependency information available\n[WARNING] Failed to retrieve plugin descriptor for org.eclipse.m2e:lifecycle-mapping:1.0.0: Plugin org.eclipse.m2e:lifecycle-mapping:1.0.0 or one of its dependencies could not be resolved: Failure to find org.eclipse.m2e:lifecycle-mapping:jar:1.0.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced\n[INFO] \n[INFO] --- versions-maven-plugin:2.4:use-latest-versions (default-cli) @ spoon-decompiler ---\n[INFO] Major version changes allowed\n[INFO] artifact fr.inria.gforge.spoon:spoon-core: checking for updates from maven.inria.fr-snapshot\n[WARNING] repository metadata for: 'artifact fr.inria.gforge.spoon:spoon-core' could not be retrieved from repository: maven.inria.fr-snapshot due to an error: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.770 s\n[INFO] Finished at: 2020-03-12T14:59:10+01:00\n[INFO] Final Memory: 25M/178M\n[INFO] ------------------------------------------------------------------------\n+ mvn clean test\nPicked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8\n[INFO] Scanning for projects...\n[INFO] Inspecting build with total of 1 modules...\n[INFO] Installing Nexus Staging features:\n[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building Spoon Decompiler 0.2.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\nDownloading: https://maven.irisa.fr/artifactory/spoon-public-snapshot/fr/inria/gforge/spoon/spoon-core/8.1.0-SNAPSHOT/spoon-core-8.1.0-20200312.123333-186.pom\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.999 s\n[INFO] Finished at: 2020-03-12T14:59:14+01:00\n[INFO] Final Memory: 15M/174M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal on project spoon-decompiler: Could not resolve dependencies for project fr.inria.gforge.spoon:spoon-decompiler:jar:0.2.0-SNAPSHOT: Failed to collect dependencies at fr.inria.gforge.spoon:spoon-core:jar:8.1.0-SNAPSHOT: Failed to read artifact descriptor for fr.inria.gforge.spoon:spoon-core:jar:8.1.0-SNAPSHOT: Could not transfer artifact fr.inria.gforge.spoon:spoon-core:pom:8.1.0-20200312.123333-186 from/to maven.inria.fr-snapshot (https://maven.irisa.fr/artifactory/spoon-public-snapshot): sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException\nBuild step 'Execute shell' marked build as failure\n\n```\n\nChanges since last successful build:\n- [github] 819de26e04d886a7a98debd25ccb2a22339c427d - doc: removed a confusing sentence from documentation (#3292)\n\n- [github] a1c948d00a927b25927690c814b7da8520456dc2 - doc: add https://github.com/societe-generale/arch-unit-maven-plugin (#3288)\n\n\n\n[View full output](https://ci.inria.fr/sos/job/spoon-decompiler/233/)", "url": "https://github.com/INRIA/spoon/issues/3304", "user": "spoon-bot", "labels": ["bug"], "created": "2020-03-12 13:59:15", "closed": "2020-03-12 14:22:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Fully qualified names problem in Sniper pretty printer", "body": "After the latest changes to master it is adding fully qualified names when originally there weren't.\r\n![image](https://user-images.githubusercontent.com/12514975/75094953-ba22a500-5587-11ea-8591-6c1a2b6f260c.png)\r\n", "url": "https://github.com/INRIA/spoon/issues/3268", "user": "moraispgsi", "labels": ["bug"], "created": "2020-02-22 15:29:42", "closed": "2020-06-14 20:02:57", "commits": {}, "ttf": 113.00027777777778, "commitsDetails": []}, {"title": "feature: removeDeprecatedMethods should not remove the methods that are used somewhere", "body": "Method  [`removeDeprecatedMethods`](https://github.com/INRIA/spoon/blob/8ff4eb442fc32dbda372aeec673d0b9f74b04e98/src/main/java/spoon/refactoring/Refactoring.java#L213) should not remove the methods that are used somewhere in the project, see https://stackoverflow.com/questions/4256252/tool-that-lists-all-deprecated-classes-methods-that-are-no-longer-used-anywhere/59254336?noredirect=1#comment104736583_59254336\r\n", "url": "https://github.com/INRIA/spoon/issues/3195", "user": "monperrus", "labels": ["bug", "good first issue"], "created": "2019-12-15 20:05:27", "closed": "2020-02-11 09:57:58", "commits": {}, "ttf": 57.000277777777775, "commitsDetails": []}, {"title": "Problem with shadow class", "body": "Hello!\r\n\r\nI use spoon for long time for one of our project, very recently only I came up with this exception, and I can't figure out what's happening. The error appears only when dealing with a very large code base, hence hard to debug and be more precise, but I can.\r\n\r\nDoes the fact that it involves javafx helps?\r\n\r\n```\r\nException in thread \"main\" spoon.support.SpoonClassNotFoundException: cannot create shadow class: javafx.scene.control.TextField\r\n        at spoon.reflect.factory.TypeFactory.get(TypeFactory.java:552)\r\n        at spoon.support.compiler.jdt.JDTImportBuilder.getOrLoadClass(JDTImportBuilder.java:143)\r\n        at spoon.support.compiler.jdt.JDTImportBuilder.build(JDTImportBuilder.java:76)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.lambda$buildModel$1(JDTBasedSpoonCompiler.java:427)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.forEachCompilationUnit(JDTBasedSpoonCompiler.java:449)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:426)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:364)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:329)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:112)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:95)\r\n        at spoon.Launcher.buildModel(Launcher.java:766)\r\n        at fr.infologic.ia.parametrage.data.CopiloteModel.buildModel(CopiloteModel.java:147)\r\n        at fr.infologic.ia.parametrage.Main.main(Main.java:64)\r\nCaused by: java.lang.ExceptionInInitializerError\r\n        at sun.misc.Unsafe.ensureClassInitialized(Native Method)\r\n        at sun.reflect.UnsafeFieldAccessorFactory.newFieldAccessor(UnsafeFieldAccessorFactory.java:43)\r\n        at sun.reflect.ReflectionFactory.newFieldAccessor(ReflectionFactory.java:156)\r\n        at java.lang.reflect.Field.acquireFieldAccessor(Field.java:1088)\r\n        at java.lang.reflect.Field.getFieldAccessor(Field.java:1069)\r\n        at java.lang.reflect.Field.get(Field.java:393)\r\n        at spoon.support.visitor.java.JavaReflectionTreeBuilder.visitField(JavaReflectionTreeBuilder.java:294)\r\n        at spoon.support.visitor.java.JavaReflectionVisitorImpl.visitClass(JavaReflectionVisitorImpl.java:90)\r\n        at spoon.support.visitor.java.JavaReflectionTreeBuilder.visitClass(JavaReflectionTreeBuilder.java:150)\r\n        at spoon.support.visitor.java.JavaReflectionTreeBuilder.scan(JavaReflectionTreeBuilder.java:107)\r\n        at spoon.reflect.factory.TypeFactory.get(TypeFactory.java:550)\r\n        ... 12 more\r\nCaused by: java.lang.IllegalStateException: Toolkit not initialized\r\n        at com.sun.javafx.application.PlatformImpl.runLater(PlatformImpl.java:273)\r\n        at com.sun.javafx.application.PlatformImpl.runLater(PlatformImpl.java:268)\r\n        at com.sun.javafx.application.PlatformImpl.setPlatformUserAgentStylesheet(PlatformImpl.java:550)\r\n        at com.sun.javafx.application.PlatformImpl.setDefaultPlatformUserAgentStylesheet(PlatformImpl.java:512)\r\n        at javafx.scene.control.Control.<clinit>(Control.java:87)\r\n        ... 23 more\r\n```", "url": "https://github.com/INRIA/spoon/issues/3172", "user": "mehdi-kaytoue", "labels": ["bug"], "created": "2019-11-14 12:07:56", "closed": "2020-02-13 08:45:37", "commits": {}, "ttf": 90.00027777777778, "commitsDetails": []}, {"title": "bug in SniperJavaPrettyPrinter spoon.SpoonException: Missing SourceFragmentContext", "body": "I'm analyzing and changing a bunch of classes that have copyright comments before the package declaration.\r\n\r\nIf I use SniperJavaPrettyPrinter and change one of this classes I get an exception (see below).\r\n\r\n### Launcher class\r\n\r\n    public static void main(String[] args) {\r\n        Launcher launcher = new Launcher();\r\n\r\n        // path can be a folder or a file\r\n        // addInputResource can be called several times\r\n        launcher.addInputResource(\"C:\\\\workspace\\\\Parser\\\\src\\\\main\\\\java\\\\spoon\\\\issues\\\\BadClass.java\");\r\n        launcher.setSourceOutputDirectory(\"generated\");\r\n        launcher.addProcessor(new MyProcessor());\r\n        launcher.getEnvironment().setPrettyPrinterCreator(\r\n                () -> new SniperJavaPrettyPrinter(launcher.getEnvironment()));\r\n\r\n        launcher.run();\r\n\r\n    }\r\n\r\n    public static class MyProcessor extends AbstractProcessor<CtParameter<?>> {\r\n\r\n        @Override\r\n        public void process(CtParameter<?> element) {\r\n            element.setSimpleName(\"changed\");\r\n        }\r\n\r\n    }\r\n}\r\n\r\n### Class that breaks everything\r\n\r\n\r\n>//this comment will crash spoon\r\n>package spoon.issues;\r\n>\r\n>public class BadClass {\r\n>\r\n>    public void changeMyParameter(String changeMe) {\r\n>    }\r\n>}\r\n\r\n\r\n### Exception\r\n\r\n`Exception in thread \"main\" spoon.SpoonException: Inconsistent child fragment class spoon.support.reflect.code.CtCommentImpl has unexpected parent class spoon.support.reflect.declaration.CtPackageDeclarationImpl\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.addChild(ElementSourceFragment.java:303)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.add(ElementSourceFragment.java:269)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.addChild(ElementSourceFragment.java:298)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.addChild(ElementSourceFragment.java:203)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.access$000(ElementSourceFragment.java:44)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment$1.enter(ElementSourceFragment.java:145)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtComment(CtScanner.java:877)\r\n\tat spoon.support.reflect.code.CtCommentImpl.accept(CtCommentImpl.java:86)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.doScan(EarlyTerminatingScanner.java:143)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:119)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:104)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:81)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:331)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:56)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.doScan(EarlyTerminatingScanner.java:143)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:119)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:104)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:81)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.visitCtCompilationUnit(EarlyTerminatingScanner.java:158)\r\n\tat spoon.support.reflect.declaration.CtCompilationUnitImpl.accept(CtCompilationUnitImpl.java:406)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.doScan(EarlyTerminatingScanner.java:143)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:119)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.EarlyTerminatingScanner.scan(EarlyTerminatingScanner.java:104)\r\n\tat spoon.support.sniper.internal.ElementSourceFragment.addTreeOfSourceFragmentsOfElement(ElementSourceFragment.java:169)\r\n\tat spoon.support.reflect.declaration.CtCompilationUnitImpl.getOriginalSourceFragment(CtCompilationUnitImpl.java:358)\r\n\tat spoon.support.modelobs.SourceFragmentCreator.onChange(SourceFragmentCreator.java:29)\r\n\tat spoon.support.modelobs.ChangeCollector$ChangeListener.onObjectUpdate(ChangeCollector.java:167)\r\n\tat spoon.support.reflect.declaration.CtNamedElementImpl.setSimpleName(CtNamedElementImpl.java:43)\r\n\tat CopyOfTestParser$MyProcessor.process(CopyOfTestParser.java:30)`", "url": "https://github.com/INRIA/spoon/issues/3154", "user": "dbarciela", "labels": ["bug"], "created": "2019-10-17 10:31:11", "closed": "2019-11-18 17:30:23", "commits": {}, "ttf": 32.000277777777775, "commitsDetails": []}, {"title": "sniper: unable to rename class", "body": "Using this code:\r\n\r\n```java\r\nfinal CtClass<?> ctClass = f.Class().get(\"spoon.test.prettyprinter.testclasses.Validation\");\r\nctClass.setSimpleName(\"Test\");\r\n```\r\n\r\nThe model is correctly changed, but the sniper mode does not succeed to generate the correct output.", "url": "https://github.com/INRIA/spoon/issues/3097", "user": "tdurieux", "labels": ["bug"], "created": "2019-09-11 14:08:56", "closed": "2020-06-15 08:02:56", "commits": {}, "ttf": 277.0002777777778, "commitsDetails": []}, {"title": "bug: Unresolved type reference causes model building failure", "body": "Here is failing test https://github.com/pvojtechovsky/spoon/tree/bug3087", "url": "https://github.com/INRIA/spoon/issues/3087", "user": "pvojtechovsky", "labels": ["bug"], "created": "2019-08-31 07:08:05", "closed": "2019-08-31 11:22:10", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Code of SourceOptions#sources isn't closing IO streams", "body": "/spoon-core/src/main/java/spoon/compiler/builder/SourceOptions.java\r\n```java\r\n\tpublic T sources(List<SpoonFile> sources) {\r\n\t\tif (sources == null || sources.isEmpty()) {\r\n\t\t\targs.add(\".\");\r\n\t\t\treturn myself;\r\n\t\t}\r\n\t\tfor (SpoonFile source : sources) {\r\n\t\t\tif (source.isActualFile()) {\r\n\t\t\t\targs.add(source.toString());\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFile file = File.createTempFile(source.getName(), \".java\");\r\n\t\t\t\t\tfile.deleteOnExit();\r\n//----------------> the streams created on next line are never closed\r\n\t\t\t\t\tIOUtils.copy(source.getContent(), new FileOutputStream(file));\r\n\t\t\t\t\targs.add(file.toString());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tthrow new RuntimeException(e.getMessage(), e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn myself;\r\n\t}\r\n```", "url": "https://github.com/INRIA/spoon/issues/3083", "user": "pvojtechovsky", "labels": ["bug", "good first issue"], "created": "2019-08-30 06:36:30", "closed": "2019-09-01 11:35:43", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Parsing a one-line class may produce incorrect line number", "body": "Spoon 7.5.0. openjdk 11.\r\n\r\nAnalysed code: `public class A { public Object b() { return a < b; }}` in a virtual file.\r\n\r\nAs results, all the line positions are incorrect (-1).\r\nNo issue with two-line code:\r\n`public class A { public Object b() { return a <\\n b; }}`\r\n\r\nTest example:\r\n\r\n```java\r\npublic class Test {\r\n  public static void main(final String[] args) {\r\n    final Launcher launcher = new Launcher();\r\n\r\n    launcher.addInputResource(\r\n      new VirtualFile(\"public class A { public Object b() { return a < b; }}\", \"chunk.java\"));\r\n\r\n    launcher.buildModel();\r\n    final CtModel model = launcher.getModel();\r\n    \r\n    model.getElements(new TypeFilter<>(CtElement.class))\r\n      .stream()\r\n      .filter(elt -> !(elt.getPosition() instanceof NoSourcePosition))\r\n      .forEach(elt -> System.out.println(elt.getClass().getSimpleName() + \": \" +\r\n        elt.getPosition().getLine() + \" \" + elt.getPosition().getEndLine()));\r\n  }\r\n```", "url": "https://github.com/INRIA/spoon/issues/3068", "user": "arnobl", "labels": ["bug"], "created": "2019-07-30 11:55:25", "closed": "2019-08-01 15:14:51", "commits": {"c37dfb103de5c1ff97176aa708725148d85a3b48": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "c37dfb103de5c1ff97176aa708725148d85a3b48", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["b32f5aef0c4700ab190d5c27952a8bb18ec4f764"], "nameRev": "c37dfb103de5c1ff97176aa708725148d85a3b48 tags/spoon-decompiler-0.1.0~37", "commitMessage": "fix(core): Parsing a one-line class produces correct line numbers (#3069)\n\nfix #3068 ", "commitDateTime": "2019-08-01 17:14:46", "authoredDateTime": "2019-08-01 17:14:46", "commitGitStats": [{"filePath": "src/main/java/spoon/support/reflect/cu/position/SourcePositionImpl.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/position/PositionTest.java", "insertions": 25, "deletions": 5, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SourcePositionImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.cu.position.SourcePositionImpl.searchLineNumber(int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "PositionTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.position.PositionTest.testLinePositionOkWithOneLineClassCode()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug: spoon.SpoonException: Declaring type of field result isn't defined", "body": "I am trying to process Java classes from ElasticSearch. There is a certain class which if added to Launcher.\r\nHere's my code to process the file.\r\n\r\n```java\r\n\r\npublic static void analyze(String path) throws IOException, InterruptedException {\r\n        Launcher launcher = new Launcher();\r\n\r\n        Thread.setDefaultUncaughtExceptionHandler((x,y) -> {\r\n            y.printStackTrace();\r\n        });\r\n\r\n        launcher.addInputResource(\"/home/satyendra/IdeaProjects/elasticsearch/modules/elasticsearch/src/main/java/org/elasticsearch/http/Utf8HttpResponse.java\");\r\n\r\n        launcher.getEnvironment().setAutoImports(true); // optional\r\n\r\n        launcher.getEnvironment().setNoClasspath(true); // optional\r\n\r\n        launcher.run();\r\n        final Factory factory = launcher.getFactory();\r\n        final ProcessingManager processingManager = new QueueProcessingManager(factory);\r\n        final ClassProcessor processor = new ClassProcessor();\r\n        processingManager.addProcessor(processor);\r\n        processingManager.process(factory.Class().getAll());\r\n\r\n        System.out.println(factory.Class().getAll());\r\n\r\n        CtType s = new TypeFactory().get(String.class);\r\n//        s.getFields().forEach(System.out::println);\r\n    }\r\n```\r\nThe class that fails is [UtfHttpResponse](https://gist.github.com/trexsatya/6d9f15dc2a25c4cd9f1caa116b58ffd1)\r\n\r\nI did a little digging and find that the problem is due to multi-line static block.", "url": "https://github.com/INRIA/spoon/issues/3065", "user": "trexsatya", "labels": ["bug"], "created": "2019-07-29 17:54:43", "closed": "2019-08-01 18:19:25", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "bug: Unknown source position when using lambda in inner class", "body": "Hello,\r\n\r\nI have a quite weird behavior in my processor when analyzing this class: https://github.com/woffs/tazapp-android/blob/master/tazapp/src/main/java/de/thecode/android/tazreader/reader/usertoc/UserTocAdapter.java#L180-L191\r\n\r\nI tracked down the bug to this minimal code sample: \r\n```java\r\npublic class Test {\r\n    public static class Failing {\r\n        Any listener;\r\n    }\r\n\r\n    private static class ExtendedClass extends Failing {\r\n        public void test() { \r\n           // The difference in behaviour happens if I comment this line out\r\n           Runnable r = v -> listener.someAction();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nHere, the class `Failing` will have a position returning `(uknown file)` in my processor if the line with the lambda stays uncommented.\r\nMy processor will work fine if I comment it out though.\r\n\r\nYou will find as follow the configuration of my spoon launcher:\r\n```java\r\n        Launcher launcher = new Launcher();\r\n\r\n        launcher.addInputResource(appPath);\r\n        launcher.getEnvironment().setNoClasspath(true);\r\n        launcher.buildModel();\r\n\r\n        AbstractProcessor<CtClass> classProcessor = new ClassProcessor();\r\n        AbstractProcessor<CtInterface> interfaceProcessor = new InterfaceProcessor();\r\n        launcher.addProcessor(classProcessor);\r\n        launcher.addProcessor(interfaceProcessor);\r\n        launcher.process();\r\n```\r\n\r\nAnd I will also attach the two states from my debugger.\r\nDo you have an idea of the issue? Anything I can do about it?\r\n\r\nThanks in advance.\r\n\r\n![2019-07-18-233325_565x504_scrot](https://user-images.githubusercontent.com/4600261/61494245-f40a4800-a9b5-11e9-9fa4-9fa8ef9d7141.png)\r\n![2019-07-18-233420_1045x419_scrot](https://user-images.githubusercontent.com/4600261/61494246-f4a2de80-a9b5-11e9-9ff1-b749a7a05a16.png)\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/3052", "user": "aveuiller", "labels": ["bug"], "created": "2019-07-18 21:46:05", "closed": "2019-07-25 05:25:37", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "bug when a field is accessed in a parenthesized expression", "body": "failing test case in #3021", "url": "https://github.com/INRIA/spoon/issues/3023", "user": "monperrus", "labels": ["bug"], "created": "2019-06-17 15:33:30", "closed": "2019-06-20 18:08:35", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "bug(DefaultPrettyPrinter): brocken indentation for else if statments", "body": "![1](https://user-images.githubusercontent.com/25069103/59107644-adafdb00-896b-11e9-8337-f454f5b5cfbb.png)\r\n![2](https://user-images.githubusercontent.com/25069103/59107648-b2748f00-896b-11e9-9ef2-75556623848d.png)\r\n![3](https://user-images.githubusercontent.com/25069103/59107787-f5366700-896b-11e9-8c0c-badc08e8aaf1.png)\r\n", "url": "https://github.com/INRIA/spoon/issues/3012", "user": "lzfgnu", "labels": ["bug"], "created": "2019-06-07 13:32:12", "closed": "2019-08-31 14:06:27", "commits": {}, "ttf": 85.00027777777778, "commitsDetails": []}, {"title": "auto import", "body": "Hello \r\ni'm using auto import in my configuration to save the result of my transformation in a file  \r\nbut when it come to this instruction \r\nView minusButton = child.findViewById(R.id.contact_remove);\r\n\r\nit is printed like this \r\nView minusButton = child.findViewById(contact_remove);\r\nand i have an error : cannot find symbol variable contact_remove\r\n\r\nhow can i solve this ? \r\nwith setAutoImport(true) \r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/2996", "user": "mislalee", "labels": ["bug"], "created": "2019-05-27 12:35:03", "closed": "2019-06-14 16:48:24", "commits": {}, "ttf": 18.00027777777778, "commitsDetails": []}, {"title": "Bug lambda with diamond operator and several interfaces ", "body": "Hi,\r\n\r\nThere seems to be an error with a particular use of lambda expressions : \r\n```java\r\npublic interface TestLambda{\r\n    default <T extends Ben & Jerry> Optional<T> bar () {\r\n        return (Optional<T>) foo().stream().filter(elt -> elt.benMethod(Ben.class)).findFirst();\r\n    }\r\n\r\n    default <T extends Ben & Jerry> List<T> foo () {\r\n        return Collections.emptyList();\r\n    }\r\n}\r\n```\r\n`benMethod` being a method declared in `Ben` interface.\r\nIt becomes :\r\n```java\r\npublic interface TestLambda {\r\n    default <T extends Ben & Jerry> Optional<T> bar() {\r\n        return ((Optional<T>) (foo().stream().filter((Ben & Jerry elt) -> elt.benMethod(Ben.class)).findFirst()));\r\n    }\r\n\r\n    default <T extends Ben & Jerry> List<T> foo() {\r\n        return Collections.emptyList();\r\n    }\r\n}\r\n```\r\n(Notice the `(Ben & Jerry elt) -> ` that doesn't compile)\r\n\r\nThank you for your support :)", "url": "https://github.com/INRIA/spoon/issues/2985", "user": "lodart", "labels": ["bug"], "created": "2019-05-23 14:24:19", "closed": "2019-06-05 06:38:40", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "Problem with creating matcher.", "body": "Hello,\r\nI'm trying to implement template matcher (patterns give me some internal missing CtElement for to provide Factory error).\r\nMy matcher class is from website:\r\n```java\r\npublic class NullCheckMatcher {\r\n    \r\n    public TemplateParameter<Collection<?>> _col_;\r\n    \r\n    public void matcher1() {\r\n    if (_col_.S().size() > 10) {\r\n      throw new IndexOutOfBoundsException();\r\n    }\r\n  }\r\n}\r\n```\r\nI'm trying to create matcher in processor:\r\n```java\r\nFactory f = e.getFactory();\r\nCtClass<?> klass = f.Class().get(NullCheckMatcher.class);\r\nCtMethod m = (CtMethod) klass.filterChildren(new NameFilter(\"matcher1\")).first();\r\nCtBlock block = m.getBody();\r\n\r\nCtIf templateRoot = (CtIf) ((CtMethod) klass.getElements(new NameFilter(\"matcher1\")).get(0)).getBody().getStatement(0);\r\n```\r\nvariable e is CtMethod.\r\nProblem is that body of method (variable block) contains no statements, so the last statement gives me IndexOutOfBoundException: 0.\r\nThanks for help.", "url": "https://github.com/INRIA/spoon/issues/2982", "user": "MakroCZ", "labels": ["bug"], "created": "2019-05-22 18:02:38", "closed": "2019-07-10 09:33:16", "commits": {}, "ttf": 48.000277777777775, "commitsDetails": []}, {"title": "bug?: anonymous class inside a method ", "body": "hello i'm trying to find the emplacement of a inner class to do some modification ( the anonymous class ) but when i'm printing the getQualifiedName of the Ctclass i'm getting this : \r\nnet.ktnx.mobileledger.ui.profiles.ProfileDetailFragment$<unknown>\r\n\r\nwhich cause a lot of bugs , and I can not locate it in the file .\r\n\r\nCould you help me please.\r\n\r\nhere is the method :\r\n\r\n![image](https://user-images.githubusercontent.com/21294779/57606930-e07bd480-7561-11e9-9bc2-c69a0d0bab84.png)\r\n", "url": "https://github.com/INRIA/spoon/issues/2974", "user": "nanaker", "labels": ["bug"], "created": "2019-05-13 08:31:43", "closed": "2020-03-10 09:24:04", "commits": {}, "ttf": 302.0002777777778, "commitsDetails": []}, {"title": "Wrong return type for method references", "body": "The CtExecutableReference interface specifies that `getType()` should return the method return type for a reference to a method, however the current implementation of the transformation from the JDT model to the spoon model is incorrect (at least, it appears so to me): [at line 585 in JDTTreeBuilderHelper.java](https://github.com/INRIA/spoon/blob/2208265abc5a13a32f83ed6e3aa4196e6e9ba342/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java#L585) the type of the newly-created ExecutableReference is set to the type declaring the method, rather than the method return type itself. \r\n\r\nThis bug breaks, for example, the `Refactoring.changeMethodName(CtMethod)` method, since the ExecutableReference does not match with the one returned from the method itself, and overall makes matching method references to their corresponding method pretty awkward, as it has to be done manually.", "url": "https://github.com/INRIA/spoon/issues/2966", "user": "MassimilianoPoggi", "labels": ["bug"], "created": "2019-05-07 16:40:59", "closed": "2019-06-05 18:30:16", "commits": {}, "ttf": 29.00027777777778, "commitsDetails": []}, {"title": "JarLauncher always use the same tmp directory", "body": "The JarLauncher in the spoon decompiler always uses the same tmp directory, no matter if the jar changes. This result in having classes inside the model that were not actually inside the jar, just because the decompiled source code is still there from the previous Jar.\r\n\r\nThe line that gives the problem is line 92 in JarLauncher.java:\r\n`decompiledSrcPath = System.getProperty(\"java.io.tmpdir\") + System.getProperty(\"file.separator\") + \"spoon-tmp\";`\r\n\r\nI suggest to create a new random directory every time and delete it at the end, or just delete this one every time.\r\nThanks", "url": "https://github.com/INRIA/spoon/issues/2951", "user": "lucacampanellaadn", "labels": ["bug"], "created": "2019-04-26 13:51:48", "closed": "2019-05-04 04:01:26", "commits": {"b392b8672bbb0082f0eb57ba111fdde4a8e9a033": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "b392b8672bbb0082f0eb57ba111fdde4a8e9a033", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["151176f4fae4d472c5bad16fc07c384ec85ca207"], "nameRev": "b392b8672bbb0082f0eb57ba111fdde4a8e9a033 tags/spoon-core-7.4.0~4", "commitMessage": "fix(JarLauncher): fix #2951, Really delete temporary decompiled source directory (#2952)\n\n", "commitDateTime": "2019-05-04 06:01:20", "authoredDateTime": "2019-05-04 06:01:20", "commitGitStats": [{"filePath": "spoon-decompiler/src/main/java/spoon/JarLauncher.java", "insertions": 9, "deletions": 1, "lines": 10}, {"filePath": "spoon-decompiler/src/test/java/spoon/JarLauncherTest.java", "insertions": 32, "deletions": 1, "lines": 33}], "commitSpoonAstDiffStats": [{"spoonFilePath": "JarLauncher.java", "spoonMethods": [{"spoonMethodName": "spoon.JarLauncher", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "JarLauncherTest.java", "spoonMethods": [{"spoonMethodName": "spoon.JarLauncherTest.testTmpDirDeletion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "reverting on incorrect .java files", "body": "Hello! I am trying to parse .java files, but I have some files which were decompiled with synthetic methods. example:\r\n\r\n```\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.ANNOTATION_TYPE })\r\npublic @interface ListenerClass {\r\n    ListenerMethod[] method() default {};\r\n    String remover() default \"\";\r\n\r\n    public enum NONE {\r\n        private static final /* synthetic */ NONE[] $VALUES;\r\n        static {\r\n            $VALUES = new NONE[0];\r\n        }\r\n        public static NONE valueOf(final String s) {\r\n            return Enum.valueOf(NONE.class, s);\r\n        }\r\n        public static NONE[] values() {\r\n            return NONE.$VALUES.clone();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\nit has synthetic enum methods, so it doesn't compile.\r\nI try to parse it by: \r\nLauncher launcher = new Launcher();\r\nlauncher.addInputResource(source.toAbsolutePath().toString());\r\nCtModel model = launcher.buildModel(); \r\n\r\nit gives me:\r\njava.lang.IllegalArgumentException: The method remover() should be a spoon.reflect.declaration.CtAnnotationMethod\r\n\r\nit breaks in CtAnnotationTypeImpl.addMethod because method has a type \"CtMethodImpl\", not a \"CtAnnotationMethod\".\r\n\r\nbut if you swap 2 lines: \r\nString remover() default \"\";\r\nListenerMethod[] method() default {};\r\n\r\nit works. Can you suggest what I can do with not really good .java files? Can I just skip places which doesn't compile? I didn't find any options for it. I think it works on jdt-eclipse. Thanks!\r\n", "url": "https://github.com/INRIA/spoon/issues/2946", "user": "Charmik", "labels": ["bug"], "created": "2019-04-16 15:39:35", "closed": "2019-06-17 07:01:13", "commits": {}, "ttf": 61.000277777777775, "commitsDetails": []}, {"title": "Problem modifying file code with static import.", "body": "When I modify the file (I only modify the parts that have TRY CATCH). Everything that is modified with static (example: import static org.fusesource.leveldbjni.JniDBFactory.asString;), are removed from the code, so when I am going to compile the code again I have not found variable errors, which are exactly these static imports .\r\n\r\nI have here the two files for comparison.\r\nI will show only the imports.\r\n\r\nORIGINAL CODE: \r\n\r\n```\r\npackage org.apache.hadoop.mapred;\r\n\r\nimport static org.fusesource.leveldbjni.JniDBFactory.asString;\r\nimport static org.fusesource.leveldbjni.JniDBFactory.bytes;\r\nimport static org.jboss.netty.buffer.ChannelBuffers.wrappedBuffer;\r\nimport static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;\r\nimport static org.jboss.netty.handler.codec.http.HttpMethod.GET;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.METHOD_NOT_ALLOWED;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.OK;\r\nimport static org.jboss.netty.handler.codec.http.HttpResponseStatus.UNAUTHORIZED;\r\nimport static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.RandomAccessFile;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.URL;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.ClosedChannelException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.ThreadFactory;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.regex.Pattern;\r\n\r\nimport javax.crypto.SecretKey;\r\n\r\nimport org.apache.hadoop.conf.Configuration;\r\nimport org.apache.hadoop.fs.Path;\r\nimport org.apache.hadoop.io.DataInputByteBuffer;\r\nimport org.apache.hadoop.io.DataOutputBuffer;\r\nimport org.apache.hadoop.io.ReadaheadPool;\r\nimport org.apache.hadoop.io.SecureIOUtils;\r\nimport org.apache.hadoop.io.Text;\r\nimport org.apache.hadoop.mapred.proto.ShuffleHandlerRecoveryProtos.JobShuffleInfoProto;\r\nimport org.apache.hadoop.mapreduce.MRConfig;\r\nimport org.apache.hadoop.mapreduce.security.SecureShuffleUtils;\r\nimport org.apache.hadoop.mapreduce.security.token.JobTokenIdentifier;\r\nimport org.apache.hadoop.mapreduce.security.token.JobTokenSecretManager;\r\nimport org.apache.hadoop.mapreduce.task.reduce.ShuffleHeader;\r\nimport org.apache.hadoop.metrics2.MetricsSystem;\r\nimport org.apache.hadoop.metrics2.annotation.Metric;\r\nimport org.apache.hadoop.metrics2.annotation.Metrics;\r\nimport org.apache.hadoop.metrics2.lib.DefaultMetricsSystem;\r\nimport org.apache.hadoop.metrics2.lib.MutableCounterInt;\r\nimport org.apache.hadoop.metrics2.lib.MutableCounterLong;\r\nimport org.apache.hadoop.metrics2.lib.MutableGaugeInt;\r\nimport org.apache.hadoop.security.proto.SecurityProtos.TokenProto;\r\nimport org.apache.hadoop.security.ssl.SSLFactory;\r\nimport org.apache.hadoop.security.token.Token;\r\nimport org.apache.hadoop.util.DiskChecker;\r\nimport org.apache.hadoop.util.Shell;\r\nimport org.apache.hadoop.util.concurrent.HadoopExecutors;\r\nimport org.apache.hadoop.yarn.api.records.ApplicationId;\r\nimport org.apache.hadoop.yarn.proto.YarnServerCommonProtos.VersionProto;\r\nimport org.apache.hadoop.yarn.server.api.ApplicationInitializationContext;\r\nimport org.apache.hadoop.yarn.server.api.ApplicationTerminationContext;\r\nimport org.apache.hadoop.yarn.server.api.AuxiliaryService;\r\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.ContainerLocalizer;\r\nimport org.apache.hadoop.yarn.server.records.Version;\r\nimport org.apache.hadoop.yarn.server.records.impl.pb.VersionPBImpl;\r\nimport org.apache.hadoop.yarn.server.utils.LeveldbIterator;\r\nimport org.fusesource.leveldbjni.JniDBFactory;\r\nimport org.fusesource.leveldbjni.internal.NativeDB;\r\nimport org.iq80.leveldb.DB;\r\nimport org.iq80.leveldb.DBException;\r\nimport org.iq80.leveldb.Options;\r\nimport org.jboss.netty.bootstrap.ServerBootstrap;\r\nimport org.jboss.netty.buffer.ChannelBuffers;\r\nimport org.jboss.netty.channel.Channel;\r\nimport org.jboss.netty.channel.ChannelFactory;\r\nimport org.jboss.netty.channel.ChannelFuture;\r\nimport org.jboss.netty.channel.ChannelFutureListener;\r\nimport org.jboss.netty.channel.ChannelHandler;\r\nimport org.jboss.netty.channel.ChannelHandlerContext;\r\nimport org.jboss.netty.channel.ChannelPipeline;\r\nimport org.jboss.netty.channel.ChannelPipelineFactory;\r\nimport org.jboss.netty.channel.ChannelStateEvent;\r\nimport org.jboss.netty.channel.Channels;\r\nimport org.jboss.netty.channel.ExceptionEvent;\r\nimport org.jboss.netty.channel.MessageEvent;\r\nimport org.jboss.netty.channel.SimpleChannelUpstreamHandler;\r\nimport org.jboss.netty.channel.group.ChannelGroup;\r\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\r\nimport org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\r\nimport org.jboss.netty.handler.codec.frame.TooLongFrameException;\r\nimport org.jboss.netty.handler.codec.http.DefaultHttpResponse;\r\nimport org.jboss.netty.handler.codec.http.HttpChunkAggregator;\r\nimport org.jboss.netty.handler.codec.http.HttpRequest;\r\nimport org.jboss.netty.handler.codec.http.HttpRequestDecoder;\r\nimport org.jboss.netty.handler.codec.http.HttpResponse;\r\nimport org.jboss.netty.handler.codec.http.HttpResponseEncoder;\r\nimport org.jboss.netty.handler.codec.http.HttpResponseStatus;\r\nimport org.jboss.netty.handler.codec.http.QueryStringDecoder;\r\nimport org.jboss.netty.handler.ssl.SslHandler;\r\nimport org.jboss.netty.handler.stream.ChunkedWriteHandler;\r\nimport org.jboss.netty.handler.timeout.IdleState;\r\nimport org.jboss.netty.handler.timeout.IdleStateAwareChannelHandler;\r\nimport org.jboss.netty.handler.timeout.IdleStateEvent;\r\nimport org.jboss.netty.handler.timeout.IdleStateHandler;\r\nimport org.jboss.netty.util.CharsetUtil;\r\nimport org.jboss.netty.util.HashedWheelTimer;\r\nimport org.jboss.netty.util.Timer;\r\nimport org.eclipse.jetty.http.HttpHeader;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport com.google.common.annotations.VisibleForTesting;\r\nimport com.google.common.base.Charsets;\r\nimport com.google.common.cache.CacheBuilder;\r\nimport com.google.common.cache.CacheLoader;\r\nimport com.google.common.cache.LoadingCache;\r\nimport com.google.common.cache.RemovalListener;\r\nimport com.google.common.cache.RemovalNotification;\r\nimport com.google.common.cache.Weigher;\r\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\r\nimport com.google.protobuf.ByteString;\r\n```\r\n\r\nOUTPUT CODE:\r\n\r\n```\r\npackage org.apache.hadoop.mapred;\r\n\r\n\r\nimport ChannelFutureListener.CLOSE;\r\nimport Charsets.UTF_8;\r\nimport HttpHeader.CONNECTION;\r\nimport HttpHeader.CONTENT_LENGTH;\r\nimport HttpHeader.KEEP_ALIVE;\r\nimport JniDBFactory.factory;\r\nimport JobID.JOBID_REGEX;\r\nimport MRConfig.SHUFFLE_SSL_ENABLED_DEFAULT;\r\nimport MRConfig.SHUFFLE_SSL_ENABLED_KEY;\r\nimport SSLFactory.Mode;\r\nimport SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH;\r\nimport SecureShuffleUtils.HTTP_HEADER_URL_HASH;\r\nimport ShuffleHeader.DEFAULT_HTTP_HEADER_NAME;\r\nimport ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION;\r\nimport ShuffleHeader.HTTP_HEADER_NAME;\r\nimport ShuffleHeader.HTTP_HEADER_VERSION;\r\nimport com.google.common.annotations.VisibleForTesting;\r\nimport com.google.common.cache.CacheBuilder;\r\nimport com.google.common.cache.LoadingCache;\r\nimport com.google.common.cache.RemovalNotification;\r\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\r\nimport com.google.protobuf.ByteString;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.RandomAccessFile;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.URL;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.ClosedChannelException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.ThreadFactory;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.regex.Pattern;\r\nimport javax.crypto.SecretKey;\r\nimport org.apache.hadoop.conf.Configuration;\r\nimport org.apache.hadoop.fs.Path;\r\nimport org.apache.hadoop.io.DataInputByteBuffer;\r\nimport org.apache.hadoop.io.DataOutputBuffer;\r\nimport org.apache.hadoop.io.ReadaheadPool;\r\nimport org.apache.hadoop.io.SecureIOUtils;\r\nimport org.apache.hadoop.mapred.proto.ShuffleHandlerRecoveryProtos.JobShuffleInfoProto;\r\nimport org.apache.hadoop.mapreduce.security.SecureShuffleUtils;\r\nimport org.apache.hadoop.mapreduce.security.token.JobTokenIdentifier;\r\nimport org.apache.hadoop.mapreduce.security.token.JobTokenSecretManager;\r\nimport org.apache.hadoop.mapreduce.task.reduce.ShuffleHeader;\r\nimport org.apache.hadoop.metrics2.MetricsSystem;\r\nimport org.apache.hadoop.metrics2.annotation.Metric;\r\nimport org.apache.hadoop.metrics2.annotation.Metrics;\r\nimport org.apache.hadoop.metrics2.lib.DefaultMetricsSystem;\r\nimport org.apache.hadoop.metrics2.lib.MutableCounterInt;\r\nimport org.apache.hadoop.metrics2.lib.MutableCounterLong;\r\nimport org.apache.hadoop.metrics2.lib.MutableGaugeInt;\r\nimport org.apache.hadoop.security.proto.SecurityProtos.TokenProto;\r\nimport org.apache.hadoop.security.ssl.SSLFactory;\r\nimport org.apache.hadoop.security.token.Token;\r\nimport org.apache.hadoop.util.DiskChecker;\r\nimport org.apache.hadoop.util.Shell;\r\nimport org.apache.hadoop.util.concurrent.HadoopExecutors;\r\nimport org.apache.hadoop.yarn.api.records.ApplicationId;\r\nimport org.apache.hadoop.yarn.proto.YarnServerCommonProtos.VersionProto;\r\nimport org.apache.hadoop.yarn.server.api.ApplicationInitializationContext;\r\nimport org.apache.hadoop.yarn.server.api.ApplicationTerminationContext;\r\nimport org.apache.hadoop.yarn.server.api.AuxiliaryService;\r\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.ContainerLocalizer;\r\nimport org.apache.hadoop.yarn.server.records.Version;\r\nimport org.apache.hadoop.yarn.server.utils.LeveldbIterator;\r\nimport org.fusesource.leveldbjni.internal.NativeDB;\r\nimport org.iq80.leveldb.DB;\r\nimport org.iq80.leveldb.DBException;\r\nimport org.iq80.leveldb.Options;\r\nimport org.jboss.netty.bootstrap.ServerBootstrap;\r\nimport org.jboss.netty.buffer.ChannelBuffers;\r\nimport org.jboss.netty.channel.Channel;\r\nimport org.jboss.netty.channel.ChannelFactory;\r\nimport org.jboss.netty.channel.ChannelFuture;\r\nimport org.jboss.netty.channel.ChannelFutureListener;\r\nimport org.jboss.netty.channel.ChannelHandler;\r\nimport org.jboss.netty.channel.ChannelHandlerContext;\r\nimport org.jboss.netty.channel.ChannelPipeline;\r\nimport org.jboss.netty.channel.ChannelPipelineFactory;\r\nimport org.jboss.netty.channel.ChannelStateEvent;\r\nimport org.jboss.netty.channel.Channels;\r\nimport org.jboss.netty.channel.ExceptionEvent;\r\nimport org.jboss.netty.channel.MessageEvent;\r\nimport org.jboss.netty.channel.SimpleChannelUpstreamHandler;\r\nimport org.jboss.netty.channel.group.ChannelGroup;\r\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\r\nimport org.jboss.netty.handler.codec.frame.TooLongFrameException;\r\nimport org.jboss.netty.handler.codec.http.HttpChunkAggregator;\r\nimport org.jboss.netty.handler.codec.http.HttpRequest;\r\nimport org.jboss.netty.handler.codec.http.HttpRequestDecoder;\r\nimport org.jboss.netty.handler.codec.http.HttpResponse;\r\nimport org.jboss.netty.handler.codec.http.HttpResponseEncoder;\r\nimport org.jboss.netty.handler.codec.http.HttpResponseStatus;\r\nimport org.jboss.netty.handler.ssl.SslHandler;\r\nimport org.jboss.netty.handler.stream.ChunkedWriteHandler;\r\nimport org.jboss.netty.handler.timeout.IdleState;\r\nimport org.jboss.netty.handler.timeout.IdleStateAwareChannelHandler;\r\nimport org.jboss.netty.handler.timeout.IdleStateEvent;\r\nimport org.jboss.netty.util.HashedWheelTimer;\r\nimport org.jboss.netty.util.Timer;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n```\r\n\r\n\r\n\r\nthis is the SPOON (7.3.0) configuration that I use in code.\r\n\r\n```\r\nspoon = new Launcher();\r\nspoon.getEnvironment().setNoClasspath(true);\r\nspoon.addInputResource(f.getAbsolutePath());\r\nspoon.getEnvironment().setCommentEnabled(true);\r\nspoon.getEnvironment().setAutoImports(true);\r\nspoon.setSourceOutputDirectory(PathProject.getPathTemp());\r\n```\r\n\r\n\r\nI have already tried using `spoon.getEnvironment().setAutoImports(false);` also, but I continued with the same problem.\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/2927", "user": "LuanPereiraLima", "labels": ["bug"], "created": "2019-04-03 21:49:11", "closed": "2019-09-10 10:55:42", "commits": {}, "ttf": 159.00027777777777, "commitsDetails": []}, {"title": "Bug adding comment in AST in CtCatch", "body": "The following code example triggers \r\n\r\n> 2019-02-27 13:02:47,477 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - \"// offending comment\" cannot be added into the AST, with parent class spoon.support.reflect.code.CtCatchImplplease report the bug by posting on https://github.com/INRIA/spoon/issues/2482\r\n\r\n```\r\npackage de.test;\r\n\r\npublic class Test {\r\n   \r\n   public static void exampleMethod() {\r\n      try {\r\n         Object o = new Object();\r\n      } catch (Exception e) // first comment \r\n      // offending comment\r\n      {\r\n         // some catch-Block-Code...\r\n      }\r\n   }\r\n}\r\n```\r\n\r\nBy the way I suggest two little optimisations in the error-output:\r\n- it would help a lot to output not just the comment but the SourcePosition as it is available with CtElement.getPosition(). The way it is it took me quite a while to figure out the offending code-snippet in a large codebase scanned...\r\n- before \"please\" there is missing a whitespace (makes it harder to read)", "url": "https://github.com/INRIA/spoon/issues/2894", "user": "blackfoxoh", "labels": ["bug"], "created": "2019-02-27 12:11:05", "closed": "2019-06-19 14:06:24", "commits": {}, "ttf": 112.00027777777778, "commitsDetails": []}, {"title": "EvalHelper#getCorrespondingRuntimeObject doesn't handle valid field references", "body": "Currently, [EvalHelper#getCorrespondingRuntimeObject ](https://github.com/INRIA/spoon/blob/ee7b9d962eb3b56d048302fedf5fdc7f76db7e55/src/main/java/spoon/support/reflect/eval/EvalHelper.java#L70) only supports references to enum fields. However, Java annotations can also reference static fields of other classes (e.g. `Integer.MAX_VALUE`).\r\n\r\nTo make methods such as `CtAnnotation#getValueAsObject` more useful, `EvalHelper#getCorrespondingRuntimeObject` should be extended to support all valid annotaiton field reads.", "url": "https://github.com/INRIA/spoon/issues/2891", "user": "Aaron1011", "labels": ["bug"], "created": "2019-02-24 02:20:00", "closed": "2019-03-08 11:59:34", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "ArrayIndexOutOfBoundsException in PositionBuilder", "body": "This code in `spoon.support.compiler.jdt.PositionBuilder.buildPositionCtElement()`:\r\n\r\n    if (contents[bodyStart - 1] == '{') {\r\n        bodyStart--;\r\n        if (contents[bodyEnd + 1] == '}') {\r\n            bodyEnd++;\r\n        } else {\r\n            ...\r\n        }\r\n    }\r\n\r\ncrashes for a source file that misses braces at the end.\r\n\r\nStack trace:\r\n\r\n    java.lang.ArrayIndexOutOfBoundsException: 5736\r\n        at spoon.support.compiler.jdt.PositionBuilder.buildPositionCtElement(PositionBuilder.java:354)\r\n        at spoon.support.compiler.jdt.ContextBuilder.enter(ContextBuilder.java:100)\r\n        at spoon.support.compiler.jdt.JDTTreeBuilder.visit(JDTTreeBuilder.java:1059)\r\n        at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:335)\r\n        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1414)\r\n        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:816)\r\n        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:777)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.lambda$buildModel$0(JDTBasedSpoonCompiler.java:433)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.forEachCompilationUnit(JDTBasedSpoonCompiler.java:457)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:431)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:375)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:340)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:123)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:106)\r\n        at spoon.Launcher.buildModel(Launcher.java:772)", "url": "https://github.com/INRIA/spoon/issues/2888", "user": "rolve", "labels": ["bug"], "created": "2019-02-22 17:04:15", "closed": "2019-03-11 17:51:30", "commits": {}, "ttf": 17.00027777777778, "commitsDetails": []}, {"title": "SpoonException when setting the content of a comment that begins with //", "body": "I am using Spoon to anonymize Java files, so I am removing instances of names inside comments. I get the content of the comment using `CtComment.getContent()`, replace some stuff, and put the new string back using `setContent()`.\r\n\r\nHowever, if the original content of a multi-line comment starts with `//`, then the code in `JDTCommentBuilder.cleanComment()` throws an exception, because it thinks this is a single-line comment (but it is the *content* of a multi-line comment that happens to *look like* a single-line comment).\r\n\r\nThe original comment looks for example like this:\r\n\r\n    /*\r\n    // foo\r\n    bar\r\n    */\r\n\r\nWhy is `cleanComment()` even used? Isn't `setContent()` supposed to modify only the *content* of the comment, without dealing with comment markers?", "url": "https://github.com/INRIA/spoon/issues/2887", "user": "rolve", "labels": ["bug"], "created": "2019-02-22 15:57:36", "closed": "2019-03-05 22:40:07", "commits": {}, "ttf": 11.000277777777777, "commitsDetails": []}, {"title": "Dead link", "body": "Bytecode analysis\r\nNote that spoon also supports the analysis of bytecode through decompilation. See javadoc. <<<<< this link\r\n\r\n\r\nhttp://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/JarLauncher.html", "url": "https://github.com/INRIA/spoon/issues/2868", "user": "dwightfowler", "labels": ["bug", "chore"], "created": "2019-02-01 21:33:03", "closed": "2019-02-07 15:55:20", "commits": {"67e514c2ae088eef5dba82af5a93766bee93edf8": {"commitGHEventType": "referenced", "commitUser": "monperrus"}, "7b11c0e040951fb459d31369ea188e0bdfcf5540": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "67e514c2ae088eef5dba82af5a93766bee93edf8", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7b11c0e040951fb459d31369ea188e0bdfcf5540", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["6e18bbfe4db86c1f1096aa5a2914e52dc9ecdc20"], "nameRev": "7b11c0e040951fb459d31369ea188e0bdfcf5540 tags/spoon-core-7.3.0~2", "commitMessage": "doc: fix broken link (#2871)\n\nfix #2868. (the reason is that only module spoon-core is deployed as maven site with javadoc)", "commitDateTime": "2019-02-07 16:55:19", "authoredDateTime": "2019-02-07 16:55:19", "commitGitStats": [{"filePath": "doc/launcher.md", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "If module-info.java exists, compliance level should be >=9 otherwise stop with clear message", "body": "Hello,\r\n\r\nTo reproduce the problem it is needed to create a project with the following structure:\r\n\r\n- D:\\\\untitled\\\\SomeModule\r\n    - src\r\n        - api\r\n            - api.java\r\n            - module-info.java\r\n\r\nA new `module-info.java` has appeared in Java 9.\r\n\r\nIf you add a comment (any one in any place) in `module-info.java`, for example:\r\n\r\n```\r\nmodule SomeModule {\r\n  /*some exports*/\r\n}\r\n```\r\nand execute the following code:\r\n\r\n```\r\nLauncher launcher = new Launcher();\r\nlauncher.addInputResource(\"D:\\\\untitled\\\\SomeModule\");\r\nlauncher.buildModel();\r\n```\r\n\r\nWe'll get:\r\n\r\n```\r\nException in thread \"main\" spoon.SpoonException: Unexpected lineSeparatorPositions\r\n     at spoon.support.reflect.cu.position.SourcePositionImpl.<init>(SourcePositionImpl.java:123)\r\n     at spoon.support.DefaultCoreFactory.createSourcePosition(DefaultCoreFactory.java:762)\r\n     at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:144)\r\n     at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:111)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.lambda$buildModel$2(JDTBasedSpoonCompiler.java:443)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.forEachCompilationUnit(JDTBasedSpoonCompiler.java:457)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:442)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:375)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:340)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:123)\r\n     at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:106)\r\n     at spoon.Launcher.buildModel(Launcher.java:772)\r\n```\r\n\r\nIf you delete all comments from the `module-info.java`, the method `launcher.buildModel()` will be executed without any exceptions. ", "url": "https://github.com/INRIA/spoon/issues/2861", "user": "SvyatoslavRazmyslov", "labels": ["bug", "good first issue", "help wanted"], "created": "2019-01-30 11:46:32", "closed": "2019-05-24 05:24:00", "commits": {}, "ttf": 113.00027777777778, "commitsDetails": []}, {"title": "StackOverflowError in CtAnnotation#getValueOfObject", "body": "CtAnnotation#getValueOfObject fails with a StackOverflowError when the value of the annotation parameter is an operation that references a constant that is not in the model built by Spoon.\r\n\r\nThe sample project https://github.com/seintur/spoon-annotation-getValueAsObject reproduces the bug.", "url": "https://github.com/INRIA/spoon/issues/2858", "user": "seintur", "labels": ["bug"], "created": "2019-01-26 21:28:53", "closed": "2019-02-07 17:42:15", "commits": {}, "ttf": 11.000277777777777, "commitsDetails": []}, {"title": "NoSuchMethodError when compiling code", "body": "I tried to run the following code (from the examples) using the newest version of spoon (7.2.0):\r\n```\r\nLauncher l = new Launcher();\r\n\t\tl.getEnvironment().setNoClasspath(true);\r\n\t\tl.addInputResource(\"src/main/java\");\r\n\t\tl.addProcessor(new HelloWorldProcessor());\r\n\t\tl.run();\r\n```\r\nUp until 7.1.0 this was working fine. Furthermore there is no error in the IDE. Only during compilation it fails with the following exception:\r\n\r\n```\r\nRunning fr.inria.gforge.spoon.HelloWorldProcessorTest\r\n\"hello world\"\r\nTests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.16 sec <<< FAILURE! - in fr.inria.gforge.spoon.HelloWorldProcessorTest\r\ntestName(fr.inria.gforge.spoon.HelloWorldProcessorTest)  Time elapsed: 0.159 sec  <<< ERROR!\r\njava.lang.NoSuchMethodError: spoon.reflect.declaration.CtCompilationUnit.getImports()Ljava/util/List;\r\n        at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:2005)\r\n        at spoon.support.JavaOutputProcessor.createJavaFile(JavaOutputProcessor.java:125)\r\n        at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:161)\r\n        at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:46)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:74)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:652)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:651)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:651)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:651)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:651)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n        at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:651)\r\n        at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:176)\r\n        at spoon.reflect.visitor.CtScanner.visitCtModule(CtScanner.java:926)\r\n        at spoon.reflect.factory.ModuleFactory$CtUnnamedModule.accept(ModuleFactory.java:105)\r\n        at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:184)\r\n        at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)\r\n        at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:129)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingTypes(JDTBasedSpoonCompiler.java:487)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:211)\r\n        at spoon.Launcher.prettyprint(Launcher.java:789)\r\n        at spoon.Launcher.run(Launcher.java:727)\r\n        at fr.inria.gforge.spoon.HelloWorldProcessorTest.testName(HelloWorldProcessorTest.java:14)\r\n\r\n```", "url": "https://github.com/INRIA/spoon/issues/2850", "user": "djuelg", "labels": ["bug"], "created": "2019-01-02 16:17:45", "closed": "2019-02-11 08:50:43", "commits": {}, "ttf": 39.000277777777775, "commitsDetails": []}, {"title": "NPE in CtTypeReferenceImpl#isInSamePackage in noclasspath", "body": "Version 7.2.0 and 7.3.0-SNAPSHOT\r\n\r\nI receive this exception when I try to run Spoon in noclasspath:\r\n\r\n```java\r\nException in thread \"main\" spoon.SpoonException: Printing of spoon.support.reflect.code.CtThisAccessImpl on path \r\n\tCtClassImpl:InCondition\r\n\tCtConstructorImpl:<init>\r\n\tCtBlockImpl\r\n\tCtAssignmentImpl\r\n\tCtFieldWriteImpl\r\n\tCtThisAccessImpl\r\nat position (/home/tdurieux/git/patch-clustering/Expression.java:348) failed\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:354)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:67)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.printCtFieldAccess(DefaultJavaPrettyPrinter.java:871)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtFieldWrite(DefaultJavaPrettyPrinter.java:804)\r\n\tat spoon.support.reflect.code.CtFieldWriteImpl.accept(CtFieldWriteImpl.java:27)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:59)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtAssignment(DefaultJavaPrettyPrinter.java:494)\r\n\tat spoon.support.reflect.code.CtAssignmentImpl.accept(CtAssignmentImpl.java:55)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:67)\r\n\tat spoon.reflect.visitor.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:182)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtBlock(DefaultJavaPrettyPrinter.java:526)\r\n\tat spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:67)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtConstructor(DefaultJavaPrettyPrinter.java:704)\r\n\tat spoon.support.reflect.declaration.CtConstructorImpl.accept(CtConstructorImpl.java:57)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:67)\r\n\tat spoon.reflect.visitor.ElementPrinterHelper.writeElementList(ElementPrinterHelper.java:196)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtClass(DefaultJavaPrettyPrinter.java:622)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector$1.scan(CopyPasteDetector.java:67)\r\n\tat add.features.detector.repairpatterns.CopyPasteDetector.detect(CopyPasteDetector.java:75)\r\n\tat add.features.detector.repairpatterns.RepairPatternDetector.analyze(RepairPatternDetector.java:45)\r\n\tat add.features.detector.repairpatterns.RepairPatternDetector.analyze(RepairPatternDetector.java:15)\r\n\tat add.main.Launcher.execute(Launcher.java:154)\r\n\tat add.main.Launcher.main(Launcher.java:167)\r\nCaused by: java.lang.NullPointerException\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.isInSamePackage(CtTypeReferenceImpl.java:665)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.canAccess(CtTypeReferenceImpl.java:656)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.getAccessType(CtTypeReferenceImpl.java:691)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtTypeReference(DefaultJavaPrettyPrinter.java:1824)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtTypeReferenceWithoutGenerics(DefaultJavaPrettyPrinter.java:1808)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtThisAccess(DefaultJavaPrettyPrinter.java:948)\r\n\tat spoon.support.reflect.code.CtThisAccessImpl.accept(CtThisAccessImpl.java:28)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:345)\r\n\t... 29 more\r\n```", "url": "https://github.com/INRIA/spoon/issues/2845", "user": "tdurieux", "labels": ["bug"], "created": "2018-12-20 14:07:59", "closed": "2019-06-23 14:40:54", "commits": {}, "ttf": 185.00027777777777, "commitsDetails": []}, {"title": "comment in lambda expression triggers a ParentNotInitializedException", "body": "It looks like comments in lambda expressions are a problem for 7.1.0 version of spoon lib.\r\n\r\n```\r\nOptional<Field> fieldConditionValueOptional = join.getConditions().stream().filter(condition -> //\r\n            condition.getDescription().getName().equals(fieldName)\r\n                    && (condition.getOperator() == EQUAL || condition.getOperator() == IS_EMPTY)\r\n                    && condition instanceof FieldCondition)\r\n                    .map(condition -> new Field(condition.getDescription(),\r\n                            condition.getOperator() == EQUAL ? condition.getValue() : condition.getDescription().getInitialValue()))\r\n                    .findFirst();\r\n```\r\n\r\n```\r\n09:25:19.480 [main] ERROR jdt.JDTCommentBuilder - //  is not added into the AST\r\nspoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/PATHTOSOURCE/OP10704.java:1686)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375) ~[spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:493) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:157) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:113) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:477) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:390) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105) [spoon-core-7.1.0.jar:?]\r\n\tat spoon.Launcher.buildModel(Launcher.java:767) [spoon-core-7.1.0.jar:?]\r\n\tat xxx.xxxxxx.xxxxxx.xxxxxxx.ApplicationInitFinder.main(ApplicationInitFinder.java:65) [main/:?]\r\n```", "url": "https://github.com/INRIA/spoon/issues/2801", "user": "stefanleh", "labels": ["bug"], "created": "2018-11-30 08:35:15", "closed": "2019-06-17 13:01:18", "commits": {}, "ttf": 199.00027777777777, "commitsDetails": []}, {"title": "BUG: import static with wildcard cannot be compiled.", "body": "Hi all.\r\n\r\nIt seems that Spoon is not able anymore to compile java classes with a static import using a wildcard.\r\n\r\nI created a JUnit test to reproduce the bug, see this [branch](https://github.com/danglotb/spoon/tree/bug-import-static-wildcard) or use the following lines:\r\n\r\n```sh\r\ngit remote add danglotb https://github.com/danglotb/spoon\r\ngit fetch danglotb bug-import-static-wildcard\r\ngit checkout bug-import-static-wildcard\r\n```\r\n\r\nThe corresponding failing test is `spoon.test.compilation.CompilationTest#compileTestWithImportStaticWildcard()`.\r\n\r\nBug for assertfixer", "url": "https://github.com/INRIA/spoon/issues/2780", "user": "danglotb", "labels": ["bug"], "created": "2018-11-26 13:33:05", "closed": "2019-02-06 08:46:37", "commits": {}, "ttf": 71.00027777777778, "commitsDetails": []}, {"title": "bug in comments inside the lambda expression", "body": "The comments in the lambda expression are reported to have errors.\r\n\r\nAn example code:\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class CommentInLambdaExpressionTest {\r\n\r\npublic static void main(String[] args) {\r\n\tCommentInLambdaExpressionTest test = new CommentInLambdaExpressionTest();\r\n\tList<Integer> lst = test.setup();\r\n\tSystem.out.println(lst);\r\n}\r\n\r\npublic List<Integer> setup() {\r\n\tList<Integer> messages = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\r\n\treturn messages.stream().filter( num -> \r\n\t// comment in lambda expression\r\n\tnum > 5\r\n\t).collect(Collectors.toList());\r\n}\r\n}\r\n```\r\nThe code triggers the error:\r\n`2018-11-08 10:11:15,847 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - \"// comment in lambda expression\" cannot be added into the AST, with parent class spoon.support.reflect.code.CtLambdaImplplease report the bug by posting on #2482`", "url": "https://github.com/INRIA/spoon/issues/2763", "user": "rihou", "labels": ["bug"], "created": "2018-11-12 14:48:54", "closed": "2019-02-23 05:37:47", "commits": {}, "ttf": 102.00027777777778, "commitsDetails": []}, {"title": "bug: validate TypeFactory.createTypeParameterReference() input", "body": "In older versions of Spoon, it was legit to write `typeFactory.createTypeParameterReference(\"?\")`. Now it should be considered a mistake, `CoreFactory.createWildcardReference()` should be used instead.\r\n\r\nGenerally the input of factory methods that return all kind of references, classes, etc. could be validated better. JLS puts some constraints on what strings could be class names, method names, variable names, etc.", "url": "https://github.com/INRIA/spoon/issues/2736", "user": "leventov", "labels": ["bug"], "created": "2018-11-02 16:44:49", "closed": "2019-02-24 23:11:21", "commits": {"f4fd11296244ba117c90456194515251e7ef041f": {"commitGHEventType": "referenced", "commitUser": "nharrand"}}, "ttf": 114.00027777777778, "commitsDetails": [{"commitHash": "f4fd11296244ba117c90456194515251e7ef041f", "commitGHEventType": "referenced", "commitUser": "nharrand", "commitParents": ["f34a71edd2996d48322659a80e1f1b32e4dc3ba2"], "nameRev": "f4fd11296244ba117c90456194515251e7ef041f tags/spoon-core-7.4.0~39", "commitMessage": "fix(TypeFactory): raise an exception for deprecated createTypeParameterReference wildcard (#2890)\n\n fix#2736", "commitDateTime": "2019-02-25 00:11:21", "authoredDateTime": "2019-02-25 00:11:21", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/factory/TypeFactory.java", "insertions": 4, "deletions": 0, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "TypeFactory.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.factory.TypeFactory.createTypeParameterReference(java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "CtExecutableReference cannot use CtTypeParameterReference. Use boundingType of CtTypeParameterReference instead", "body": "For the record our CI using Spoon against Guava is in bad shape since the beginning of the month. See: https://ci.inria.fr/sos/job/Guava/\r\n\r\nLast error we got is the following:\r\n\r\n```\r\n[ERROR] Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.4:generate (default) on project guava: Exception during the spoonify of the target project. spoon.SpoonException: CtExecutableReference cannot use CtTypeParameterReference. Use boundingType of CtTypeParameterReference instead. -> [Help 1]\r\n```", "url": "https://github.com/INRIA/spoon/issues/2721", "user": "surli", "labels": ["bug"], "created": "2018-10-26 15:52:50", "closed": "2018-10-29 19:10:24", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "bug: Default expression of field of shadow type is not initialized", "body": "If the class below comes from JAR file (sources are not available for spoon)\r\n```java\r\nclass A {\r\n String field = \"defaultExpression\";\r\n}\r\n```\r\nbug: then default expression of `field` is null.\r\nexpected: then default expression of `field` is `\"defaultExpression\"`", "url": "https://github.com/INRIA/spoon/issues/2698", "user": "pvojtechovsky", "labels": ["bug"], "created": "2018-10-19 09:08:00", "closed": "2019-04-04 05:20:12", "commits": {}, "ttf": 166.00027777777777, "commitsDetails": []}, {"title": "bug: the order of imports is changed in sniper mode", "body": "the order of imports is changed in sniper mode\r\n\r\nspin-off of #2615", "url": "https://github.com/INRIA/spoon/issues/2638", "user": "monperrus", "labels": ["bug"], "created": "2018-10-08 18:27:57", "closed": "2019-09-10 10:55:49", "commits": {}, "ttf": 336.0002777777778, "commitsDetails": []}, {"title": "Change DefaultJavaPrettyPrinter to respect checkstyle", "body": "Idea born in https://github.com/INRIA/spoon/pull/2527#issuecomment-426017038", "url": "https://github.com/INRIA/spoon/issues/2610", "user": "zielint0", "labels": ["bug"], "created": "2018-10-01 20:30:29", "closed": "2018-10-17 19:57:57", "commits": {}, "ttf": 15.000277777777777, "commitsDetails": []}, {"title": "tests fail with windows", "body": "cannot be built on windows see https://ci.inria.fr/sos/job/spoon-windows/", "url": "https://github.com/INRIA/spoon/issues/2584", "user": "spoon-bot", "labels": ["bug"], "created": "2018-09-30 10:41:52", "closed": "2019-04-04 16:19:34", "commits": {}, "ttf": 186.00027777777777, "commitsDetails": []}, {"title": "bug: imports added to generated sources are never used", "body": "Test case:\r\n* The Spoon pattern is based on java source which imports template class like e.g. `com.somepackage.Request`\r\n* The Spoon pattern replaces this template class by another class, so the `com.somepackage.Request` isn't used in generated code.\r\n\r\nbug: printed sources contains import of `com.somepackage.Request` if any javadoc contains substring \"Request\".\r\nI my case the javadoc was, which caused that is: `Generated by com.somepackage_generator.templates.soap.RequestBuilderTemplate#serviceWrapper(RequestBuilderTemplate.java:25)`\r\n\r\nThe problem is in /spoon-core/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java method visitCtJavaDoc\r\nin code\r\n`javadoc.contains(ctImport.getReference().getSimpleName())`\r\n\r\nSpoon should understand javadoc better before it marks import as used.", "url": "https://github.com/INRIA/spoon/issues/2485", "user": "pvojtechovsky", "labels": ["bug"], "created": "2018-09-20 07:50:38", "closed": "2018-09-21 07:41:37", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bugs: bugs found with static analyzer PVS-Studio Java", "body": "Hello!\r\nI found several bugs in Spoon with our PVS-Studio Java static analyzer prototype.\r\n\r\n1.\r\nhttps://github.com/INRIA/spoon/blob/6b07da89021260f2222212ec1cd523ae9f4ec72f/src/main/java/spoon/support/visitor/ClassTypingContext.java#L218-L227 **Warning:** V6008 Null dereference of 'type'. ClassTypingContext.java:225\r\n\r\n2.\r\nhttps://github.com/INRIA/spoon/blob/97f6af6a14ba948050f087e205cc43d9b1516460/src/main/java/spoon/support/compiler/jdt/PositionBuilder.java#L691-L696 **Warning:** V6007 Expression 'content[off] == '\\n'' is always false. PositionBuilder.java:694\r\n\r\nProbably forgot to increment `off` here.\r\n\r\n3.\r\nhttps://github.com/INRIA/spoon/blob/8f14f3d0af5a21eef32a061224abbc786e7d3484/src/test/java/spoon/support/visitor/java/JavaReflectionTreeBuilderTest.java#L244-L245 **Warning:** V6009 Function 'equals' receives an odd argument. An object 'removeModifiers(elementModifiers, ModifierKind.PUBLIC, ModifierKind.ABSTRACT)' is used as an argument to its own method. JavaReflectionTreeBuilderTest.java:244\r\n\r\n\r\nhttps://github.com/INRIA/spoon/blob/8f14f3d0af5a21eef32a061224abbc786e7d3484/src/test/java/spoon/support/visitor/java/JavaReflectionTreeBuilderTest.java#L253-L254 **Warning:** V6009 Function 'equals' receives an odd argument. An object 'removeModifiers(elementModifiers, ModifierKind.PUBLIC)' is used as an argument to its own method. JavaReflectionTreeBuilderTest.java:253\r\n\r\nI'm pretty sure that `otherModifiers` (which is unused now) should be used here.\r\n\r\n4.\r\nhttps://github.com/INRIA/spoon/blob/88fe9031bca9d7c9cbb2103cb9e66ab5936760a9/src/main/java/spoon/metamodel/MMMethodKind.java#L114-L117 **Warning:** V6007 Expression 'result.level == k.level' is always false. MMMethodKind.java:115\r\n\r\nWe've already checked that `result.level < k.level`, how could it be `result.level == k.level`?\r\n\r\n5.\r\nhttps://github.com/INRIA/spoon/blob/267199348663afc9d94b8896ef9be714350a3d3a/src/main/java/spoon/support/reflect/declaration/CtEnumImpl.java#L115-L117 **Warning:** V6060 The 'enumValues' reference was utilized before it was verified against null. CtEnumImpl.java:117, CtEnumImpl.java:116\r\n\r\nhttps://github.com/INRIA/spoon/blob/79980e9ee7785f406115d7a07d44f20d8274add1/src/main/java/spoon/pattern/PatternBuilder.java#L116-L117 **Warning:** V6060 The 'template' reference was utilized before it was verified against null. PatternBuilder.java:117, PatternBuilder.java:116\r\n\r\nhttps://github.com/INRIA/spoon/blob/c020be3c28e95e1803abf79a63c8d9b1f649f203/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java#L310-L312 **Warning:** V6060 The 'cuDeclaration' reference was utilized before it was verified against null. ReferenceBuilder.java:312, ReferenceBuilder.java:310\r\n\r\nThese checks for null make no sense, because we would get NRE earlier anyway.\r\n\r\n6.\r\nThere are lots of suspicious unused variables as well. Here is the list:\r\n**Warning:** V6021 Variable 'tpr' is not used. RoleHandlersGenerator.java:147\r\n**Warning:** V6021 Variable 'caseStmt' is not used. PositionBuilder.java:390\r\n**Warning:** V6021 Variable 'mapEntryNode' is not used. PatternParameterConfigurator.java:601\r\n**Warning:** V6021 Variable 'mmMethod' is not used. MetamodelProperty.java:112\r\n**Warning:** V6021 Variable 'executableTypeReference' is not used. JDTTreeBuilderHelper.java:240\r\n**Warning:** V6021 Variable 'executableFactory' is not used. JDTTreeBuilderHelper.java:190\r\n**Warning:** V6021 Variable 'typeFactory' is not used. JDTTreeBuilderHelper.java:188\r\n**Warning:** V6021 Variable 'innerClass' is not used. ImportScannerImpl.java:697\r\n**Warning:** V6021 Variable 'childSPI' is not used. ElementSourceFragment.java:184\r\n**Warning:** V6021 Variable 'sp' is not used. ElementSourceFragment.java:142\r\n", "url": "https://github.com/INRIA/spoon/issues/2483", "user": "Egor18", "labels": ["bug"], "created": "2018-09-19 14:51:47", "closed": "2018-09-26 06:04:52", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "bug: bug in comment association and pretty-printing", "body": "Hi, I am not sure if this is a bug for printing the source code with the comments.\r\n\r\nOriginal:\r\n```\r\npublic final class test{\r\n\r\n    \r\n// ------------------------------------ //\r\n// test / test test     //\r\n// ------------------------------------ //\r\n\r\n    /**\r\n     * test2\r\n     *\r\n     */   \r\n    public interface testInterface {\r\n        /**\r\n         * test3\r\n         * \r\n         */\r\n        public void mytest(short a, short b);\r\n    }\r\n    private static class myInterface implements testInterface {\r\n        public void mytest(short a, short b){\r\n            \r\n        }\r\n    }\r\n    \r\n}//end class test\r\n\r\n```\r\nPretty-printed by Spoon Launcher:\r\n```\r\n\r\n\r\npublic final class test {\r\n    // ------------------------------------ //\r\n    public interface testInterface {\r\n        // test / test test     //\r\n        // ------------------------------------ //\r\n        /**\r\n         * test2\r\n         */\r\n        /**\r\n         * test3\r\n         */\r\n        public void mytest(short a, short b);\r\n    }\r\n\r\n    private static class myInterface implements test.testInterface {\r\n        public void mytest(short a, short b) {\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\nSo the problem is:\r\n1. the test comment is printed inside of the interface class instead of being outside\r\n2. the comment that marks the end of the class is gone", "url": "https://github.com/INRIA/spoon/issues/2482", "user": "tempuser1909", "labels": ["bug"], "created": "2018-09-19 08:00:34", "closed": "2018-10-08 18:33:15", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "spoon-maven-plugin: <enableComments>false</enableComments>", "body": "Now that comments are enabled by default now, it seems that \r\n\r\n    <enableComments>false</enableComments>\r\n\r\ndoes not work anymore in spoon-maven-plugin\r\n\r\n@surli WDYT?", "url": "https://github.com/INRIA/spoon/issues/2465", "user": "monperrus", "labels": ["bug", "spoon-maven-plugin"], "created": "2018-09-14 21:20:33", "closed": "2018-09-27 17:57:32", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "bug: Spoon rewrite license header making license checks failing", "body": "For example when using this license:\r\n```\r\n/*\r\n * See the NOTICE file distributed with this work for additional\r\n * information regarding copyright ownership.\r\n *\r\n * This is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU Lesser General Public License as\r\n * published by the Free Software Foundation; either version 2.1 of\r\n * the License, or (at your option) any later version.\r\n *\r\n * This software is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this software; if not, write to the Free\r\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\r\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\r\n */\r\n```\r\n\r\nSpoon will rewrite it like this:\r\n```\r\n/**\r\n * See the NOTICE file distributed with this work for additional information regarding copyright ownership.\r\n *\r\n * This is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any\r\n * later version.\r\n *\r\n * This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this software; if not, write to\r\n * the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF site:\r\n * http://www.fsf.org.\r\n */\r\n```\r\n\r\nand the license checkers will fail. We should keep as much as possible the same style. \r\nIssue spotted here: https://github.com/STAMP-project/dspot/issues/538", "url": "https://github.com/INRIA/spoon/issues/2443", "user": "surli", "labels": ["bug"], "created": "2018-09-05 11:30:22", "closed": "2018-09-30 15:16:47", "commits": {}, "ttf": 25.00027777777778, "commitsDetails": []}, {"title": "[ImportScanner] SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext", "body": "Preconditions:\r\n### Test2.java\r\n```\r\npublic class Test2 {\r\n    private interface TestInt {\r\n        String implementThis(String string);\r\n    }\r\n\r\n    //static, extends, implements and return method() - all that things needed\r\n    static class Test3 extends ParentForTest implements TestInt {\r\n        @Override\r\n        public String implementThis(final String string) {\r\n            return testMethod();\r\n        }\r\n    }\r\n}\r\n```\r\n### ParentForTest.java\r\n```\r\npublic class ParentForTest{\r\n    public String testMethod() {\r\n        return \"\";\r\n    }\r\n}\r\n```\r\n### Main.java\r\n```\r\n        final Launcher launcher = new Launcher();\r\n        launcher.addInputResource(\"/path/Test2.java\");\r\n        launcher.buildModel();\r\n\r\n        for (final CtType clazz : launcher.getModel().getAllTypes()) {\r\n                ImportScanner importScanner = new ImportScannerImpl();\r\n                importScanner.computeImports(class);\r\n                Set<CtImport> allImports = importScanner.getAllImports();\r\n        }\r\n```\r\n### Run\r\n\r\n\r\nException in thread \"main\" spoon.SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext, was spoon.support.visitor.ClassTypingContext\r\n\tat spoon.support.visitor.MethodTypingContext.setMethod(MethodTypingContext.java:73)\r\n\tat spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:639)\r\n\tat spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:314)\r\n\tat spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:981)\r\n\tat spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:977)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:468)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:318)\r\n\tat spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:78)\r\n\tat spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:73)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:468)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:318)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResult(SuperInheritanceHierarchyFunction.java:375)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResultWithListener(SuperInheritanceHierarchyFunction.java:327)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperInterfaces(SuperInheritanceHierarchyFunction.java:314)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:283)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:265)\r\n\tat spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:51)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:501)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:318)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:104)\r\n\tat spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:73)\r\n\tat spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:36)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:501)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:318)\r\n\tat spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:104)\r\n\tat spoon.support.reflect.declaration.CtTypeImpl.getAllMethods(CtTypeImpl.java:977)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:562)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:585)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:109)\r\n\tat spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:83)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.visitCtInvocation(ImportScannerImpl.java:220)\r\n\tat spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:55)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtReturn(CtScanner.java:678)\r\n\tat spoon.support.reflect.code.CtReturnImpl.accept(CtReturnImpl.java:36)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:147)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:302)\r\n\tat spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:68)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:559)\r\n\tat spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:72)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:147)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:338)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.visitCtClass(ImportScannerImpl.java:206)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:67)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:147)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:338)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.visitCtClass(ImportScannerImpl.java:206)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:67)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:146)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:259)\r\n\tat spoon.wrikeparser.ParseImports.main(ParseImports.java:79)\r\n```", "url": "https://github.com/INRIA/spoon/issues/2441", "user": "iMaysoN", "labels": ["bug"], "created": "2018-09-04 13:03:07", "closed": "2018-12-01 18:48:07", "commits": {}, "ttf": 88.00027777777778, "commitsDetails": []}, {"title": "bug: serious warning in EnumFactory (\"Inconvertible types\")", "body": "Line `return (CtEnum<?>) super.get(qualifiedName);` gaves warning: *Inconvertible types; cannot cast 'spoon.reflect.declaration.CtType<java.lang.Object>' to 'spoon.reflect.declaration.CtEnum<?>'*\r\n\r\nIs it something to analyze and fix?\r\n\r\nspoon/reflect/factory/EnumFactory.java\r\n```\r\n\t@Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic CtEnum<?> get(String qualifiedName) {\r\n\t\ttry {\r\n\t\t\treturn (CtEnum<?>) super.get(qualifiedName);\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n```", "url": "https://github.com/INRIA/spoon/issues/2408", "user": "zielint0", "labels": ["bug"], "created": "2018-08-23 20:20:08", "closed": "2018-10-08 19:17:45", "commits": {}, "ttf": 45.000277777777775, "commitsDetails": []}, {"title": "[BUG]: \"this\" becomes \"super\" after Spoon analysis", "body": "I have encountered an strange bug when using Spoon, either with version 6.2 or 7.0\r\n\r\nThe source code I am analyzing is https://github.com/apache/commons-math/blob/master/src/main/java/org/apache/commons/math4/linear/ArrayRealVector.java\r\n\r\nAfter building the model using the following code on the above source file:\r\n\r\n`Launcher launcher = new Launcher();`\r\n`launcher.addInputResource(targetClassLocation);`\r\n`launcher.setSourceOutputDirectory(location + File.separator + \"spoon\");`\r\n`launcher.getEnvironment().setSourceClasspath(classPath.split(\"::\"));`\r\n`launcher.buildModel();`\r\n`List<CtElement> originalClasses = launcher.getFactory().Package().getRootPackage()\r\n\t\t\t\t\t\t\t.getElements(new TypeFilter(CtClass.class));`\r\n`WriteLinesToFile.writeToFiles(originalClasses.get(0).toString(), \"ArrayRealVector.java\");`\r\n\r\nThe output file \"ArrayRealVector.java\" is different with the original source file \"ArrayRealVector.java\".\r\nThe key work `this` becomes `super`.\r\n\r\nOriginal:\r\n<img width=\"676\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2504533/44250265-4121ef00-a226-11e8-9d35-df1a65324868.png\">\r\n\r\n\r\nAnalyzed:\r\n\r\n<img width=\"741\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2504533/44250287-526afb80-a226-11e8-9498-4b33e67bc36d.png\">\r\n\r\n\r\n\r\n\r\nI do not know how this would happen, which seems to be a serious bug.\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/2381", "user": "justinwm", "labels": ["bug"], "created": "2018-08-17 06:04:35", "closed": "2018-10-19 18:39:16", "commits": {}, "ttf": 63.000277777777775, "commitsDetails": []}, {"title": "BUG: stack over flow when getAllMethods()", "body": "Hi all, I am reporting an error:\r\n\r\nSpoon throws a `StackOverFlowError` when I am trying to call `getAllMethods()` on the following object:\r\n\r\n```java\r\npublic class Matriochka extends SubMatriochka {\r\n     public void aMethod()  {\r\n     }\r\n }\r\n```\r\n```java\r\npublic class SubMatriochka {\r\n     public <F extends Enum<F> & Factory> int aMethod(Class<F> object) {\r\n        return 23;\r\n    }\r\n }\r\n```\r\n\r\n_i.e._ the following snippet is throwing a  `StackOverFlowError`\r\n```java\r\nfinal Class<?> aClass = Matriochka.class;\r\nfinal CtType<?> ctType = createFactory().Class().get(aClass);\r\nctType.getAllMethods();\r\n```\r\n\r\nYou may find a test, with all the resources to reproduce the error on my [fork](https://github.com/danglotb/spoon/tree/stackoverflow-error) on the branch **stackoverflow-error**.\r\n\r\nThank you!", "url": "https://github.com/INRIA/spoon/issues/2378", "user": "danglotb", "labels": ["bug"], "created": "2018-08-16 18:36:48", "closed": "2018-09-30 15:18:40", "commits": {}, "ttf": 44.000277777777775, "commitsDetails": []}, {"title": "Auto-imports of java.lang classes fail to use qualified names if class of same name is defined in file.", "body": "Hello,\r\n\r\nIf I try to run an Launcher (with auto imports) on the following java code:\r\n\r\n~~~\r\npackage TestJava;\r\n\r\npublic class JavaLongUse {\r\n\r\n    public class Long {\r\n\r\n    }\r\n\r\n    public static long method() {\r\n        return java.lang.Long.parseLong(\"10000\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(method());\r\n    }\r\n}\r\n~~~\r\n\r\nI get the following output:\r\n\r\n~~~\r\npackage TestJava;\r\n\r\n\r\npublic class JavaLongUse {\r\n    public static class Long {}\r\n\r\n    public static long method() {\r\n        return Long.parseLong(\"10000\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(JavaLongUse.method());\r\n    }\r\n}\r\n~~~\r\n\r\nWhich leads to the compilation error \"The method parseLong(String) is undefined for the type JavaLongUse.Long\", because \"java.lang.Long\" disappears in the output file, and \"Long\" now refers to the JavaLongUse.Long class.\r\n\r\nIs there a way to force qualified names in specific places?", "url": "https://github.com/INRIA/spoon/issues/2369", "user": "Vetii", "labels": ["bug"], "created": "2018-08-13 13:16:19", "closed": "2018-09-06 15:56:21", "commits": {}, "ttf": 24.00027777777778, "commitsDetails": []}, {"title": "spoon bug discovered for constructors invoked by a nested method ", "body": "I am parsing the following project: https://github.com/mouna2/JHOTDRAW/tree/master/jhot\r\nI found a bug for the following file located under https://github.com/mouna2/JHOTDRAW/blob/master/jhot/samples/mini/ConnectingFiguresSample.java\r\n\r\nMore specifically here is the problematic code fragment that I am trying to parse: \r\n\r\n```\r\n SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n\r\n            // Create the two text areas\r\n            TextAreaFigure ta = new TextAreaFigure();\r\n            ta.setBounds(new Point2D.Double(10,10),new Point2D.Double(100,100));\r\n\r\n            TextAreaFigure tb = new TextAreaFigure();\r\n            tb.setBounds(new Point2D.Double(210,110),new Point2D.Double(300,200));\r\n\r\n            // Create an elbow connection\r\n            ConnectionFigure cf = new LineConnectionFigure();\r\n            cf.setLiner(new ElbowLiner());\r\n\r\n            // Connect the figures\r\n            cf.setStartConnector(ta.findConnector(Geom.center(ta.getBounds()), cf));\r\n            cf.setEndConnector(tb.findConnector(Geom.center(tb.getBounds()), cf));\r\n\r\n            // Add all figures to a drawing\r\n            Drawing drawing = new DefaultDrawing();\r\n            drawing.add(ta);\r\n            drawing.add(tb);\r\n            drawing.add(cf);\r\n\r\n            // Show the drawing\r\n            JFrame f = new JFrame(\"My Drawing\");\r\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n            f.setSize(400,300);\r\n\r\n            DrawingView view = new DefaultDrawingView();\r\n            view.setDrawing(drawing);\r\n            f.getContentPane().add(view.getComponent());\r\n\r\n            f.setVisible(true);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nI am trying to extract the calls from the method run() to the constructors within the method run(). For instance, I want to extract the call from run to the constructor of the class ElbowLiner. The constructor of the class ElbowLiner is declared in \"org.jhotdraw.draw.ElbowLiner\". However when I use the line of code: invo.getExecutable().getDeclaringType().toString() to get the type of the constructor, I am getting instead org.jhotdraw.samples.mini.ElbowLiner(), \"org.jhotdraw.samples.mini\" is the path under which the class that I am parsing is located under. I think this must be a bug.\r\n\r\nThe code I am using to parse the project is located here: \r\n\r\nhttps://github.com/mouna2/SpoonProcessorFinal/blob/master/src/main/java/JHotDraw/SpoonIssue.java\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/2357", "user": "mouna2", "labels": ["bug"], "created": "2018-08-09 08:48:07", "closed": "2018-09-30 15:19:48", "commits": {}, "ttf": 52.000277777777775, "commitsDetails": []}, {"title": "Spoon generate duplicate brackets in invocations.", "body": "After applying processing, there will be duplicate brackets inside invocations if they contain \"+\".\r\n\r\nFor example, if the original line is like:\r\n`logger.info(\"Value declared in if:\" + c);`\r\n\r\nAfter parsing in Spoon, it would become:\r\n`logger.info((\"Value declared in if:\" + c));`\r\n\r\nAnother example:\r\nbefore:\r\n`LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());`\r\nafter:\r\n`LOG.warn((\"AuthenticationToken ignored: \" + (ex.getMessage())));`\r\n\r\nThe processor looks like:\r\n```\r\npublic class CusProcessor extends AbstractProcessor<CtStatement> {\r\n    public void process(CtStatement element) {\r\n        if (element instanceof CtInvocationImpl) {\r\n            CtInvocationImpl invoke = (CtInvocationImpl) element;\r\n            System.out.println(invoke);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nLauncher code:\r\n```\r\n        Launcher launcher = new Launcher();\r\n        launcher.addInputResource(filePath);\r\n        launcher.getEnvironment().setNoClasspath(true); \r\n        launcher.getEnvironment().setAutoImports(true);\r\n        launcher.getEnvironment().setOutputType(OutputType.NO_OUTPUT);\r\n        launcher.getEnvironment().setCommentEnabled(false);\r\n        launcher.addProcessor(new CusProcessor());\r\n        launcher.run();\r\n```\r\nMy guess is that it is because of the internal compiler, is there a way to fix this?", "url": "https://github.com/INRIA/spoon/issues/2330", "user": "nemo9cby", "labels": ["bug"], "created": "2018-08-02 18:16:33", "closed": "2019-06-23 14:41:48", "commits": {}, "ttf": 324.0002777777778, "commitsDetails": []}, {"title": "bug? About the usage of CtCodeSnippetStatement", "body": "I just found in https://github.com/SpoonLabs/astor/pull/112 that @martinezmatias was using `CtCodeSnippetStatement` in given more that one statement at a time, and it was working in 6.2.0 but apparently no more in 7.0.0. \r\n\r\nHere's an example of the test and its behaviour in Spoon 7.0.0:\r\n\r\n```java\r\nString snippet = \"int n=0; n += 2\";\r\nFactory factory = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\r\nCtStatement st = factory.Code().createCodeSnippetStatement(snippet).compile();\r\n\r\nSystem.out.println(st.toString()); // n += 2;\r\nCtElement fix = ((CtBlock) st.getParent()).getStatement(1); // indexOutOfBoundsException : there's only one statement\r\n```\r\n\r\nSo apparently there's a bug here because the second statement indeed have the block as parent, but is not included as a statement of the block. \r\n\r\nNow the question is: should a `CtCodeSnippetStatement` accept to get more that one statement? Shouldn't we create a new element `CtCodeSnippetBlock` to those cases? \r\n\r\nI'm really not a user of those features in Spoon so I need your vision on this one.", "url": "https://github.com/INRIA/spoon/issues/2318", "user": "surli", "labels": ["bug"], "created": "2018-08-01 10:09:20", "closed": "2018-09-21 20:12:18", "commits": {}, "ttf": 51.000277777777775, "commitsDetails": []}, {"title": "isSubTypeOf on TypeReference is not robust against missing declarations", "body": "`a.isSubTypeOf(b)` from `TypeReference` is not robust and throws a `NullPointerException` if the declaration of `a` is not available.\r\n\r\n```\r\nCaused by: java.lang.NullPointerException\r\n\tat spoon.support.reflect.reference.CtTypeParameterReferenceImpl.isSubtypeOf(CtTypeParameterReferenceImpl.java:278)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer.createElementType(AsgRelationshipTransformer.kt:393)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer.visitCtFieldReference(AsgRelationshipTransformer.kt:119)\r\n\tat spoon.support.reflect.reference.CtFieldReferenceImpl.accept(CtFieldReferenceImpl.java:58)\r\n\tat at.jku.isse.gradient.java.SpoonVisitor.scan(SpoonVisitor.kt:16)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer.scan(AsgRelationshipTransformer.kt:62)\r\n\tat at.jku.isse.gradient.java.SpoonVisitor.scan(SpoonVisitor.kt:10)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer$visitCtTypeReference$$inlined$let$lambda$1.accept(AsgRelationshipTransformer.kt:83)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer$visitCtTypeReference$$inlined$let$lambda$1.accept(AsgRelationshipTransformer.kt:26)\r\n\tat java.util.Optional.ifPresent(Optional.java:159)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer.visitCtTypeReference(AsgRelationshipTransformer.kt:73)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.accept(CtTypeReferenceImpl.java:78)\r\n\tat at.jku.isse.gradient.java.SpoonVisitor.scan(SpoonVisitor.kt:16)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer$Transformer.scan(AsgRelationshipTransformer.kt:62)\r\n\tat at.jku.isse.gradient.java.AsgRelationshipTransformer.transform(AsgRelationshipTransformer.kt:20)\r\n\tat at.jku.isse.gradient.java.ModelTransformer$transform$7.accept(ModelTransformer.kt:38)\r\n\tat at.jku.isse.gradient.java.ModelTransformer$transform$7.accept(ModelTransformer.kt:11)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)\r\n\tat java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)\r\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\r\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.execLocalTasks(ForkJoinPool.java:1040)\r\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1058)\r\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\r\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\r\n```\r\n\r\n**Versions**\r\nSpoon 7.0.0 (but also in early versions)\r\n", "url": "https://github.com/INRIA/spoon/issues/2288", "user": "Tallic", "labels": ["bug"], "created": "2018-07-27 09:03:08", "closed": "2018-09-16 19:02:06", "commits": {"5f12101e059222340b44d4dfa1dbe97e916175e0": {"commitGHEventType": "referenced", "commitUser": "pvojtechovsky"}}, "ttf": 51.000277777777775, "commitsDetails": [{"commitHash": "5f12101e059222340b44d4dfa1dbe97e916175e0", "commitGHEventType": "referenced", "commitUser": "pvojtechovsky", "commitParents": ["3c72b5c7f682ac93cc0edef7f04ee447590f41de"], "nameRev": "5f12101e059222340b44d4dfa1dbe97e916175e0 tags/spoon-core-7.1.0~125", "commitMessage": "test: isSubTypeOf doesn't fail (see #2288) on missing type references (#2448)\n\n", "commitDateTime": "2018-09-16 21:02:05", "authoredDateTime": "2018-09-16 21:02:05", "commitGitStats": [{"filePath": "src/test/java/spoon/test/ctType/CtTypeTest.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtTypeTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctType.CtTypeTest.testIsSubTypeOfonTypeReferences()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "regression: CommentTest.testStatementComments is failing on windows", "body": "Since the merge of #2246 there's a regression in `CommentTest.testStatementComments` on windows machine. See: https://ci.inria.fr/sos/job/spoon-windows/80/", "url": "https://github.com/INRIA/spoon/issues/2268", "user": "surli", "labels": ["bug"], "created": "2018-07-24 06:49:00", "closed": "2018-07-24 07:45:11", "commits": {"2b1f348465c66de3dc103089bc5af8c55fa1f70a": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2b1f348465c66de3dc103089bc5af8c55fa1f70a", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["6d6d7fb02767029a737aa417880d6919f24f9cbc"], "nameRev": "2b1f348465c66de3dc103089bc5af8c55fa1f70a tags/spoon-core-7.1.0~270", "commitMessage": "fix: CommentTest#testStatementComments uses OS specific EOL (#2269)\n\nfix of #2268 ", "commitDateTime": "2018-07-24 09:34:44", "authoredDateTime": "2018-07-24 09:34:44", "commitGitStats": [{"filePath": "src/test/java/spoon/test/comment/CommentTest.java", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CommentTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.comment.CommentTest.testStatementComments()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Spoon CompilationUnit improvements", "body": "This issue is related to #1785\r\n\r\nSniper mode printer needs to handle `package reference` , `import x.y.z;` and list of types of compilation unit.\r\nIt brings several requirements on compilation unit.\r\n\r\n- [x] The compilation unit should implement `SourcePositionHolder` so it may act as root of the tree of source fragments (see #2255)\r\n- [x] The compilation unit should have new property `CtPackageDeclaration packageDeclaration`\r\n- [x] `packageDeclaration` should hold `SourcePosition` of the line `package x.y.z;`. (see #2811) \r\n- [x] `CtCompilationUnitImpl#declaredTypeRefs` should be declared as @MetamodelPropertyField(DECLARED_TYPE_REF) ... including @PropertyGetter and @PropertySetter on interface and appropriate `RoleHandler`\r\n - [x] `CtCompilationUnitImpl#imports` should be declared as @MetamodelPropertyField(DECLARED_IMPORT) ... including @PropertyGetter and @PropertySetter on interface and appropriate `RoleHandler`\r\n - [x] `CtCompilationUnitImpl#packageDeclaration` should be declared as @MetamodelPropertyField(PACKAGE_DECLARATION) ... including @PropertyGetter and @PropertySetter on interface and appropriate `RoleHandler`\r\n- [x] `CtCompilationUnit` should implement `CtElement` (which extends CtVisitable) and `CtScanner` should visit package reference, imports and all declared type references.\r\n- [x] `CtImport.getParent()` should return instance of `CompilationUnit` (therefore it must extend `CtElement`)\r\n\r\n**Concept related to Spoon AST model**\r\n`CtCompilationUnit` is not accessible from `CtModel`. It is not part of it's parent/child tree.\r\nEach `CtCompilationUnit` is a root of own model, which has no parent, and has these children:\r\n* package reference\r\n* module reference\r\n* imports\r\n* references to included types.\r\n\r\nWDYT? Do you see any problem? Drop here a note if you would have time to implement some part of that.", "url": "https://github.com/INRIA/spoon/issues/2254", "user": "pvojtechovsky", "labels": ["bug", "discussion", "help wanted"], "created": "2018-07-21 11:19:37", "closed": "2018-12-04 20:09:00", "commits": {"6deb7e3570b33777f7c92351ada753375560ac5b": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 136.00027777777777, "commitsDetails": [{"commitHash": "6deb7e3570b33777f7c92351ada753375560ac5b", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["79980e9ee7785f406115d7a07d44f20d8274add1"], "nameRev": "6deb7e3570b33777f7c92351ada753375560ac5b tags/spoon-core-7.1.0~283", "commitMessage": "feat(position): CompilationUnit extends SourcePositionHolder (#2255)\n\n`CompilationUnit` extends `SourcePositionHolder` now, so it can act as root of source fragments - as needed for sniper mode pretty printer as discussed in #2254.", "commitDateTime": "2018-07-22 14:50:40", "authoredDateTime": "2018-07-22 14:50:40", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/cu/CompilationUnit.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/support/reflect/cu/CompilationUnitImpl.java", "insertions": 19, "deletions": 1, "lines": 20}, {"filePath": "src/test/java/spoon/test/compilationunit/TestCompilationUnit.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CompilationUnit.java", "spoonMethods": []}, {"spoonFilePath": "CompilationUnitImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.cu.CompilationUnitImpl", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.support.reflect.cu.CompilationUnitImpl.getPosition()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.support.reflect.cu.CompilationUnitImpl.getOriginalSourceCode()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TestCompilationUnit.java", "spoonMethods": [{"spoonMethodName": "spoon.test.compilationunit.TestCompilationUnit.testCompilationUnitSourcePosition()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "compileAndReplaceSnippetsIn() does not replace", "body": "Hi all.\r\n\r\nIt seems that the method [compileAndReplaceSnippetsIn(CtType<?>)](https://github.com/INRIA/spoon/blob/master/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java#L51) of SnippetCompilationHelper does not replace the snippet.\r\n\r\nYou can find a test case that reproduce the bug on my [fork](https://github.com/danglotb/spoon/tree/snippet-compileAndReplace): [SnippetCompilationHelperTest](https://github.com/danglotb/spoon/blob/52f701005f638d04c505a27def4def04dde5b07c/src/test/java/spoon/support/compiler/SnippetCompilationHelperTest.java#L1)\r\n\r\nThere is also a problem with the compilation, it requires to have the compiled version of the sources in the classpath.\r\n", "url": "https://github.com/INRIA/spoon/issues/2238", "user": "danglotb", "labels": ["bug"], "created": "2018-07-17 15:07:21", "closed": "2018-09-23 06:49:24", "commits": {}, "ttf": 67.00027777777778, "commitsDetails": []}, {"title": "bug: should reject invalid names according to the Java specification", "body": "Hi all.\r\n\r\nI am opening this thread to discuss the possibility of checking the name against the specification names.\r\n\r\nCurrently in Spoon, I can do the following:\r\n\r\n```java\r\nCtVariableReference reference = factory.createLocalVariableReference().setSimpleName(\"tacos.EatIt()\")\r\nfactory.createVariableRead(reference, false);\r\n```\r\n\r\nThis can lead to an inconsistency of the spoon model because the invocation is represented by a local variable.\r\n\r\nWhat can be done, is a check on the provided name, using a regex.\r\n\r\nWDYT?\r\n\r\nEDIT: I fixed the snippet since it was incorrect. However, the discussion remains the same and open.", "url": "https://github.com/INRIA/spoon/issues/2237", "user": "danglotb", "labels": ["bug", "good first issue"], "created": "2018-07-17 14:25:45", "closed": "2019-12-15 16:46:29", "commits": {}, "ttf": 516.0002777777778, "commitsDetails": []}, {"title": "bug: comment not attached to element (error message in log)", "body": "I see the following stack trace in the logs:\r\n```\r\n2018-07-12 17:41:16,176 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // prevent users from disabling is not added into the AST\r\nspoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/Users/urli/Github/runelite/runelite-client/src/main/java/net/runelite/client/plugins/config/ConfigPlugin.java:46)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:480)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:391)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:340)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:129)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:113)\r\n\tat spoon.Launcher.buildModel(Launcher.java:769)\r\n\tat Main.main(Main.java:10)\r\n```\r\n\r\nReproduction steps:\r\n```\r\ngit clone https://github.com/runelite/runelite\r\ngit checkout runelite-parent-1.4.7\r\ncd runelite/runelite-client\r\nmvn dependency:build-classpath\r\n```\r\n\r\n```java\r\nLauncher launcher = new Launcher();\r\n        launcher.addInputResource(\"runelite/runelite-client/src/main/java\");\r\n        launcher.getEnvironment().setSourceClasspath(CLASSPATH.split(\":\"));\r\n        CtModel model = launcher.buildModel();\r\n```", "url": "https://github.com/INRIA/spoon/issues/2209", "user": "surli", "labels": ["bug"], "created": "2018-07-12 15:45:47", "closed": "2018-10-23 19:15:06", "commits": {}, "ttf": 103.00027777777778, "commitsDetails": []}, {"title": "bug: label is not part of element position", "body": "```java\r\nsome_label: while(true);\r\n```\r\nThe source position of such `while`  statement doesn't contain label. But it should contain it.", "url": "https://github.com/INRIA/spoon/issues/2204", "user": "pvojtechovsky", "labels": ["bug"], "created": "2018-07-11 19:03:27", "closed": "2018-09-19 19:19:17", "commits": {}, "ttf": 70.00027777777778, "commitsDetails": []}, {"title": "getTypeDeclaration() thread safety", "body": "As far as I understand, spoon model should be thread safe for reading.\r\nHowever, in some rare cases I face problems when I call `getTypeDeclaration()` from different threads.\r\n\r\nThe error looks like this:\r\n```\r\njava.lang.ClassCastException: java.util.HashMap$Node cannot be cast to java.util.HashMap$TreeNode\r\n\tat java.util.HashMap$TreeNode.moveRootToFront(HashMap.java:1832)\r\n\tat java.util.HashMap$TreeNode.treeify(HashMap.java:1949)\r\n\tat java.util.HashMap$TreeNode.split(HashMap.java:2175)\r\n\tat java.util.HashMap.resize(HashMap.java:714)\r\n\tat java.util.HashMap.putVal(HashMap.java:663)\r\n\tat java.util.HashMap.put(HashMap.java:612)\r\n\tat spoon.reflect.factory.TypeFactory.get(TypeFactory.java:555)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.getTypeDeclaration(CtTypeReferenceImpl.java:186)\r\n        ...\r\n```\r\nI believe that the possible solution is to use `ConcurrentHashMap` instead of `HashMap` for `shadowCache` in `TypeFactory`.\r\nUnfortunately it's hard to reproduce this error, because it occurs only sometimes.\r\n\r\nSo, what do you think about it?\r\nThanks.", "url": "https://github.com/INRIA/spoon/issues/2180", "user": "Egor18", "labels": ["bug", "discussion"], "created": "2018-07-06 10:02:58", "closed": "2018-07-10 15:24:26", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "Bug: Overriding a method with self referential generic leads to StackOverflowException", "body": "Given:\r\n```\r\npublic class A {\r\n\t<T extends Enum<T>> void m6(T t) {\r\n\t}\r\n}\r\npublic class B extends A {\r\n\t@Override\r\n\t<S extends Enum<S>> void m6(S s) {\r\n\t}\r\n}\r\n```\r\nChecking if `B#m6` overrides `A#m6` leads to a `StackOverflowException`.\r\nI could manage to fix that in `spoon.support.visitor.MethodTypingContext#isSameMethodFormalTypeParameter` but there seams to be another issue when adopting the type (called in `spoon.support.visitor.ClassTypingContext.ExecutableContext#isSameSignatureLikeScopeMethod`, line 696). \r\n\r\nMay be it is due to the fact, that a type definition like `S extends Enum<S>` is stored in the model like this:\r\n\r\n0: CtTypeParameter (`S extends Enum<S>`)\r\n1: --> superClass: CtTypeReference (`Enum<S>`)\r\n2: ----> actualTypeArguments[0]: CtTypeParameterReference (`S`)\r\n3: ------> superType: CtTypeReference (`Enum<S>`)\r\n4: --------> actualTypeArguments[0]: CtTypeParameterReference (`S`)\r\n5: ----------> superType: CtTypeReference (`java.lang.Object`)\r\n\r\nThe `spoon.support.visitor.AbstractTypingContext#adaptType` method adapts a \"level 0\" type to a \"level 2\" type, which then not equals.", "url": "https://github.com/INRIA/spoon/issues/2160", "user": "vidl", "labels": ["bug"], "created": "2018-07-03 12:44:03", "closed": "2018-09-27 19:43:57", "commits": {}, "ttf": 86.00027777777778, "commitsDetails": []}, {"title": "bug: ClassCastException in DJPP", "body": "Thanks @HabchiSarra for having spotted this one \ud83d\udc4d \r\n\r\nObtained stack trace: \r\n> Caused by: java.lang.ClassCastException: spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.reference.CtArrayTypeReference\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtParameter(DefaultJavaPrettyPrinter.java:1569)\r\n\r\nReproduced on Spoon 6.3.0-snapshot\r\n\r\nReproduction Steps:\r\n\r\n> git clone https://github.com/ukanth/afwall\r\n> git checkout bc6885e512f72760b91c33633b58eea5fee27a44\r\n\r\n```java\r\nLauncher launcher = new Launcher();\r\n\r\n        launcher.getEnvironment().setNoClasspath(true);\r\n        launcher.addInputResource(\"/Users/urli/Github/afwall/aFWall/src/main/java\");\r\n        launcher.setSourceOutputDirectory(\"/tmp/afwall\");\r\n        launcher.run();\r\n```", "url": "https://github.com/INRIA/spoon/issues/2130", "user": "surli", "labels": ["bug"], "created": "2018-06-28 08:37:10", "closed": "2018-06-28 13:11:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "BUG: ModelBuildingException: Cannot infer type arguments", "body": "Hi! \r\n\r\nI am using the Spoon of version 6.2.0 to analyze java source files, and encountered the following error:\r\n<img width=\"1787\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2504533/41573708-9328555e-73b0-11e8-843f-3ee755eeb482.png\">\r\n\r\nThe line 229 of the target source file is:\r\n\r\n`        disruptor = new Disruptor<>(factory, ringBufferSize, threadFactory, ProducerType.MULTI, waitStrategy);`\r\n\r\nIt seems that Spoon cannot infer the argument type of Disruptor<>.\r\n\r\nActually, I am analyzing the Apache Logging project https://github.com/apache/logging-log4j2, and the  target source file is `logging-log4j2/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigDisruptor.java`.\r\n\r\nI have added all the required classpathes simply using the following code:\r\n\r\n<img width=\"659\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2504533/41573838-44598938-73b1-11e8-8a82-d489145cd955.png\">\r\n\r\nHere, the filename is the target source file.\r\n\r\nHave anyone encountered similar errors? Hope you can help me resolve this issue. Thanks very much!!", "url": "https://github.com/INRIA/spoon/issues/2081", "user": "justinwm", "labels": ["bug"], "created": "2018-06-19 03:11:01", "closed": "2018-06-21 12:45:10", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "bug: all imports are not well managed when generating ModelRoleHandlers by CtGenerationTest", "body": "The following imports are added but wrong after copy/paste the file:\r\n\r\n```\r\nimport spoon.generating.meta.spoon.reflect.meta.impl.ListHandler;\r\nimport spoon.generating.meta.spoon.reflect.meta.impl.MapHandler;\r\nimport spoon.generating.meta.spoon.reflect.meta.impl.SetHandler;\r\nimport spoon.generating.meta.spoon.reflect.meta.impl.SingleHandler;\r\n```", "url": "https://github.com/INRIA/spoon/issues/2076", "user": "surli", "labels": ["bug"], "created": "2018-06-16 09:45:46", "closed": "2018-06-19 08:02:08", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "bug: CtGenerationTest#testGenerateRoleHandlers relies on ModelHandler which is generated by the test", "body": "There is an egg/chicken issue with `CtGenerationTest#testGenerateRoleHandlers`.\r\nI created in #2054 a new role to manage inferred variables and I use it in `CtLocalVariable`. It seems that now I cannot generate the `ModelRoleHandlers` using this test, because the model role handlers is not defined...\r\n\r\nSee:\r\n> spoon.SpoonException: The element of class interface spoon.reflect.code.CtLocalVariable does not have CtRole.INFERRED_VARIABLE\r\n\r\nAny idea @pvojtechovsky @monperrus ?", "url": "https://github.com/INRIA/spoon/issues/2063", "user": "surli", "labels": ["bug"], "created": "2018-06-14 11:07:11", "closed": "2018-06-16 10:36:27", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "Spoon-Gradle-Plugin : bug on windows", "body": "I got the following stacktrace when running on windows, on linux it works fine:\r\n```\r\nCaused by: spoon.compiler.InvalidClassPathException: C does not exist, it is not a valid folder\r\n        at spoon.support.StandardEnvironment.verifySourceClasspath(StandardEnvironment.java:424)\r\n        at spoon.support.StandardEnvironment.setSourceClasspath(StandardEnvironment.java:414)\r\n        at spoon.compiler.Environment$setSourceClasspath$3.call(Unknown Source)\r\n        at fr.inria.gforge.spoon.SpoonAndroidTask.configureEnvironment(SpoonAndroidTask.groovy:38)\r\n        at fr.inria.gforge.spoon.SpoonAndroidCheckTask.super$4$configureEnvironment(SpoonAndroidCheckTask.groovy)\r\n        at fr.inria.gforge.spoon.SpoonAndroidCheckTask.configureEnvironment(SpoonAndroidCheckTask.groovy:9)\r\n        at fr.inria.gforge.spoon.SpoonAndroidCheckTask$configureEnvironment.callCurrent(Unknown Source)\r\n        at fr.inria.gforge.spoon.SpoonAndroidTask.run(SpoonAndroidTask.groovy:52)\r\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:46)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\r\n        at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:784)\r\n        at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:751)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:121)\r\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\r\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\r\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\r\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:110)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:92)\r\n        ... 103 more\r\n```", "url": "https://github.com/INRIA/spoon/issues/2062", "user": "m3ftah", "labels": ["bug", "spoon-maven-plugin"], "created": "2018-06-14 09:05:13", "closed": "2018-06-14 11:14:38", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Shadow and partial classpath", "body": "I think there is a major bug in the Shadow.\r\n\r\nYou have:\r\n- A in the source\r\n- B referenced in A and is in the classpath\r\n- C referenced in B but is not in the classpath\r\n\r\nThe creation of the shadow of B will fail because when we will try to create the shadow of C a SpoonClassNotFound will be thrown and the creation of the shadow of B will stop.", "url": "https://github.com/INRIA/spoon/issues/2038", "user": "tdurieux", "labels": ["bug"], "created": "2018-06-06 13:12:46", "closed": "2018-06-09 07:53:05", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "SpoonException when computing imports", "body": "Hi all,\r\n\r\nI hit this exception when I run the following code. Any help? \r\n\r\n```\r\nImportScanner importContext = new ImportScannerImpl();\r\nimportContext.computeImports(classA);\r\n```\r\n\r\n`spoon.SpoonException: The lambda can be based on interface, which has only one method. But java.util.Comparator has at least two: compare(T,T) and equals(java.lang.Object)`\r\n\r\nThe concerned class is: [org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMapping](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestMappingHandlerMapping.java)\r\n\r\nThanks in advance.\r\n\r\nBest,\r\nMohamed", "url": "https://github.com/INRIA/spoon/issues/2003", "user": "mboussaa", "labels": ["bug"], "created": "2018-05-23 14:21:03", "closed": "2018-06-05 12:56:52", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "Spoon 6.3.0: NPE in spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(ReferenceBuilder.java:543)", "body": "Steps to reproduce:\r\nSpoon 6.3.0\r\nCode coming from: https://github.com/runelite/runelite/pull/2844\r\nClasspath: computed with `mvn dependency:build-classpath`\r\nFull classpath mode. \r\n\r\nStacktrace:\r\n```\r\njava.lang.NullPointerException: null\r\n        at spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(ReferenceBuilder.java:543)\r\n        at spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(ReferenceBuilder.java:482)\r\n        at spoon.support.compiler.jdt.ReferenceBuilder.getExecutableReference(ReferenceBuilder.java:420)\r\n        at spoon.support.compiler.jdt.JDTTreeBuilder.visit(JDTTreeBuilder.java:786)\r\n        at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:659)\r\n        at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.traverse(FieldDeclaration.java:341)\r\n        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1358)\r\n        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:778)\r\n        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:739)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:414)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:362)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:335)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116)\r\n        at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99)\r\n```", "url": "https://github.com/INRIA/spoon/issues/1994", "user": "surli", "labels": ["bug"], "created": "2018-05-18 09:10:39", "closed": "2018-06-06 09:30:04", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "ClassNotFoundException when Spoon is invoked from a Java 9 project with modules", "body": "The following foobar project illustrates the issue:\r\n\r\nhttps://github.com/seintur/spoon-jdk9-module-example\r\n\r\nIn a nutshell, the project defines:\r\n* a module named mod that exports a package named pkg that contains a class named C,\r\n* C defines a main method and calls Launcher.parseClass to build a model with Spoon.\r\n\r\nThe project can be run with: mvn test\r\n\r\nThe test phase uses exec-maven-plugin to launch mod/pkg.C.main\r\n\r\nThe run fails with the following stack trace:\r\n```java\r\n[INFO] --- exec-maven-plugin:1.6.0:exec (default) @ bar ---\r\nException in thread \"main\" java.lang.ExceptionInInitializerError\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.factory.QueryFactory.createQuery(QueryFactory.java:66)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.CtModelImpl.filterChildren(CtModelImpl.java:46)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.CtModelImpl.getElements(CtModelImpl.java:138)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.CtModelImpl.getAllPackages(CtModelImpl.java:115)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.CtModelImpl.getAllTypes(CtModelImpl.java:106)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.Launcher.parseClass(Launcher.java:807)\r\n\tat mod/pkg.C.main(C.java:11)\r\nCaused by: spoon.SpoonException: The class detected from ClassCastException not found.\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(CtQueryImpl.java:616)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.visitor.chain.CtQueryImpl.getIndexOfCallerInStackOfLambda(CtQueryImpl.java:587)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.visitor.chain.CtQueryImpl.<clinit>(CtQueryImpl.java:566)\r\n\t... 7 more\r\nCaused by: java.lang.ClassNotFoundException: spoon.core@6.3.0-SNAPSHOT/spoon.reflect.declaration.CtType\r\n\tat java.base/java.lang.Class.forName0(Native Method)\r\n\tat java.base/java.lang.Class.forName(Class.java:291)\r\n\tat spoon.core@6.3.0-SNAPSHOT/spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(CtQueryImpl.java:614)\r\n\t... 9 more\r\n[ERROR] Command execution failed.\r\n```\r\nThe failure originates from Class.forName that is used in spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(CtQueryImpl.java:614). Since this is a modularized project the class cannot be load from the usual classpath (hence the exception), but from the module path.\r\n\r\n(note: Class.forName is used in several other locations in Spoon)\r\n\r\nI do not have yet a solution to pull but my hint is that the class loading should be managed in a more principled way than with Class.forName.\r\n\r\nFor example, spoon.Environment already defines a pair of setter/getter for the input class loader. It remains to be seen whether Environment can be used to load classes (with Class.forName maybe as a default way). By this way, Environment can be extended to provide other class loading schemes such as the ones based on module paths.", "url": "https://github.com/INRIA/spoon/issues/1991", "user": "seintur", "labels": ["bug"], "created": "2018-05-16 19:07:05", "closed": "2018-05-19 14:27:24", "commits": {"8c61af54d64b3dbadf3b8111d0b6432c400abe65": {"commitGHEventType": "referenced", "commitUser": "seintur"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "8c61af54d64b3dbadf3b8111d0b6432c400abe65", "commitGHEventType": "referenced", "commitUser": "seintur", "commitParents": ["9d6de686d92d79a5afcaa471f689895d784f9ae2"], "nameRev": "8c61af54d64b3dbadf3b8111d0b6432c400abe65 tags/spoon-core-6.0.0~82", "commitMessage": "fix: the query engine also works on JVMs where lambdas are not in stack trace elements (#1579)\n\n", "commitDateTime": "2017-10-10 11:13:50", "authoredDateTime": "2017-10-10 11:13:50", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/chain/CtQueryImpl.java", "insertions": 84, "deletions": 49, "lines": 133}, {"filePath": "src/test/java/spoon/test/filters/FilterTest.java", "insertions": 18, "deletions": 19, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtQueryImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl", "TOT": 7, "UPD": 1, "INS": 2, "MOV": 3, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.accept(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.getErrorMessage()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.onClassCastException(java.lang.ClassCastException,java.lang.String,java.lang.Object)", "TOT": 7, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 5}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.detectExpectedClassFromCCE(java.lang.ClassCastException,java.lang.Object)", "TOT": 13, "UPD": 0, "INS": 0, "MOV": 12, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.OutputFunctionWrapper.getErrorMessage()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.getIndexOfCallerInStackOfLambda()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(java.lang.ClassCastException,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.onClassCastException(java.lang.ClassCastException,java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FilterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.filters.FilterTest.testInvalidQueryStep()", "TOT": 9, "UPD": 4, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "spoon.test.filters.FilterTest.testInvalidQueryStepFailurePolicyIgnore()", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testElementMapFunction()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testQueryInQuery()", "TOT": 7, "UPD": 7, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testEmptyQuery()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testClassCastExceptionOnForEach()", "TOT": 29, "UPD": 13, "INS": 0, "MOV": 8, "DEL": 8}, {"spoonMethodName": "spoon.test.filters.FilterTest.testParentFunction()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testCtScannerListener()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testElementMapFunctionOtherContracts()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testElementMapFunctionNull()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testEarlyTerminatingQuery()", "TOT": 5, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testElementMapConsumableFunction()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.filters.FilterTest.testReuseOfBaseQuery()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "spoon.test.filters.FilterTest.testReuseOfQuery()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["8c61af54d64b3dbadf3b8111d0b6432c400abe65"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 84, "deletions": 49, "lines": 133, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 39, "UPD": 1, "INS": 10, "MOV": 18, "DEL": 10, "spoonFilesChanged": 1, "spoonMethodsChanged": 9}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/spoon/reflect/visitor/chain"], "changesInPackagesSPOON": ["spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.onClassCastException(java.lang.ClassCastException,java.lang.String,java.lang.Object)", "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.getErrorMessage()", "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.onClassCastException(java.lang.ClassCastException,java.lang.Object)", "spoon.reflect.visitor.chain.CtQueryImpl.OutputFunctionWrapper.getErrorMessage()", "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.detectExpectedClassFromCCE(java.lang.ClassCastException,java.lang.Object)", "spoon.reflect.visitor.chain.CtQueryImpl.getIndexOfCallerInStackOfLambda()", "spoon.reflect.visitor.chain.CtQueryImpl.AbstractStep.accept(java.lang.Object)", "spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(java.lang.ClassCastException,java.lang.Object)", "spoon.reflect.visitor.chain.CtQueryImpl"]}, {"title": " bug: type javax.annotation.Nullable cannot be resolved. ", "body": "Hi all, I got again this JDT error, when I parse this minimal code, in not classpath.\r\nIt would be great to be able to fix it.\r\n\r\n```java\r\nimport javax.annotation.Nullable;\r\nimport com.google.common.collect.Lists;\r\n\r\npublic class Test {\r\n}\r\n```\r\n\r\nThe exception disappears when  one of the import is removed.\r\n\r\nException:\r\n\r\n```java\r\norg.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type javax.annotation.Nullable cannot be resolved. It is indirectly referenced from required .class files\r\n\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:159)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:226)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2432)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:4887)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromCompoundName(LookupEnvironment.java:1682)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromConstantPoolName(LookupEnvironment.java:1712)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromConstantPoolName(LookupEnvironment.java:1720)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createAnnotation(BinaryTypeBinding.java:170)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createAnnotations(BinaryTypeBinding.java:179)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethod(BinaryTypeBinding.java:804)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethods(BinaryTypeBinding.java:910)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:529)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:1022)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:1003)\r\n\tat org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:303)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:317)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:257)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:527)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:586)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:435)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:501)\r\n\tat spoon.support.compiler.jdt.TreeBuilderCompiler.buildUnits(TreeBuilderCompiler.java:60)\r\n\tat spoon.support.compiler.jdt.JDTBatchCompiler.getUnits(JDTBatchCompiler.java:168)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:397)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:359)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:335)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99)\r\n\tat spoon.Launcher.buildModel(Launcher.java:720)\r\n```", "url": "https://github.com/INRIA/spoon/issues/1971", "user": "tdurieux", "labels": ["bug"], "created": "2018-04-21 11:13:28", "closed": "2018-06-05 07:48:56", "commits": {}, "ttf": 44.000277777777775, "commitsDetails": []}, {"title": "regression: Spoon-based projects broken because of positions", "body": "I just put a label \"breaking_pr\" on #1964 because it seems some projects based on Spoon has been broken due to this PR. I'm not sure that this PR intended to have a breaking behaviour for clients, but it's obviously the case. I open the issue here because the 4 concerned projects are tested in the Spoon CI to ensure that the snapshots are not breaking things. \r\n\r\nThe concerned projects are the following:\r\n\r\n* [x] https://github.com/SpoonLabs/gumtree-spoon-ast-diff FIXED\r\n* [x] https://github.com/SpoonLabs/nopol FIXED\r\n* [x] <s>https://github.com/SpoonLabs/spooet</s> UNRELATED\r\n* [x] https://github.com/Spirals-Team/npefix FIXED\r\n\r\nNopol and gumtree are both broken using last snapshot of Spoon returning `java.lang.UnsupportedOperationException: PartialSourcePosition only contains a CompilationUnit`.\r\nComplete Jenkins logs for Nopol: https://ci.inria.fr/sos/job/nopol/88/console\r\nFor gumtree: https://ci.inria.fr/sos/job/gumtree-spoon-ast-diff/506/console\r\n\r\nThen we have Spooet which seems broken because of changes on the visibility of `reset` method on `DefaultJavaPrettyPrinter`: I'm not quite sure if it's coming from #1964 or not. Complete Jenkins log: https://ci.inria.fr/sos/job/spooet/494/console\r\n\r\nFinally NPEFix seems to compute diff differently since last commits. Here again the log: https://ci.inria.fr/sos/job/npefix/460/console\r\n\r\nWDYT @monperrus @tdurieux @pvojtechovsky are those bugs or is it a normal regression due to a major change?", "url": "https://github.com/INRIA/spoon/issues/1970", "user": "surli", "labels": ["bug"], "created": "2018-04-18 17:12:06", "closed": "2018-04-30 08:35:34", "commits": {}, "ttf": 11.000277777777777, "commitsDetails": []}, {"title": "NPE  with generic types", "body": "Dear Spoon team, \r\n\r\nI am having a bug when building the spoon model of one of my projects.\r\nI replicated it below with dummy names.\r\n\r\n```\r\npublic class SpoonBug<F extends AClass>\r\n{\r\n    protected void aMethod()\r\n    {\r\n        //String s = AClass.A_FIELD; // This line alone: OK\r\n        String s = F.A_FIELD;         // This line alone: NPE, see below\r\n    }\r\n}\r\n```\r\nWhat is weird, is that, the original code (without dummy names),\r\ncompile and works as expected, no problem with Ecplise editor, \r\njust that autocomplete on \"F.\" returns nothing, but works with \"AClass.\"\r\n\r\nI manually changed all \"F.\" in my code by their \"AClass\" in the meantime. \r\nThanks for your help and the great API you provide!\r\nBest regards,\r\nMehdi \r\n\r\n------\r\n```\r\nException in thread \"main\" java.lang.NullPointerException\r\n\tat spoon.support.compiler.jdt.JDTTreeBuilderQuery.isValidProblemBindingField(JDTTreeBuilderQuery.java:213)\r\n\tat spoon.support.compiler.jdt.JDTTreeBuilderHelper.createTargetFieldAccess(JDTTreeBuilderHelper.java:565)\r\n\tat spoon.support.compiler.jdt.JDTTreeBuilderHelper.createVariableAccess(JDTTreeBuilderHelper.java:301)\r\n\tat spoon.support.compiler.jdt.JDTTreeBuilder.visit(JDTTreeBuilder.java:1315)\r\n\tat org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.traverse(QualifiedNameReference.java:1134)\r\n\tat org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:314)\r\n\tat org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:355)\r\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1367)\r\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:778)\r\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:739)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:414)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:362)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:335)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99)\r\n\tat spoon.Launcher.buildModel(Launcher.java:720)\r\n\tat [fr.... my applic]\r\n```", "url": "https://github.com/INRIA/spoon/issues/1962", "user": "mehdi-kaytoue", "labels": ["bug"], "created": "2018-04-13 09:49:30", "closed": "2018-06-04 18:35:51", "commits": {}, "ttf": 52.000277777777775, "commitsDetails": []}, {"title": "bug: MainTest#testMain_checkShadow is failing with random CU order and JDK9", "body": "It seems that the order of resolution of CU is important somewhere in shadow visitors, which might cause errors.\r\nStep to reproduce:\r\n \r\n```bash\r\n# check java version is 9\r\nSPOON_SEED_CU_COMPARATOR=1 mvn -Dtest=MainTest#testMain_checkShadow test\r\n```\r\n\r\nResult:\r\n```\r\n[ERROR] testMain_checkShadow(spoon.test.main.MainTest)  Time elapsed: 9.633 s  <<< FAILURE!\r\njava.lang.AssertionError: cannot find decl for onSetAdd(spoon.reflect.declaration.CtElement,spoon.reflect.path.CtRole,java.util.Set,T)\r\n\tat spoon.test.main.MainTest.checkShadow(MainTest.java:250)\r\n\tat spoon.test.main.MainTest.testMain_checkShadow(MainTest.java:109)\r\n\r\n```", "url": "https://github.com/INRIA/spoon/issues/1955", "user": "surli", "labels": ["bug"], "created": "2018-04-11 10:37:00", "closed": "2018-05-11 13:26:42", "commits": {}, "ttf": 30.00027777777778, "commitsDetails": []}, {"title": "SourcePositions are incorrect in some cases", "body": "In the PR #1950 I added check for consistency of source position start/end offsets:\r\n```java\r\nclass BodyHolderSourcePositionImpl\r\n\tpublic BodyHolderSourcePositionImpl(...) {\r\n\t\tsuper(...);\r\n\t\tcheckArgsAreAscending(declarationSourceStart, modifierSourceStart, modifierSourceEnd + 1, sourceStart, sourceEnd + 1, bodyStart, bodyEnd + 1, declarationSourceEnd + 1);\r\n...\r\n}\r\n...\r\nprotected static void checkArgsAreAscending(int...values) {\r\n\tint last = -1;\r\n\tfor (int value : values) {\r\n\t\tif (value < 0) {\r\n\t\t\tthrow new SpoonException(\"SourcePosition value must not be negative\");\r\n\t\t}\r\n\t\tif (last > value) {\r\n\t\t\tthrow new SpoonException(\"SourcePosition values must be ascending or equal\");\r\n\t\t}\r\n\t\tlast = value;\r\n\t}\r\n}\r\n```\r\nIt is needed for sniper mode (source code refactored by spoon has minimum differences comparing to origin source code).\r\n\r\nBut this SourcePosition consistency check causes that many tests fail now.", "url": "https://github.com/INRIA/spoon/issues/1953", "user": "pvojtechovsky", "labels": ["bug", "help wanted"], "created": "2018-04-07 06:19:12", "closed": "2018-06-21 18:34:12", "commits": {}, "ttf": 75.00027777777778, "commitsDetails": []}, {"title": "BuildModelException because of an \"ambiguous method\" with full classpath", "body": "I got recently the following error:\r\n\r\n> spoon.compiler.ModelBuildingException: The method info(String, Object) is ambiguous for the type Logger at /private/tmp/twill/twill-yarn/src/main/java/org/apache/twill/internal/appmaster/ApplicationMasterService.java:750\r\n\r\nwhen calling Spoon on the project: https://github.com/apache/twill/tree/master/twill-yarn with a full classpath obtained with `mvn dependency:build-classpath`\r\n\r\nReproduction steps:\r\nFetch the following commit: https://github.com/apache/twill/commit/7f494d13da45e6f9a27dfe1b4bde9d521d306c20\r\n\r\n```java\r\nString path = \"/tmp/twill/twill-yarn/src/main/java\";\r\n        String classPath = \"\"; // full classpath obtained with mvn dependency:build-classpath\r\n\r\n        Launcher launcher = new Launcher();\r\n        launcher.addInputResource(path);\r\n        launcher.getEnvironment().setSourceClasspath(classPath.split(\":\"));\r\n        //launcher.getEnvironment().setNoClasspath(true);\r\n\r\n        CtModel model = launcher.buildModel();\r\n```", "url": "https://github.com/INRIA/spoon/issues/1911", "user": "surli", "labels": ["bug", "wontfix"], "created": "2018-03-14 17:03:46", "closed": "2018-06-25 09:19:00", "commits": {}, "ttf": 102.00027777777778, "commitsDetails": []}, {"title": "chore: Spoon snapshots are currently not available", "body": "The last snapshots of Spoon are now automatically deployed on a new repository but the repository is currently only available through authentication. \r\n\r\nI'm working with the owner of the repository to change that, sorry for the inconveniance.", "url": "https://github.com/INRIA/spoon/issues/1909", "user": "surli", "labels": ["bug"], "created": "2018-03-14 12:11:38", "closed": "2018-03-23 19:06:02", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "bug: superInterfaces on shadow type miss actual type arguments", "body": "I am refactoring SpoonMetaModel by way it can be created without spoon sources - just using spoon runtime reflection. And I have found this problem. For example CtConditionalImpl is defined like this\r\n```java\r\nclass CtConditionalImpl<T> implements CtConditional<T>\r\n````\r\n\r\nbut when I get shadow CtClass of CtConditionalImpl, then getSuperInterfaces() returns CtTypeReference without actuall type arguments. So it looks like this\r\n```java\r\nclass CtConditionalImpl<T> implements CtConditional\r\n````\r\nI need that actual type argument on interface references, in ClassTypingContext.\r\n\r\nThis information was not available until `Class#getAnnotatedInterfaces()` was introduced in Java8. Could you please use that new method to deliver actual type arguments of extended interfaces too?\r\n\r\nI created a branch with a failing test https://github.com/pvojtechovsky/spoon/tree/fixSuperIfaceArgs", "url": "https://github.com/INRIA/spoon/issues/1906", "user": "pvojtechovsky", "labels": ["bug"], "created": "2018-03-11 11:22:39", "closed": "2018-05-23 08:26:14", "commits": {"cb870d1cab3bb2105bf0a818d578db83a6c10b71": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 72.00027777777778, "commitsDetails": [{"commitHash": "cb870d1cab3bb2105bf0a818d578db83a6c10b71", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["9781b8c35f3cacb17b4dc72dd4c1ab590c4836dc"], "nameRev": "cb870d1cab3bb2105bf0a818d578db83a6c10b71 tags/spoon-core-7.0.0~111", "commitMessage": "fix: manage generics from interfaces in shadow mode (#1914)\n\nFix #1906 ", "commitDateTime": "2018-05-23 10:26:13", "authoredDateTime": "2018-05-23 10:26:13", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/factory/TypeFactory.java", "insertions": 16, "deletions": 3, "lines": 19}, {"filePath": "src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java", "insertions": 15, "deletions": 5, "lines": 20}, {"filePath": "src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/main/java/spoon/support/visitor/ClassTypingContext.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java", "insertions": 204, "deletions": 134, "lines": 338}, {"filePath": "src/main/java/spoon/support/visitor/java/JavaReflectionVisitor.java", "insertions": 19, "deletions": 15, "lines": 34}, {"filePath": "src/main/java/spoon/support/visitor/java/JavaReflectionVisitorImpl.java", "insertions": 175, "deletions": 124, "lines": 299}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/AbstractRuntimeBuilderContext.java", "insertions": 7, "deletions": 15, "lines": 22}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/AnnotationRuntimeBuilderContext.java", "insertions": 9, "deletions": 2, "lines": 11}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/ExecutableRuntimeBuilderContext.java", "insertions": 27, "deletions": 27, "lines": 54}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/RuntimeBuilderContext.java", "insertions": 5, "deletions": 7, "lines": 12}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/TypeReferenceRuntimeBuilderContext.java", "insertions": 51, "deletions": 9, "lines": 60}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/TypeRuntimeBuilderContext.java", "insertions": 27, "deletions": 9, "lines": 36}, {"filePath": "src/main/java/spoon/support/visitor/java/internal/VariableRuntimeBuilderContext.java", "insertions": 8, "deletions": 13, "lines": 21}, {"filePath": "src/main/java/spoon/support/visitor/java/reflect/RtMethod.java", "insertions": 26, "deletions": 20, "lines": 46}, {"filePath": "src/test/java/spoon/support/visitor/java/JavaReflectionTreeBuilderTest.java", "insertions": 447, "deletions": 14, "lines": 461}, {"filePath": "src/test/java/spoon/test/annotation/AnnotationTest.java", "insertions": 2, "deletions": 4, "lines": 6}, {"filePath": "src/test/java/spoon/test/generics/GenericsTest.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "src/test/java/spoon/test/imports/ImportTest.java", "insertions": 4, "deletions": 0, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Maven plugin fail with \"No source directory\" error on artifact projects", "body": "I was just able to reproduce it the following way:\r\n\r\n* clone https://github.com/xwiki/xwiki-commons/\r\n* `cd xwiki-commons-pom && mvn install -N && cd ..`\r\n* `cd xwiki-commons-core/xwiki-commons-component/xwiki-commons-component-archetype && mvn clean package -e`\r\n\r\nAnd got the following tack trace:\r\n\r\n```\r\n[INFO] --- spoon-maven-plugin:2.8:check (default) @ xwiki-commons-component-archetype ---\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 1.938 s\r\n[INFO] Finished at: 2018-03-09T14:03:29+01:00\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.8:check (default) on project xwiki-commons-component-archetype: No source directory for XWiki Commons - Component - Component Archetype project. -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.8:check (default) on project xwiki-commons-component-archetype: No source directory for XWiki Commons - Component - Component Archetype project.\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:213)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:498)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: org.apache.maven.plugin.MojoExecutionException: No source directory for XWiki Commons - Component - Component Archetype project.\r\n    at fr.inria.gforge.spoon.SpoonMojoGenerate.execute (SpoonMojoGenerate.java:208)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:498)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\nCaused by: java.lang.RuntimeException: No source directory for XWiki Commons - Component - Component Archetype project.\r\n    at fr.inria.gforge.spoon.configuration.AbstractSpoonConfigurationBuilder.addInputFolder (AbstractSpoonConfigurationBuilder.java:66)\r\n    at fr.inria.gforge.spoon.SpoonMojoGenerate.buildArguments (SpoonMojoGenerate.java:150)\r\n    at fr.inria.gforge.spoon.SpoonMojoGenerate.initMojo (SpoonMojoGenerate.java:184)\r\n    at fr.inria.gforge.spoon.SpoonMojoGenerate.execute (SpoonMojoGenerate.java:202)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:498)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)\r\n```\r\n\r\nmvn -version:\r\n```\r\nJava HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=512m; support was removed in 8.0\r\nApache Maven 3.5.3 (3383c37e1f9e9b3bc3df5050c29c8aff9f295297; 2018-02-24T20:49:05+01:00)\r\nMaven home: /media/data/install/linux/utils/mvn\r\nJava version: 1.8.0_121, vendor: Oracle Corporation\r\nJava home: /media/data/install/linux/utils/jdk1.8.0_121/jre\r\nDefault locale: en_US, platform encoding: UTF-8\r\nOS name: \"linux\", version: \"4.13.0-36-generic\", arch: \"amd64\", family: \"unix\"\r\n```\r\n\r\nAlso reproduce on Maven 3.3.9 and 3.5.2.", "url": "https://github.com/INRIA/spoon/issues/1901", "user": "tmortagne", "labels": ["bug", "spoon-maven-plugin"], "created": "2018-03-09 13:05:05", "closed": "2018-03-13 21:54:23", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "`spooned` directory should not be created using NO_OUTPUT with spoon 6.1.0", "body": "The launcher configuration is as follow:\r\n\r\n        Launcher launcher = new Launcher();\r\n        for (String stingClass : classesToAnalyze) {\r\n            launcher.addInputResource(stingClass);\r\n        }\r\n        launcher.addProcessor(generateOutputProcessor());\r\n        launcher.getEnvironment().setNoClasspath(true);\r\n        launcher.getEnvironment().setCommentEnabled(true);\r\n        launcher.getEnvironment().setOutputType(OutputType.NO_OUTPUT);\r\n        return launcher;\r\n", "url": "https://github.com/INRIA/spoon/issues/1896", "user": "aveuiller", "labels": ["bug"], "created": "2018-03-08 09:03:35", "closed": "2018-03-16 16:14:43", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "bug: Java8 \"Foo[]::new\" cannot be resolved", "body": "Assuming a Java8 `new ArrayList().stream().toArray(Foo[]::new)`\r\n\r\nThe `Foo[]::new` is a CtExRefExpression which cannot be resolved with `getExecutableDeclaration` even if Foo is in the classpath.\r\n\r\nSee failing test in https://github.com/INRIA/spoon/compare/master...monperrus:bug-execrefexpr", "url": "https://github.com/INRIA/spoon/issues/1883", "user": "monperrus", "labels": ["bug"], "created": "2018-02-25 00:26:08", "closed": "2018-06-15 14:42:08", "commits": {}, "ttf": 110.00027777777778, "commitsDetails": []}, {"title": "bug: CtElement.getRoleInParent() and CtElement.getValueByRole(CtRole) are not consistent for catch with multple types", "body": "When parsing \r\n```Java\r\n\ttry {\r\n\t\tObject val = m.get(o);\r\n\t\tif (val != null) {\r\n\t\t\treturn val.getClass().getCanonicalName();\r\n\t\t}\r\n\t} catch (IllegalArgumentException | IllegalAccessException e) {\r\n\t\tLauncher.LOGGER.error(e.getMessage(), e);\r\n\t}\r\n```\r\nthe node corresponding to the type of `java.lang.IllegalArgumentException` has a role `CtRole.TYPE` in its parent `CtCatchVariable`, but if `getValueByRole(CtRole.TYPE)` is called on this parent, it returns the type `java.lang.Exception`. (Wheras it should return, if I understand correctly, a List containing both types `java.lang.IllegalArgumentException` and `java.lang.IllegalAccessException`)\r\n", "url": "https://github.com/INRIA/spoon/issues/1872", "user": "nharrand", "labels": ["bug"], "created": "2018-02-21 14:32:17", "closed": "2018-02-23 13:53:00", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "bug: order of type members is not kept", "body": "issue created to keep track of the problem of #1787 in the issue tab ", "url": "https://github.com/INRIA/spoon/issues/1857", "user": "monperrus", "labels": ["bug"], "created": "2018-02-16 18:20:03", "closed": "2018-02-18 12:39:45", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "In noclasspath mode, all calls to `CtTypeReference#getActualClass` should catch SpoonClassNotFoundException", "body": "The current behaviour in Spoon is that if `getActualClass` is called a `SpoonClassNotFoundException` is thrown if the class cannot be found. It is still true in noclasspath mode, and it makes sense when a client calls the method directly. \r\n\r\nHowever IMHO it does not make sense in the internal API of Spoon: in noclasspath mode, we should never propagate a SpoonClassNotFoundException in the internal API. I suggest that we change the API to manage those as standard exception and no more RuntimeException. The benefit will be that we know exactly where we need to catch those or to propagate them. WDYT? ", "url": "https://github.com/INRIA/spoon/issues/1833", "user": "surli", "labels": ["bug"], "created": "2018-01-30 13:35:44", "closed": "2018-06-04 16:29:38", "commits": {}, "ttf": 125.00027777777778, "commitsDetails": []}, {"title": "Spoon-maven-plugin prevents from compiling projects", "body": "Some projects got the error:\r\n\r\n>[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ xwiki-commons-blame-api ---\r\n[INFO] Nothing to compile - all classes are up to date\r\n\r\nSee for example the discussion here: https://github.com/SpoonLabs/spoon-maven-plugin/pull/51#issuecomment-355977076", "url": "https://github.com/INRIA/spoon/issues/1830", "user": "surli", "labels": ["bug", "spoon-maven-plugin"], "created": "2018-01-19 16:21:06", "closed": "2018-01-22 15:45:25", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Spoon-maven-plugin prevents from using maven in debug mode", "body": "When launching maven in debug mode \"-X\" we got the usage of Spoon and the process finishes with it:\r\n\r\n> [DEBUG] Configuring mojo 'fr.inria.gforge.spoon:spoon-maven-plugin:2.8-SNAPSHOT:check' with basic configurator -->\r\n[DEBUG]   (f) buildOnlyOutdatedFiles = false\r\n[DEBUG]   (f) compileOriginalSources = false\r\n[DEBUG]   (f) compliance = 8\r\n[DEBUG]   (f) debug = false\r\n[DEBUG]   (s) enableComments = false\r\n[DEBUG]   (f) noClasspath = false\r\n[DEBUG]   (f) noCopyResources = false\r\n[DEBUG]   (f) outFolder = /tmp/xwiki-commons/xwiki-commons-core/xwiki-commons-blame/xwiki-commons-blame-api/target/generated-sources/spoon\r\n[DEBUG]   (f) outputType = classes\r\n[DEBUG]   (f) processors = [org.xwiki.tool.spoon.ForbiddenInvocationProcessor]\r\n[DEBUG]   (f) project = MavenProject: org.xwiki.commons:xwiki-commons-blame-api:10.0-SNAPSHOT @ /tmp/xwiki-commons/xwiki-commons-core/xwiki-commons-blame/xwiki-commons-blame-api/pom.xml\r\n[DEBUG]   (f) skip = false\r\n[DEBUG]   (f) srcFolders = []\r\n[DEBUG]   (f) withImports = false\r\n[DEBUG] -- end configuration --\r\nError: Parameter 'level' cannot be declared more than once.\r\nSpoon version 6.1.0\r\nUsage: java <launcher name> [option(s)]\r\n Options : \r\n  [-h|--help]\r\n  [--tabs]\r\n        Use tabulations instead of spaces in the generated code (use spaces by\r\n        default).\r\n[...]\r\n", "url": "https://github.com/INRIA/spoon/issues/1829", "user": "surli", "labels": ["bug", "spoon-maven-plugin"], "created": "2018-01-19 16:19:15", "closed": "2018-01-22 15:45:47", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Bug: JavaDoc getShortDescription", "body": "I created my model with this lines:\r\n\r\n        Launcher modelLauncher = new Launcher();\r\n        modelLauncher.getEnvironment().setNoClasspath(true);\r\n        modelLauncher.getEnvironment().setCommentEnabled(true);\r\n        modelLauncher.addInputResource(\"C:\\\\spoon\\\\src\\\\main\\\\java\\\\spoon\\\\Launcher.java\");\r\n        CtModel model = modelLauncher.buildModel();\r\n        JavaDocVisitor visitor = new JavaDocVisitor();\r\n        visitor.scan(model.getRootPackage());`\r\n\r\n\r\nWhen i executed this program i got the following exceptions:\r\n\r\n> Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 54\r\n\tat java.lang.String.substring(Unknown Source)\r\n\tat spoon.support.reflect.code.CtJavaDocImpl.getShortDescription(CtJavaDocImpl.java:99)\r\n\tat uni.bremen.de.JavaDocVisitor.smellByWords(JavaDocVisitor.java:223)\r\n\tat uni.bremen.de.JavaDocVisitor.visitCtJavaDoc(JavaDocVisitor.java:134)\r\n\tat spoon.support.reflect.code.CtJavaDocImpl.accept(CtJavaDocImpl.java:113)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:550)\r\n\tat spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:70)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:327)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:640)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:56)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:639)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:56)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)\r\n\tat uni.bremen.de.Modelscanner.main(Modelscanner.java:19)`\r\n\r\nThe line 223 in my JavaDocVisitor is this if condition:\r\n`if (!javaDoc.getContent().isEmpty() && wordCounter(javaDoc.getShortDescription()) < minShortLength)`\r\n\r\nThe same thing is by the method getLongDescription.\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1826", "user": "Cyclone-1337", "labels": ["bug"], "created": "2018-01-17 15:17:00", "closed": "2018-01-17 15:47:47", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Good first bug: Fix parsing of Javadoc comments", "body": "Good first bug to welcome new contributors\r\n\r\nJavadoc tags (eg `@see`) are not well parsed, they are printed with the \"* \" before the content and the spaces before the \"*\" are not consistently handled.\r\n\r\nAn assertion is available in `JavaDocTest#testJavaDocReprint()`\r\n", "url": "https://github.com/INRIA/spoon/issues/1825", "user": "monperrus", "labels": ["bug", "good first issue"], "created": "2018-01-16 20:33:44", "closed": "2018-02-09 17:17:05", "commits": {}, "ttf": 23.00027777777778, "commitsDetails": []}, {"title": "NullPointerException in MavenLauncher$InheritanceModel.getDependencies(MavenLauncher.java:271)", "body": "Hi all\r\n\r\nI often get this exception when targeting several projects \r\n```\r\nException in thread \"main\" java.lang.NullPointerException\r\n\tat spoon.MavenLauncher$InheritanceModel.getDependencies(MavenLauncher.java:271)\r\n\tat spoon.MavenLauncher.<init>(MavenLauncher.java:104)\r\n\tat spoon.MavenLauncher.<init>(MavenLauncher.java:59)\r\n```\r\nI didn't get any explanation on internet \r\n\r\nPlease Help", "url": "https://github.com/INRIA/spoon/issues/1807", "user": "JackLehman", "labels": ["bug"], "created": "2018-01-02 20:53:27", "closed": "2018-01-04 21:38:45", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Getting enum values from shadowed enum type", "body": "Hi. I'm trying to get all elements of some enum.\r\nFor the enum, which declaration is present in the source code this works fine:\r\n\r\n```\r\n...\r\nCtTypeReference typeRef = expr.getType();\r\nif (typeRef.isEnum())\r\n{\r\n  CtType type = typeRef.getTypeDeclaration();\r\n  if (type instanceof CtEnum)\r\n  {\r\n    System.out.println(((CtEnum) type).getEnumValues());\r\n  }\r\n}\r\n```\r\n\r\nBut once the enum is not present in the source (i.e. it is located in some .jar), this approach does not work.\r\nFor shadowed type reference `.isEnum()` always returns false, and the actual type of such enum is `CtClass` (why not `CtEnum`?).\r\nSo, it is impossible to cast it to `CtEnum` and call `.getEnumValues()`.\r\n\r\nObviously, to get enum values from enum which is located in .jar, I can check if it's parent is `java.lang.Enum` and then get all the fields, excluding `.ENUM$VALUES`, `name` and `ordinal`.\r\nBut it seems to be quite overcomplicated, because I need to use two different approaches for shadowed and non-shadowed enums.\r\n\r\nSo can you please explain, why is this happening? Is it possible to get shadowed enum values easier?\r\nFurthermore, I'm interested, are there any similar problems with other data types?\r\n\r\nP.S. This partially concerns [incremental build](https://github.com/INRIA/spoon/pull/1688).\r\n\r\nThank you.", "url": "https://github.com/INRIA/spoon/issues/1791", "user": "Egor18", "labels": ["bug"], "created": "2017-12-31 13:23:31", "closed": "2018-01-03 19:57:46", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "StackOverflowError with spring-boot maven project", "body": "I am getting a StackOverflowError when trying to target the spring-boot project (1.5.9 version). I am using spoon 6.0.0.\r\nHere is the code snippet:\r\n\r\n```\r\nString springBoot= \"{local directory}/spring-boot-1.5.9.RELEASE/spring-boot\";\r\nMavenLauncher launcher = new MavenLauncher(springBoot, MavenLauncher.SOURCE_TYPE.APP_SOURCE);\r\n\t\tlauncher.getEnvironment().setNoClasspath(true);\r\n\t\tCtModel model = launcher.buildModel();\r\n\t\tmodel.getAllTypes().forEach((type) -> {\r\n\t\t\ttype.getAllMethods().forEach((method) -> {\r\n\t\t\t//TODO\r\n\t\t\t});\r\n\t\t});\r\n\r\n```\r\nThe console output (The message is quite long) \r\n```\r\n\r\nException in thread \"main\" java.lang.StackOverflowError\r\n\tat spoon.reflect.visitor.CtBiScannerDefault.visitCtTypeParameterReference(CtBiScannerDefault.java:679)\r\n\tat spoon.support.reflect.reference.CtTypeParameterReferenceImpl.accept(CtTypeParameterReferenceImpl.java:65)\r\n\tat spoon.reflect.visitor.CtAbstractBiScanner.biScan(CtAbstractBiScanner.java:86)\r\n\tat spoon.support.visitor.equals.EqualsVisitor.equals(EqualsVisitor.java:30)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.equals(CtElementImpl.java:125)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReferenceBoundingType(AbstractTypingContext.java:82)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(AbstractTypingContext.java:73)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:44)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:63)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.MethodTypingContext.isSameMethodFormalTypeParameter(MethodTypingContext.java:252)\r\n\tat spoon.support.visitor.MethodTypingContext.hasSameMethodFormalTypeParameters(MethodTypingContext.java:230)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptTypeParameter(MethodTypingContext.java:204)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(AbstractTypingContext.java:75)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:44)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReferenceBoundingType(AbstractTypingContext.java:82)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(AbstractTypingContext.java:73)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:44)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:63)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.MethodTypingContext.isSameMethodFormalTypeParameter(MethodTypingContext.java:252)\r\n\tat spoon.support.visitor.MethodTypingContext.hasSameMethodFormalTypeParameters(MethodTypingContext.java:230)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptTypeParameter(MethodTypingContext.java:204)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(AbstractTypingContext.java:75)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:44)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:47)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReferenceBoundingType(AbstractTypingContext.java:82)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(AbstractTypingContext.java:73)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:44)\r\n\r\n```\r\nThanks,\r\n\r\nBest,\r\nMohamed", "url": "https://github.com/INRIA/spoon/issues/1783", "user": "mboussaa", "labels": ["bug"], "created": "2017-12-11 18:29:42", "closed": "2018-01-12 13:01:41", "commits": {}, "ttf": 31.00027777777778, "commitsDetails": []}, {"title": "Bug: Annotation @javax.validation.constraints.NotNull not correctly parsed", "body": "Maven dependencies:\r\n```\r\n<dependency>\r\n    <groupId>javax.validation</groupId>\r\n    <artifactId>validation-api</artifactId>\r\n   <version>2.0.0.Final</version>\r\n</dependency>\r\n <dependency>\r\n   <groupId>fr.inria.gforge.spoon</groupId>\r\n    <artifactId>spoon-core</artifactId>\r\n    <version>6.0.0</version>\r\n</dependency>\r\n```\r\n\r\nIt seems like the field parsing is not working with this specific annotation (others seems to be working fine!)\r\nHere is the field: \r\n@NotNull\r\npublic String mandatoryField;\r\n\r\nHere is the toString() of the spoon model constructed:\r\n```\r\npublic java.lang.@javax.validation.constraints.NotNull\r\nString mandatoryField;\r\n```\r\n\r\nIt should be this according t me:\r\n```\r\n@javax.validation.constraints.NotNull\r\npublic java.lang.String mandatoryField;\r\n```\r\n\r\nI don't understand how this is possible. This is working fine for example with annotation @javax.xml.bind.annotation.XmlTransient", "url": "https://github.com/INRIA/spoon/issues/1773", "user": "ghilainm", "labels": ["bug"], "created": "2017-12-05 11:31:05", "closed": "2017-12-12 08:58:54", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "bug: Project with modules cannot be spooned in full classpath mode yet", "body": "We have to use some arguments with JDT in order to make it work with full classpath mode.", "url": "https://github.com/INRIA/spoon/issues/1769", "user": "surli", "labels": ["bug"], "created": "2017-12-04 11:47:55", "closed": "2018-06-18 15:29:46", "commits": {}, "ttf": 196.00027777777777, "commitsDetails": []}, {"title": "isSubtypeOf is not working with class hierarchies", "body": "Hi, \r\nI am using spoon to analyze an Android project. I am creating the launcher like the following:\r\n```\r\nLauncher launcher = new Launcher();\r\nlauncher.addInputResource(\"path to my Android project\");\r\nlauncher.getEnvironment().setSourceClasspath(new String[]{\"path to Android jar file\");\r\nlauncher.getEnvironment().setNoClasspath(true);\r\nCtModel model = launcher.buildModel();\r\n```\r\nIn my Android project, I have a class like following:\r\n```\r\npublic class MyEditText extends AppCompatEditText {\r\n}\r\n```\r\n```AppCompandEditText``` is an Android class which extends ```EditText```\r\nNow, I want to check if ```MyEditText``` is a subType of ```EditText```. \r\nI am doing like following:\r\n```\r\nCtTypeReference androidEditRef = launcher.getFactory().Type().createReference(\"android.widget.EditText\");\r\n\r\nCtTypeReference nodeRef = App.launcher.getFactory().Type().createReference(\"MyEditTextPackagePath\");\r\n\r\nnodeRef.isSubtypeOf(androidEditRef)\r\n```\r\nNow this one returns false, I feel like ```isSubType``` is not checking the class hierarchy. \r\nPlease let me know if I am doing something wrong here. ", "url": "https://github.com/INRIA/spoon/issues/1757", "user": "mohammadnaseri", "labels": ["bug"], "created": "2017-11-29 10:53:51", "closed": "2017-12-18 15:10:38", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "ParentNotInitializedException when setNoClassPath is true", "body": "I am trying to analyse the core code of an Android app.\r\nThe decompiled APK contains several packages and I want to consider only one of them.\r\n\r\n```\r\nLauncher spoon = new Launcher();\r\nspoon.addInputResource(\"full/path/to/org\");\r\nspoon.buildModel(); <-- this crashes\r\n```\r\n\r\n> Exception in thread \"main\" spoon.compiler.ModelBuildingException: Callback cannot be resolved to a type at ...\r\n\r\nIt yields an error because it was looking for a type that does not exist in the classpath. I could add more input sources, but I wanted to \"isolate\" the source code instead of aggregating every source until it works.\r\n\r\nThus, I added the following statement just after the creation of the `Launcher` as the documentation described my situation [1]\r\n\r\n`spoon.getEnvironment().setNoClasspath(true);`\r\n\r\n> spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for (class spoon.support.reflect.reference.CtExecutableReferenceImpl)\r\n\r\nI don't understand this error. Is it refering to the `CtExecutableReferenceImp` itself, or an element of this type in the analyzed code? Do I have to set another flag? Is it an expected behavior?\r\nThe main terminated on a error status (code 1).\r\n\r\nThanks\r\n\r\n[1]\r\n> Sets the option \"noclasspath\", use with caution (see explanation below). With this option, Spoon does not require the full classpath to build the model. In this case, all references to classes that are not in the classpath are handled with the reference mechanism. The \"simplename\" of the reference object refers to the unbound identifier. This option facilitates the use of Spoon when is is hard to have the complete and correct classpath, for example for mining software repositories. For writing analyses, this option works well if you don't cross the reference by a call to getDeclaration() (if you really want to do so, then check for nullness of the result before). In normal mode, compilation errors are signaled as exception, with this option enabled they are signaled as message only. The reason is that in most cases, there are necessarily errors related to the missing classpath elements.", "url": "https://github.com/INRIA/spoon/issues/1747", "user": "ttben", "labels": ["bug"], "created": "2017-11-24 10:55:40", "closed": "2017-11-25 21:20:42", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "About memory performance in Spoon 6.0.0", "body": "@tdurieux brings to my attention that apparently Spoon 6.0.0 is much more slower than previous releases, so I tried to analyze the memory usage between Spoon 5.9.0 and Spoon 6.0.0 when calling Launcher#run on a project (namely Google Guava). \r\n\r\nThe result is shown here: \r\n![spoon-bench-result](https://user-images.githubusercontent.com/1478232/33169260-424e5fda-d044-11e7-9725-c72e1ec7b5ba.png)\r\n\r\nApparently Spoon 6.0.0 uses around 200 Mb supplementary on my machine. Does anyone know out to properly compute a bench and to find where we may have a performance issue? \r\n", "url": "https://github.com/INRIA/spoon/issues/1744", "user": "surli", "labels": ["bug", "help wanted"], "created": "2017-11-23 10:49:44", "closed": "2018-02-14 15:29:04", "commits": {}, "ttf": 83.00027777777778, "commitsDetails": []}, {"title": "bug: ElementPrinterHelper#createListPrinter \"startPrefixSpace\" is not supported", "body": "When building a list printer with boolean startPrefixSpace to true, it does not print a space before the start token. ", "url": "https://github.com/INRIA/spoon/issues/1735", "user": "surli", "labels": ["bug"], "created": "2017-11-21 12:16:40", "closed": "2017-12-01 17:48:40", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "Unwanted factorized annotation values", "body": "I am currently writing a program aiming at refactoring tests from junit 4 to 5.\r\nTo do so, I want to change Categories to Tags.\r\n\r\nHere is the junit4 version:\r\n`@Category({SlowTests.class, FastTests.class})`\r\n\r\nHere is the expected result in junit 5 wanted to be produced (one tag per category):\r\n```\r\n@Tag(\"SlowTests\")\r\n@Tag(\"FastTests\")\r\n```\r\n\r\nHere is my code, a for-loop on a list:\r\n```\r\nfor (String tag : tagList) {\r\n            method.getFactory().Annotation().annotate(method, Tag.class,\"value\",tag);\r\n        }\r\n```\r\n\r\nHere is the result:\r\n`@Tag({ \"TestAnnotation.SlowTests\" , \"TestAnnotation.FastTests\" })`\r\n\r\nAny idea why the tags are \"factorized\"?\r\nThanks !", "url": "https://github.com/INRIA/spoon/issues/1722", "user": "lodart", "labels": ["bug"], "created": "2017-11-13 16:08:03", "closed": "2017-11-14 20:25:48", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "MavenLauncher NPE using pom.xml with no 'build' section", "body": "According to the [Maven XSD](http://maven.apache.org/xsd/maven-4.0.0.xsd) the 'build' section of a 'pom.xml' file is optional. \r\n\r\n```\r\n<xs:element minOccurs=\"0\" name=\"build\" type=\"Build\">\r\n```\r\nHowever, if such a file is passed as input to the MavenLauncher, the following NPE exception is thrown:\r\n\r\n```\r\nException in thread \"main\" java.lang.NullPointerException\r\n    at spoon.MavenLauncher$InheritanceModel.getSourceVersion(MavenLauncher.java:344)\r\n    at spoon.MavenLauncher.<init>(MavenLauncher.java:113)\r\n    at spoon.MavenLauncher.<init>(MavenLauncher.java:59)\r\n```", "url": "https://github.com/INRIA/spoon/issues/1716", "user": "fvarrebola", "labels": ["bug"], "created": "2017-11-12 20:56:35", "closed": "2017-11-13 14:26:00", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "CtScanner doesn't scan all comments.", "body": "The missing code in CtScanner can be found by change in CtScannerTest#testScannerCallsAllProperties.\r\nComment this code:\r\n```java\r\n\t\t\t\tif(getter.getName().equals(\"getComments\")) {\r\n\t\t\t\t\t//ignore missing getComments ... until discussion about its contracts is finished\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n```\r\nand test will fail and report all missing `scan(CtRole.COMMENT, ...)` calls.", "url": "https://github.com/INRIA/spoon/issues/1712", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-11-12 13:00:46", "closed": "2018-02-19 21:05:49", "commits": {}, "ttf": 99.00027777777778, "commitsDetails": []}, {"title": "StackOverflowError using Spoon with Spring dependencies", "body": "When using Spoon with Spring dependencies, e.g.\r\n```\r\n\t<dependency>\r\n\t\t<groupId>org.springframework</groupId>\r\n\t\t<artifactId>spring-webmvc</artifactId>\r\n\t\t<version>4.3.12.RELEASE</version>\r\n\t</dependency>\r\n```\r\n\r\nI got a `StackOverflowError` at line 504 of class `spoon.reflect.factory.TypeFactory` inside the method `public <T> CtType<T> get(Class<?> cl)` with parameter `interface org.springframework.cache.annotation.Cacheable`\r\n\r\nMy code is dependent of Spring (e.g. some methods have a `@Cacheable` annotation) but without the Spring dependency inside the Spoon classpath, the problem do not occur.\r\n\r\nI'm using Spoon library:\r\n```\r\n  \t<dependency>\r\n  \t\t<groupId>fr.inria.gforge.spoon</groupId>\r\n  \t\t<artifactId>spoon-core</artifactId>\r\n  \t\t<version>5.9.0</version>\r\n  \t</dependency>\r\n```", "url": "https://github.com/INRIA/spoon/issues/1698", "user": "rpochet", "labels": ["bug"], "created": "2017-11-08 23:11:06", "closed": "2017-11-13 10:29:18", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "bug: regression related to modifiers", "body": "Apparently some modifiers are still not correctly handled. \r\nWe got an error when using Spoon with JUnit, see: \r\n> /builds/workspace/JUnit/target/generated-sources/spoon/org/junit/rules/Timeout.java:[97,91] error: local variable e is accessed from within inner class; needs to be declared final\r\n\r\nin https://ci.inria.fr/sos/job/JUnit/858/console", "url": "https://github.com/INRIA/spoon/issues/1689", "user": "surli", "labels": ["bug"], "created": "2017-11-06 11:25:43", "closed": "2017-11-08 09:51:48", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "build-oudated-file feature is broken", "body": "Hi. I was trying to speed up model building process by building only outdated files, and probably I found some bug.\r\nHere is the code, that I use to build the model:\r\n```\r\npublic static CtModel buildModel(String resourcePath)\r\n{\r\n\tLauncher launcher = new Launcher();\r\n\tlauncher.addInputResource(resourcePath);\r\n\tlauncher.getEnvironment().setNoClasspath(true);\r\n\tlauncher.getEnvironment().setCommentEnabled(true);\r\n\tlauncher.createCompiler();\r\n\tlauncher.setSourceOutputDirectory(\"D:/outpath\");\r\n\tlauncher.getModelBuilder().setBuildOnlyOutdatedFiles(true);\r\n\tlauncher.buildModel();\r\n\tlauncher.getModelBuilder().generateProcessedSourceFiles(OutputType.COMPILATION_UNITS);\r\n\treturn launcher.getModel();\r\n}\r\n```\r\nSo, as far as I understand, in order to build only outdated files we need to save spoon-generated source files, and then spoon will compare their modification time with actual source files.\r\nWhen I run this code at the first time, it works fine (when it builds model from scratch).\r\nBut then, if I run this code again, I will get:\r\n```\r\nException in thread \"main\" java.lang.UnsupportedOperationException\r\n\tat java.util.Collections$UnmodifiableCollection.remove(Collections.java:1058)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.keepOutdatedFiles(JDTBasedSpoonCompiler.java:546)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:412)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:377)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:353)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:124)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:107)\r\n\tat spoon.Launcher.buildModel(Launcher.java:705)\r\n\tat com.pvsstudio.pvsjava.analyzer.Main.buildModel(Main.java:80)\r\n\tat com.pvsstudio.pvsjava.analyzer.Main.main(Main.java:138)\r\n```\r\nI looked through the spoon code, and found this:\r\n```\r\nprotected CompilationUnitDeclaration[] buildUnits(JDTBuilder jdtBuilder, SpoonFolder sourcesFolder, String[] classpath, String debugMessagePrefix, boolean buildOnlyOutdatedFiles) {\r\n\tList<SpoonFile> sourceFiles = Collections.unmodifiableList(sourcesFolder.getAllJavaFiles());\r\n\t....\r\n\tif (buildOnlyOutdatedFiles && outputDirectory.exists()) {\r\n\t\t@SuppressWarnings(\"unchecked\") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { \"java\" }, true);\r\n\t\tkeepOutdatedFiles(sourceFiles, outputFiles);\r\n\t}\r\n\t....\r\n}\r\n```\r\n```\r\nprotected void keepOutdatedFiles(List<SpoonFile> files, Collection<File> outputFiles) {\r\n\t....\r\n\tFile f = sf.toFile();\r\n\tfor (String s : relativeOutputPaths) {\r\n\t\tif (f.getAbsolutePath().endsWith(s)) {\r\n\t\t\tif (f.lastModified() <= new File(outputDirectory, s).lastModified()) {\r\n\t\t\t\tfiles.remove(sf); // <== But files is unmodifiable list!\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nSo, as you can see, exception is thrown because of .remove(sf) call on unmodifiable list.\r\nI'm pretty sure, that sourceFiles should not be an unmodifiableList.\r\nI really want some fix, because without it I can not use incremental model build.\r\n\r\nIn addition, I've got one more question about model building. Is it possible to use multiple CPU-cores to speed up the build?\r\nThank you.", "url": "https://github.com/INRIA/spoon/issues/1685", "user": "Egor18", "labels": ["bug"], "created": "2017-11-01 18:33:25", "closed": "2018-03-23 19:07:47", "commits": {}, "ttf": 142.00027777777777, "commitsDetails": []}, {"title": "bug: Regression with the use of generics", "body": "Apparently we got a regression with generics maybe because of #1661 \r\nWe got the following error when using Spoon on assertj: \r\n\r\n> Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.4:generate (default) on project assertj-core: Exception during the spoonify of the target project. Type mismatch: cannot convert from AbstractListAssert<capture#76-of ?,List<? extends Object>,Object,ObjectAssert<Object>> to AbstractListAssert<?,List<?>,Object,ObjectAssert<Object>> at /builds/workspace/AssertJ/src/main/java/org/assertj/core/api/AbstractIterableAssert.java:491 -> [Help 1]\r\n\r\n\r\nFull log available there: https://ci.inria.fr/sos/job/AssertJ/428/console", "url": "https://github.com/INRIA/spoon/issues/1670", "user": "surli", "labels": ["bug"], "created": "2017-10-30 09:03:02", "closed": "2017-11-06 10:51:59", "commits": {}, "ttf": 7.000277777777778, "commitsDetails": []}, {"title": "CtTypeParameterReference#getBoundingType() should return Object appropriately", "body": "CtTypeParameterReference#getBoundingType() should always return Object reference when bounding type is null or Object\r\n\r\nspin-off of #1661 ", "url": "https://github.com/INRIA/spoon/issues/1666", "user": "monperrus", "labels": ["bug"], "created": "2017-10-28 20:38:16", "closed": "2017-11-06 10:51:59", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "Code generators belongs to /spoon-core/src/test", "body": "The package `/spoon-core/src/main/java/spoon/generating`  with all the classes should be moved to  `/spoon-core/src/test/java`, because \r\n1) it is used only in tests\r\n2) it might have dependency to some test support classes - causes compilation error in #1582 \r\n\r\nDo you agree? Can I move it?", "url": "https://github.com/INRIA/spoon/issues/1638", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-10-22 11:50:20", "closed": "2017-11-06 12:12:26", "commits": {"b38c8a0449626d6e410337b27a70f49aeb22e228": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "b38c8a0449626d6e410337b27a70f49aeb22e228", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["696125120a2a2829146c7761433856fc1576e2ac"], "nameRev": "b38c8a0449626d6e410337b27a70f49aeb22e228 tags/spoon-core-6.0.0~29", "commitMessage": "refactor: move package `spoon.generating.*` from src/main to src/test (#1647)\n\nfix #1638", "commitDateTime": "2017-11-06 13:12:24", "authoredDateTime": "2017-11-06 13:12:24", "commitGitStats": [{"filePath": "src/main/java/spoon/{generating => support/visitor}/replace/CtListener.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/{generating => support/visitor}/replace/ReplaceListListener.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/{generating => support/visitor}/replace/ReplaceListener.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/{generating => support/visitor}/replace/ReplaceMapListener.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/{generating => support/visitor}/replace/ReplaceSetListener.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java", "insertions": 113, "deletions": 85, "lines": 198}, {"filePath": "src/test/java/spoon/MavenLauncherTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/{main => test}/java/spoon/generating/CloneVisitorGenerator.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/CtBiScannerGenerator.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/ReplacementVisitorGenerator.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/clone/CloneBuilderTemplate.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/clone/CloneVisitorTemplate.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/clone/GetterTemplateMatcher.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/clone/SetterTemplateMatcher.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/replace/ReplaceScanner.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/{main => test}/java/spoon/generating/replace/ReplacementVisitor.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/{main => test}/java/spoon/generating/scanner/CtBiScannerTemplate.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/{main => test}/java/spoon/generating/scanner/PeekElementTemplate.java", "insertions": 0, "deletions": 0, "lines": 0}, {"filePath": "src/test/java/spoon/processing/CtGenerationTest.java", "insertions": 4, "deletions": 3, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtListener.java", "spoonMethods": [{"spoonMethodName": "spoon.generating.replace.CtListener", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ReplaceListListener.java", "spoonMethods": []}, {"spoonFilePath": "ReplaceListener.java", "spoonMethods": []}, {"spoonFilePath": "ReplaceMapListener.java", "spoonMethods": []}, {"spoonFilePath": "ReplaceSetListener.java", "spoonMethods": []}, {"spoonFilePath": "ReplacementVisitor.java", "spoonMethods": [{"spoonMethodName": "spoon.generating.replace.ReplacementVisitor.replaceInMapIfExist(java.util.Map,spoon.generating.replace.ReplaceMapListener)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.generating.replace.ReplacementVisitor.replaceInSetIfExist(java.util.Set,spoon.generating.replace.ReplaceSetListener)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.generating.replace.ReplacementVisitor.replaceInListIfExist(java.util.List,spoon.generating.replace.ReplaceListListener)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.generating.replace.ReplacementVisitor.replaceElementIfExist(spoon.reflect.declaration.CtElement,spoon.generating.replace.ReplaceListener)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MavenLauncherTest.java", "spoonMethods": [{"spoonMethodName": "spoon.MavenLauncherTest.spoonMavenLauncherTest()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CloneVisitorGenerator.java", "spoonMethods": []}, {"spoonFilePath": "CtBiScannerGenerator.java", "spoonMethods": []}, {"spoonFilePath": "ReplacementVisitorGenerator.java", "spoonMethods": []}, {"spoonFilePath": "CloneBuilderTemplate.java", "spoonMethods": []}, {"spoonFilePath": "CloneVisitorTemplate.java", "spoonMethods": []}, {"spoonFilePath": "GetterTemplateMatcher.java", "spoonMethods": []}, {"spoonFilePath": "SetterTemplateMatcher.java", "spoonMethods": []}, {"spoonFilePath": "ReplaceScanner.java", "spoonMethods": [{"spoonMethodName": "spoon.generating.replace.ReplaceScanner.createListenerClass(spoon.reflect.factory.Factory,java.lang.String,spoon.reflect.reference.CtTypeReference,spoon.generating.replace.ReplaceScanner$Type)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.generating.replace.ReplaceScanner.createListenerClass(spoon.reflect.factory.Factory,java.lang.String,spoon.reflect.reference.CtTypeReference,spoon.generating.replace.ReplaceScanner$Type).1.matches(spoon.reflect.reference.CtTypeReference)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CtBiScannerTemplate.java", "spoonMethods": []}, {"spoonFilePath": "PeekElementTemplate.java", "spoonMethods": []}, {"spoonFilePath": "CtGenerationTest.java", "spoonMethods": [{"spoonMethodName": "spoon.processing.CtGenerationTest.testGenerateReplacementVisitor()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.processing.CtGenerationTest.testGenerateCtBiScanner()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.processing.CtGenerationTest.testGenerateCloneVisitor()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug in setPosition", "body": "from @Egor18\r\n\r\nAlso I probably have found some issue with `getPosition()` method.\r\nConsider the following code:\r\n```\r\nif (cond) return 10;\r\nelse return 20;\r\n```\r\n\r\nWhen I'm trying to get positions this way:\r\n```\r\n@Override\r\npublic void visitCtIf(CtIf ifElement)\r\n{\r\n  super.visitCtIf(ifElement);\r\n  \r\n  CtStatement thenStatement = ifElement.getThenStatement();\r\n  CtStatement elseStatement = ifElement.getElseStatement();\r\n \r\n  System.out.println(thenStatement.getPosition());\r\n  System.out.println(elseStatement.getPosition());\r\n\r\n  ...\r\n}\r\n```\r\n\r\nIt outputs:\r\n```\r\n(unknown file)\r\n(unknown file)\r\n```\r\n\r\nBut if I change source code to this:\r\n```\r\nif (cond)\r\n{\r\n  return 10;\r\n}\r\nelse\r\n{\r\n  return 20;\r\n}\r\n```\r\n\r\nIt works fine:\r\n```\r\n(/Users/Egor/eclipse-workspace/Test/src/Test.java:10)\r\n(/Users/Egor/eclipse-workspace/Test/src/Test.java:14)\r\n```\r\n\r\nTo bypass this issue I have to use this trick:\r\n```\r\nSourcePosition thenPos = thenBody.getStatement(0).getPosition();\r\nSourcePosition elsePos = elseBody.getStatement(0).getPosition();\r\n```\r\n\r\nIt would be great to have it fixed :)\r\nThank you.", "url": "https://github.com/INRIA/spoon/issues/1636", "user": "monperrus", "labels": ["bug"], "created": "2017-10-21 17:03:21", "closed": "2017-10-31 14:41:40", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "bug: import of interface class in JDTImportBuilder", "body": "I don't understand the `klass.isInterface()` in this line:\r\n\r\nhttps://github.com/INRIA/spoon/blob/4ed07f7395ad0b46a0ec360388fe5a0be6f98ac0/src/main/java/spoon/support/compiler/jdt/JDTImportBuilder.java#L115\r\n\r\nFor me we should never import method from interfaces, it means nothing.\r\nDo I miss something?", "url": "https://github.com/INRIA/spoon/issues/1628", "user": "tdurieux", "labels": ["bug"], "created": "2017-10-20 09:08:55", "closed": "2017-11-08 09:52:39", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "The method getResourceA\u200csStream(String) is undefined for the type ClassLoader", "body": "**Replicate**\r\nSpoon the following source file:\r\n``` .java\r\npackage com.company.test;\r\n\r\npublic class Test {\r\n    public Test() {\r\n        final ClassLoader loader = getClass().getClassLoader();\r\n        loader.getResourceA\u200csStream(\"filename.xsl\");\r\n    }\r\n}\r\n```\r\n\r\n**Configuration Settings**\r\nUsing the following configuration settings:\r\n``` .java\r\n        int JDK_VERSION = 7;\r\n\r\n        final Environment environment = launcher.getEnvironment();\r\n        environment.setAutoImports(true);\r\n        environment.setCommentEnabled(true);\r\n        environment.setComplianceLevel(JDK_VERSION);\r\n```\r\n\r\n**Expected Results**\r\nThe source code is loaded successfully.\r\n\r\n**Actual Results**\r\nThe `JDTBasedSpoonCompiler` cannot find `getResourceAsStream(String)`:\r\n\r\n```\r\nspoon.compiler.ModelBuildingException: The method getResourceA\u200csStream(String) is undefined for the type ClassLoader at Test.java:5\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.report(JDTBasedSpoonCompiler.java:597)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.reportProblems(JDTBasedSpoonCompiler.java:578)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:126)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:107)\r\n\tat spoon.Launcher.buildModel(Launcher.java:705)\r\n```\r\n", "url": "https://github.com/INRIA/spoon/issues/1626", "user": "DaveJarvis", "labels": ["bug"], "created": "2017-10-19 18:32:46", "closed": "2017-10-25 15:56:33", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "StackOverflowError with Spoon 6.0.0 using the MavenLauncher", "body": "Hi, I'm having some issues while spooning the source code of this project: https://github.com/joel-costigliola/assertj-core\r\n\r\nThe MavenLauncher was working really well so far, on other smaller projects, but I'm having this error with this project:\r\n\r\n```\r\njava.lang.StackOverflowError\r\n\tat spoon.support.visitor.clone.CloneBuilder.visitCtTypeReference(CloneBuilder.java:241)\r\n\tat spoon.reflect.visitor.CtInheritanceScanner.visitCtTypeParameterReference(CtInheritanceScanner.java:797)\r\n\tat spoon.support.visitor.clone.CloneBuilder.visitCtTypeParameterReference(CloneBuilder.java:236)\r\n\tat spoon.reflect.visitor.CtInheritanceScanner.visitCtWildcardReference(CtInheritanceScanner.java:802)\r\n\tat spoon.support.reflect.reference.CtWildcardReferenceImpl.accept(CtWildcardReferenceImpl.java:28)\r\n\tat spoon.reflect.visitor.CtInheritanceScanner.scan(CtInheritanceScanner.java:170)\r\n\tat spoon.support.visitor.clone.CloneBuilder.build(CloneBuilder.java:33)\r\n\tat spoon.support.visitor.clone.CloneVisitor.visitCtWildcardReference(CloneVisitor.java:646)\r\n\tat spoon.support.reflect.reference.CtWildcardReferenceImpl.accept(CtWildcardReferenceImpl.java:28)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.equals.CloneHelper.clone(CloneHelper.java:48)\r\n\tat spoon.support.visitor.equals.CloneHelper.clone(CloneHelper.java:72)\r\n\tat spoon.support.visitor.clone.CloneVisitor.visitCtTypeReference(CloneVisitor.java:670)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.accept(CtTypeReferenceImpl.java:83)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.equals.CloneHelper.clone(CloneHelper.java:48)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.clone(CtElementImpl.java:479)\r\n\tat spoon.support.reflect.reference.CtReferenceImpl.clone(CtReferenceImpl.java:79)\r\n\tat spoon.support.reflect.reference.CtTypeReferenceImpl.clone(CtTypeReferenceImpl.java:803)\r\n\tat spoon.support.visitor.AbstractTypingContext.adaptType(AbstractTypingContext.java:58)\r\n\tat spoon.support.visitor.MethodTypingContext.adaptType(MethodTypingContext.java:43)\r\n...\r\n```\r\n\r\nMy configuration is the following: \r\n\r\n```\r\n            Launcher launcher = new MavenLauncher(path, MavenLauncher.SOURCE_TYPE.ALL_SOURCE);\r\n            launcher.getEnvironment().setLevel(String.valueOf(Level.ALL));\r\n            launcher.getEnvironment().setShouldCompile(true);\r\n            launcher.getEnvironment().setAutoImports(true);\r\n            launcher.getEnvironment().setNoClasspath(false);\r\n\r\n            launcher.run();\r\n```\r\n\r\nI made a small maven project producing this errror when running a mvn clean install through IntelliJ IDEA. \r\n[SpoonStackError.zip](https://github.com/INRIA/spoon/files/1397738/SpoonAssertJ.zip)\r\n\r\nAny idea from where this might come from ? \r\n\r\nThank you :+1: \r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1617", "user": "orichalque", "labels": ["bug"], "created": "2017-10-19 09:12:06", "closed": "2017-11-08 09:56:20", "commits": {}, "ttf": 20.00027777777778, "commitsDetails": []}, {"title": "Uncorrect parsing of field with generic type fully quallified name", "body": "When trying to parse the class below, the field\r\n```java\r\nclass Test {\r\n   path.to.pack.Target<Object, Object> field;\r\n}\r\n```\r\nis parsed as\r\n```java \r\nimport path.to.pack.Target<Object, Object>;\r\nclass Test {\r\n   Target<Object, Object><Object, Object> field;\r\n}\r\n```\r\n\r\nSpoon was called as :\r\n```java\r\nLauncher launcher = new Launcher();\r\nlauncher.addInputResource(srcDir.getPath());\r\nlauncher.getEnvironment().setAutoImports(true);\r\nlauncher.getEnvironment().setNoClasspath(true);\r\nlauncher.getEnvironment().setComplianceLevel(8);\r\nlauncher.buildModel();\r\n\r\nCtModel model = launcher.getModel();\r\n```\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1607", "user": "nharrand", "labels": ["bug"], "created": "2017-10-16 13:34:58", "closed": "2017-10-17 16:18:23", "commits": {"e620e692915979b40b49acc225ffa51d9db799ac": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "e620e692915979b40b49acc225ffa51d9db799ac", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["3cd7a265d4559aba4516ca168e8bee5fb4b3549f"], "nameRev": "e620e692915979b40b49acc225ffa51d9db799ac tags/spoon-core-6.0.0~70", "commitMessage": "fix: fix bug related to generics in CtTypeReference in noclasspath (#1609)\n\nClose #1607\r\n", "commitDateTime": "2017-10-17 18:09:43", "authoredDateTime": "2017-10-17 18:09:43", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java", "insertions": 11, "deletions": 5, "lines": 16}, {"filePath": "src/test/java/spoon/test/imports/ImportTest.java", "insertions": 22, "deletions": 0, "lines": 22}, {"filePath": "src/test/java/spoon/test/reference/TypeReferenceTest.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "src/test/resources/import-with-generics/TestWithGenerics.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "JDTTreeBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.JDTTreeBuilder.createParameterizedType(org.eclipse.jdt.internal.compiler.ast.TypeReference)", "TOT": 8, "UPD": 0, "INS": 3, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "ReferenceBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(org.eclipse.jdt.internal.compiler.ast.TypeReference)", "TOT": 10, "UPD": 2, "INS": 3, "MOV": 3, "DEL": 2}, {"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.buildTypeReference(org.eclipse.jdt.internal.compiler.ast.TypeReference,org.eclipse.jdt.internal.compiler.lookup.Scope)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(org.eclipse.jdt.internal.compiler.lookup.TypeBinding,org.eclipse.jdt.internal.compiler.ast.TypeReference)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ImportTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.ImportTest.testImportWithGenerics()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TypeReferenceTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.reference.TypeReferenceTest.testTypeReferenceWithGenerics()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TestWithGenerics.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.testclasses.TestWithGenerics", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Inconsistency of CtCatchVariable#type and #multiTypes", "body": "The fields CtCatchVariableImpl#type and CtCatchVariableImpl#multiTypes both represents same role CtRole.TYPE - I am OK with that. because both works with same field - type.\r\n\r\nBut it is actually implemented inconsistently\r\n```java\r\n//set type to x\r\nCtCatchVariableImpl.setType(x)\r\n//set type to y\r\nCtCatchVariableImpl.setMultiType([y])\r\n//ok, the type is y\r\nassertEquals([y], CtCatchVariableImpl.getMultiType())\r\n//what should next line do? This is how it behaves now\r\nassertEquals(x, CtCatchVariableImpl.getType())\r\n//but it should be\r\nassertEquals(y, CtCatchVariableImpl.getType())\r\n//set type to a,b,c\r\nCtCatchVariableImpl.setMultiType([a,b,c])\r\n//ok, the type is a,b,c\r\nassertEquals([a,b,c], CtCatchVariableImpl.getMultiType())\r\n//what should next line do? This is how it behaves now\r\nassertEquals(x, CtCatchVariableImpl.getType())\r\n//but it should probably throw an exception \"There are multiple types in catch. Use getMultiType()\"\r\n```\r\n\r\nWDYT?\r\n\r\nI need to solve this problem before #1582 can be implemented.", "url": "https://github.com/INRIA/spoon/issues/1593", "user": "pvojtechovsky", "labels": ["bug", "good first issue"], "created": "2017-10-12 19:55:15", "closed": "2017-10-30 21:06:06", "commits": {}, "ttf": 18.00027777777778, "commitsDetails": []}, {"title": "Cannot get Class<?> from annotation in spoon processor", "body": "Hello, I have tested it with spoon 5.3.0 and 5.7.0\r\nI'm trying to process (with spoon processor) annotation that provides me with java `Class<?>` object.\r\nWhen that type from annotation is in classpath where spoon was launched from or in spoon's `source classpath` all works well.\r\nBut when it is placed with `input sources` for spoon to process, spoon cannot create reference to that type (it (`spoon.support.reflect.reference.CtTypeReferenceImpl#findClass`) searches only in `URLClassLoader` created from provided `sources classpath`, although spoon `Environment` has necessary type (from `input sources`) and actually can resolve it).\r\nPlease, any help\r\n\r\nUPD\r\nI have created sample <a target=\"_blank\" href=\"https://github.com/gnom7/spoon-bug\">project</a> that demonstrates my issue.\r\n`processor` module contains annotation and processor for it, it will be our `sources classpath` (as source code uses annotation).\r\n`main` module depends on `processor` and runs code transformation.\r\n`com` folder in project's root contains sources to process.\r\nAfter project build, run `Main` class in `main` module and look at the `bug` module's `target` where spooned sources will be placed. `K1.java` should have method that returns `com.K2.class`, but now it has empty body. Then if you copy K2 class to `processor` module (so it appears in the sources classpath) or to the `main` module, spoon processes sources well.\r\nAlso, is there any built in way to fail spoon's caller process with exception when exception occurres inside spoon (to fail-fast if spoon is likely to generate garbage), i.e. force `Launcher` to rethrow its inner exception?", "url": "https://github.com/INRIA/spoon/issues/1590", "user": "gnom7", "labels": ["bug"], "created": "2017-10-11 16:33:22", "closed": "2017-12-01 10:39:43", "commits": {}, "ttf": 50.000277777777775, "commitsDetails": []}, {"title": "Bug: error with star imports and visibilities of classes", "body": "Hi all,\r\n\r\nSpoon doesn't check the visibility of classes when build imports, that results in error if Spoon wants to replace the star `*` by an non-public class.\r\n\r\nCheers.", "url": "https://github.com/INRIA/spoon/issues/1587", "user": "danglotb", "labels": ["bug"], "created": "2017-10-11 11:56:47", "closed": "2017-10-11 14:24:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "The spoon output file after modification has some unfiltered classpath declarations.", "body": "Hello I observed something while using spoon parser and modifier.\r\n\r\nPlease find the input code below:\r\n\r\n```java\r\npublic class App {\r\n    public static void main(String[] args) {\r\n            System.out.println(\"Hello world \");\r\n            System.out.println(\"Second print statement\");\r\n        }\r\n}\r\n\r\n/*Say I delete the the second print statement System.out.println(\"Second print statement\");\r\nThe resulting out is shown below\r\n*/\r\n\r\npublic class App {\r\n    public static void main(String[] args) {\r\n            java.lang.System.out.println(\"Hello world \");\r\n        }\r\n}\r\n```\r\n\r\nWhy is the classpath of System.out.println i.e \"java.lang\" added as part of the final output, is there a prettyprint flag, which needs to be considered to create an exact output as similar to the original input?\r\n\r\nRegards\r\nSourabh\r\n\r\n\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1550", "user": "sourabhsparkala", "labels": ["bug"], "created": "2017-09-21 14:02:48", "closed": "2017-10-25 13:06:20", "commits": {}, "ttf": 33.000277777777775, "commitsDetails": []}, {"title": "Renaming the package name, is creating a compilation issue", "body": "Hello,\r\n\r\nPlease find the below code\r\n\r\n```java\r\npackage app;\r\n\r\nClass Test{\r\n        public static void main(String[] args){\r\n                  System.out.println(\"test\");\r\n        }\r\n}\r\n```\r\n\r\n\r\nI am parsing the code using spoon, and I am trying to change the name of the package app\r\n\r\n```java\r\n(element instanceof CtPackage){\r\n         ((CtPackage) element).setSimpleName(\"newtest\");\r\n}\r\n````\r\n\r\nThe output of the code is occurring as:\r\n\r\n```java\r\npackage .newtest;\r\n\r\nClass Test{\r\n        public static void main(String[] args){\r\n                  System.out.println(\"test\");\r\n        }\r\n}\r\n```\r\n\r\nThere is PACKAGE_SEPERATOR '.' added before the package. I am not sure if this is the correct way of renaming the package for a class.\r\n\r\nRegards\r\nSourabh\r\n", "url": "https://github.com/INRIA/spoon/issues/1522", "user": "sourabhsparkala", "labels": ["bug"], "created": "2017-09-06 18:59:52", "closed": "2017-09-19 19:21:34", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "getDeclaration may throw a StackOverflowException in noclasspath mode", "body": "See #1515", "url": "https://github.com/INRIA/spoon/issues/1516", "user": "msteinbeck", "labels": ["bug"], "created": "2017-09-04 12:52:21", "closed": "2017-09-05 14:35:46", "commits": {"82eb44bdc63e882696001b3a25f5e32ef2ec8526": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "82eb44bdc63e882696001b3a25f5e32ef2ec8526", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["0e4787187d8d6192c43144de0fc91e5047fa867b"], "nameRev": "82eb44bdc63e882696001b3a25f5e32ef2ec8526 tags/spoon-core-5.9.0~1", "commitMessage": "fix: fix a stack overflow when calling getDeclaration in noclasspath (#1515)\n\nfix #1516 \r\n\r\n* Fixed test name.\r\n\r\n* Fix a potential stack overflow with CtTypeParameterReference\r\n\r\n* Improve test\r\n", "commitDateTime": "2017-09-05 16:35:43", "authoredDateTime": "2017-09-05 16:35:43", "commitGitStats": [{"filePath": "src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java", "insertions": 9, "deletions": 3, "lines": 12}, {"filePath": "src/test/java/spoon/test/reference/ElasticsearchStackoverflowTest.java", "insertions": 67, "deletions": 0, "lines": 67}, {"filePath": "src/test/resources/noclasspath/elasticsearch-stackoverflow/BroadcastShardResponse.java", "insertions": 63, "deletions": 0, "lines": 63}, {"filePath": "src/test/resources/noclasspath/elasticsearch-stackoverflow/TransportBroadcastAction.java", "insertions": 295, "deletions": 0, "lines": 295}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Processor is not using templated type when process method is in an abstract class", "body": "We define an abstract spoon Processor declaring a process method on a templated type:\r\n- https://github.com/HSarah/Tandoori/blob/master/src/main/java/analyzer/TypeProcessor.java\r\n\r\nAnd create a concrete class extending the previous one:\r\n- https://github.com/HSarah/Tandoori/blob/master/src/main/java/analyzer/ClassProcessor.java\r\n- https://github.com/HSarah/Tandoori/blob/master/src/main/java/analyzer/InterfaceProcessor.java\r\n\r\nThe problem is that both the concrete processors are receiving every classes that matches the  upper bound of our template.", "url": "https://github.com/INRIA/spoon/issues/1503", "user": "aveuiller", "labels": ["bug"], "created": "2017-08-10 11:41:05", "closed": "2017-08-31 14:25:30", "commits": {"1d1ed44e13912f8131880119da287c317605e6e3": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 21.00027777777778, "commitsDetails": [{"commitHash": "1d1ed44e13912f8131880119da287c317605e6e3", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["0e10a4eeb6426b1acd96e20a102a9d2f69f83334"], "nameRev": "1d1ed44e13912f8131880119da287c317605e6e3 tags/spoon-core-5.9.0~3", "commitMessage": "fix: fix issue related to processing generic types (#1504)\n\nfix #1503 ", "commitDateTime": "2017-08-31 16:25:29", "authoredDateTime": "2017-08-31 16:25:29", "commitGitStats": [{"filePath": "src/main/java/spoon/support/visitor/ProcessingVisitor.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/test/java/spoon/test/processing/ProcessingTest.java", "insertions": 70, "deletions": 0, "lines": 70}, {"filePath": "src/test/java/spoon/test/processing/testclasses/CtClassProcessor.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/spoon/test/processing/testclasses/CtInterfaceProcessor.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "src/test/java/spoon/test/processing/testclasses/CtTypeProcessor.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/spoon/test/processing/testclasses/GenericCtTypeProcessor.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ProcessingVisitor.java", "spoonMethods": [{"spoonMethodName": "spoon.support.visitor.ProcessingVisitor.canBeProcessed(spoon.reflect.declaration.CtElement)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "ProcessingTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.processing.ProcessingTest.testProcessorWithGenericType()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.processing.ProcessingTest.testCallProcessorWithMultipleTypes()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CtClassProcessor.java", "spoonMethods": [{"spoonMethodName": "spoon.test.processing.testclasses.CtClassProcessor", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CtInterfaceProcessor.java", "spoonMethods": [{"spoonMethodName": "spoon.test.processing.testclasses.CtInterfaceProcessor", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CtTypeProcessor.java", "spoonMethods": [{"spoonMethodName": "spoon.test.processing.testclasses.CtTypeProcessor", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "GenericCtTypeProcessor.java", "spoonMethods": [{"spoonMethodName": "spoon.test.processing.testclasses.GenericCtTypeProcessor", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "NPE on DefaultJavaPrettyPrinter#printCtFieldAccess", "body": "More intel about bug reproduction can be found on the following issue: https://github.com/HSarah/Tandoori/issues/8\r\n\r\nThe full stack trace using spoon 5.9.0-SNAPSHOT below\r\n```\r\nspoon.SpoonException: Printing of spoon.support.reflect.code.CtFieldReadImpl on path \r\n\tCtPackageImpl:org\r\n\tCtPackageImpl:ethack\r\n\tCtPackageImpl:orwall\r\n\tCtClassImpl:PreferencesActivity\r\n\tCtClassImpl:NetworkPrefs\r\n\tCtFieldImpl:listener\r\n\tCtNewClassImpl\r\n\tCtClassImpl:1\r\n\tCtMethodImpl:onSharedPreferenceChanged\r\n\tCtBlockImpl\r\n\tCtIfImpl\r\n\tCtBlockImpl\r\n\tCtInvocationImpl\r\n\tCtFieldReadImpl:PARAM_ACTIVATE\r\nat position (/home/antoine/Documents/work/dev/sarra/reproduction/orWall/tandoori/sources/org/ethack/orwall/PreferencesActivity.java:126) failed\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:319)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtInvocation(DefaultJavaPrettyPrinter.java:1177)\r\n\tat spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:57)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:310)\r\n\tat spoon.reflect.visitor.printer.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:139)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtBlock(DefaultJavaPrettyPrinter.java:491)\r\n\tat spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:49)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:310)\r\n\tat spoon.reflect.visitor.printer.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:139)\r\n\tat spoon.reflect.visitor.printer.ElementPrinterHelper.writeIfOrLoopBlock(ElementPrinterHelper.java:366)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtIf(DefaultJavaPrettyPrinter.java:1091)\r\n\tat spoon.support.reflect.code.CtIfImpl.accept(CtIfImpl.java:46)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:310)\r\n\tat spoon.reflect.visitor.printer.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:139)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtBlock(DefaultJavaPrettyPrinter.java:491)\r\n\tat spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:49)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:310)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:249)\r\n\tat analyzer.ExecutableProcessor.countEffectiveCodeLines(ExecutableProcessor.java:61)\r\n\tat analyzer.ExecutableProcessor.process(ExecutableProcessor.java:42)\r\n\tat analyzer.ClassProcessor.processMethods(ClassProcessor.java:66)\r\n\tat analyzer.ClassProcessor.process(ClassProcessor.java:53)\r\n\tat analyzer.ClassProcessor.process(ClassProcessor.java:25)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:92)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtNewClass(CtScanner.java:581)\r\n\tat spoon.support.reflect.code.CtNewClassImpl.accept(CtNewClassImpl.java:35)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtField(CtScanner.java:387)\r\n\tat spoon.support.reflect.declaration.CtFieldImpl.accept(CtFieldImpl.java:68)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:308)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:69)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:308)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:69)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:629)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:57)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:628)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:57)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:628)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:57)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:628)\r\n\tat spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:57)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)\r\n\tat spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:131)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.process(JDTBasedSpoonCompiler.java:184)\r\n\tat spoon.Launcher.process(Launcher.java:707)\r\n\tat analyzer.MainProcessor.process(MainProcessor.java:57)\r\n\tat analyzer.Main.runAnalysis(Main.java:106)\r\n\tat analyzer.Main.main(Main.java:51)\r\nCaused by: java.lang.NullPointerException\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.printCtFieldAccess(DefaultJavaPrettyPrinter.java:790)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtFieldRead(DefaultJavaPrettyPrinter.java:762)\r\n\tat spoon.support.reflect.code.CtFieldReadImpl.accept(CtFieldReadImpl.java:27)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:310)\r\n\t... 68 more\r\n```", "url": "https://github.com/INRIA/spoon/issues/1501", "user": "aveuiller", "labels": ["bug"], "created": "2017-08-09 15:27:50", "closed": "2017-08-17 13:43:09", "commits": {"27e3d3f895346849555bcd09e47968351dc04b31": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "27e3d3f895346849555bcd09e47968351dc04b31", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["fbf56d6f6628980965c3b2f8eab9ee9db1e3649c"], "nameRev": "27e3d3f895346849555bcd09e47968351dc04b31 tags/spoon-core-5.9.0~8", "commitMessage": "fix: fix NPE in noclasspath mode (#1502)\n\nFix #1501", "commitDateTime": "2017-08-17 15:43:09", "authoredDateTime": "2017-08-17 15:43:09", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/prettyprinter/DefaultPrettyPrinterTest.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/spoon/test/prettyprinter/PrinterTest.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/test/resources/noclasspath/orwall/BackgroundProcess.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "src/test/resources/noclasspath/orwall/PreferencesActivity.java", "insertions": 161, "deletions": 0, "lines": 161}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultJavaPrettyPrinter.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.DefaultJavaPrettyPrinter.printCtFieldAccess(spoon.reflect.code.CtFieldAccess)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "DefaultPrettyPrinterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.prettyprinter.DefaultPrettyPrinterTest.testIssue1501()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "PrinterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.prettyprinter.PrinterTest.testPrintingOfOrphanFieldReference()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BackgroundProcess.java", "spoonMethods": [{"spoonMethodName": "org.ethack.orwall.BackgroundProcess", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "PreferencesActivity.java", "spoonMethods": [{"spoonMethodName": "org.ethack.orwall.PreferencesActivity", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Stackoverflow problem at spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference", "body": "Dear All\r\n\r\nI am using the version of 5.7, and I have encountered a stackoverflow problem when processing a Java file using spoon.\r\n\r\nMy code is very simple, just as follows:\r\n`\r\nLauncher spoon = new Launcher();`\r\n`spoon.addInputResource(\"./targets/KMeansPlusPlusClusterer.java\");`\r\n`spoon.getEnvironment().setNoClasspath(true);`\r\n`ClassDeclarationProcessor processor = new ClassDeclarationProcessor();`\r\n`spoon.addProcessor(processor);`\r\n`spoon.run();`\r\n\r\nClass `ClassDeclrationProcessor` simply overwrites the `process()` method and dose nothing right now.\r\nFor the other Java files, it's OK, but there is an stackoverflow problem when the input source files is `KMeansPlusPlusClusterer.java`.\r\n\r\n![image](https://user-images.githubusercontent.com/2504533/28401908-8e8f4e5c-6d4f-11e7-9db2-8ff34d62f861.png)\r\n\r\n\r\n\r\nI suppose it might relates to the input file.\r\n\r\nIs there any who knows how to resolve this issue and process the source file correctly?\r\n\r\nYou can find the `KMeansPlusPlusClusterer.java` in the following link.\r\n\r\n[https://github.com/justinwm/Lexer/blob/master/code/src/KMeansPlusPlusClusterer.java](https://github.com/justinwm/Lexer/blob/master/code/src/KMeansPlusPlusClusterer.java)\r\n\r\nThanks very much!!", "url": "https://github.com/INRIA/spoon/issues/1482", "user": "justinwm", "labels": ["bug"], "created": "2017-07-20 05:30:23", "closed": "2017-08-04 07:53:37", "commits": {}, "ttf": 15.000277777777777, "commitsDetails": []}, {"title": "ctClass#getSuperclass returns the current class", "body": "The class [it.feio.android.omninotes.models.Attachement](https://github.com/federicoiosue/Omni-Notes/blob/9ebbc0151950f8f9ec69326a9f4decc3db290f4d/omniNotes/src/main/java/it/feio/android/omninotes/models/Attachment.java) will return itself when `getSuperclass()` is called.\r\n\r\nThis happens in noclasspath mode", "url": "https://github.com/INRIA/spoon/issues/1475", "user": "aveuiller", "labels": ["bug"], "created": "2017-07-13 16:07:56", "closed": "2017-07-22 22:47:49", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "bug: FilterTest#testClassCastExceptionOnForEach seems to fail on CI", "body": "See: https://ci.inria.fr/sos/job/Spoon%20Install%20Commit%20Hook/224/console\r\n\r\n> Tests run: 40, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 4.194 sec <<< FAILURE! - in spoon.test.filters.FilterTest\r\ntestClassCastExceptionOnForEach(spoon.test.filters.FilterTest)  Time elapsed: 0.109 sec  <<< ERROR!\r\nspoon.SpoonException: Execution of query callback failed\r\n\tat spoon.test.filters.FilterTest.testClassCastExceptionOnForEach(FilterTest.java:884)\r\nCaused by: java.lang.ClassCastException: spoon.reflect.CtModelImpl$CtRootPackage cannot be cast to spoon.reflect.declaration.CtType\r\n\tat spoon.test.filters.FilterTest.testClassCastExceptionOnForEach(FilterTest.java:884)", "url": "https://github.com/INRIA/spoon/issues/1467", "user": "surli", "labels": ["bug"], "created": "2017-07-06 08:47:43", "closed": "2018-11-27 16:08:49", "commits": {"3bc2a92df077d287d4864101e1942419c86fb169": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 509.0002777777778, "commitsDetails": [{"commitHash": "3bc2a92df077d287d4864101e1942419c86fb169", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["f7fd9124f71519187ad32d86f442423694c65c37"], "nameRev": "3bc2a92df077d287d4864101e1942419c86fb169 tags/spoon-core-7.2.0~26", "commitMessage": "fix(CtQueryImpl#detectTargetClassFromCCE, FilterTest#testInvalidQueryStep): Adapt parsing of ClassCastException message which has changed in oracle jdk 11 (#2787)\n\n* fix #1467\r\n\r\n* fix checkstyle\r\n\r\n* fix test\r\n\r\n* sweeping dust under the carpet\r\n\r\n* cleaning up\r\n\r\n* cleaning up\r\n\r\n* split pr in 2\r\n", "commitDateTime": "2018-11-27 17:08:48", "authoredDateTime": "2018-11-27 17:08:48", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/chain/CtQueryImpl.java", "insertions": 28, "deletions": 16, "lines": 44}, {"filePath": "src/test/java/spoon/test/filters/FilterTest.java", "insertions": 4, "deletions": 1, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtQueryImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.detectTargetClassFromCCE(java.lang.ClassCastException,java.lang.Object)", "TOT": 15, "UPD": 1, "INS": 5, "MOV": 8, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.chain.CtQueryImpl.processCCE(java.lang.String,java.lang.String,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FilterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.filters.FilterTest.testInvalidQueryStep()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug: Comments are probably not parsed well on Mac", "body": "`JDTCommentBuilder#cleanComment` method splits lines by Linux `\\n`\r\n```java\r\nString[] lines = comment.split(\"\\n\");\r\n```\r\nand then cleans up remaining MS Windows `\\r`. I guess that this algorithm will not work on Mac, which uses `\\r` as EOL.\r\n\r\nThe handling of EOL in spoon seems to be not consistent. May be the best would be to \r\n1) preprocess all parsed java source file and to normalize EOL from `\\r\\n` and `\\r` to Linux `\\n`\r\n2) then all internal algorithms in spoon can be easier and may expect that EOL is always `\\n`\r\n3) to configure what EOL is used when pretty printing\r\n\r\nWDYT?\r\n\r\nI am not not going to develop anything here. I just noted that it should be handled somehow during #1455, which is hard for me to test, because I am not able to say what behavior is correct concerning EOL... and Spoon. \r\n\r\nAre there already some rules how EOLs should be handled by Spoon?", "url": "https://github.com/INRIA/spoon/issues/1460", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-07-02 07:00:59", "closed": "2017-10-31 15:36:52", "commits": {"9fbb9b764e389d58719b72ecbd1aa1b52c2f4456": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 121.00027777777778, "commitsDetails": [{"commitHash": "9fbb9b764e389d58719b72ecbd1aa1b52c2f4456", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["bdb87fc5b68f300851ab6d041c3a991f2caeb26c"], "nameRev": "9fbb9b764e389d58719b72ecbd1aa1b52c2f4456 tags/spoon-core-6.0.0~39", "commitMessage": "test: check that CtComment works with \\r separator (#1679)\n\nclose #1460", "commitDateTime": "2017-10-31 16:36:49", "authoredDateTime": "2017-10-31 16:36:49", "commitGitStats": [{"filePath": "src/test/java/spoon/test/comment/CommentTest.java", "insertions": 16, "deletions": 2, "lines": 18}, {"filePath": "src/test/resources/comment/JavaDocComment.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CommentTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.comment.CommentTest.testJavaDocComment()", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 4, "DEL": 1}, {"spoonMethodName": "spoon.test.comment.CommentTest.testJavaDocCommentOnUnix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.comment.CommentTest.testJavaDocCommentOnMac()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.comment.CommentTest.testJavaDocComment(spoon.reflect.declaration.CtClass,java.lang.String)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "JavaDocComment.java", "spoonMethods": [{"spoonMethodName": "spoon.test.comment.testclasses.JavaDocComment", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "fix: getFactory could be null if an element of the model is created without using a factory", "body": "This could now throw NPE with change of ModelListener which use intensively getFactory(). \r\nSimple fix: create a new default factory inside getFactory if it's null: `new FactoryImpl(new DefaultCoreFactory(),new StandardEnvironment());`", "url": "https://github.com/INRIA/spoon/issues/1446", "user": "surli", "labels": ["bug"], "created": "2017-06-28 14:06:17", "closed": "2017-06-29 14:54:40", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "NPE in importScanner", "body": "```java\r\njava.lang.NullPointerException\r\n\tat spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:407)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:429)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:106)\r\n\tat spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:71)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtParameterReference(CtScanner.java:652)\r\n\tat spoon.support.reflect.reference.CtParameterReferenceImpl.accept(CtParameterReferenceImpl.java:40)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtVariableWrite(CtScanner.java:794)\r\n\tat spoon.support.reflect.code.CtVariableWriteImpl.accept(CtVariableWriteImpl.java:26)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)\r\n\tat spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:204)\r\n\tat spoon.reflect.visitor.DefaultJavaPrettyPrinter.computeImports(DefaultJavaPrettyPrinter.java:274)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:232)\r\n\tat fr.inria.spirals.npefix.transformer.processors.VarRetrieveAssign.process(VarRetrieveAssign.java:58)\r\n\tat fr.inria.spirals.npefix.transformer.processors.VarRetrieveAssign.process(VarRetrieveAssign.java:21)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:92)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:272)\r\n\tat spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:536)\r\n\tat spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:66)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:308)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:65)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:64)\r\n\tat spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:308)\r\n\tat spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:65)\r\n\tat spoon.reflect.visitor.CtScanner.scan(CtScanner.java:150)\r\n\tat spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:88)\r\n\tat spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)\r\n\tat fr.inria.spirals.npefix.main.all.Launcher.instrument(Launcher.java:121)\r\n\tat com.github.tdurieux.npefix.maven.plugin.NPEFixMojo.execute(NPEFixMojo.java:132)\r\n\tat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\r\n\tat org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\r\n\tat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\r\n\tat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\r\n\tat org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\r\n\tat org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\r\n\tat org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\r\n\tat org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\r\n\r\n```", "url": "https://github.com/INRIA/spoon/issues/1436", "user": "tdurieux", "labels": ["bug"], "created": "2017-06-27 12:20:13", "closed": "2017-06-27 13:50:20", "commits": {"a3dec4f1b6ab1f84108edb829790119eec6d8516": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "a3dec4f1b6ab1f84108edb829790119eec6d8516", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["3d3217aba7aad3bfb106a449902aae3e6cea6c7c"], "nameRev": "a3dec4f1b6ab1f84108edb829790119eec6d8516 tags/spoon-core-5.8.0~22", "commitMessage": "fix(import): fix NPE with import scanner (#1437)\n\nClose #1436 ", "commitDateTime": "2017-06-27 15:50:17", "authoredDateTime": "2017-06-27 15:50:17", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/ImportScannerImpl.java", "insertions": 6, "deletions": 4, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImportScannerImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug: CtBodyHolder, CTRHSReceiver and CtShadowable are not CtInheritanceScan-ABLE", "body": "See pb with CtBodyHolder, CTRHSReceiver and CtShadowable\r\n\r\none can check this contract in a new architectural test", "url": "https://github.com/INRIA/spoon/issues/1430", "user": "monperrus", "labels": ["bug", "help wanted"], "created": "2017-06-26 13:56:26", "closed": "2017-11-13 18:14:03", "commits": {}, "ttf": 140.00027777777777, "commitsDetails": []}, {"title": "CtCatchVariable type is null when inside a lambda in noclasspath mode", "body": "JDT does not give any information about type of union catch variable in no classpath mode like this: \r\n```catch (IOException | JsonException e )```. \r\n\r\nHowever we manage to get information about its types, so we should be able to infer the type. We should fix that. ", "url": "https://github.com/INRIA/spoon/issues/1420", "user": "surli", "labels": ["bug"], "created": "2017-06-23 14:03:37", "closed": "2017-06-28 14:21:25", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "NPE when using a union catch type inside a lambda not known in no classpath mode", "body": "Just spotted a really specific bug: \r\nwhen calling this kind of code in noclasspath mode, it crashes with NPE: \r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.io.StringReader;\r\nimport java.util.function.Function;\r\nimport toto.NbpOperator; // the important thing is here\r\n\r\npublic class UnionCatch {\r\n    public void toto() {\r\n        bla((NbpOperator) t -> {\r\n                try {\r\n                    Reader reader = new StringReader(\"machin\");\r\n                    int i = -1;\r\n                    while (reader.ready()) {\r\n                        i = reader.read();\r\n                    }\r\n                    return i;\r\n\r\n               // and here\r\n                } catch (IOException | NullPointerException e) {\r\n                    System.out.printf(\"Error\");\r\n                    return 0;\r\n                }\r\n            });\r\n    }\r\n}\r\n```\r\n\r\nThe bug does not occur with a simple catch. Neither it does outside a lambda. Or if the lambda is known in the classpath. ", "url": "https://github.com/INRIA/spoon/issues/1415", "user": "surli", "labels": ["bug"], "created": "2017-06-23 09:16:07", "closed": "2017-06-23 14:33:07", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Type cannot be resolved in no classpath mode", "body": "I'm using spoon to analyse the project [AntennaPod](https://github.com/AntennaPod/AntennaPod), commit [67a1201d282eb258bb496be87c56529c26eae3a1](https://github.com/AntennaPod/AntennaPod/tree/67a1201d282eb258bb496be87c56529c26eae3a1). \r\n\r\nMy launcher configuration is as follows: \r\n```\r\n launcher.addInputResource(appPath);\r\n launcher.getEnvironment().setNoClasspath(true);\r\n launcher.getEnvironment().setSourceClasspath(cl);\r\n launcher.buildModel();\r\n```\r\nI'm getting the following error: \r\n```\r\norg.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type android.annotation.TargetApi cannot be resolved. It is indirectly referenced from required .class files\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:159)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:226)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2391)\r\n\tat org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:4727)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromCompoundName(LookupEnvironment.java:1324)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromConstantPoolName(LookupEnvironment.java:1354)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromConstantPoolName(LookupEnvironment.java:1362)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createAnnotation(BinaryTypeBinding.java:168)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createAnnotations(BinaryTypeBinding.java:176)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethod(BinaryTypeBinding.java:843)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethods(BinaryTypeBinding.java:901)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:524)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:722)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:705)\r\n\tat org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:301)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:180)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:214)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:466)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:520)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:397)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2118)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:485)\r\n\tat org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:999)\r\n\tat org.eclipse.jdt.internal.compiler.ast.ArrayInitializer.resolveTypeExpecting(ArrayInitializer.java:186)\r\n\tat org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:262)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:218)\r\n\tat org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:243)\r\n\tat org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getOtherFieldBindings(QualifiedNameReference.java:729)\r\n\tat org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:1079)\r\n\tat org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:252)\r\n\tat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)\r\n\tat org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)\r\n\tat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)\r\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)\r\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)\r\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)\r\n\tat spoon.support.compiler.jdt.TreeBuilderCompiler.buildUnits(TreeBuilderCompiler.java:68)\r\n\tat spoon.support.compiler.jdt.JDTBatchCompiler.getUnits(JDTBatchCompiler.java:120)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:409)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:371)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:347)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:118)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:101)\r\n\tat spoon.Launcher.buildModel(Launcher.java:699)\r\n\tat analyzer.MainProcessor.process(MainProcessor.java:49)\r\n\tat analyzer.Main.runAnalysis(Main.java:88)\r\n\tat analyzer.Main.main(Main.java:45)\r\n\r\n```\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1410", "user": "HabchiSarra", "labels": ["bug"], "created": "2017-06-21 15:25:44", "closed": "2017-06-23 14:13:05", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "Autoimport: Don't use static import when compliance level < 1.5", "body": "", "url": "https://github.com/INRIA/spoon/issues/1409", "user": "tdurieux", "labels": ["bug"], "created": "2017-06-21 15:07:20", "closed": "2017-06-23 07:42:15", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "issue with isOverriding behavior when extending TypeParameters", "body": "If you consider the interface `Iterable<E>` which contain a method `forEach(Consumer<? super E>)` and if you create a class with a `T extends String` which implements `Iterable<T>`, then you implement your own version of `forEach`: if you use `ClassTypingContext.isSameSignature()` on the two `forEach` methods, it will return false because they do not have the same type parameter. \r\n\r\nI'm really not sure if this is a bug or not: in the overriding method, the type parameter is more defined, so the signature is not exactly the same. But then, if we only use `isSameSignature` in `getAllMethods` (see #1375) we will get both `Iterable#forEach` and `ArrayList#forEach`, when using it on `ArrayList`. \r\n\r\nWDYT? Should we consider the signature are the same, or should we consider that `getAllMethods` should indeed return the two different methods? \r\n\r\nEdit: Actually I extended my test to check with `isOverriding` and it returns false which is obviously wrong. So there's a real issue here. ", "url": "https://github.com/INRIA/spoon/issues/1407", "user": "surli", "labels": ["bug"], "created": "2017-06-21 13:59:12", "closed": "2017-06-28 14:08:58", "commits": {"05df3b8c995cb3bbf1303d1a98dbe6224edee45c": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "05df3b8c995cb3bbf1303d1a98dbe6224edee45c", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["f984d8855a7017b11c55a578f0cd05e25743f9da"], "nameRev": "05df3b8c995cb3bbf1303d1a98dbe6224edee45c tags/spoon-core-5.8.0~16", "commitMessage": "fix: fix issue in ClassTypingContext#isOverriding (#1411)\n\nclose #1407", "commitDateTime": "2017-06-28 16:08:55", "authoredDateTime": "2017-06-28 16:08:55", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "src/main/java/spoon/support/visitor/AbstractTypingContext.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/spoon/reflect/declaration/CtTypeInformationTest.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/spoon/reflect/declaration/UnknownDeclarationTest.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "src/test/java/spoon/test/filters/FilterTest.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/test/java/spoon/test/generics/GenericsTest.java", "insertions": 54, "deletions": 0, "lines": 54}, {"filePath": "src/test/java/spoon/test/generics/testclasses/EnumSetOf.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/spoon/test/generics/testclasses/SameSignature.java", "insertions": 19, "deletions": 0, "lines": 19}, {"filePath": "src/test/java/spoon/test/reference/ExecutableReferenceGenericTest.java", "insertions": 5, "deletions": 1, "lines": 6}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ReferenceBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(org.eclipse.jdt.internal.compiler.lookup.TypeBinding)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "CtExecutableReferenceImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.reference.CtExecutableReferenceImpl.getDeclaration()", "TOT": 5, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "AbstractTypingContext.java", "spoonMethods": [{"spoonMethodName": "spoon.support.visitor.AbstractTypingContext.adaptTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "JavaReflectionTreeBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.visitor.java.JavaReflectionTreeBuilder.visitType(java.lang.reflect.Type)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "CtTypeInformationTest.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.declaration.CtTypeInformationTest.testGetSuperclass()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "UnknownDeclarationTest.java", "spoonMethods": []}, {"spoonFilePath": "FilterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.filters.FilterTest.testInvocationFilterWithExecutableInLibrary()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "GenericsTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.generics.GenericsTest.testIsSameSignatureWithGenerics()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.generics.GenericsTest.testGetExecDeclarationOfEnumSetOf()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EnumSetOf.java", "spoonMethods": [{"spoonMethodName": "spoon.test.generics.testclasses.EnumSetOf", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SameSignature.java", "spoonMethods": [{"spoonMethodName": "spoon.test.generics.testclasses.SameSignature", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExecutableReferenceGenericTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.reference.ExecutableReferenceGenericTest.testReferencesBetweenConstructorsInOtherClass()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Wrong CtRole?", "body": "Is it correct that `CtSwitchImpl#cases` has role CASE and `CtCaseImpl#caseExpression` has tole CASE too ? I suggest to use different roles for these different meanings.\r\n\r\n`CtTypeImpl#typeMembers` has role FIELD. I guess it is confusing. The role name should TYPE_MEMBER, because it may contain fields, methods, constructors and inner types.\r\n\r\n`CtContinueImpl#labelledStatement` has role LABEL, it is the same role like `CtStatementImpl#label`. I guess \r\n`CtContinueImpl#labelledStatement` should have role TARGET_LABEL.\r\n\r\nI also wonder why `CtBreakImpl#targetLabel` has type String and `CtContinueImpl#labelledStatement` has type CtStatement. Why that difference?\r\n\r\nIs it correct that same roles are using different target types? For example:\r\n* CtUnaryOperatorImpl#operand has role EXPRESSION and type spoon.reflect.code.CtExpression<T>\r\n* CtNewClassImpl#anonymousClass has role EXPRESSION and type spoon.reflect.declaration.CtClass<?>\r\n\r\nBut sometime it is correct, for example:\r\n* CtExecutableImpl#body has type spoon.reflect.code.CtBlock<?>\r\n* CtLoopImpl#body has type spoon.reflect.code.CtStatement\r\nbecause CtStatement can be converted to CtBlock\r\n\r\nI have extracted all 1) field type, 2) field name, 3) role name, 4) declaring type name\r\ninto this CSV file [fields.txt](https://github.com/INRIA/spoon/files/1065264/fields.txt)\r\nYou can open it in MS Excel and sort by some column and easily see other inconsistencies too.", "url": "https://github.com/INRIA/spoon/issues/1386", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-06-09 21:22:15", "closed": "2017-06-23 13:10:35", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "bug: CtContinue#getLabelledStatement should be derived, computed with lookup", "body": "and setter setLabelledStatement removed", "url": "https://github.com/INRIA/spoon/issues/1381", "user": "monperrus", "labels": ["bug"], "created": "2017-06-08 12:01:12", "closed": "2017-06-20 13:43:18", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "bug: regression with generic types", "body": "Apparently the CI spotted a regression with generic types usage: see https://ci.inria.fr/sos/job/RxJava/538/console", "url": "https://github.com/INRIA/spoon/issues/1371", "user": "surli", "labels": ["bug"], "created": "2017-06-07 08:35:34", "closed": "2017-06-07 13:14:24", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bug: Stack overflow on recursive call of ReferenceBuilder.getTypeReference with some type parameters", "body": "See https://ci.inria.fr/sos/job/AssertJ/291/console", "url": "https://github.com/INRIA/spoon/issues/1364", "user": "surli", "labels": ["bug"], "created": "2017-06-06 09:39:15", "closed": "2017-06-06 13:44:36", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bug: getAllMethods should not take method from interface with generic type T if overridden in the current class", "body": "Use `isSubSignature` in `SignatureBasedSortedSet` instead of `SignatureComparator`", "url": "https://github.com/INRIA/spoon/issues/1362", "user": "surli", "labels": ["bug"], "created": "2017-06-06 07:59:42", "closed": "2017-06-28 14:19:53", "commits": {}, "ttf": 22.00027777777778, "commitsDetails": []}, {"title": "Template: Substitution insertAll also insert apply method which is mandatory", "body": "Apparently the `Template` interface had changed to integrate `apply` method, which make it mandatory in all templates. However the interface documentation show an usage of a SimpleTemplate, using `Substitution#insertAll`: then the insertAll also insert the method `apply` of the template, which is - I think - never the expected behaviour. ", "url": "https://github.com/INRIA/spoon/issues/1347", "user": "surli", "labels": ["bug"], "created": "2017-05-31 12:30:02", "closed": "2017-05-31 14:34:52", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Template: Substitution insertAll also insert apply method which is mandatory", "body": "Apparently the `Template` interface had changed to integrate `apply` method, which make it mandatory in all templates. However the interface documentation show an usage of a SimpleTemplate, using `Substitution#insertAll`: then the insertAll also insert the method `apply` of the template, which is - I think - never the expected behaviour. ", "url": "https://github.com/INRIA/spoon/issues/1346", "user": "surli", "labels": ["bug"], "created": "2017-05-31 12:28:34", "closed": "2017-06-07 13:22:02", "commits": {}, "ttf": 7.000277777777778, "commitsDetails": []}, {"title": "Variable called \"java\" messes with the imports", "body": "Hello,\r\nI'm Spooning the JUnit4 source code, and in the [following class](https://github.com/junit-team/junit4/blob/master/src/test/java/junit/tests/runner/TextRunnerTest.java), a variable has been named \"java\": \r\n\r\n`String java = System.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + \"java\";`\r\n\r\nI configured my launcher with `launcher.getEnvironment().setAutoImports(false);`, after running the launcher, the following code is generated: \r\n\r\n`java.lang.String java = ((((java.lang.System.getProperty(\"java.home\")) + (java.io.File.separator)) + \"bin\") + (java.io.File.separator)) + \"java\";`\r\n\r\nWhich is completely normal, but the compilation will fail because \"java.lang.System\" refers to the \"java\" String declared earlier, which has no \"lang\" attribute (obviously).\r\n\r\nSince my previous issue I'm running Spoon using `launcher.getEnvironment().setAutoImports(false);`.\r\n\r\nSince it is quite specific, I'm renaming the Java variable in the source code, but it can be a bit time-consuming, when there's multiple classes with a similar variable.\r\n\r\nThibault", "url": "https://github.com/INRIA/spoon/issues/1320", "user": "orichalque", "labels": ["bug"], "created": "2017-05-22 09:39:51", "closed": "2017-05-23 16:43:22", "commits": {"08151bda54b23451d85534763a4ec706708c2e53": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "08151bda54b23451d85534763a4ec706708c2e53", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["4a41286b73ef0230f3df61a921db0306195ca31e"], "nameRev": "08151bda54b23451d85534763a4ec706708c2e53 tags/spoon-core-5.7.0~25", "commitMessage": "fix: improve ImportScanner to support variables called \"java\" (#1321)\n\nfix #1320", "commitDateTime": "2017-05-23 18:43:20", "authoredDateTime": "2017-05-23 18:43:20", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/ImportScannerImpl.java", "insertions": 57, "deletions": 33, "lines": 90}, {"filePath": "src/main/java/spoon/reflect/visitor/MinimalImportScanner.java", "insertions": 13, "deletions": 1, "lines": 14}, {"filePath": "src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/imports/ImportScannerTest.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/spoon/test/imports/ImportTest.java", "insertions": 17, "deletions": 3, "lines": 20}, {"filePath": "src/test/java/spoon/test/imports/testclasses2/JavaLangConflict.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/test/java/spoon/test/variable/AccessFullyQualifiedFieldTest.java", "insertions": 8, "deletions": 6, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImportScannerImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.visitCtTypeReference(spoon.reflect.reference.CtTypeReference)", "TOT": 10, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 2}, {"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.isTypeInCollision(spoon.reflect.reference.CtReference,boolean)", "TOT": 38, "UPD": 11, "INS": 12, "MOV": 9, "DEL": 6}, {"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.visitCtFieldReference(spoon.reflect.reference.CtFieldReference)", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 1}, {"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.addClassImport(spoon.reflect.reference.CtTypeReference)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MinimalImportScanner.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.MinimalImportScanner.addFieldImport(spoon.reflect.reference.CtFieldReference)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.MinimalImportScanner.addMethodImport(spoon.reflect.reference.CtExecutableReference)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ElementPrinterHelper.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.printer.ElementPrinterHelper.writeHeader(java.util.List,java.util.Collection)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ImportScannerTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.ImportScannerTest.testComputeImportsInClass()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImportTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.ImportTest.testSpoonWithImports()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.imports.ImportTest.testNotImportExecutableType()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.imports.ImportTest.testJavaLangIsConsideredAsImported()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "JavaLangConflict.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.testclasses2.JavaLangConflict", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AccessFullyQualifiedFieldTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.variable.AccessFullyQualifiedFieldTest.testNoFQNWhenShadowedByField()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.variable.AccessFullyQualifiedFieldTest.testNoFQNWhenShadowedByLocalVariable()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.variable.AccessFullyQualifiedFieldTest.testNoFQNWhenUsedInTryCatch()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.variable.AccessFullyQualifiedFieldTest.testNoFQNWhenUsedInLoop()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "The fully qualified name of an annotation on a method inside an anonymous inner class is sometimes not completely correct", "body": "I use spoon (the latest version) to get the annotations present in the following java file (in Github project ehcache/ehcache3)\r\n\r\n```java\r\npackage org.ehcache.core;\r\n\r\nimport org.ehcache.Cache;\r\nimport org.ehcache.core.spi.store.Store;\r\nimport org.ehcache.core.spi.store.StoreAccessException;\r\n\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * This implementation could change depending on <a href=\"https://github.com/jsr107/jsr107spec/issues/337\">jsr107spec issue #337</a>\r\n * as letting next() return true might not be such a great idea, and too strict accounting of stats in the TCK\r\n * preventing a look-ahead iterator implementation.\r\n *\r\n * @author Ludovic Orban\r\n */\r\nclass SpecIterator<K, V> implements Iterator<Cache.Entry<K, V>> {\r\n\r\n  private final Jsr107Cache<K, V> cache;\r\n  private final Store.Iterator<Cache.Entry<K, Store.ValueHolder<V>>> iterator;\r\n  private Cache.Entry<K, Store.ValueHolder<V>> current;\r\n\r\n  public SpecIterator(Jsr107Cache<K, V> cache, Store<K, V> store) {\r\n    this.cache = cache;\r\n    this.iterator = store.iterator();\r\n  }\r\n\r\n  @Override\r\n  public boolean hasNext() {\r\n    return iterator.hasNext();\r\n  }\r\n\r\n  @Override\r\n  public Cache.Entry<K, V> next() {\r\n    try {\r\n      Cache.Entry<K, Store.ValueHolder<V>> next = iterator.next();\r\n      final K nextKey = next.getKey();\r\n      Store.ValueHolder<V> nextValueHolder = next.getValue();\r\n\r\n      // call Cache.get() here to check for expiry *and* account for a get in the stats, without using the loader\r\n      if (cache.getNoLoader(nextKey) == null) {\r\n        current = null;\r\n        return null;\r\n      }\r\n\r\n      current = next;\r\n\r\n      final V nextValue = nextValueHolder.value();\r\n      return new Cache.Entry<K, V>() {\r\n        @Override\r\n        public K getKey() {\r\n          return nextKey;\r\n        }\r\n\r\n        @Override\r\n        public V getValue() {\r\n          return nextValue;\r\n        }\r\n      };\r\n    } catch (StoreAccessException sae) {\r\n      current = null;\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public void remove() {\r\n    if (current == null) {\r\n      throw new IllegalStateException();\r\n    }\r\n    cache.remove(current.getKey());\r\n    current = null;\r\n  }\r\n}\r\n```\r\n\r\nHowever, the returned names for the @Override annotation inside the anonymous inner class is org.ehcache.core.Override. ", "url": "https://github.com/INRIA/spoon/issues/1307", "user": "zhongxingyu", "labels": ["bug"], "created": "2017-05-18 15:17:10", "closed": "2017-05-19 18:17:38", "commits": {"cdd2acb779ea5934db6f939cc130394b207ef8e4": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "cdd2acb779ea5934db6f939cc130394b207ef8e4", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["014167880a6e1c523bb27614a02a298ff12eade7"], "nameRev": "cdd2acb779ea5934db6f939cc130394b207ef8e4 tags/spoon-core-5.7.0~29", "commitMessage": "fix: fix bug in qualified names in a special case due to missing information in JDT. Fix #1307.  (#1312)\n\n", "commitDateTime": "2017-05-19 20:17:38", "authoredDateTime": "2017-05-19 20:17:38", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java", "insertions": 12, "deletions": 2, "lines": 14}, {"filePath": "src/test/java/spoon/test/annotation/AnnotationTest.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "src/test/resources/noclasspath/annotation/issue1307/SpecIterator.java", "insertions": 73, "deletions": 0, "lines": 73}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ReferenceBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.setPackageOrDeclaringType(spoon.reflect.reference.CtTypeReference,spoon.reflect.reference.CtReference)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "AnnotationTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.annotation.AnnotationTest.annotationOverrideFQNIsOK()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SpecIterator.java", "spoonMethods": [{"spoonMethodName": "org.ehcache.core.SpecIterator", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Exception at compilation due to a constructor with private visibility", "body": "Hello,\r\n\r\nI'm having an issue while instrumenting the source code of [AssertJ](https://github.com/joel-costigliola/assertj-core) with Spoon. \r\nThe instrumentation part will work, but the compilation part will fail due to the following error:\r\n```\r\nspoon.compiler.ModelBuildingException: The constructor BooleanArrays() is not visible at C:\\Users\\...\\eclipse\\BooleanArraysBaseTest.java:44\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.report(JDTBasedSpoonCompiler.java:578)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.reportProblems(JDTBasedSpoonCompiler.java:559)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.compile(JDTBasedSpoonCompiler.java:158)\r\n\tat spoon.Launcher.run(Launcher.java:658)\r\n```\r\n\r\nI created a small Maven project with the part of the AssertJ source code that I cannot instrument/compile with Spoon. \r\n\r\nThe project architecture is the following: \r\n\r\n```\r\nTheProject\r\n|\r\n|\r\n|__ pom.xml\r\n|\r\n|\r\n\\__ src\r\n        |\r\n        |\r\n        \\__ main\r\n        :       |\r\n        :       |\r\n        :       \\__ java\r\n        :               |\r\n        :               |\r\n        :               \\__ internal\r\n        :                       |\r\n        :                       |\r\n        :                       |__ BooleanArrays.java\r\n        :                       |\r\n        :                       |\r\n        :                       |__ Failures.java\r\n        |\r\n        |\r\n        \\__ test\r\n                |\r\n                |\r\n                \\__ java\r\n                        |\r\n                        |\r\n                        \\__ internal\r\n                        :       |\r\n                        :       |\r\n                        :       |__ BooleanArraysBaseTest.java\r\n                        |\r\n                        |\r\n                        \\__ test\r\n                                |\r\n                                |\r\n                                |__ BooleanArrays.java\r\n```\r\n\r\nAccording to the Exception message, the problems comes from the class `BooleanArraysBaseTest`, which contains the following code: \r\n\r\n```\r\npublic class BooleanArraysBaseTest {\r\n\r\n  protected boolean[] actual;\r\n  protected Failures failures;\r\n  protected BooleanArrays arrays;\r\n\r\n  @Before\r\n  public void setUp() {\r\n    actual = test.BooleanArrays.arrayOf(true, false);\r\n    failures = spy(new Failures());\r\n    arrays = new BooleanArrays();\r\n    arrays.failures = failures;\r\n  }\r\n}\r\n```\r\n\r\nThe statement `arrays = new BooleanArrays();` refers to the BooleanArrays class contained in the same package ('internal'), which is a Singleton, having a constructor with the package visibility: \r\n\r\n```\r\n  @VisibleForTesting\r\n  BooleanArrays() {\r\n  }\r\n```\r\n\r\nThe other class also called `BooleanArrays`, but contained in the other package ('test') has a private constructor. \r\n \r\nMy Launcher configuration is the following:\r\n```\r\nlauncher.getEnvironment().setShouldCompile(true);\r\nlauncher.getEnvironment().setAutoImports(true);\r\nlauncher.getEnvironment().setNoClasspath(false);\t\t\r\n\r\nlauncher.getEnvironment().setSourceClasspath(/* an array with jars */);\t\t\r\n\r\nlauncher.addInputResource(/* src/main/java folder*/);\r\nlauncher.addInputResource(/* src/test/java folder */);\r\n\r\nlauncher.setBinaryOutputDirectory(/* a folder in the project spooned*/); \r\nlauncher.setSourceOutputDirectory(/* an other folder in the project spooned*/);\r\n\r\nlauncher.addProcessor(/* a processor */);\r\nlauncher.run()\r\n\r\n```\r\n\r\nIs there something wrong with my configuration ? I managed to instrument several other projects, but not this one.\r\nTell me if you need any other information.\r\n\r\nAn archive containing this project is available [here](http://ovh.to/tq4oPt9).\r\n\r\nThank you,\r\n\r\nThibault\r\n", "url": "https://github.com/INRIA/spoon/issues/1306", "user": "orichalque", "labels": ["bug"], "created": "2017-05-18 11:32:52", "closed": "2017-05-19 18:14:45", "commits": {"014167880a6e1c523bb27614a02a298ff12eade7": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "014167880a6e1c523bb27614a02a298ff12eade7", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["9b69b9c3611a632324d3ae00e658b0280dcc734b"], "nameRev": "014167880a6e1c523bb27614a02a298ff12eade7 tags/spoon-core-5.7.0~30", "commitMessage": "fix: fix bug in import inference (auto-import mode). Close #1306. (#1308)\n\n", "commitDateTime": "2017-05-19 20:14:44", "authoredDateTime": "2017-05-19 20:14:44", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/ImportScannerImpl.java", "insertions": 16, "deletions": 2, "lines": 18}, {"filePath": "src/test/java/spoon/test/ctClass/CtClassTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "src/test/java/spoon/test/ctClass/testclasses/issue1306/internal/BooleanArrays.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "src/test/java/spoon/test/ctClass/testclasses/issue1306/internal/BooleanArraysBaseTest.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "src/test/java/spoon/test/ctClass/testclasses/issue1306/test/BooleanArrays.java", "insertions": 30, "deletions": 0, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ImportScannerImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.reflect.visitor.ImportScannerImpl.addClassImport(spoon.reflect.reference.CtTypeReference)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CtClassTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctClass.CtClassTest.testDefaultConstructorAreOk()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BooleanArrays.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctClass.testclasses.issue1306.test.BooleanArrays", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BooleanArraysBaseTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctClass.testclasses.issue1306.internal.BooleanArraysBaseTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "getQualifiedName returns simple name when analysing a single file (sometimes)", "body": "Hello, \r\n\r\nI have two classes \"TransporteurFragment\" and \"CompletableFragment\". Both of them are in the same package.\r\nTransporteurFragment extends CompletableFragment, and CompletableFragment is an abstract class extending Fragment (from Android) and containing one abstract method.\r\n\r\nIf I scan the entire project folder, and do element.getSuperclass().getQualifiedName(), where element is the CtClass corresponding to TransporteurFragment, it returns the correct QualifiedName (x.y.z.CompletableFragment). \r\nHowever, if I scan only the TransporteurFragment file, it returns \"CompletableFragment\". \r\n\r\nAt first I though it was not a bug and only a consequence of scanning a single file, but then I though about the imports that indicates where the used classes are from, and the fact that it works for other files ...\r\n\r\nI tried to reproduce this, with basic Java files but I don't know why, it works ... \r\nI have however detected that if CompletableFragment is in a different package than TransporteurFragment, even when scanning only TransporteurFragment.java, it returns the correct QualifiedName, which let me think that maybe there is a real issue ;)\r\n\r\nI hope I was clear enough, if not, I can share you the files that cause me problems !\r\n\r\n(I use v5.6.0 of Spoon, from Maven)", "url": "https://github.com/INRIA/spoon/issues/1293", "user": "mduruisseau", "labels": ["bug"], "created": "2017-05-10 13:58:30", "closed": "2017-05-16 12:42:59", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Commented class may lead to compilation unit error", "body": "Apparently calling Spoon on a project containing an entirely commented class might lead to an error with JDT: \r\n\r\n> inconsistent compilation unit: '$project/src/main/java/io/apisense/sting/environment/PressureSting.java': declared types are []\r\n\r\nThanks @aveuiller for spotting weird bug in Spoon ;-)", "url": "https://github.com/INRIA/spoon/issues/1274", "user": "surli", "labels": ["bug"], "created": "2017-04-27 09:31:21", "closed": "2017-05-03 16:15:09", "commits": {"d3f34babbcfeea49de9d6175d581df3f8b491845": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "d3f34babbcfeea49de9d6175d581df3f8b491845", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["8850c5ba129601b4f38fb5a3017fe9dcbc918aa3"], "nameRev": "d3f34babbcfeea49de9d6175d581df3f8b491845 tags/spoon-core-5.7.0~53", "commitMessage": "fix: fix JDT error when input resource contains an entirely commented class (#1279)\n\nClose  #1274", "commitDateTime": "2017-05-03 18:15:09", "authoredDateTime": "2017-05-03 18:15:09", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java", "insertions": 11, "deletions": 9, "lines": 20}, {"filePath": "src/test/java/spoon/test/api/APITest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/support/ResourceTest.java", "insertions": 11, "deletions": 6, "lines": 17}, {"filePath": "src/test/resources/spoon/test/api/CommentedClass.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "JDTBasedSpoonCompiler.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration[])", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 0}]}, {"spoonFilePath": "APITest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.api.APITest.testBasicAPIUsage()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ResourceTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.support.ResourceTest.testFileSystemFolder()", "TOT": 10, "UPD": 5, "INS": 3, "MOV": 2, "DEL": 0}, {"spoonMethodName": "spoon.test.support.ResourceTest.testVirtualFolder()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CommentedClass.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "[generic type] Regression in being able to spoon Guava", "body": "It seems that #1218 introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon, see the trace : \r\n<details>\r\n\r\n> Cloning the remote Git repository\r\n> Cloning repository https://github.com/spoon-bot/guava.git\r\n> git init /builds/workspace/Guava # timeout=10\r\n> Fetching upstream changes from https://github.com/spoon-bot/guava.git\r\n> git --version # timeout=10\r\n> git fetch --tags --progress https://github.com/spoon-bot/guava.git +refs/heads/*:refs/remotes/origin/*\r\n> git config remote.origin.url https://github.com/spoon-bot/guava.git # timeout=10\r\n> git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10\r\n> git config remote.origin.url https://github.com/spoon-bot/guava.git # timeout=10\r\n> Fetching upstream changes from https://github.com/spoon-bot/guava.git\r\n> git fetch --tags --progress https://github.com/spoon-bot/guava.git +refs/heads/*:refs/remotes/origin/*\r\n> git rev-parse refs/remotes/origin/master^{commit} # timeout=10\r\n> git rev-parse refs/remotes/origin/origin/master^{commit} # timeout=10\r\n> Checking out Revision cc335985ccd19c6dd13087ca3c13c92e7793c36b (refs/remotes/origin/master)\r\n> git config core.sparsecheckout # timeout=10\r\n> git checkout -f cc335985ccd19c6dd13087ca3c13c92e7793c36b\r\n> git rev-list cc335985ccd19c6dd13087ca3c13c92e7793c36b # timeout=10\r\n> [Guava] $ /bin/sh -xe /tmp/hudson8643585831120465795.sh\r\n> rm -rf /builds/.m2/repository/fr/inria/gforge/spoon\r\n> [Guava] $ /bin/sh -xe /tmp/hudson1465629534996861412.sh\r\n> [...]\r\n> [INFO] ------------------------------------------------------------------------\r\n> [INFO] BUILD FAILURE\r\n> [INFO] ------------------------------------------------------------------------\r\n> [INFO] Total time: 1:21.906s\r\n> [INFO] Finished at: Tue Apr 25 01:32:31 CEST 2017\r\n> [INFO] Final Memory: 22M/644M\r\n> [INFO] ------------------------------------------------------------------------\r\n> [ERROR] Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.4:generate (default) on project guava: Exception during the spoonify of the target project. spoon.SpoonException: Cannot resolve 1) type parameter <K>  of declarer @com.google.common.annotations.GwtIncompatible\r\n> [ERROR] public abstract class ForwardingNavigableMap<K, V> extends com.google.common.collect.ForwardingSortedMap<K, V> implements java.util.NavigableMap<K, V> {\r\n> [ERROR] protected ForwardingNavigableMap() {\r\n> [ERROR] }\r\n> [ERROR] \r\n> [ERROR] @java.lang.Override\r\n> [ERROR] protected abstract java.util.NavigableMap<K, V> delegate();\r\n> [ERROR] \r\n> [ERROR] @java.lang.Override\r\n> [ERROR] public java.util.Map.Entry<K, V> lowerEntry(K key) {\r\n> [ERROR] return delegate().lowerEntry(key);\r\n> [ERROR] }\r\n> [ERROR] \r\n> [ERROR] protected java.util.Map.Entry<K, V> standardLowerEntry(K key) {\r\n> [ERROR] return headMap(key, false).lastEntry();\r\n> [ERROR] }\r\n> [ERROR] \r\n> [ERROR] @java.lang.Override\r\n> [ERROR] public K lowerKey(K key) {\r\n> [ERROR] return delegate().lowerKey(key);\r\n> [ERROR] }\r\n> [...]\r\n\r\n</details>\r\n\r\nSee full stack trace:\r\nhttps://ci.inria.fr/sos/job/Guava/262/console", "url": "https://github.com/INRIA/spoon/issues/1271", "user": "surli", "labels": ["bug"], "created": "2017-04-26 08:00:54", "closed": "2018-11-28 16:45:52", "commits": {"4c0ac3299569c30661ef249b9a30813fc1081b62": {"commitGHEventType": "closed", "commitUser": "monperrus"}, "469086ef781293f01982ef7a685e642c330dd0b9": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 581.0002777777778, "commitsDetails": [{"commitHash": "4c0ac3299569c30661ef249b9a30813fc1081b62", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["27fc8208c4da4145c687c7f4db057de7dbed50f6"], "nameRev": "4c0ac3299569c30661ef249b9a30813fc1081b62 tags/spoon-core-5.7.0~57", "commitMessage": "fix: fix regression regarding actual type arguments resolving (#1273)\n\nclose #1271 ", "commitDateTime": "2017-04-27 21:08:19", "authoredDateTime": "2017-04-27 21:08:19", "commitGitStats": [{"filePath": "src/main/java/spoon/support/visitor/ClassTypingContext.java", "insertions": 12, "deletions": 1, "lines": 13}, {"filePath": "src/test/java/spoon/test/generics/GenericsTest.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/test/java/spoon/test/generics/testclasses/Banana.java", "insertions": 8, "deletions": 0, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ClassTypingContext.java", "spoonMethods": [{"spoonMethodName": "spoon.support.visitor.ClassTypingContext.resolveTypeParameters(java.util.List)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "spoon.support.visitor.ClassTypingContext.getActualTypeArguments(java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "GenericsTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.generics.GenericsTest.testClassContextOnInnerClass()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Banana.java", "spoonMethods": [{"spoonMethodName": "spoon.test.generics.testclasses.Banana", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "469086ef781293f01982ef7a685e642c330dd0b9", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["3bc2a92df077d287d4864101e1942419c86fb169"], "nameRev": "469086ef781293f01982ef7a685e642c330dd0b9 tags/spoon-core-7.2.0~25", "commitMessage": "chore: Update build.sh to use the correct snapshot repo in Jenkins (#2777)\n\nfix #1271 ", "commitDateTime": "2018-11-28 17:45:51", "authoredDateTime": "2018-11-28 17:45:51", "commitGitStats": [{"filePath": "doc/jenkins/build.sh", "insertions": 6, "deletions": 2, "lines": 8}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Hashcode cannot be used to differentiate two instances of spoon model?", "body": "Hi there!\r\n\r\nI have a `maven` project that contains a `IfProcessor` using `spoon-core` in its `5.6.0` version.\r\nThe body of this `IfProcessor` is below. It logs the hashcode of an `CtIf` instance and its parent  instance using Spoon's hashcode and using `System.identityHashCode` methods.\r\n\r\n```\r\npublic class IfProcessor extends AbstractProcessor<CtIf> {\r\n    @Override\r\n    public void process(CtIf ctIf) {\r\n        getEnvironment().report(this, Level.INFO, \"Enter CtIf...\");\r\n\r\n        CtElement parent = ctIf.getParent();\r\n\r\n        getEnvironment().report(this, Level.INFO, \"CtIf hash code: \" + ctIf.hashCode());\r\n        getEnvironment().report(this, Level.INFO, \"parent hash code: \" + parent.hashCode());\r\n        getEnvironment().report(this, Level.INFO, \"System.identityHashCode(ctIf); \" + System.identityHashCode(ctIf));\r\n        getEnvironment().report(this, Level.INFO, \"System.identityHashCode(parent): \" + System.identityHashCode(parent));\r\n\r\n        getEnvironment().report(this, Level.INFO, \"Leaving CtIf...\");\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\nI have another `maven` project that depends on the first one and use the `spoon-maven-plugin` on its `2.4` version.\r\nIt contains a dummy java class:\r\n\r\n```\r\npublic class ASampleClass {\r\n    public static void aStaticMethod(String a) {\r\n        if(a.equals(\"a\")) {\r\n            a = \"b\";\r\n        } else {\r\n            a = \"a\";\r\n        }\r\n\r\n        if(a.equals(\"ccc\")) {\r\n            a = \"ccc\";\r\n        } else {\r\n            a = \"abdce\";\r\n        }\r\n\r\n        int w = 3;\r\n    }\r\n}\r\n```\r\n\r\nExecuting the `IfProcessor` on this code sample outputs the following:\r\n\r\n```\r\n2017-04-20 10:46:30,147 INFO spoon.support.StandardEnvironment - Spoon version 5.4.0\r\n2017-04-20 10:46:30,147 INFO spoon.support.StandardEnvironment - running Spoon...\r\n2017-04-20 10:46:30,147 INFO spoon.support.StandardEnvironment - start processing...\r\n2017-04-20 10:46:30,633 INFO spoon.support.StandardEnvironment - Enter CtIf...\r\n2017-04-20 10:46:30,633 INFO spoon.support.StandardEnvironment - CtIf hash code: 1\r\n2017-04-20 10:46:30,633 INFO spoon.support.StandardEnvironment - parent hash code: 1\r\n2017-04-20 10:46:30,633 INFO spoon.support.StandardEnvironment - System.identityHashCode(ctIf); 1785807415\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - System.identityHashCode(parent): 1041451158\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - Leaving CtIf...\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - Enter CtIf...\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - CtIf hash code: 1\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - parent hash code: 1\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - System.identityHashCode(ctIf); 1924802798\r\n2017-04-20 10:46:30,634 INFO spoon.support.StandardEnvironment - System.identityHashCode(parent): 1041451158\r\n2017-04-20 10:46:30,635 INFO spoon.support.StandardEnvironment - Leaving CtIf...\r\n2017-04-20 10:46:30,653 INFO spoon.support.StandardEnvironment - end of processing: \r\n2017-04-20 10:46:30,653 INFO spoon.support.StandardEnvironment - no errors, no warnings\r\n```\r\n\r\nAs you can see `System.identityHashCode(parent)` returns the same identifier for both `CtIf` parent whereas `CtIf`s' hashcodes are differents. Using your method, `CtIf`s' hashcodes and their parent hashcodes are equals to `1` and I am not quite sure why.", "url": "https://github.com/INRIA/spoon/issues/1265", "user": "ttben", "labels": ["bug"], "created": "2017-04-20 08:54:42", "closed": "2017-04-24 14:08:07", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "IndexOutOfBoundsException when adding empty array in annotation value", "body": "I'm trying to add an empty array to a annotation value. But a IndexOutOfBoundsException is thrown reporting invalid 0 index.", "url": "https://github.com/INRIA/spoon/issues/1264", "user": "marciodel", "labels": ["bug"], "created": "2017-04-18 10:34:24", "closed": "2017-05-03 14:28:11", "commits": {"4dedea2d16b5d20c99d724461318f783c8631d3d": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "4dedea2d16b5d20c99d724461318f783c8631d3d", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["f993132633e7ecdd4145052b9eac0267659f9c6e"], "nameRev": "4dedea2d16b5d20c99d724461318f783c8631d3d tags/spoon-core-5.7.0~55", "commitMessage": "fix: fix special case not handled in factory.Annotation().annotate() (#1278)\n\nClose #1264", "commitDateTime": "2017-05-03 16:28:09", "authoredDateTime": "2017-05-03 16:28:09", "commitGitStats": [{"filePath": "src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/spoon/test/annotation/AnnotationTest.java", "insertions": 22, "deletions": 0, "lines": 22}, {"filePath": "src/test/java/spoon/test/annotation/testclasses/Bar.java", "insertions": 8, "deletions": 0, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtAnnotationImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.declaration.CtAnnotationImpl.convertValueToExpression(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "AnnotationTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.annotation.AnnotationTest.annotationAddValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Bar.java", "spoonMethods": [{"spoonMethodName": "spoon.test.annotation.testclasses.Bar", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "[generic type] Incorrect CtExecutableReference signature from CtInvocation when one of the arguments uses generic type", "body": "The signature obtained the following way:\r\n\r\n```\r\nCtInvocation invocation = getInvocationFromModel();\r\nString signature = invocation.getExecutable().getSignature();\r\n\r\n```\r\nis incorrect when one of the method arguments is a templated type AND is also a type not present in the known source paths (e.g., a type from some imported library).\r\n\r\nFor example, if we have the following method:\r\n\r\n`void someMethod(SomeType<String> arg) {..}`\r\n\r\nwhere SomeType is:\r\n\r\n```\r\npackage externallib.types;\r\n\r\npublic interface SomeType<T> {\r\n}\r\n\r\n```\r\nThe resulting signature does not correctly indicate the fully-scoped (externallib.types.SomeType) name of SomeType. This appears to happen only when going through the CtInvocation, not when scanning for the CtMethod and then calling getSignature.\r\n\r\nNote: In my configuration, setNoClasspath has been set to true. This occurs with 5.6.0.", "url": "https://github.com/INRIA/spoon/issues/1258", "user": "wirefreethought", "labels": ["bug"], "created": "2017-04-11 16:58:07", "closed": "2017-04-14 07:14:27", "commits": {"d25247f87b6bdb3aa917a90e70f1d1117424f153": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "d25247f87b6bdb3aa917a90e70f1d1117424f153", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["11d500fb62e40afef7e00af14a5cfadf4eb73011"], "nameRev": "d25247f87b6bdb3aa917a90e70f1d1117424f153 tags/spoon-core-5.7.0~63", "commitMessage": "fix: fix a bug in wrongly qualified type in executable references  (#1259)\n\nCloses  #1258\r\n\r\n* Create a proper unit test for #1258 and propose a fix\r\n\r\n* Add an assertion\r\n", "commitDateTime": "2017-04-14 09:14:26", "authoredDateTime": "2017-04-14 09:14:26", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/test/java/spoon/test/imports/ImportTest.java", "insertions": 33, "deletions": 0, "lines": 33}, {"filePath": "src/test/resources/import-resources/fr/inria/AnotherMissingImport.java", "insertions": 14, "deletions": 0, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ReferenceBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.ReferenceBuilder.getTypeReference(org.eclipse.jdt.internal.compiler.lookup.TypeBinding)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ImportTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.imports.ImportTest.testAnotherMissingImport()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AnotherMissingImport.java", "spoonMethods": [{"spoonMethodName": "fr.inria.AnotherMissingImport", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Package information gets lost if method parameter is a static field", "body": "When passing a static field into a method, the package information of the accessed field is lost.\r\n\r\n\r\nStatic field:\r\n\r\n\tpackage my;\r\n\r\n\tpublic class StaticField {\r\n\t\tpublic final static String TEXT = \"Test\";\r\n\t}\r\n\r\n# Working sample\r\nImported class \"my.StaticField\" is available in model and serialized:\r\n\r\n\timport my.StaticField;\r\n\r\n\tclass TestWorking {\r\n\t\tpublic void literalConcat() {\r\n\t\t\tString r = \"Hello:  \" + StaticField.Text;\r\n\t\t}\r\n\t}\r\n\r\n# Failing sample\r\nImported package \"my\" is missing in model:\r\n\r\n\timport my.StaticField;\r\n\r\n\tclass TestNotWorking {\r\n\t\tprivate void method(String s) {\r\n\t\t}\r\n\t\t\r\n\t\tpublic void typeReference() {\r\n\t\t\tmethod(StaticField.TEXT);\r\n\t\t}\r\n\t}\r\n\r\n## Expected result\r\n\r\n\timport my.StaticField;\r\n\r\n\tclass TestNotWorking {\r\n\t\tprivate void method(String s) {\r\n\t\t}\r\n\t\t\r\n\t\tpublic void typeReference() {\r\n\t\t\tmethod(StaticField.TEXT);\r\n\t\t}\r\n\t}\r\n\r\n## Actual result\r\n\r\n\t// <-- import missing\r\n\r\n\tclass TestNotWorking {\r\n\t\tprivate void method(String s) {\r\n\t\t}\r\n\t\t\r\n\t\tpublic void typeReference() {\r\n\t\t\tmethod(StaticField.TEXT);\r\n\t\t}\r\n\t}\r\n\r\nWhen serializing the class TestWorking, *StaticField* gets imported. This should be the behavior for the second class, too. But when class *TestNotWorking* is serialized, the statement \"import my.StaticField\" is missing.", "url": "https://github.com/INRIA/spoon/issues/1257", "user": "schakko", "labels": ["bug"], "created": "2017-04-08 14:26:15", "closed": "2017-05-03 08:59:18", "commits": {}, "ttf": 24.00027777777778, "commitsDetails": []}, {"title": "[generic type] CtMethod.getReference().getActualMethod() fails for generic parameter types", "body": "```java\r\n//model\r\ninterface IFace<T extends Long> {\r\n void method(T param);\r\n}\r\n//test\r\nCtMethod method = ...//refers `void method(T param)`\r\nmethod.getReference().getActualMethod(); //returns null\r\n```\r\nmethod.getReference().getActualMethod() returns null, because parameter type reference `T` is not able to found it's declaration in `IFace`, because CtExecutableReference parent is null - there is no way how to get to declaration of generic type dynamically.\r\n\r\nThe workaround is:\r\n```java\r\nCtExecutableReference ref = method.getReference();\r\nref.setParent(method);\r\nref.getActualMethod(); //returns expected `Method`\r\n```\r\nI have seen this problem [here](https://github.com/INRIA/spoon/pull/1218/commits/ffab37263d416be0476cd26ebb23c07a6724deb4#diff-89d21fcd8875342a0be9725d0bb210f9R54)", "url": "https://github.com/INRIA/spoon/issues/1256", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-04-04 19:28:09", "closed": "2017-05-31 18:35:09", "commits": {}, "ttf": 56.000277777777775, "commitsDetails": []}, {"title": "Compilation bug, spoon silently doesn't compile any source code in environment where new File(\".\") points to the folder without any java sources (for example in tomcat environment where it points to the bin folder)", "body": "Hello, I have a project that uses spoon 5.3.0. but as for now due to missing org.eclipse.jdt.core/3.12.0.v20160516-2131 (on which spoon relies) in maven repo (and because of that problem some builds on my CI have been failed) I consider switching to spoon 5.6.0, but it seems that I have faced a bug -- when I tested my code in IDE everything was fine, but the same code didn't work in tomcat environment - spoon silently didn't compiled any source code.\r\n\r\nDebugging:\r\nWhen running compile() on SpoonModelBuilder it calls batchCompiler.compile(args); so those args doesn't contain input sources, but \".\"\r\n\r\n```\r\nfinal String[] args = new JDTBuilderImpl() //\r\n\t\t\t\t.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpath(getSourceClasspath()).binaries(getBinaryOutputDirectory())) //\r\n\t\t\t\t.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //\r\n\t\t\t\t.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //\r\n\t\t\t\t.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //\r\n\t\t\t\t.sources(new SourceOptions().sources()) // no sources, handled by the JDTBatchCompiler\r\n\t\t\t\t.build();\r\n\r\n\t\tgetFactory().getEnvironment().debugMessage(\"compile args: \" + Arrays.toString(args));\r\n\t\tSystem.setProperty(\"jdt.compiler.useSingleThread\", \"true\");\r\n\t\tbatchCompiler.compile(args);\r\n```\r\nthen in org.eclipse.jdt.internal.compiler.batch.Main it creates `new File(\".\")` from that argument and calls org.eclipse.jdt.internal.compiler.batch.FileFinder which recursively searchs for files with `SuffixConstants.SUFFIX_STRING_JAVA` (\".java\") extension, so when running in tomcat `new File(\".\")` points to tomcat bin folder wich does not contain any .java files (and running in IDE in sandbox project it points to project base dir -- so it contains .java files), then in Main class filesCount == 0 is true (there is no .java files in tomcat bin folder) and compilation termiates even not being started and in IDE filesCount != 0 (project base dir contains .java files) and compilation proceeds. I haven't debugged further more, and I don't know how then compiled files appeared from VALID sources (not from the project base)...\r\nwhen filesCount == 0, the code below in Main class switches proceed flag to false and eclipse compiler dies.\r\n```\r\n\tif (printUsageRequired || (filesCount == 0 && classCount == 0)) {\r\n\t\tif (usageSection ==  null) {\r\n\t\t\tprintUsage(); // default\r\n\t\t} else {\r\n\t\t\tprintUsage(usageSection);\r\n\t\t}\r\n\t\tthis.proceed = false;\r\n\t\treturn;\r\n\t}\r\n```\r\n\r\n```\r\n/*\r\n *  Low-level API performing the actual compilation\r\n */\r\npublic boolean compile(String[] argv) {\r\n\t// decode command line arguments\r\n\ttry {\r\n\t\tconfigure(argv); //!!!! code above is here\r\n\t\tif (this.progress != null)\r\n\t\t\tthis.progress.begin(this.filenames == null ? 0 : this.filenames.length * this.maxRepetition);\r\n\t\tif (this.proceed) { //!!!! the proceed flag was already switched to false....\r\n```\r\nI have used `InputType.FILES - compiles the java files from the file system, which were registered by {@link #addInputSource(File)} and {@link #addTemplateSource(File)}`\r\nand as was said in the above javaDoc `compiler.addInputSource(spoonResource);` method, so it seems to me that I have done all right.\r\n (the same for v5.5.0)\r\n(for v5.4.0 eclipse compiler is missing too)\r\nThe sample of my code is below.\r\n```\r\nSpoonModelBuilder compiler = new Launcher().createCompiler();\r\ncompiler.setSourceClasspath(classpath);\r\ncompiler.addInputSource(new File(\"/sourceFolder\"));\r\ncompiler.setBinaryOutputDirectory(new File(\"/outputFolder\"));\r\ncompiler.compile(SpoonModelBuilder.InputType.FILES);\r\n```\r\n\r\nPlease note that the same code runs fine directly from IDE via main method, and doesn't work when running in tomcat in bean initialization code.\r\n\r\nYou can create small spring-boot project with dummy component with `@PostConstruct` method in which you can try to compile something, like I did (just place resulting jar with project and embedded tomcat in separate empty folder and run `java -jar your.jar`, then add to the folder some .java files and compilation will be performed).\r\nSo the matter is that with such implementation when new File(\".\") folder does not contain java source code spoon will not be able to compile wichever other source code.", "url": "https://github.com/INRIA/spoon/issues/1246", "user": "gnom7", "labels": ["bug"], "created": "2017-03-31 15:55:08", "closed": "2017-04-03 16:36:03", "commits": {"4d5b8b139a19c17d055b7afd32ed88a45cbd277b": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "4d5b8b139a19c17d055b7afd32ed88a45cbd277b", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["395bcfa1cd6c22d227593287e5da6b0e9bf2c4ad"], "nameRev": "4d5b8b139a19c17d055b7afd32ed88a45cbd277b tags/spoon-core-5.7.0~66", "commitMessage": "fix: fix issue #1246 (PR #1251)\n\n", "commitDateTime": "2017-04-03 18:36:02", "authoredDateTime": "2017-04-03 18:36:02", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/compilation/CompilationTest.java", "insertions": 25, "deletions": 0, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "JDTBasedSpoonCompiler.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.JDTBasedSpoonCompiler.compile(spoon.SpoonModelBuilder$InputType[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CompilationTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.compilation.CompilationTest.testCompilationInEmptyDir()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "CtElementImpl.getMetadataKeys() throws NPE", "body": "I get NPE when invoking method getMetadataKeys() on CtElement. Looking through source code, it looks like metadata can be null. It should have null check and return null like getMetadata() method or return empty set.", "url": "https://github.com/INRIA/spoon/issues/1239", "user": "anivanovic", "labels": ["bug"], "created": "2017-03-26 14:06:13", "closed": "2017-03-27 11:56:43", "commits": {"5403f1552074216126dd0350d0426fc7ccf2dd2c": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "5403f1552074216126dd0350d0426fc7ccf2dd2c", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["f190d8ebcdcfdba60a5490a5a934599fd93b159d"], "nameRev": "5403f1552074216126dd0350d0426fc7ccf2dd2c tags/spoon-core-5.7.0~71", "commitMessage": "fix: fix NPE in CtElement#getMetadataKeys. Closes #1239 (#1240)\n\n", "commitDateTime": "2017-03-27 13:56:43", "authoredDateTime": "2017-03-27 13:56:43", "commitGitStats": [{"filePath": "src/main/java/spoon/support/reflect/declaration/CtElementImpl.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/test/java/spoon/test/ctElement/MetadataTest.java", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtElementImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.declaration.CtElementImpl.getMetadataKeys()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MetadataTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctElement.MetadataTest.testMetadata()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Static variable declared in an interface won't be correctly imported", "body": "Hello, \r\nI'm instrumenting the source code of JUnit4 using Spoon, and I noticed an issue.\r\n\r\nI have this method before running Spoon :\r\n\r\n```\r\n    public synchronized void addFailure(final Test test, final AssertionFailedError e) {\r\n        testFailed(TestRunListener.STATUS_FAILURE, test, e);\r\n    }\r\n```\r\nThis interface: \r\n\r\n```\r\npublic interface TestRunListener {\r\n    /* test status constants*/\r\n    int STATUS_ERROR = 1;\r\n    int STATUS_FAILURE = 2;\r\n    ...\r\n}\r\n```\r\n\r\nAnd after running Spoon on my code, my method becomes: \r\n```\r\n    public synchronized void addFailure(final Test test, final AssertionFailedError e) {\r\n        // new statement added here.\r\n        testFailed(STATUS_FAILURE, test, e);\r\n    }\r\n```\r\n\r\nAnd the import is wrong : `import TestRunListener.STATUS_FAILURE;` instead of  `import junit.runner.TestRunListener;`\r\n\r\nI'm currently using spoon-core-5.6.0-20170312.234509-77.jar\r\nIs there a command-line option to add ? For now I'm using :\r\n`launcher.setArgs(new String[]{\"--output-type\", \"nooutput\", \"--with-imports\", \"-x\"});`\r\n\r\nAnd I still have an error without the \"--with-import\". \r\n\r\nBest Regards,\r\n\r\nT. \r\n\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1236", "user": "orichalque", "labels": ["bug"], "created": "2017-03-21 15:57:43", "closed": "2017-03-27 08:52:53", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "NullPointerException when adding files from an Eclipse plugin", "body": "Hello,\r\n\r\nI'm trying to instrument classes from an Eclipse plug-in. I tried first from a simple Maven project and it worked well, but within the Eclipse plug-in environment I get the following stack trace: \r\n\r\n```\r\nCaused by: java.lang.NullPointerException\r\n\tat org.eclipse.jdt.internal.compiler.batch.FileSystem.<init>(FileSystem.java:141)\r\n\tat org.eclipse.jdt.internal.compiler.batch.Main.getLibraryAccess(Main.java:3086)\r\n\tat spoon.support.compiler.jdt.JDTBatchCompiler.getUnits(JDTBatchCompiler.java:107)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:410)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:372)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:348)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:119)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:102)\r\n\tat spoon.Launcher.buildModel(Launcher.java:700)\r\n\tat spoon.Launcher.run(Launcher.java:651)\r\n\tat cl2t.instrumentation.instrumenters.SpoonInstrumenter.instrumentTarget(SpoonInstrumenter.java:51)\r\n\tat cl2t.Cl2tRunner.lambda$1(Cl2tRunner.java:69)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1249)\r\n\tat cl2t.Cl2tRunner.run(Cl2tRunner.java:69)\r\n\tat cl2t.handlers.DiscoveryHandler.execute(DiscoveryHandler.java:35)\r\n\tat cl2t.handlers.StatementHandler.execute(StatementHandler.java:22)\r\n\tat org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:295)\r\n\tat org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)\r\n\t... 37 more\r\n```\r\n\r\nWhat I'm doing is this: \r\n\r\n```\r\n                launcher = new Launcher();\r\n\t\tlauncher.setArgs(new String[]{\"--output-type\", \"nooutput\"})\r\n\t\tString classFile = InstrumentationUtils.getSrcFile(target);\r\n\t\tFile file = new File(classFile);\r\n\t\tSystem.out.println(file.exists()); //true\r\n\t\tFileSystemFile fsf = new FileSystemFile(file);\r\n\t\tlauncher.addInputResource(fsf);\r\n\t\tlauncher.addProcessor(new CompileProcessor());\r\n\t\tlauncher.run();\r\n```\r\n\r\nWhen running on debug, I saw that the error comes from the following line in the FileSystem class: \r\n\r\n```\r\nprotected FileSystem(Classpath[] paths, String[] initialFileNames, boolean annotationsFromClasspath) {\r\n\tfinal int length = paths.length; //paths = null\r\n        ...\r\n```\r\n\r\nShould I add other command line options or is this the same bug as the 2 other issues #1191 and #1116 ?\r\n\r\nBest Regards,\r\n\r\nThibault", "url": "https://github.com/INRIA/spoon/issues/1222", "user": "orichalque", "labels": ["bug"], "created": "2017-03-13 14:12:01", "closed": "2017-03-15 08:26:22", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}, {"title": "bug in removeStatement", "body": "In this example, if you want to remove the second i++ with `block.removeStatement(block.getStatement(3));`, Spoon removes the first one.\r\n\r\n```\r\n{  int i = 1;\r\n    i++;\r\n    if (i > 0) {\r\n        java.lang.System.out.println(\"test\");\r\n    }\r\n    i++;\r\n}\r\n```\r\n(found by @martinezmatias thanks!)", "url": "https://github.com/INRIA/spoon/issues/1221", "user": "monperrus", "labels": ["bug"], "created": "2017-03-13 09:24:08", "closed": "2017-03-15 13:13:03", "commits": {"561853c421c1e8fc6b3cdd3b3837bf8c2940020a": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "561853c421c1e8fc6b3cdd3b3837bf8c2940020a", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["286e6e993ab642e2e4331ba4573eadab5ca12b1c"], "nameRev": "561853c421c1e8fc6b3cdd3b3837bf8c2940020a tags/spoon-core-5.6.0~2", "commitMessage": "fix: fix wrong behavior for special cases in removeStatement. Closes #1221. (#1224)\n\n", "commitDateTime": "2017-03-15 14:13:01", "authoredDateTime": "2017-03-15 14:13:01", "commitGitStats": [{"filePath": "src/main/java/spoon/support/reflect/code/CtBlockImpl.java", "insertions": 17, "deletions": 1, "lines": 18}, {"filePath": "src/test/java/spoon/test/ctBlock/TestCtBlock.java", "insertions": 45, "deletions": 0, "lines": 45}, {"filePath": "src/test/java/spoon/test/ctBlock/testclasses/Toto.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "src/test/java/spoon/test/snippets/SnippetTest.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtBlockImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.code.CtBlockImpl.removeStatement(spoon.reflect.code.CtStatement)", "TOT": 9, "UPD": 0, "INS": 4, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "TestCtBlock.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctBlock.TestCtBlock", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Toto.java", "spoonMethods": [{"spoonMethodName": "spoon.test.ctBlock.testclasses.Toto", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SnippetTest.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "CtFieldReference.getDefaultExpression() returns initializer from a field of another class", "body": "Hi, I'm trying to collect and evaluate certain strings in the source repository.\r\n\r\nI tried VisitorPartialEvaluator, but it runs into an infinite loop. The reason of this is that fields get mixed up. The code setup is like this:\r\n\r\n```java\r\nclass BaseClass {\r\n    public final static String PREFIX = \"BasePrefix\";\r\n}\r\n\r\nclass ClassB {\r\n    public final static String PREFIX = BaseClass.PREFIX + \".b\";\r\n    public String getKey() {\r\n        return BaseClass.PREFIX + \".x\";\r\n    }\r\n}\r\n```\r\n\r\nNow if you try to read the return value of the `getKey()` method, the CtFieldReference object will return the default value of `ClassB.PREFIX`, not `BaseClass.PREFIX`.", "url": "https://github.com/INRIA/spoon/issues/1213", "user": "bastik", "labels": ["bug"], "created": "2017-03-10 01:20:09", "closed": "2017-03-15 16:44:37", "commits": {"f818e07e0713e20a4cb40dae32a8c7579d8bf140": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "f818e07e0713e20a4cb40dae32a8c7579d8bf140", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["561853c421c1e8fc6b3cdd3b3837bf8c2940020a"], "nameRev": "f818e07e0713e20a4cb40dae32a8c7579d8bf140 tags/spoon-core-5.6.0~1", "commitMessage": "fix: fix bug in getDeclaration(). Closes #1213. (PR #1215)\n\nThis change impacts declaration lookup of field references after clone.", "commitDateTime": "2017-03-15 17:44:35", "authoredDateTime": "2017-03-15 17:44:35", "commitGitStats": [{"filePath": "src/main/java/spoon/refactoring/Refactoring.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "src/main/java/spoon/support/compiler/SnippetCompilationHelper.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "src/main/java/spoon/support/reflect/declaration/CtNamedElementImpl.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/main/java/spoon/support/reflect/reference/CtFieldReferenceImpl.java", "insertions": 0, "deletions": 28, "lines": 28}, {"filePath": "src/test/java/spoon/test/field/FieldTest.java", "insertions": 42, "deletions": 0, "lines": 42}, {"filePath": "src/test/java/spoon/test/field/testclasses/A.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/spoon/test/field/testclasses/BaseClass.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/test/java/spoon/test/reference/CloneReferenceTest.java", "insertions": 37, "deletions": 3, "lines": 40}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Refactoring.java", "spoonMethods": [{"spoonMethodName": "spoon.refactoring.Refactoring.changeTypeName(spoon.reflect.declaration.CtType,java.lang.String)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.refactoring.Refactoring.changeTypeName(spoon.reflect.declaration.CtType,java.lang.String).1.matches(spoon.reflect.reference.CtTypeReference)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "SnippetCompilationHelper.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.SnippetCompilationHelper.internalCompileStatement(spoon.reflect.declaration.CtElement,spoon.reflect.reference.CtTypeReference)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "CtNamedElementImpl.java", "spoonMethods": []}, {"spoonFilePath": "CtFieldReferenceImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.reference.CtFieldReferenceImpl.getDeclaration()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "spoon.support.reflect.reference.CtFieldReferenceImpl.lookupDynamically()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FieldTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.field.FieldTest.testGetDefaultExpression()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "A.java", "spoonMethods": [{"spoonMethodName": "spoon.test.field.testclasses.A", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BaseClass.java", "spoonMethods": [{"spoonMethodName": "spoon.test.field.testclasses.BaseClass", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CloneReferenceTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.reference.CloneReferenceTest.testGetDeclarationAfterClone()", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "spoon.test.reference.CloneReferenceTest.testGetDeclarationOfFieldAfterClone()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "regression detected in Jenkins CI", "body": "see https://ci.inria.fr/sos/job/casper/", "url": "https://github.com/INRIA/spoon/issues/1207", "user": "monperrus", "labels": ["bug"], "created": "2017-03-06 08:47:26", "closed": "2017-03-11 16:49:26", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "[generic type] JDT-related bug concerning type inference with generics and wildcard", "body": "See PR: #1200 ", "url": "https://github.com/INRIA/spoon/issues/1202", "user": "surli", "labels": ["bug", "wontfix"], "created": "2017-03-03 15:08:04", "closed": "2017-12-04 20:10:20", "commits": {}, "ttf": 276.0002777777778, "commitsDetails": []}, {"title": "jTravis: fix bug related to the usage of date depending on timezone", "body": "Travis is failing (see: https://travis-ci.org/Spirals-Team/librepair/builds/202171182) because of a date problem I did not encounter locally: \r\n\r\n> Failed tests:   testGetBuildWithPR(fr.inria.spirals.jtravis.helpers.PRInformationHelperTest): expected:<PRInformation{head=CommitPojo{id='0', sha='567bbabd0c21214107dd8eb23edaf1e31c6ef1b3', branch='doc-typo-wording-fixes', message='Typo and wording fixes', committedAt=Tue Dec 27 18:59:07 UTC 2016, authorName='null', authorEmail='null', committerName='Lionel Seinturier', committerEmail='Lionel.Seinturier@univ-lille1.fr', compareUrl='https://github.com/seintur/spoon/commit/567bbabd0c21214107dd8eb23edaf1e31c6ef1b3'}, base=CommitPojo{id='0', sha='2b13f0f7e82f805b2480f6ff759b2d2e8debb493', branch='master', message='Typo: fixes a typo in doc/gradle.md', committedAt=Tue Dec 27 15:46:43 UTC 2016, authorName='null', authorEmail='null', committerName='\u0414\u043c\u0438\u0442\u0440\u0438\u0439', committerEmail='dm1998@list.ru', compareUrl='https://github.com/INRIA/spoon/commit/2b13f0f7e82f805b2480f6ff759b2d2e8debb493'}, otherRepo=RepositoryPojo{id=27972573, slug='seintur/spoon', active=true, description='Spoon is a library for analyzing and transforming Java source code.', lastBuildId=0}}> but was:<PRInformation{head=CommitPojo{id='0', sha='567bbabd0c21214107dd8eb23edaf1e31c6ef1b3', branch='doc-typo-wording-fixes', message='Typo and wording fixes', committedAt=Tue Dec 27 17:59:07 UTC 2016, authorName='null', authorEmail='null', committerName='Lionel Seinturier', committerEmail='Lionel.Seinturier@univ-lille1.fr', compareUrl='https://github.com/seintur/spoon/commit/567bbabd0c21214107dd8eb23edaf1e31c6ef1b3'}, base=CommitPojo{id='0', sha='2b13f0f7e82f805b2480f6ff759b2d2e8debb493', branch='master', message='Typo: fixes a typo in doc/gradle.md', committedAt=Tue Dec 27 14:46:43 UTC 2016, authorName='null', authorEmail='null', committerName='\u0414\u043c\u0438\u0442\u0440\u0438\u0439', committerEmail='dm1998@list.ru', compareUrl='https://github.com/INRIA/spoon/commit/2b13f0f7e82f805b2480f6ff759b2d2e8debb493'}, otherRepo=RepositoryPojo{id=27972573, slug='seintur/spoon', active=true, description='Spoon is a library for analyzing and transforming Java source code.', lastBuildId=0}}>\r\n\r\nApparently date are shifted one hour before. It should come from a different timezone on Travis server", "url": "https://github.com/INRIA/spoon/issues/1187", "user": "surli", "labels": ["bug"], "created": "2017-02-16 09:19:23", "closed": "2017-02-16 09:20:18", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bug: CtLambda:getMethod introduces a regression", "body": "The PR #1164 seems to introduce a regression when using Spoon on RxJava: \r\n```\r\nspoon.SpoonException: The lambda can be based on interface, which has only one method. But io.reactivex.NbpObservable$NbpOperator has at least two: <T extends java.lang.Object> java.util.function.Function identity() and java.lang.Object apply(java.lang.Object)\r\n```\r\n\r\nSee the full log there: https://ci.inria.fr/sos/job/RxJava/419/console", "url": "https://github.com/INRIA/spoon/issues/1176", "user": "surli", "labels": ["bug"], "created": "2017-02-09 08:24:29", "closed": "2017-02-09 19:41:21", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "bug: CtLocalVariableReference#getDeclaration is not correct", "body": "Following code\r\n```java\r\nvoid localD() {\r\n\tint field = 23;  //declaration A\r\n\tRunnable fnc = new Runnable(){\r\n\t\t@Override\r\n\t\tpublic void run() {\r\n\t\t\tassertTrue(field == 23); //this reference incorectly returns declaration B\r\n\t\t\tint field = 25; //declaration B\r\n\t\t}\r\n\t};\r\n}\r\n```", "url": "https://github.com/INRIA/spoon/issues/1170", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-02-05 14:39:13", "closed": "2017-02-09 19:53:16", "commits": {"05592e51945eb22dd570955c33c83a01d757bac8": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "05592e51945eb22dd570955c33c83a01d757bac8", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["b63ac185bb5c83b60f1c1bdbc10aa9b4004ae3a6"], "nameRev": "05592e51945eb22dd570955c33c83a01d757bac8 tags/spoon-core-5.6.0~17", "commitMessage": "fix: LocalVariableScopeFunction handles CtFor, CtTryWithResource, local classes, ...  (PR #1154, close #1170)\n\n", "commitDateTime": "2017-02-09 20:53:14", "authoredDateTime": "2017-02-09 20:53:14", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/filter/LocalVariableReferenceFunction.java", "insertions": 30, "deletions": 2, "lines": 32}, {"filePath": "src/main/java/spoon/reflect/visitor/filter/LocalVariableScopeFunction.java", "insertions": 1, "deletions": 23, "lines": 24}, {"filePath": "src/main/java/spoon/reflect/visitor/filter/PotentialVariableDeclarationFunction.java", "insertions": 112, "deletions": 0, "lines": 112}, {"filePath": "src/main/java/spoon/reflect/visitor/filter/SiblingsFunction.java", "insertions": 90, "deletions": 0, "lines": 90}, {"filePath": "src/main/java/spoon/support/reflect/reference/CtLocalVariableReferenceImpl.java", "insertions": 29, "deletions": 43, "lines": 72}, {"filePath": "src/test/java/spoon/test/query_function/VariableReferencesModelTest.java", "insertions": 284, "deletions": 0, "lines": 284}, {"filePath": "src/test/java/spoon/test/query_function/VariableReferencesTest.java", "insertions": 337, "deletions": 0, "lines": 337}, {"filePath": "src/test/java/spoon/test/reference/VariableAccessTest.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/spoon/test/reference/testclasses/Tortillas.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "refactor: remove FieldScopeFunction", "body": "I came to opinion, that comparing to LocalVariable/CatchVariable/Parameter-ScopeFunction, are needed to found references to these variables or detect conflicts during refactorings, the `FieldScopeFunction` makes no sense.\r\n\r\nWhy?\r\nThe `CtFieldReference` knows the declaring type and field name, what is unique identification of the referred field, so no scope function is needed to found `CtFieldReferences`. The only little purpose of field scope function might be to optimize performance and to search for such field references only in part of model. \r\nBut this optimization:\r\n* makes sense only for private and package protected fields, because it is clear where their references can be found.\r\n* makes no sense for protected fields, because much more expensive scanning for child classes is needed to detect correct scope\r\n* makes no sense for public fields, because they can be referred from whole model.\r\n\r\nSo I suggest to \r\n1) implement FieldScopeFunction in simpler and faster way, which focuses only for performance and does not try to search ONLY in places where field may occur.\r\n2) to add comment to FieldScopeFunction and VariableScopeFunction, that Field scope is NOT correct for protected fields, because it searches in whole model.\r\n\r\nBecause current implementation of precise FieldScopeFunction is buggy and correct implementation is quite difficult and hard to test.\r\n\r\nYour opinion please?", "url": "https://github.com/INRIA/spoon/issues/1167", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-02-03 22:08:33", "closed": "2017-02-16 16:52:56", "commits": {}, "ttf": 12.000277777777777, "commitsDetails": []}, {"title": "bug: FileNotFoundException while saving the results", "body": "Hey,\r\n\r\nI'm currently having issues while saving the spoon results.\r\nHere's the maven log :\r\n```\r\n[INFO] Reactor Summary:\r\n[INFO]\r\n[INFO] devops-lab1 ........................................ SUCCESS [  0.873 s]\r\n[INFO] devops-spoon ....................................... SUCCESS [  3.372 s]\r\n[INFO] ISLDB :: Equipe DB ................................. FAILURE [ 22.286 s]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 26.893 s\r\n[INFO] Finished at: 2017-02-03T16:35:08+01:00\r\n[INFO] Final Memory: 22M/343M\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal fr.inria.gforge.spoon:spoon-maven-plugin:2.2:generate (default) on project qdb: Error to save result of the plugin: java.io.FileNotFoundException: file:\\D:\\Users\\Gunther\\devops-lab1\\qdb\\target\\spoon-maven-plugin\\result-spoon-1486136103651.xml (The filename, directory name, or volume label syntax is incorrect) -> [Help 1]\r\n[ERROR]\r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR]\r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException\r\n[ERROR]\r\n[ERROR] After correcting the problems, you can resume the build with the command\r\n[ERROR]   mvn <goals> -rf :qdb\r\n```\r\n\r\nI currently have 1 parent module (devops-lab1)  containing 2 sub modules :\r\n- spoon\r\n- qdb\r\n\r\nThanks.", "url": "https://github.com/INRIA/spoon/issues/1166", "user": "scipio3000", "labels": ["bug"], "created": "2017-02-03 15:39:32", "closed": "2017-02-07 09:17:20", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "bug: CtMethod#isDefaultMethod() returns false for default methods", "body": "This code fails, even if `Consumer#andThen` method is default.\r\n```\r\nassertTrue(factory.Class().get(java.util.function.Consumer.class)\r\n   .getMethodsByName(\"andThen\").get(0).isDefaultMethod());\r\n```\r\n", "url": "https://github.com/INRIA/spoon/issues/1163", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-02-02 21:37:52", "closed": "2017-02-06 12:44:50", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "bug: Lambda parameter references are not equal", "body": "The code:\r\n```java\r\nConsumer<Integer> c = (field)->{\r\n\tfield=1;\r\n};\r\n```\r\ncontains CtParameter field in Lambda Expression and CtParameterReference in body of lambda expression. If I try to check whether these parameter references are equal then they are not\r\n```java\r\nCtParameter<?> param = (CtParameter<?>)lambda.getParameters().get(0);\r\nCtParameterReference paramRef = lambda.filterChildren(new TypeFilter<>(CtParameterReference.class)).first();\r\n//it fails here\r\nassertTrue(param.getReference().equals(paramRef));\r\n```\r\n\r\nSee failing test here https://github.com/pvojtechovsky/spoon/commit/b2f771622ed24d69165bcb51b521e5f30cd9b2b7", "url": "https://github.com/INRIA/spoon/issues/1159", "user": "pvojtechovsky", "labels": ["bug"], "created": "2017-02-01 23:12:52", "closed": "2017-02-07 13:26:34", "commits": {"825335e09e986700bb15390cccedc1bab898cf29": {"commitGHEventType": "closed", "commitUser": "surli"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "825335e09e986700bb15390cccedc1bab898cf29", "commitGHEventType": "closed", "commitUser": "surli", "commitParents": ["870a297e6b21673c5c62890cf4b57807dfaf3480"], "nameRev": "825335e09e986700bb15390cccedc1bab898cf29 tags/spoon-core-5.6.0~20", "commitMessage": "feature: CtLambda#getMethod() and fix of #1159 (#1164)\n\n* feature CtLambda#getMethod() + test\r\n\r\n* fix comment as suggested by Martin\r\n\r\n* add commented test of\r\nlambda.getReference().getOverridingExecutable().getDeclaration()\r\n\r\n* renamed getMethod to getOverriddenMethod\r\nFix #1159 ", "commitDateTime": "2017-02-07 14:26:32", "authoredDateTime": "2017-02-07 14:26:32", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/code/CtLambda.java", "insertions": 9, "deletions": 0, "lines": 9}, {"filePath": "src/main/java/spoon/reflect/factory/ExecutableFactory.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "insertions": 38, "deletions": 0, "lines": 38}, {"filePath": "src/test/java/spoon/test/lambda/LambdaTest.java", "insertions": 27, "deletions": 0, "lines": 27}, {"filePath": "src/test/java/spoon/test/lambda/testclasses/Foo.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CtLambda.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.code.getOverriddenMethod()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExecutableFactory.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.factory.ExecutableFactory.createReference(spoon.reflect.declaration.CtExecutable)", "TOT": 5, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "CtLambdaImpl.java", "spoonMethods": [{"spoonMethodName": "spoon.support.reflect.code.CtLambdaImpl.getOverriddenMethod()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LambdaTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.lambda.LambdaTest.testEqualsLambdaParameterRef()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.lambda.LambdaTest.testLambdaMethod()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Foo.java", "spoonMethods": [{"spoonMethodName": "spoon.test.lambda.testclasses.Foo.m9()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "bug: cannot spoon project palatable/lambda", "body": "Spoon fails at building the model of https://github.com/palatable/lambda\r\n\r\n    Type mismatch: cannot convert from new CoProduct2<A,B>(){} to capture#8-of ? extends CoProduct2<A,B> at /builds/workspace/lambda/src/main/java/com/jnape/palatable/lambda/adt/coproduct/CoProduct3.java:65", "url": "https://github.com/INRIA/spoon/issues/1149", "user": "spoon-bot", "labels": ["bug"], "created": "2017-01-28 11:57:52", "closed": "2017-01-30 15:51:19", "commits": {}, "ttf": 2.000277777777778, "commitsDetails": []}, {"title": "Positions lead to ArrayOutOfBoundException in real source", "body": "We have a file 'CollectionHelper' in argouml test code for which spoon's source positions do not match the real source.\r\n\r\nIt's a relative small file with just one method and we try to obtain the source code of the method.\r\n\r\n[file.zip](https://github.com/INRIA/spoon/files/720999/file.zip)\r\n\r\nThis is what spoon wants to give us:\r\n```java\r\nminimal update strategy and updating the\r\n     * collection in place. This can be used with the JMI \"live\" semantic\r\n     * collections to update the model in place. Order of processing is to first\r\n     * remove all obsolete elements from the collection and then add all new\r\n     * elements.\r\n     * \r\n     * @param base\r\n     *            the base collection to be updated\r\n     * @param updates\r\n     *            desired end state of collection\r\n     */\r\n    static void update(Collection base, Collection updates) {\r\n        if (updates == null) {\r\n            base.clear();\r\n            return;\r\n        }\r\n        Collection toBeRemoved = new ArrayList();\r\n        Collection toBeAdded = new ArrayList();\r\n\r\n        Iterator oldIt = base.iterator();\r\n        while (oldIt.hasNext()) {\r\n            State s = (State) oldIt.next();\r\n            if (!updates.contains(s)) {\r\n                toBeRemoved.add(s);\r\n            }\r\n        }\r\n        Iterator newIt = updates.iterator();\r\n        while (newIt.hasNext()) {\r\n            State s = (State) newIt.next();\r\n            if (!base.contains(s)) {\r\n                toBeAdded.add(s);\r\n            }\r\n        }\r\n\r\n        base.removeAll(toBeRemoved);\r\n        base.addAll(toBeAdded);\r\n    }\r\n\r\n}\r\n```", "url": "https://github.com/INRIA/spoon/issues/1143", "user": "arturbosch", "labels": ["bug"], "created": "2017-01-21 07:51:39", "closed": "2017-01-30 08:21:32", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "NullPointerException when using Spoon inside an IntelliJ Plugin (works with .jar but not with Maven)", "body": "Hi !\r\n\r\n**Context:** \r\nWe are using Spoon library inside an IntelliJ plugin for many months. Until now, we used version 5.1.1 downloaded from your website (\"spoon-core-5.1.1-jar-with-dependencies.jar\"). Earlier this week, we updated it on v 5.4, also using the .jar (with dependencies). Till then, no problem.\r\nOn the 11th January (v5.5 release), we switched to a maven dependency. Unfortunately, it looks like there is an incompatibility with IntelliJ and the JDT-core jar included by Spoon ?\r\nI also tried Spoon v5.4.0 (from Maven) VS Spoon v5.4.0 (jar-with-dependencies), but it does the same thing: the jar is OK but when using Maven, it throws this exception:\r\n\r\n**Exception :**\r\n```\r\njava.lang.NullPointerException\r\n\tat org.eclipse.jdt.internal.compiler.batch.FileSystem.<init>(FileSystem.java:141)\r\n\tat org.eclipse.jdt.internal.compiler.batch.Main.getLibraryAccess(Main.java:3086)\r\n\tat spoon.support.compiler.jdt.JDTBatchCompiler.getUnits(JDTBatchCompiler.java:107)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:410)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:372)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:348)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:119)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:102)\r\n\tat spoon.Launcher.buildModel(Launcher.java:700)\r\n```\r\n\r\nUsing breakpoints and debugger, I found this : \r\n![image](https://cloud.githubusercontent.com/assets/1167669/21925416/a9ab9468-d97d-11e6-9be5-e43ff443f028.png)\r\n\r\nWhen you can see the NullPointerException, apparently because \"paths\" is null.\r\nHowever, I am not sure that the problem come from this file. Here is the diff between the two version of the FileSystem.class (decompiled by IntelliJ), on the left side, the one from IntelliJ, on the right side, the Spoon one.\r\n![image](https://cloud.githubusercontent.com/assets/1167669/21925834/7ca01ff0-d97f-11e6-9def-2579d5f1ba88.png)\r\n\r\nI tried several methods to \"force use\" the .jar from Spoon,  without success.\r\nEDIT: Even when deleting the lib from IntelliJ (ecj-4.5.2.jar), the NP Exception is still thrown.\r\n\r\nHave you any idea how I could fix that ?\r\n\r\nThanks !\r\n\r\n\r\n", "url": "https://github.com/INRIA/spoon/issues/1116", "user": "mduruisseau", "labels": ["bug"], "created": "2017-01-13 10:06:57", "closed": "2017-02-06 12:47:54", "commits": {}, "ttf": 24.00027777777778, "commitsDetails": []}, {"title": "Changes to SourcePosition in 5.5.0 ?", "body": "Hello,\r\naccording to #1081 I don't find any mentions of changes to the SourcePosition. \r\n\r\nIn our use case we want to calculate the size of constructors and methods. Which worked just fine in 5.4.\r\nNow with the 5.5 Snapshot I want to analyze a file which has a inner private class with no constructors.\r\nSpoon generates a default `private` constructor with one statement -> `super()`. The start line of this constructor is 1 and getPosition().getFile() returns null while the statements (super()) line is 383 and it has a file.\r\n\r\nMy method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor.\r\n\r\nI always can implement the case to ignore generated constructors, but I just want to make sure this is intented or not.", "url": "https://github.com/INRIA/spoon/issues/1084", "user": "arturbosch", "labels": ["bug"], "created": "2017-01-04 17:18:53", "closed": "2017-01-05 16:11:55", "commits": {"bf0652c5a3dddb0322ff2b471071ffecce7b7c70": {"commitGHEventType": "referenced", "commitUser": "surli"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "bf0652c5a3dddb0322ff2b471071ffecce7b7c70", "commitGHEventType": "referenced", "commitUser": "surli", "commitParents": ["af9ecca3acc9eab0c78f75491f5218beaac17486"], "nameRev": "bf0652c5a3dddb0322ff2b471071ffecce7b7c70 tags/spoon-core-5.5.0~12", "commitMessage": "fix(position): implicit elements do not have position (#1086)\n\nFix #1084", "commitDateTime": "2017-01-05 17:11:54", "authoredDateTime": "2017-01-05 17:11:54", "commitGitStats": [{"filePath": "src/main/java/spoon/support/compiler/jdt/ContextBuilder.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/position/PositionTest.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/spoon/test/position/testclasses/Foo.java", "insertions": 5, "deletions": 0, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ContextBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.ContextBuilder.enter(spoon.reflect.declaration.CtElement,org.eclipse.jdt.internal.compiler.ast.ASTNode)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "PositionTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.position.PositionTest.defaultConstructorPositionTest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Foo.java", "spoonMethods": [{"spoonMethodName": "spoon.test.position.testclasses.Foo", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "ParentNotInitializedException when processing comments with -c ", "body": "I am aware that comments can be processed using the command \"-c\"  since Spoon 5.2.0. Thanks for this feature.  \r\n\r\nWhen using Spoon to process comments in either code snippet below, ParentNotInitializedException will be thrown. An empty processor can be used to reproduce this issue. This happens in both Spoon 5.2 and 5.4.\r\n\r\n\r\npublic class Comment_1 {\r\n\r\n\tpublic void code_1()\r\n\t{\r\n\t\ttry {\t\t}\r\n\t\t// A \r\n\t\t// B\r\n\t\tcatch (Exception ex)\r\n\t\t{\t\t}\r\n\t}\r\n}\r\n\r\n\r\npublic class Comment2 {\r\n\r\n\t// C\r\n \t@interface Code_2{} \t\r\n}\r\n\r\nDetails of the exception are as follows.\r\n\r\nspoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/home/jifeng/workspace/Temp4/src/main/java/example/Comment1.java:17)\r\n\tat spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:284)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:377)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:131)\r\n\tat spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:96)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:387)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116)\r\n\tat spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99)\r\n\tat spoon.Launcher.buildModel(Launcher.java:712)\r\n\tat spoon.Launcher.run(Launcher.java:663)\r\n\tat spoon.Launcher.run(Launcher.java:106)\r\n\tat spoon.Launcher.main(Launcher.java:99)\r\n", "url": "https://github.com/INRIA/spoon/issues/1073", "user": "giphon", "labels": ["bug"], "created": "2016-12-24 14:05:11", "closed": "2017-01-05 16:15:27", "commits": {"ce55bc43a9751081097121a5745d516cad2c5200": {"commitGHEventType": "closed", "commitUser": "monperrus"}}, "ttf": 12.000277777777777, "commitsDetails": [{"commitHash": "ce55bc43a9751081097121a5745d516cad2c5200", "commitGHEventType": "closed", "commitUser": "monperrus", "commitParents": ["ac4988af27def9422c7b95f88efa7263549ee56c"], "nameRev": "ce55bc43a9751081097121a5745d516cad2c5200 tags/spoon-core-5.5.0~10", "commitMessage": "fix(comment): fix bug in comments in array initialization (#1088)\n\nCloses #1073 ", "commitDateTime": "2017-01-05 17:15:25", "authoredDateTime": "2017-01-05 17:15:25", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/main/java/spoon/support/compiler/jdt/JDTCommentBuilder.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/spoon/test/comment/CommentTest.java", "insertions": 10, "deletions": 3, "lines": 13}, {"filePath": "src/test/java/spoon/test/comment/testclasses/Comment2.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/test/java/spoon/test/comment/testclasses/InlineComment.java", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultJavaPrettyPrinter.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtNewArray(spoon.reflect.code.CtNewArray)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ElementPrinterHelper.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.printer.ElementPrinterHelper.getComments(spoon.reflect.declaration.CtElement,spoon.reflect.visitor.printer.CommentOffset)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "JDTCommentBuilder.java", "spoonMethods": [{"spoonMethodName": "spoon.support.compiler.jdt.JDTCommentBuilder.addCommentToNear(spoon.reflect.code.CtComment,java.util.Collection)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "CommentTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.comment.CommentTest.testInLineComment()", "TOT": 7, "UPD": 4, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "spoon.test.comment.CommentTest.testCommentsInComment1And2()", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Comment2.java", "spoonMethods": [{"spoonMethodName": "spoon.test.comment.testclasses.Comment2.code_3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "InlineComment.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "This is not correctly printed in case of multiple inner class", "body": "In the following structure: \r\n```\r\npublic class Rule {\r\n    public static final class Phoneme implements PhonemeExpr {\r\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {[...]};\r\n\r\n        private final StringBuilder phonemeText;\r\n        private final Language language;\r\n\r\n        public Phoneme(final CharSequence phonemeText, final Language language) {\r\n            this.phonemeText = new StringBuilder(phonemeText);\r\n            this.language = language;\r\n        }\r\n```\r\n\r\nThe last `this` are printed as following: `Rule.Phoneme.this` leading to a compilation error because the fields are `final`.", "url": "https://github.com/INRIA/spoon/issues/1055", "user": "surli", "labels": ["bug"], "created": "2016-12-20 09:59:56", "closed": "2016-12-20 16:36:27", "commits": {"747c36d098e25771e4c4002b5e18626044b71551": {"commitGHEventType": "referenced", "commitUser": "monperrus"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "747c36d098e25771e4c4002b5e18626044b71551", "commitGHEventType": "referenced", "commitUser": "monperrus", "commitParents": ["75f027f108342f5afa426a716754831e078bbaed"], "nameRev": "747c36d098e25771e4c4002b5e18626044b71551 tags/spoon-core-5.5.0~23", "commitMessage": "fix(pretty-print): fix pretty-printing of 'this' access for inner classes (#1061)\n\ncloses #1055", "commitDateTime": "2016-12-20 17:36:26", "authoredDateTime": "2016-12-20 17:36:26", "commitGitStats": [{"filePath": "src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java", "insertions": 14, "deletions": 8, "lines": 22}, {"filePath": "src/main/java/spoon/reflect/visitor/PrintingContext.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/spoon/test/prettyprinter/PrinterTest.java", "insertions": 41, "deletions": 0, "lines": 41}, {"filePath": "src/test/java/spoon/test/prettyprinter/testclasses/Rule.java", "insertions": 98, "deletions": 0, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultJavaPrettyPrinter.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtThisAccess(spoon.reflect.code.CtThisAccess)", "TOT": 13, "UPD": 2, "INS": 4, "MOV": 5, "DEL": 2}]}, {"spoonFilePath": "PrintingContext.java", "spoonMethods": [{"spoonMethodName": "spoon.reflect.visitor.PrintingContext.pushCurrentThis(spoon.reflect.declaration.CtType)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "PrinterTest.java", "spoonMethods": [{"spoonMethodName": "spoon.test.prettyprinter.PrinterTest.testRuleCanBeBuild()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "spoon.test.prettyprinter.PrinterTest.testJDTBatchCompilerCanBeBuild()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Rule.java", "spoonMethods": [{"spoonMethodName": "spoon.test.prettyprinter.testclasses.Rule", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Yet another bug spotted with static import", "body": "Apparently some collision still occured with static imports, when using spoon on common-codecs project for example. ", "url": "https://github.com/INRIA/spoon/issues/1053", "user": "surli", "labels": ["bug"], "created": "2016-12-19 16:24:28", "closed": "2017-03-06 09:44:27", "commits": {}, "ttf": 76.00027777777778, "commitsDetails": []}, {"title": "Bug with static import methods when the method or value is in an inner enum", "body": "If a class is defined like this:\r\n\r\n```\r\npublic Foo {\r\n    static enum Toto {}\r\n    public Toto[] aMethod() {\r\n        return Toto.values();\r\n   }\r\n}\r\n```\r\n\r\nIn autoImports value it tries to import the values() method from the inner enum. ", "url": "https://github.com/INRIA/spoon/issues/1044", "user": "surli", "labels": ["bug"], "created": "2016-12-16 13:07:01", "closed": "2016-12-17 13:19:36", "commits": {}, "ttf": 1.0002777777777778, "commitsDetails": []}]}