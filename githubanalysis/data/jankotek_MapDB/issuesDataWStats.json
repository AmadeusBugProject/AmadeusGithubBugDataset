{"bugLabels": ["bug"], "issues": [{"labels": ["3.0", "bug"], "filteredCommits": ["3984104325b21dc0a22ade78d1c1398f65e77537"], "url": "https://github.com/jankotek/mapdb/issues/965", "gitStatsSummary": {"insertions": 13, "gitFilesChange": 1, "lines": 15, "deletions": 2}, "numCommits": 1, "commits": {"3984104325b21dc0a22ade78d1c1398f65e77537": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesGIT": ["src/main/java/org/mapdb/StoreWAL.kt"], "body": "There is memory leak in `StoreWAL`. Caches use `LongLongHashMap`, this map is cleared, but its internal `long[]` array never shrinks. ", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "Memory leak in StoreWAL ", "statsSkippedReason": "", "closed": "2020-01-08 16:53:13", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2020-01-08 18:18:41", "commitHash": "3984104325b21dc0a22ade78d1c1398f65e77537", "commitParents": ["49cf625e20694e1c56aa2edf8385aafdcae1fd55"], "commitGHEventType": "referenced", "nameRev": "3984104325b21dc0a22ade78d1c1398f65e77537 tags/mapdb-3.0.8~3", "commitGitStats": [{"insertions": 13, "lines": 15, "filePath": "src/main/java/org/mapdb/StoreWAL.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #965, Memory leak in StoreWAL\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2020-01-08 18:18:41"}], "created": "2020-01-08 16:04:05"}, {"labels": ["3.0", "bug"], "filteredCommits": ["f4595deb7132a686e916bb74b1451aec74abf5bf"], "url": "https://github.com/jankotek/mapdb/issues/964", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 4, "deletions": 0}, "numCommits": 1, "commits": {"f4595deb7132a686e916bb74b1451aec74abf5bf": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesGIT": ["src/main/java/org/mapdb/IndexTreeLongLongMap.kt"], "body": "MapDB 3.0 branch compilation fails with following exception:\r\n\r\n```\r\n[ERROR] /home/travis/build/jankotek/mapdb/src/main/java/org/mapdb/IndexTreeLongLongMap.kt:[49,8] Class 'IndexTreeLongLongMap' is not abstract and does not implement abstract member public abstract fun updateValues(p0: LongLongToLongFunction!): Unit defined in org.eclipse.collections.api.map.primitive.MutableLongLongMap\r\n```\r\nEclipse Collection added in 10.x version new method to an inteface. Our implementation is missing this method and does not compile\r\n\r\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "MapDB 3.0 branch does not compile", "statsSkippedReason": "", "closed": "2020-01-08 16:02:19", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2020-01-08 14:28:27", "commitHash": "f4595deb7132a686e916bb74b1451aec74abf5bf", "commitParents": ["b1c3174c645df2da4b52039b9385dea0599a31b9"], "commitGHEventType": "referenced", "nameRev": "f4595deb7132a686e916bb74b1451aec74abf5bf tags/mapdb-3.0.8~6", "commitGitStats": [{"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/IndexTreeLongLongMap.kt", "deletions": 0}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #964, implement missing method added in newer EC release\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2020-01-08 14:28:27"}], "created": "2020-01-08 12:26:56"}, {"labels": ["4.0", "bug"], "filteredCommits": ["dfa8f3117080033863a50e276d6fd64899e932e8", "a29dd2095f46e2b4d39c59633dd2bf27b57e58d5", "2074263825f2c842edad367c7d15dfe1734953d1", "7c7878a1d97dd93e34d575bd44edce9495f9ea84"], "url": "https://github.com/jankotek/mapdb/issues/888", "gitStatsSummary": {"insertions": 159, "gitFilesChange": 11, "lines": 268, "deletions": 109}, "numCommits": 2, "commits": {"dfa8f3117080033863a50e276d6fd64899e932e8": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "7c7878a1d97dd93e34d575bd44edce9495f9ea84": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "2074263825f2c842edad367c7d15dfe1734953d1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "a29dd2095f46e2b4d39c59633dd2bf27b57e58d5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 16.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.io.DataOutput2ByteArray.writeRecid(long)", "org.mapdb.serializer", "org.mapdb.io", "org.mapdb.io.DataOutput2ByteArray.writePackedRecid(long)", "org.mapdb.kotlin.JK.bb()", "org.mapdb.io.DataInput2ByteArray", "org.mapdb.kotlin.Issue888_serializer_override", "org.mapdb.kotlin.bb()", "org.mapdb.kotlin.JK.test_not_override()", "org.mapdb.kotlin", "org.mapdb.kotlin.JK.testw()"], "changesInPackagesGIT": ["", "src/main/java/org/mapdb/serializer", "src/main/java/org/mapdb/io/DataOutput2.kt", "src/main/java/org/mapdb/io/DataInput2.kt", "src/main/java/org/mapdb/serializer/Serializer.kt", "src/main/java/org/mapdb/list/LinkedList.kt", "src/main/java/org/mapdb/io", "src/main/java/org/mapdb/serializer/Serializers.kt"], "body": "Kotlin has problem when overriding default interface methods declared in Java8. There is long open issue https://youtrack.jetbrains.com/issue/KT-4779 and temporary workaround https://youtrack.jetbrains.com/issue/KT-19415\r\n\r\nHowever I tested it recently and it seems to be fixed in Kotlin `1.2.0` and `1.2.30`. \r\nRelevant unit tests are in attached commit.\r\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 11, "UPD": 1, "TOT": 12, "DEL": 1, "INS": 10, "spoonFilesChanged": 7, "MOV": 0}, "title": "Kotlin & default interface methods", "statsSkippedReason": "", "closed": "2018-04-23 06:21:06", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2018-04-06 08:47:25", "commitHash": "dfa8f3117080033863a50e276d6fd64899e932e8", "commitParents": ["b4de117dc302aaeb94bea073531720f32076f68d"], "commitGHEventType": "closed", "nameRev": "dfa8f3117080033863a50e276d6fd64899e932e8 master~85", "commitGitStats": [{"insertions": 37, "lines": 37, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_KotlinI.kt", "deletions": 0}, {"insertions": 36, "lines": 36, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_JavaI.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin"}], "spoonFilePath": "Issue888_JavaI.java"}], "commitMessage": "Fix #888, add unit tests for default interface methods\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2018-04-06 08:46:59"}, {"commitUser": "jankotek", "commitDateTime": "2018-04-06 09:40:22", "commitHash": "7c7878a1d97dd93e34d575bd44edce9495f9ea84", "commitParents": ["dfa8f3117080033863a50e276d6fd64899e932e8"], "commitGHEventType": "referenced", "nameRev": "7c7878a1d97dd93e34d575bd44edce9495f9ea84 master~84", "commitGitStats": [{"insertions": 17, "lines": 18, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_KotlinI.kt", "deletions": 1}, {"insertions": 20, "lines": 21, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_JavaI.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin.bb()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin.JK.test_not_override()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin.JK.bb()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin.JK.testw()"}], "spoonFilePath": "Issue888_JavaI.java"}], "commitMessage": "Reopen #888, default methods do not compile\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2018-04-06 09:40:22"}, {"commitUser": "jankotek", "commitDateTime": "2018-04-23 14:16:11", "commitHash": "2074263825f2c842edad367c7d15dfe1734953d1", "commitParents": ["67bc07c14a9657ef5ce84bc79bcc85e764cb22e3"], "commitGHEventType": "referenced", "nameRev": "2074263825f2c842edad367c7d15dfe1734953d1 master~70", "commitGitStats": [{"insertions": 13, "lines": 13, "filePath": "src/main/java/org/mapdb/io/DataOutput2ByteArray.java", "deletions": 0}, {"insertions": 2, "lines": 9, "filePath": "src/test/java/org/mapdb/store/StoreTest.kt", "deletions": 7}, {"insertions": 60, "lines": 60, "filePath": "src/main/java/org/mapdb/io/DataInput2.java", "deletions": 0}, {"insertions": 0, "lines": 24, "filePath": "src/main/java/org/mapdb/io/DataOutput2.kt", "deletions": 24}, {"insertions": 0, "lines": 59, "filePath": "src/main/java/org/mapdb/io/DataInput2.kt", "deletions": 59}, {"insertions": 31, "lines": 31, "filePath": "src/main/java/org/mapdb/io/DataOutput2.java", "deletions": 0}, {"insertions": 4, "lines": 8, "filePath": "src/main/java/org/mapdb/list/LinkedList.kt", "deletions": 4}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/io/DataInput2ByteArray.java", "deletions": 1}, {"insertions": 11, "lines": 11, "filePath": "src/main/java/org/mapdb/serializer/Serializers.kt", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.io.DataInput2ByteArray"}], "spoonFilePath": "DataInput2ByteArray.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.io.DataOutput2ByteArray.writeRecid(long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.io.DataOutput2ByteArray.writePackedRecid(long)"}], "spoonFilePath": "DataOutput2ByteArray.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.io"}], "spoonFilePath": "DataInput2.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.io"}], "spoonFilePath": "DataOutput2.java"}], "commitMessage": "Migrate DataInput2 interfaces to Java (see #888).\nAdd recid serialization.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2018-04-23 14:16:11"}, {"commitUser": "jankotek", "commitDateTime": "2018-04-23 08:22:52", "commitHash": "a29dd2095f46e2b4d39c59633dd2bf27b57e58d5", "commitParents": ["ae0234f9005f818f626ae977263ecfd7cbe155f6"], "commitGHEventType": "referenced", "nameRev": "a29dd2095f46e2b4d39c59633dd2bf27b57e58d5 master~73", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/store/StoreTest.kt", "deletions": 2}, {"insertions": 0, "lines": 13, "filePath": "src/main/java/org/mapdb/serializer/Serializer.kt", "deletions": 13}, {"insertions": 34, "lines": 34, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_serializer_override.java", "deletions": 0}, {"insertions": 23, "lines": 23, "filePath": "src/main/java/org/mapdb/serializer/Serializer.java", "deletions": 0}, {"insertions": 3, "lines": 6, "filePath": "src/test/java/org/mapdb/TT.kt", "deletions": 3}, {"insertions": 8, "lines": 8, "filePath": "build.gradle", "deletions": 0}, {"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/list/LinkedList.kt", "deletions": 2}, {"insertions": 2, "lines": 3, "filePath": "src/test/java/org/mapdb/kotlin/Issue888_JavaI.java", "deletions": 1}, {"insertions": 6, "lines": 12, "filePath": "src/main/java/org/mapdb/serializer/Serializers.kt", "deletions": 6}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.kotlin.Issue888_serializer_override"}], "spoonFilePath": "Issue888_serializer_override.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.serializer"}], "spoonFilePath": "Serializer.java"}, {"spoonMethods": [], "spoonFilePath": "Issue888_JavaI.java"}], "commitMessage": "Fix #888, implement interfaces with default methods in Java, not Kotlin.\nChange order of methods in Serializer to match MapDB 3\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2018-04-23 08:22:52"}], "created": "2018-04-06 06:45:26"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/881", "title": "java.lang.ArrayIndexOutOfBoundsException: 1048576 in org.mapDB version 3.0.5 with indexTreeList", "closed": "2018-05-31 10:27:04", "commitsDetails": [], "commits": {}, "ttf": 83.00027777777778, "created": "2018-03-08 18:50:43", "user": "cjoantony", "body": "Hello Everyone,\r\n\r\nI am trying to store about 100 odd entries into mapdb.\r\nI am using org.mapDB version 3.0.5\r\nI get \"java.lang.ArrayIndexOutOfBoundsException: 1048576\" as described below:\r\nCan you please guide us through this problem .\r\n\r\nMy code :\r\n```\r\nDB db = DBMaker.memoryDB().closeOnJvmShutdown().make();\r\n Serializer<Person> customserializer = new CustomSerializer();\r\nList<Person> IPersonDTOmapDBList    = this.db.indexTreeList(mapDBListName, customserializer).createOrOpen();\r\n\r\n```\r\nI am able to succesfully add objects to the list., like using API addAll() of the java.io.List\r\nHowever, when I am extracting the objects, one object at one time from the mapDB-List, i get below exception.\r\n\r\n> java.lang.ArrayIndexOutOfBoundsException: 1048576\r\n> \tat org.mapdb.DataInput2$ByteArray.unpackInt(DataInput2.java:162)\r\n> \tat org.mapdb.DataInput2.readUTF(DataInput2.java:491)\r\n> \tat com.company.mylistproj.personhandler.parser.CustomSerializer.deserialize(CustomSerializer.java:48)\r\n> \tat com.company.mylistproj.personhandler.parser.CustomSerializer.deserialize(CustomSerializer.java:1)\r\n> \tat org.mapdb.StoreDirectAbstract.deserialize(StoreDirectAbstract.kt:229)\r\n> \tat org.mapdb.StoreDirect.get(StoreDirect.kt:546)\r\n> \tat org.mapdb.IndexTreeList.get(IndexTreeList.kt:114)\r\n> \tat org.mapdb.IndexTreeList$iterator$1.next(IndexTreeList.kt:139)\r\n> \tat com.company.mylistproj.import.PersonTransformer.transformPersonEntries(PersonTransformer.java:30)\r\n\r\n\t\r\nAt (PersonTransformer.java:30) my code is :\r\n```\r\n\t    for (IPerson person : personEntriesList) {\r\n\t\t//my business logic\r\n\t\t\r\n\t\t}\r\n```\r\n\t\t\r\nCustomSerializer , I have given the required member-variables of <Person> as the values for serialize and deserialize method\r\n<Person> class has also got the same member-variables as part of its overridden equals() method.\r\n\r\nMy applicaiton Enviroment:\r\nWindows OS - Win 7\r\nApplicaiton hosted on Apache Tomcat v8\r\n\r\nThanks,\r\nCjo"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/858", "title": "Exception when iterating over keys in HashTreeMap", "closed": "2018-07-23 14:49:46", "commitsDetails": [], "commits": {}, "ttf": 244.00027777777777, "created": "2017-11-21 09:06:02", "user": "andrm", "body": "This is with 3.0.5. (excluded guava from the mapdb dependency for newer guava)\r\n\r\nException in thread \"main\" java.lang.IndexOutOfBoundsException\r\n\tat java.nio.Buffer.checkIndex(Buffer.java:540)\r\n\tat java.nio.DirectByteBuffer.get(DirectByteBuffer.java:253)\r\n\tat org.mapdb.DataInput2$ByteBuffer.unpackInt(DataInput2.java:389)\r\n\tat org.mapdb.DataInput2.readUTF(DataInput2.java:491)\r\n\tat org.mapdb.serializer.SerializerString.deserialize(SerializerString.java:20)\r\n\tat org.mapdb.serializer.SerializerString.deserialize(SerializerString.java:11)\r\n\tat org.mapdb.HTreeMap$leafValueExternalSerializer$1.deserialize(HTreeMap.kt:228)\r\n\tat org.mapdb.HTreeMap$leafValueExternalSerializer$1.deserialize(HTreeMap.kt:214)\r\n\tat org.mapdb.StoreDirectAbstract.deserialize(StoreDirectAbstract.kt:229)\r\n\tat org.mapdb.StoreDirect.get(StoreDirect.kt:546)\r\n\tat org.mapdb.HTreeMap.leafGet(HTreeMap.kt:1374)\r\n\tat org.mapdb.HTreeMap$htreeIterator$1.moveToNextLeaf(HTreeMap.kt:1057)\r\n\tat org.mapdb.HTreeMap$htreeIterator$1.next(HTreeMap.kt:1082)\r\n\tat com.google.common.collect.Iterators$ConcatenatedIterator.next(Iterators.java:1425)\r\n\tat pcon.cleanup(ProductionDb.java:257)\r\n\r\nCode:\r\nhMap = this.dataBase.hashMap(ACTION_MAP)\r\n                    .keySerializer(STRING)\r\n                    .valueSerializer(BYTE_ARRAY)\r\n                    .layout(16,128,4)\r\n                    .createOrOpen();\r\nSet<String> keys = hMap.getKeys();\r\n        for (String key : keys)  {\r\n....\r\n"}, {"labels": ["3.0", "bug"], "filteredCommits": ["3fc81e1d32f072b8164ee70ca0903760deac5255"], "url": "https://github.com/jankotek/mapdb/issues/819", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 3, "deletions": 1}, "numCommits": 1, "commits": {"3fc81e1d32f072b8164ee70ca0903760deac5255": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "f9b3de0bd216498002035ae7e52134d106d7ec6a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 12.000277777777777, "user": "javier-godoy", "changesInPackagesGIT": ["src/main/java/org/mapdb/DB.kt"], "body": "In HashMapMaker.open2 `stores` is initialized with segmentCount = _concShift, before reading _concShift from the catalog.\r\n\r\nIf the name has not been instantiated before, a call to `db.get(name)` (for an existing HTreeMap constructed with a custom layout) results in `open2` being called with the default value of _concShift, which raises an exception in HTreeMap constructor: \"**stores size wrong**\".\r\n\r\nThis issue applies to mapdb 3.0.3. \r\n\r\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "HTreeMap: \"stores size wrong\" when using a custom concShift", "statsSkippedReason": "", "closed": "2017-04-11 14:51:48", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-04-11 17:49:15", "commitHash": "3fc81e1d32f072b8164ee70ca0903760deac5255", "commitParents": ["39166af79d0d0370e5a68c7255cb6f3dde844796"], "commitGHEventType": "referenced", "nameRev": "3fc81e1d32f072b8164ee70ca0903760deac5255 tags/mapdb-3.0.4~1", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 1}], "commitSpoonAstDiffStats": [], "commitMessage": "HTreeMap Concurrency Layout was not persisted after HTreeMap reopen. See #819\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 17:49:15"}, {"commitUser": "jankotek", "commitDateTime": "2017-04-11 17:41:55", "commitHash": "f9b3de0bd216498002035ae7e52134d106d7ec6a", "commitParents": ["599ff8ba06db73a09168d10fb01a51cf23454dad"], "commitGHEventType": "referenced", "nameRev": "f9b3de0bd216498002035ae7e52134d106d7ec6a master~157", "commitGitStats": [{"insertions": 55, "lines": 55, "filePath": "src/test/java/org/mapdb/issues/Issue819.kt", "deletions": 0}, {"insertions": 2, "lines": 3, "filePath": "src/test/java/org/mapdb/HTreeMapTest.kt", "deletions": 1}, {"insertions": 3, "lines": 4, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 1}], "commitSpoonAstDiffStats": [], "commitMessage": "HTreeMap Concurrency Layout was not persisted after HTreeMap reopen. See #819\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 17:41:55"}], "created": "2017-03-30 04:39:19"}, {"labels": ["3.0", "bug"], "filteredCommits": ["327d456f48a9193b5555c10571e680865a252e4a", "39166af79d0d0370e5a68c7255cb6f3dde844796"], "url": "https://github.com/jankotek/mapdb/issues/816", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 2, "lines": 6, "deletions": 4}, "numCommits": 2, "commits": {"327d456f48a9193b5555c10571e680865a252e4a": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "af5655ffde2a7279d2d1ae175ebe04d533251fdd": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "39166af79d0d0370e5a68c7255cb6f3dde844796": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "aafa8750e5c360815e25287fe7f0e9cc82e76940": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 19.00027777777778, "user": "mattdudys", "changesInPackagesGIT": ["src/main/java/org/mapdb/BTreeMap.kt", "src/main/java/org/mapdb/HTreeMap.kt"], "body": "Set.add for the same value should first return true then subsequently return false. This passes in mapdb 1.x but fails for me in 3.0.3 and should fail in master too.\r\n\r\n```java\r\nDB db = DBMaker.tempFileDB().make();\r\nSet<String> set = db.hashSet(\"temp\", Serializer.STRING).create();\r\nassertTrue(set.add(\"foo\"));\r\nassertFalse(set.add(\"foo\"));\r\nassertFalse(set.add(\"foo\"));\r\n```\r\n\r\nIn 1.x it is `== null`: https://github.com/jankotek/mapdb/blob/release-1.0/src/main/java/org/mapdb/HTreeMap.java#L830\r\nIn master it is `!= null`: https://github.com/jankotek/mapdb/blob/2c1a33cc50e3275127d7f3f857a873ce6399096e/src/main/java/org/mapdb/HTreeMap.kt#L1020", "filteredCommitsReason": {"duplicated": 2, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "HTreeMap.KeySet.add has incorrect return value", "statsSkippedReason": "", "closed": "2017-04-11 13:57:18", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-04-11 16:57:01", "commitHash": "327d456f48a9193b5555c10571e680865a252e4a", "commitParents": ["0b589cd8eb5fde6dbe5f49294f7f140c5690d9fb"], "commitGHEventType": "closed", "nameRev": "327d456f48a9193b5555c10571e680865a252e4a master~160", "commitGitStats": [{"insertions": 1, "lines": 3, "filePath": "src/main/java/org/mapdb/HTreeMap.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "HTreeMap.KeySet.add has incorrect return value, fix #816\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 16:57:01"}, {"commitUser": "jankotek", "commitDateTime": "2017-04-11 16:58:57", "commitHash": "af5655ffde2a7279d2d1ae175ebe04d533251fdd", "commitParents": ["b6775ec32b6ab9dde56eecff622f6b1e44db20e5"], "commitGHEventType": "referenced", "nameRev": "af5655ffde2a7279d2d1ae175ebe04d533251fdd tags/mapdb-3.0.4~3", "commitGitStats": [{"insertions": 1, "lines": 3, "filePath": "src/main/java/org/mapdb/HTreeMap.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "HTreeMap.KeySet.add has incorrect return value, fix #816\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 16:58:57"}, {"commitUser": "jankotek", "commitDateTime": "2017-04-11 17:03:57", "commitHash": "39166af79d0d0370e5a68c7255cb6f3dde844796", "commitParents": ["af5655ffde2a7279d2d1ae175ebe04d533251fdd"], "commitGHEventType": "referenced", "nameRev": "39166af79d0d0370e5a68c7255cb6f3dde844796 tags/mapdb-3.0.4~2", "commitGitStats": [{"insertions": 1, "lines": 3, "filePath": "src/main/java/org/mapdb/BTreeMap.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "BTreeMap.KeySet.add has incorrect return value, fix #816\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 17:03:57"}, {"commitUser": "jankotek", "commitDateTime": "2017-04-11 17:03:13", "commitHash": "aafa8750e5c360815e25287fe7f0e9cc82e76940", "commitParents": ["327d456f48a9193b5555c10571e680865a252e4a"], "commitGHEventType": "referenced", "nameRev": "aafa8750e5c360815e25287fe7f0e9cc82e76940 master~159", "commitGitStats": [{"insertions": 1, "lines": 3, "filePath": "src/main/java/org/mapdb/BTreeMap.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "BTreeMap.KeySet.add has incorrect return value, fix #816\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-04-11 17:03:13"}], "created": "2017-03-23 03:07:39"}, {"labels": ["3.0", "bug"], "filteredCommits": ["b1731862971319ef61009a6cd780075227725b2c", "2c1a33cc50e3275127d7f3f857a873ce6399096e"], "url": "https://github.com/jankotek/mapdb/issues/815", "gitStatsSummary": {"insertions": 20, "gitFilesChange": 1, "lines": 28, "deletions": 8}, "numCommits": 2, "commits": {"b1731862971319ef61009a6cd780075227725b2c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "2c1a33cc50e3275127d7f3f857a873ce6399096e": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.issues.Issue_815"], "changesInPackagesGIT": ["src/main/java/org/mapdb/SortedTableMap.kt"], "body": "From gitter:\r\n\r\n use mapdb and I want to use the SortedTableMap with a page size greater than 1MB. Lets say 4MB\r\n  Volume volume = MappedFileVol.FACTORY.makeVolume(file, false);\r\n SortedTableMap.Sink<Integer, String> sink = SortedTableMap\r\n        .create(volume, Serializer.INTEGER, // key serializer\r\n            Serializer.STRING) // value serializer\r\n        .pageSize(4 * 1024 * 1024) // set Page Size to 4MB\r\n        .nodeSize(8) // set Node Size to 8 entries\r\n        .createFromSink()\r\nbut I got an error:\r\n Exception in thread \"main\" java.nio.BufferOverflowException\r\n    at java.nio.DirectByteBuffer.put(DirectByteBuffer.java:363)\r\n    at org.mapdb.volume.ByteBufferVol.putData(ByteBufferVol.java:86)\r\n    at org.mapdb.SortedTableMap$Companion$createFromSink$1.flushPage(SortedTableMap.kt:224)\r\n    at org.mapdb.SortedTableMap$Companion$createFromSink$1.create(SortedTableMap.kt:140)\r\n    at org.mapdb.SortedTableMap$Companion$createFromSink$1.create(SortedTableMap.kt:111)\r\n\r\nRafael Troilo @rtroilo Feb 27 18:51\r\nafter increasing the sliceShift\r\n Volume volume = MappedFileVol.FACTORY.makeVolume(file, false,0L,22,0,false);\r\nit works, I could write to the sink, everything looks good. But I can not reopen the SortedTableMap\r\n  volume = MappedFileVol.FACTORY.makeVolume(file, true,0L,22,0,false);\r\n    // read-only=true\r\n    map = SortedTableMap.open(volume, Serializer.INTEGER, Serializer.STRING);\r\n Exception in thread \"main\" org.mapdb.DBException$DataCorruption: Wrong page size: 4194304\r\n    at org.mapdb.SortedTableMap$Companion.open(SortedTableMap.kt:94)\r\n    at org.mapdb.SortedTableMap.open(SortedTableMap.kt)\r\n\r\nRafael Troilo @rtroilo Feb 27 18:57\r\nThe problem is, there is a check if the pagesize is in a certain range:\r\n             val pageSize = volume.getLong(PAGE_SIZE_OFFSET)\r\n            if (pageSize <= 0 || pageSize > CC.PAGE_SIZE)\r\n                throw DBException.DataCorruption(\"Wrong page size: \" + pageSize)\r\n\r\nRafael Troilo @rtroilo Feb 27 19:07\r\nIs there any reason for this check?\r\nI now open the Map with\r\nmap = new SortedTableMap<>(Serializer.INTEGER, Serializer.STRING, volume.getLong(32L), volume,false);\r\nand it seems to work as expected", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "Wrong check at SortedTableMap for page size", "statsSkippedReason": "", "closed": "2017-03-22 21:50:51", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-03-22 23:53:26", "commitHash": "b1731862971319ef61009a6cd780075227725b2c", "commitParents": ["bf6c50e2e2fbf0a3cb9a97b916899be86d052850"], "commitGHEventType": "referenced", "nameRev": "b1731862971319ef61009a6cd780075227725b2c tags/mapdb-3.0.4~5", "commitGitStats": [{"insertions": 27, "lines": 27, "filePath": "src/test/java/org/mapdb/TestWithTempDir.kt", "deletions": 0}, {"insertions": 36, "lines": 36, "filePath": "src/test/java/org/mapdb/issues/Issue_815.java", "deletions": 0}, {"insertions": 10, "lines": 14, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue_815"}], "spoonFilePath": "Issue_815.java"}], "commitMessage": "SortedTableMap  add extra Page Size checks  Remove wrong check  Fix  #815\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-03-22 23:53:26"}, {"commitUser": "jankotek", "commitDateTime": "2017-03-22 23:50:41", "commitHash": "2c1a33cc50e3275127d7f3f857a873ce6399096e", "commitParents": ["6a775fd1b43b2ea188646218bd021fc4ec3d86e8"], "commitGHEventType": "closed", "nameRev": "2c1a33cc50e3275127d7f3f857a873ce6399096e master~164", "commitGitStats": [{"insertions": 27, "lines": 27, "filePath": "src/test/java/org/mapdb/TestWithTempDir.kt", "deletions": 0}, {"insertions": 36, "lines": 36, "filePath": "src/test/java/org/mapdb/issues/Issue_815.java", "deletions": 0}, {"insertions": 10, "lines": 14, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue_815"}], "spoonFilePath": "Issue_815.java"}], "commitMessage": "SortedTableMap: add extra Page Size checks. Remove wrong check. Fix #815\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-03-22 23:50:41"}], "created": "2017-03-22 21:47:40"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/808", "title": "HTreeMap.KeySet#sizeLong()", "closed": "2017-04-12 07:41:17", "commitsDetails": [], "commits": {}, "ttf": 40.000277777777775, "created": "2017-03-02 08:17:47", "user": "jmveramaiquez", "body": "Hello,\r\n\r\nI'm using big sets for giant black and white lists of elements, and I've seen that the sizeLong method does not exist. \r\n\r\nI think it make sense. \r\n\r\nThanks,\r\n\r\n    JM"}, {"labels": ["4.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/802", "title": "should throw exceptions instead of errors", "closed": "2017-11-22 11:44:52", "commitsDetails": [], "commits": {}, "ttf": 285.0002777777778, "created": "2017-02-09 19:12:02", "user": "roxchkplusony", "body": "Errors mean very serious system-level problems that could abort the program. Since mapdb is a component in a larger system, it should not throw Errors, but instead Exceptions. Looking at the descriptions of a few, especially IllegalAccessError, it's clear that these aren't to be thrown lightly."}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/801", "title": "Issues with Scala 2.12.1", "closed": "2017-04-11 15:05:04", "commitsDetails": [], "commits": {}, "ttf": 64.00027777777778, "created": "2017-02-06 08:30:18", "user": "jankotek", "body": "Following code:\r\n\r\n```\r\n val db = DBMaker.memoryDB().make()\r\n  val someMap:Map[String,String] = db.hashMap(\"some-map\", Serializer.STRING, Serializer.STRING).createOrOpen()\r\n\r\n  someMap.put(\"x\", \"World!\")\r\n  println(\"Hello \" + someMap.get(\"x\"))\r\n```\r\n\r\nfails with \r\n\r\n```\r\nError:(8, 109) type mismatch;\r\n found   : org.mapdb.HTreeMap[K,V]\r\n required: Map[String,String]\r\n  val someMap:Map[String,String] = db.hashMap(\"some-map\", Serializer.STRING, Serializer.STRING).createOrOpen()\r\n```\r\n\r\nThere is also bytecode issue, class is not found in some cases:\r\n\r\nI experienced similar issue with upgrade to Scala 2.12.1, demo project is here: https://github.com/rtkaczyk/mapdb212\r\n\r\nif you compile scala project with sbt test it as is you will get:\r\n\r\n[error] Class org.mapdb.DB$Maker not found - continuing with a stub."}, {"labels": ["3.0", "bug"], "filteredCommits": ["96e6d57e538c40f46bdf5b20ebb2efcf08fa97ae"], "url": "https://github.com/jankotek/mapdb/issues/800", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 6, "deletions": 3}, "numCommits": 1, "commits": {"96e6d57e538c40f46bdf5b20ebb2efcf08fa97ae": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "4e77d12901125703083817f0785deefee1b44f25": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "scottcarey", "changesInPackagesSPOON": ["org.mapdb.issues.Issue800"], "changesInPackagesGIT": ["src/main/java/org/mapdb/SortedTableMap.kt"], "body": "MapDB 3.0.3\r\n\r\nApproximate code to reproduce:\r\n\r\n````java\r\nVolume vol = MappedFileVol.FACTORY.makeVolume(file, false);\r\nSortedTableMap.Sink<byte[], byte[]> sink = SortedTableMap.create(\r\n    vol, Serializer.BYTE_ARRAY, Serializer.BYTE_ARRAY).createFromSink();\r\n\r\nsink.put(new byte[] { 1, 1 });\r\nsink.put(new byte[] { 1, 2 });\r\nsink.create().close();\r\n\r\nSortedTableMap<byte[], byte[]> stm = SortedTableMap.open(\r\n    MappedFileVol.FACTORY.makeVolume(file, true),\r\n    Serializer.BYTE_ARRAY,\r\n    Serializer.BYTE_ARRAY);\r\n\r\n// producing a subMap that is 'after' all keys will cause trouble:\r\n\r\nstm.subMap(new byte[] { 3 }, new byte[] { 4 })\r\n  .entrySet()\r\n  .stream()\r\n  .map(entry -> entry.getKey().length + entry.getValue().length)\r\n  .collect(Collectors.toList());\r\n\r\n// it works fine if the subMap is 'before' all the keys, or covers some of them.\r\n````\r\n\r\n\r\ntrace:\r\n````\r\nkotlin.KotlinNullPointerException\r\n\tat org.mapdb.SortedTableMap$entryIterator$2.findStart(SortedTableMap.kt:1656)\r\n\tat org.mapdb.SortedTableMap$entryIterator$2.<init>(SortedTableMap.kt:1638)\r\n\tat org.mapdb.SortedTableMap.entryIterator(SortedTableMap.kt:1625)\r\n\tat org.mapdb.BTreeMapJava$SubMap.entryIterator(BTreeMapJava.java:1081)\r\n\tat org.mapdb.BTreeMapJava$EntrySet.iterator(BTreeMapJava.java:560)\r\n\tat java.util.Spliterators$IteratorSpliterator.estimateSize(Spliterators.java:1821)\r\n\tat java.util.Spliterator.getExactSizeIfKnown(Spliterator.java:408)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:511)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\r\n\tat java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\r\n````", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "KotlinNPE when streaming over a subset of a SortedTableMap", "statsSkippedReason": "", "closed": "2017-02-04 18:53:08", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-02-04 20:50:46", "commitHash": "96e6d57e538c40f46bdf5b20ebb2efcf08fa97ae", "commitParents": ["4830d1b8060db003fc03c47220669f0d6e12d648"], "commitGHEventType": "closed", "nameRev": "96e6d57e538c40f46bdf5b20ebb2efcf08fa97ae remotes/origin/segment-locks~15", "commitGitStats": [{"insertions": 45, "lines": 45, "filePath": "src/test/java/org/mapdb/issues/Issue800.java", "deletions": 0}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue800"}], "spoonFilePath": "Issue800.java"}], "commitMessage": "NPE in SortedTableMap subsets, fix #800\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-04 20:50:46"}, {"commitUser": "jankotek", "commitDateTime": "2017-02-04 20:52:02", "commitHash": "4e77d12901125703083817f0785deefee1b44f25", "commitParents": ["0811a22a9045c53b85d2f02dc990318be0dfc45c"], "commitGHEventType": "referenced", "nameRev": "4e77d12901125703083817f0785deefee1b44f25 tags/mapdb-3.0.4~8", "commitGitStats": [{"insertions": 45, "lines": 45, "filePath": "src/test/java/org/mapdb/issues/Issue800.java", "deletions": 0}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue800"}], "spoonFilePath": "Issue800.java"}], "commitMessage": "NPE in SortedTableMap subsets, fix #800\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-04 20:52:02"}], "created": "2017-02-04 00:44:01"}, {"labels": ["3.0", "bug"], "filteredCommits": ["05f771fbb10787f12b432e0040ee7505ea8b556a"], "url": "https://github.com/jankotek/mapdb/issues/794", "gitStatsSummary": {"insertions": 21, "gitFilesChange": 2, "lines": 27, "deletions": 6}, "numCommits": 1, "commits": {"05f771fbb10787f12b432e0040ee7505ea8b556a": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "e0b22554e6687f36213611ad616c44af0643df7a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "3fcb6e2185a201c92c06e4e490ae33c5f6e4d9aa": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "d689df64ac185e4e87f5b919b2a03344889b685b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 3.000277777777778, "user": "reuschling", "changesInPackagesSPOON": ["org.mapdb.issues.Issue794"], "changesInPackagesGIT": ["src/main/java/org/mapdb/Pump.kt", "src/main/java/org/mapdb/DB.kt"], "body": "Hi,\r\nafter a two days run with ~70 000 000 000 entities, treemap, datasink, I've sadly got an Broken bit parity Exception during the DataSink.create() invocation. I have now a 2.5TB file on the hard disk, but can not load it - is it possible to ignore the error and create the final treemap? Can I make something different to avoid this error? Or is this just a hardware bit switch? Here is the according code:\r\n\r\n```\r\npublic static class DataPoint extends ArrayList<String> implements Serializable\r\n{\r\n        private static final long serialVersionUID = -3660080037783514247L;\r\n        public DataPoint()\r\n        {\r\n            super(5);\r\n        }\r\n}\r\n\r\nDB db = DBMaker.fileDB(new File(\"dbFile\")).closeOnJvmShutdown().make();\r\nTreeMapSink<Long, DataPoint> sIds2DataPointSink =\r\n                    db.treeMap(\"ids2DataPoint\", Serializer.LONG, Serializer.ELSA).valuesOutsideNodesEnable().createFromSink();\r\nfor(...)\r\n{\r\n   //insert 70G DataPoint entities, each filled with 5 Strings\r\n   sIds2DataPointSink.put(lId, finalDataPoint);\r\n}\r\n//here the error occurs\r\nsIds2DataPointSink.create();\r\n```\r\n\r\nstacktrace:\r\n```\r\norg.mapdb.DBException$PointerChecksumBroken: Broken bit parity\r\n        at org.mapdb.DataIO.parity1Get(DataIO.java:440)\r\n        at org.mapdb.DataIO.unpackRecid(DataIO.java:172)\r\n        at org.mapdb.serializer.SerializerRecid.valueArrayDeserialize(SerializerRecid.java:62)\r\n        at org.mapdb.serializer.SerializerRecid.valueArrayDeserialize(SerializerRecid.java:13)\r\n        at org.mapdb.BTreeMapJava$NodeSerializer.deserialize(BTreeMapJava.java:194)\r\n        at org.mapdb.BTreeMapJava$NodeSerializer.deserialize(BTreeMapJava.java:136)\r\n        at org.mapdb.StoreDirectAbstract.deserialize(StoreDirectAbstract.kt:229)\r\n        at org.mapdb.StoreDirect.get(StoreDirect.kt:527)\r\n        at org.mapdb.BTreeMap.getNode(BTreeMap.kt:800)\r\n        at org.mapdb.BTreeMap.loadLeftEdges(BTreeMap.kt:216)\r\n        at org.mapdb.BTreeMap.<init>(BTreeMap.kt:209)\r\n        at org.mapdb.DB$TreeMapMaker.create2(DB.kt:1106)\r\n        at org.mapdb.DB$TreeMapMaker.create2(DB.kt:987)\r\n        at org.mapdb.DB$Maker.make2(DB.kt:1401)\r\n        at org.mapdb.DB$TreeMapMaker$createFromSink$1.create(DB.kt:1081)\r\n        at org.mapdb.DB$TreeMapMaker$createFromSink$1.create(DB.kt:1068)\r\n```\r\n\r\nThe environment was a Linux  openSUSE Leap 42.2, Oracle Java(TM) SE Runtime Environment (build 1.8.0_60-b27)", "filteredCommitsReason": {"duplicated": 3, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0.0, "TOT": 1.0, "DEL": 0.0, "INS": 1.0, "spoonFilesChanged": 1, "MOV": 0.0}, "title": "Version 3.0.2: org.mapdb.DBException$PointerChecksumBroken: Broken bit parity", "statsSkippedReason": "", "closed": "2017-01-12 16:15:53", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-01-12 18:15:40", "commitHash": "05f771fbb10787f12b432e0040ee7505ea8b556a", "commitParents": ["93f7f291c4c0d9fbb8e019c0ada7fa424d744171"], "commitGHEventType": "closed", "nameRev": "05f771fbb10787f12b432e0040ee7505ea8b556a remotes/origin/segment-locks~28", "commitGitStats": [{"insertions": 19, "lines": 24, "filePath": "src/main/java/org/mapdb/Pump.kt", "deletions": 5}, {"insertions": 45, "lines": 45, "filePath": "src/test/java/org/mapdb/issues/Issue794.java", "deletions": 0}, {"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 1}, {"insertions": 121, "lines": 121, "filePath": "src/test/java/org/mapdb/BTreeMap_PumpTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue794"}], "spoonFilePath": "Issue794.java"}], "commitMessage": "Fix data corruption in Data Pump, fix #794\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-01-12 18:15:40"}, {"commitUser": "jankotek", "commitDateTime": "2017-01-12 19:57:48", "commitHash": "e0b22554e6687f36213611ad616c44af0643df7a", "commitParents": ["3fcb6e2185a201c92c06e4e490ae33c5f6e4d9aa"], "commitGHEventType": "referenced", "nameRev": "e0b22554e6687f36213611ad616c44af0643df7a tags/mapdb-3.0.3~1", "commitGitStats": [{"insertions": 0, "lines": 27, "filePath": "src/test/java/org/mapdb/BTreeMap_PumpTest.kt", "deletions": 27}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix data corruption in Data Pump, fix #794\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-01-12 19:57:48"}, {"commitUser": "jankotek", "commitDateTime": "2017-01-12 19:57:22", "commitHash": "3fcb6e2185a201c92c06e4e490ae33c5f6e4d9aa", "commitParents": ["d689df64ac185e4e87f5b919b2a03344889b685b"], "commitGHEventType": "referenced", "nameRev": "3fcb6e2185a201c92c06e4e490ae33c5f6e4d9aa tags/mapdb-3.0.3~2", "commitGitStats": [{"insertions": 2, "lines": 16, "filePath": "src/main/java/org/mapdb/Pump.kt", "deletions": 14}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix data corruption in Data Pump, fix #794\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-01-12 19:57:22"}, {"commitUser": "jankotek", "commitDateTime": "2017-01-12 19:07:21", "commitHash": "d689df64ac185e4e87f5b919b2a03344889b685b", "commitParents": ["5ad8cd94149edb6fccae3aa3eb9d6169c9412aa0"], "commitGHEventType": "referenced", "nameRev": "d689df64ac185e4e87f5b919b2a03344889b685b tags/mapdb-3.0.3~3", "commitGitStats": [{"insertions": 29, "lines": 30, "filePath": "src/main/java/org/mapdb/Pump.kt", "deletions": 1}, {"insertions": 45, "lines": 45, "filePath": "src/test/java/org/mapdb/issues/Issue794.java", "deletions": 0}, {"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 1}, {"insertions": 121, "lines": 121, "filePath": "src/test/java/org/mapdb/BTreeMap_PumpTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue794"}], "spoonFilePath": "Issue794.java"}], "commitMessage": "Fix data corruption in Data Pump, fix #794\n\n# Conflicts:\n#\tsrc/main/java/org/mapdb/Pump.kt\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-01-12 18:15:40"}], "created": "2017-01-09 11:55:37"}, {"labels": ["3.0", "bug"], "filteredCommits": ["0811a22a9045c53b85d2f02dc990318be0dfc45c"], "url": "https://github.com/jankotek/mapdb/issues/776", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 6, "deletions": 2}, "numCommits": 1, "commits": {"0811a22a9045c53b85d2f02dc990318be0dfc45c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "b0937525d09fa3fb437f1c7635df216d8256cfed": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 95.00027777777778, "user": "Venorcis", "changesInPackagesSPOON": ["org.mapdb.volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb/volume"], "body": "With a database created like this:\r\n```\r\nDBMaker.fileDB(datafile).fileMmapEnable().fileMmapPreclearDisable().cleanerHackEnable().concurrencyDisable().readOnly().closeOnJvmShutdown().make();\r\n```\r\nI get the following exception when Java (actually my JUnit-test) terminates:\r\n```\r\nSEVERE: DB.close() thrown exception in shutdown hook.\r\njava.lang.StackOverflowError\r\n\tat org.mapdb.volume.ByteBufferVol.unmap(ByteBufferVol.java:347)\r\n\tat org.mapdb.volume.ByteBufferVol.unmap(ByteBufferVol.java:347)\r\n        ...\r\n```", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "StackOverflowError in shutdown hook", "statsSkippedReason": "", "closed": "2017-02-04 13:34:35", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-02-04 15:39:21", "commitHash": "0811a22a9045c53b85d2f02dc990318be0dfc45c", "commitParents": ["3a7642ca715797b96a8b86e50635c9eb2e1dcec6"], "commitGHEventType": "referenced", "nameRev": "0811a22a9045c53b85d2f02dc990318be0dfc45c tags/mapdb-3.0.4~9", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/issues/Issue776.kt", "deletions": 0}, {"insertions": 4, "lines": 6, "filePath": "src/main/java/org/mapdb/volume/ByteBufferVol.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"}], "spoonFilePath": "ByteBufferVol.java"}], "commitMessage": "StackOverflowError in  MMap File unmap,  Fix #776\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-04 15:39:21"}, {"commitUser": "jankotek", "commitDateTime": "2017-02-04 15:34:24", "commitHash": "b0937525d09fa3fb437f1c7635df216d8256cfed", "commitParents": ["3d1ddbf186607d1a5022b699de57dcf5275a3dd0"], "commitGHEventType": "closed", "nameRev": "b0937525d09fa3fb437f1c7635df216d8256cfed remotes/origin/segment-locks~17", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/issues/Issue776.kt", "deletions": 0}, {"insertions": 4, "lines": 6, "filePath": "src/main/java/org/mapdb/volume/ByteBufferVol.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"}], "spoonFilePath": "ByteBufferVol.java"}], "commitMessage": "StackOverflowError in  MMap File unmap,  Fix #776\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-04 15:34:24"}], "created": "2016-11-01 10:36:03"}, {"labels": ["3.0", "bug"], "filteredCommits": ["7c372761be264eb60cba68c45706f08adfeeebdd"], "url": "https://github.com/jankotek/mapdb/issues/774", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"7c372761be264eb60cba68c45706f08adfeeebdd": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 107.00027777777778, "user": "napperley", "changesInPackagesGIT": [], "body": "When attempting to run a sample MapDB program written in Kotlin it fails compilation with the following error message:\n\n... **Type mismatch: inferred type is String but Nothing? was expected. Projected type HTreeMap<out Any?, out Any?> restricts use of public open fun put(key: K?, value: V?): V? defined in org.mapdb.HTreeMap**\n\nShouldn't the put method in **org.mapdb.HTreeMap** be public in scope? Below is the sample code:\n\n``` kotlin\npackage org.example.mapdbtest\n\nimport org.mapdb.DBMaker\n\nobject MapDBTest {\n    @JvmStatic\n    fun main(args: Array<String>) {\n        val db = DBMaker.memoryDB().make()\n        val map = db.hashMap(\"Test\").createOrOpen()\n\n        map.put(\"animal\", \"Dog\")\n        db.close()\n    }\n}\n```\n\nWhy is HTreeMap immutable?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "put Method In org.mapdb.HTreeMap Isn't Public", "statsSkippedReason": "", "closed": "2017-02-03 17:18:57", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-02-03 19:18:43", "commitHash": "7c372761be264eb60cba68c45706f08adfeeebdd", "commitParents": ["82be9ce0c33364c521729f6eaea02c32bb12d692"], "commitGHEventType": "closed", "nameRev": "7c372761be264eb60cba68c45706f08adfeeebdd remotes/origin/segment-locks~22", "commitGitStats": [{"insertions": 14, "lines": 14, "filePath": "src/test/java/org/mapdb/issues/Issue774.kt", "deletions": 0}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #774 (already worked)\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-03 19:18:43"}], "created": "2016-10-19 05:40:55"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/766", "title": "mapdb seems incompatible with latest eclipse collections", "closed": "2016-09-26 08:15:59", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2016-09-25 15:55:48", "user": "bwzhang2011", "body": "@jankotek, ec version in mapdb arranged from 7.0 to 7.20 but the latest one was 8.0.0, when upgraded to that version, there exited complied error for IndexTreeLongLongMap class in mapdb. \n![image](https://cloud.githubusercontent.com/assets/749788/18816416/19454678-837c-11e6-8e97-fce95972ffcb.png)\n"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/761", "title": "HTreeMap#compute on fileDB hangups at updating value.", "closed": "2016-09-10 09:00:29", "commitsDetails": [], "commits": {}, "ttf": 2.000277777777778, "created": "2016-09-07 09:21:38", "user": "haruo31", "body": "HTreeMap#compute method does not work for updating a value.\nFollowing test code is for reproducing this problem.\n\n```\npackage org.mapdb.issues;\n\nimport org.junit.Test;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\nimport org.mapdb.HTreeMap;\nimport org.mapdb.Serializer;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class ComputeHTreeMapTest {\n\n    @Test\n    public void testCompute1() {\n        DB db = DBMaker.tempFileDB().fileMmapEnableIfSupported().make();\n        HTreeMap<byte[], int[]> map = db.hashMap(\"test\", Serializer.BYTE_ARRAY, Serializer.INT_ARRAY).create();\n\n        for (int i = 0; i < 10000; i ++) {\n            byte[] key = int2byte(i);\n            map.compute(key, (k, v) -> {\n                if (v == null) {\n                    return new int[] {0, 0, 0};\n                }\n                v[1] ++;\n                return v;\n            });\n        }\n        for (int i = 0; i < 10000; i ++) {\n            byte[] key = int2byte(i);\n            map.compute(key, (k, v) -> { // stucks here.\n                if (v == null) {\n                    return new int[] {0, 0, 0};\n                }\n                v[1] ++;\n                return v;\n            });\n        }\n\n        assertEquals(1, map.get(int2byte(2))[1]);\n    }\n\n    public static byte[] int2byte(int i) {\n        byte[] b = new byte[4];\n        b[0] = (byte)((i >>> 24) & 0xff);\n        b[1] = (byte)((i >>> 16) & 0xff);\n        b[2] = (byte)((i >>> 8) & 0xff);\n        b[3] = (byte)(i & 0xff);\n        return b;\n    }\n}\n```\n"}, {"labels": ["bug"], "filteredCommits": ["08809a9bdc32c3f6c2319ada4a822b1136657166", "1222781f95fb0eade07547d656e6b884dde4d1ff"], "url": "https://github.com/jankotek/mapdb/issues/760", "gitStatsSummary": {"insertions": 207, "gitFilesChange": 5, "lines": 406, "deletions": 199}, "numCommits": 2, "commits": {"08809a9bdc32c3f6c2319ada4a822b1136657166": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "1222781f95fb0eade07547d656e6b884dde4d1ff": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 4.000277777777778, "user": "pcmind", "changesInPackagesGIT": ["src/main/java/org/mapdb/StoreWAL.kt", "src/main/java/org/mapdb/HTreeMap.kt", "src/main/java/org/mapdb/StoreDirectAbstract.kt", "src/main/java/org/mapdb/Utils.kt", "src/main/java/org/mapdb/StoreDirect.kt"], "body": "Compact method in StoreDirect is not thread safe. If compact method is run concurrently with read and write operation, the Store will be corrupted.\n\n[Here](https://github.com/jankotek/mapdb/files/455087/CompactTest.zip) is two simple unit test to prove the point.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "DB/StoreDirect#compact() is not thread safe", "statsSkippedReason": "", "closed": "2016-09-10 07:43:31", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-09-10 10:43:22", "commitHash": "08809a9bdc32c3f6c2319ada4a822b1136657166", "commitParents": ["b9190ec5d87eeebca0f38db16b6e583c7362653f"], "commitGHEventType": "closed", "nameRev": "08809a9bdc32c3f6c2319ada4a822b1136657166 remotes/origin/segment-locks~47", "commitGitStats": [{"insertions": 6, "lines": 24, "filePath": "src/main/java/org/mapdb/StoreWAL.kt", "deletions": 18}, {"insertions": 5, "lines": 8, "filePath": "src/main/java/org/mapdb/StoreDirectAbstract.kt", "deletions": 3}, {"insertions": 150, "lines": 150, "filePath": "src/test/java/org/mapdb/issues/Issues760_compact_thread_safe.kt", "deletions": 0}, {"insertions": 85, "lines": 175, "filePath": "src/main/java/org/mapdb/StoreDirect.kt", "deletions": 90}, {"insertions": 19, "lines": 19, "filePath": "src/main/java/org/mapdb/Utils.kt", "deletions": 0}, {"insertions": 1, "lines": 5, "filePath": "src/main/java/org/mapdb/HTreeMap.kt", "deletions": 4}], "commitSpoonAstDiffStats": [], "commitMessage": "Rework group locks, fix #760 compaction race condition\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-09-10 10:43:22"}, {"commitUser": "jankotek", "commitDateTime": "2016-09-10 10:50:20", "commitHash": "1222781f95fb0eade07547d656e6b884dde4d1ff", "commitParents": ["3f295ff6cb96701d93268d33fe48c17eac02837d"], "commitGHEventType": "referenced", "nameRev": "1222781f95fb0eade07547d656e6b884dde4d1ff tags/mapdb-3.0.2~2", "commitGitStats": [{"insertions": 6, "lines": 9, "filePath": "src/main/java/org/mapdb/StoreDirectAbstract.kt", "deletions": 3}, {"insertions": 150, "lines": 150, "filePath": "src/test/java/org/mapdb/issues/Issues760_compact_thread_safe.kt", "deletions": 0}, {"insertions": 85, "lines": 166, "filePath": "src/main/java/org/mapdb/StoreDirect.kt", "deletions": 81}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #760, store.put and store.compact has race condition.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-09-10 10:50:20"}], "created": "2016-09-05 13:02:01"}, {"labels": ["bug"], "filteredCommits": ["be662c2dcba3b7ccaf2428fe67a74d7586143f43"], "url": "https://github.com/jankotek/mapdb/issues/747", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"be662c2dcba3b7ccaf2428fe67a74d7586143f43": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 15.000277777777777, "user": "scauwe", "changesInPackagesGIT": ["src/main/java/org/mapdb/DB.kt"], "body": "Hi all,\n\nNot a bug but feature request:\nI created the following serializer for MapDB. It moves the class descriptor out of the serialized stream into the code. In my scenario, for 30000 objects, it decreased my file size with about 3k.\nIt has the following downside:\n- being specific for one class\n- class must implement Externalizable\n- class must have a default constructor\n\n, but less data means less disc io.\nYou could also create your own interface base on Externalizable, and in deserialize(), do not validate the version number, but pass this to the call of readExternal(). This would enable a programmer to be backwards compatible and load older versions of an object. Saving would always be in the new version.\n\nUsage example:\n\n``` java\nHTreeMap<String, MyClass> mymap = db\n                .hashMap(\"aName\")\n                .keySerializer(Serializer.STRING)\n                .valueSerializer(\n                        new SerializerCompressionWrapper<MyClass>(\n                                new SerializerExternalizer<MyClass>(MyClass.class)\n                                )\n                        )\n                .createOrOpen();\n```\n\nCode is based on SerializerJava (array method not implemented since I do not realy understand them):\n\n``` java\n\nimport java.io.Externalizable;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamClass;\nimport java.io.OutputStream;\n\nimport org.mapdb.DataInput2;\nimport org.mapdb.DataOutput2;\nimport org.mapdb.serializer.GroupSerializerObjectArray;\n\npublic class SerializerExternalizer<A extends Externalizable> extends GroupSerializerObjectArray<A> {\n    final private long currentSerialVersionUID;\n    final private Class<A> instanceClass;\n    public SerializerExternalizer(Class<A> theClass){\n        instanceClass = theClass;\n        currentSerialVersionUID = ObjectStreamClass.lookup(theClass).getSerialVersionUID();\n    }\n    @Override\n    public void serialize(DataOutput2 out, A value) throws IOException {\n        ObjectOutputStream out2 = new ObjectOutputStream((OutputStream) out);   \n        out2.writeLong(currentSerialVersionUID);\n        value.writeExternal(out2);\n        out2.flush();\n    }\n\n    @Override\n    public A deserialize(DataInput2 in, int available) throws IOException {\n        try {\n            ObjectInputStream in2 = new ObjectInputStream(new DataInput2.DataInputToStream(in));\n            long storedVersionUID = in2.readLong();\n            if (storedVersionUID!=currentSerialVersionUID)\n                throw new ClassCastException(\"Unable to load class \"+instanceClass.getName()+\" with version \"+storedVersionUID+\" into version \"+currentSerialVersionUID +\" of the same class.\");\n            A instance = instanceClass.newInstance();\n            instance.readExternal(in2);\n            return instance;\n        } catch (ClassNotFoundException e) {\n            throw new IOException(e);\n        } catch (InstantiationException e) {\n            throw new IOException(e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(e);\n        }\n    }\n\n    @Override\n    public PollInstance[] valueArrayDeserialize(DataInput2 in, int size) throws IOException {\n        //TODO\n        throw new IOException(\"Operation not supported\");\n        /*\n        try {\n            ObjectInputStream in2 = new ObjectInputStream(new DataInput2.DataInputToStream(in));\n            Object ret =  in2.readObject();\n            if(CC.PARANOID && size!=valueArraySize(ret))\n                throw new AssertionError();\n            return (PollInstance[]) ret;\n        } catch (ClassNotFoundException e) {\n            throw new IOException(e);\n        }*/\n    }\n\n    @Override\n    public void valueArraySerialize(DataOutput2 out, Object vals) throws IOException {\n        //TODO\n        throw new IOException(\"Operation not supported\");\n        /*\n        ObjectOutputStream out2 = new ObjectOutputStream((OutputStream) out);\n        out2.writeObject(vals);\n        out2.flush();\n        */\n    }\n}\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "Smaller database with more specialized serializers", "statsSkippedReason": "", "closed": "2016-08-13 16:54:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-08-13 15:34:02", "commitHash": "be662c2dcba3b7ccaf2428fe67a74d7586143f43", "commitParents": ["9b82428b6fbf774a3484ad924b9d14d15dc760da"], "commitGHEventType": "closed", "nameRev": "be662c2dcba3b7ccaf2428fe67a74d7586143f43 remotes/origin/segment-locks~62", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "pom.xml", "deletions": 1}, {"insertions": 66, "lines": 66, "filePath": "src/test/java/org/mapdb/ElsaTest.kt", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/DBTest.kt", "deletions": 2}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #747, default serializer did not handle Externalizable\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-08-13 15:33:27"}], "created": "2016-07-28 20:50:30"}, {"labels": ["3.0", "bug"], "filteredCommits": ["45e767968f7691d40bf24d8a296451c7d8a010d3"], "url": "https://github.com/jankotek/mapdb/issues/746", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"45e767968f7691d40bf24d8a296451c7d8a010d3": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "scauwe", "changesInPackagesSPOON": [], "changesInPackagesGIT": ["src/main/java/org/mapdb/StoreWAL.kt"], "body": "Hi all,\n\nI was trying out mapdb with a simple test. When I run the following code once, it works. The second time (without deleting te database file), I get an exception:\n\n```\nException in thread \"main\" org.mapdb.DBException$VolumeIOError\n    at org.mapdb.volume.RandomAccessFileVol.putData(RandomAccessFileVol.java:141)\n    at org.mapdb.StoreWAL$commit$4.value(StoreWAL.kt:624)\n    at org.eclipse.collections.impl.map.mutable.primitive.LongLongHashMap.forEachKeyValue(LongLongHashMap.java:988)\n    at org.mapdb.StoreWAL.commit(StoreWAL.kt:622)\n    at org.mapdb.DB.commit(DB.kt:435)\n    at info.vancauwenberge.idm.driver.txtprotocol.util.StateFile.main(StateFile.java:33)\nCaused by: java.io.IOException: The parameter is incorrect\n    at java.io.RandomAccessFile.writeBytes(Native Method)\n    at java.io.RandomAccessFile.write(RandomAccessFile.java:525)\n    at org.mapdb.volume.RandomAccessFileVol.putData(RandomAccessFileVol.java:139)\n    ... 5 more\n```\n\nVersion: 3.0.0 (maven).\n\nCode:\n\n```\n        System.out.println(\"Opening Db\");\n        DB db = DBMaker\n                .fileDB(new File(\"C:\\\\Temp\\\\mapdb\"))\n                .closeOnJvmShutdown()\n                .transactionEnable()\n                .make();\n        HTreeMap map = db\n                .hashMap(\"map\")\n                .keySerializer(Serializer.STRING)\n                .valueSerializer(Serializer.JAVA)\n                .createOrOpen();\n        //Putting data in\n        System.out.println(\"Storing data\");\n        map.put(\"something\", \"here\");\n        for (int i = 0; i < 100; i++) {\n            map.put(\"\"+i, \"value-a\"+i);\n        }\n        System.out.println(\"Commiting transaction\");\n        db.commit();  //Here I get the stacktrace the second time.\n        System.out.println(\"Loading data\");\n        for (int i = 0; i < 100; i++) {\n            System.out.println(map.get(\"\"+i));\n        }\n        System.out.println(map.get(\"something\"));\n        System.out.println(\"Clearing data\");\n        map.clear();\n        System.out.println(\"Commiting transaction\");\n        db.commit();\n        System.out.println(\"Loading data\");\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(map.get(\"\"+i));\n        }\n        System.out.println(map.get(\"something\"));\n        System.out.println(\"Done\");\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "org.mapdb.DBException$VolumeIOError on commit()", "statsSkippedReason": "", "closed": "2016-07-17 18:52:49", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-07-17 20:52:40", "commitHash": "45e767968f7691d40bf24d8a296451c7d8a010d3", "commitParents": ["3a29f0036febf09bbd50641ed3b888fec199a0cc"], "commitGHEventType": "closed", "nameRev": "45e767968f7691d40bf24d8a296451c7d8a010d3 tags/mapdb-3.0.1~3", "commitGitStats": [{"insertions": 60, "lines": 60, "filePath": "src/test/java/org/mapdb/issues/Issue746Test.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreWAL.kt", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue746Test"}], "spoonFilePath": "Issue746Test.java"}], "commitMessage": "StoreWAL: delete() could corrupt data store. Fix #746\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-07-17 20:52:40"}], "created": "2016-07-16 21:03:35"}, {"labels": ["bug"], "filteredCommits": ["3d1ddbf186607d1a5022b699de57dcf5275a3dd0"], "url": "https://github.com/jankotek/mapdb/issues/740", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 9, "deletions": 1}, "numCommits": 1, "commits": {"3d1ddbf186607d1a5022b699de57dcf5275a3dd0": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 219.00027777777777, "user": "loefberg", "changesInPackagesSPOON": ["org.mapdb.elsa.Bean1"], "changesInPackagesGIT": ["src/main/java/org/mapdb/DBMaker.kt"], "body": "In issue #555 it is detailed how to specify a classloader when using OSGI. But the methods discussed are no longer there. Has this functionality been removed?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "Specifying classloader ", "statsSkippedReason": "", "closed": "2017-02-04 13:10:51", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2017-02-04 15:10:33", "commitHash": "3d1ddbf186607d1a5022b699de57dcf5275a3dd0", "commitParents": ["efa7f27d6c6ae795abb99a0aca1de0a6d30733ea"], "commitGHEventType": "closed", "nameRev": "3d1ddbf186607d1a5022b699de57dcf5275a3dd0 remotes/origin/segment-locks~18", "commitGitStats": [{"insertions": 8, "lines": 9, "filePath": "src/main/java/org/mapdb/DBMaker.kt", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/elsa/Bean1.java", "deletions": 2}, {"insertions": 21, "lines": 21, "filePath": "src/test/java/org/mapdb/DBMakerTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.elsa.Bean1"}], "spoonFilePath": "Bean1.java"}], "commitMessage": "Add DBMaker.classloader(), fix #740\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2017-02-04 15:10:33"}], "created": "2016-06-30 13:03:12"}, {"labels": ["3.0", "bug"], "filteredCommits": ["ad2e34b9838b3330f2050711e6e07a05c11a451d"], "url": "https://github.com/jankotek/mapdb/issues/726", "gitStatsSummary": {"insertions": 5, "gitFilesChange": 1, "lines": 9, "deletions": 4}, "numCommits": 1, "commits": {"ad2e34b9838b3330f2050711e6e07a05c11a451d": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesGIT": ["src/main/java/org/mapdb/DBMaker.kt"], "body": "From mailing list:\n\n I would like to perform a massive insertion. I prefer the solution of poulating an in-memory map, and then somehow \"serialize\" it to disk.\n I do the following, but eventually the files created are empty.\n\n```\n    memVolume = new ByteArrayVol();\n    db = DBMaker.volumeDB(memVolume, false).make();\n    map = db.hashMap(entity).createOrOpen();\n    ......populate map\n\n     and then\n\n   Volume fileVolume = MappedFileVol.FACTORY.makeVolume(fileName, false);\n   memVolume.copyTo(fileVolume);           \n```\n\nProblem is that `DBMaker.volumeDB` does not preserve volume, but creates new one. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "DBMaker.volumeDB broken", "statsSkippedReason": "", "closed": "2016-06-12 16:57:59", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-06-12 19:57:28", "commitHash": "ad2e34b9838b3330f2050711e6e07a05c11a451d", "commitParents": ["e151cf7661ad8a23f18212ad9841742dd60e69a1"], "commitGHEventType": "closed", "nameRev": "ad2e34b9838b3330f2050711e6e07a05c11a451d tags/mapdb-3.0.0-RC2~5", "commitGitStats": [{"insertions": 5, "lines": 9, "filePath": "src/main/java/org/mapdb/DBMaker.kt", "deletions": 4}, {"insertions": 39, "lines": 43, "filePath": "src/test/java/org/mapdb/volume/VolumeSingleTest.kt", "deletions": 4}, {"insertions": 6, "lines": 6, "filePath": "src/test/java/org/mapdb/DBMakerTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [], "commitMessage": "DBMaker.volumeDB() was broken, fix #726\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-06-12 19:57:28"}], "created": "2016-06-12 16:49:29"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/714", "title": "org.mapdb.DBException$DataCorruption: after db-crash", "closed": "2017-10-11 15:06:13", "commitsDetails": [], "commits": {}, "ttf": 509.0002777777778, "created": "2016-05-20 12:57:49", "user": "rehm", "body": "Hi, i use mapDB for a huge import task. After some random time the import abort with: \n\n```\nmapdb Error in `java': malloc(): smallbin double linked list corrupted\n```\n\nRe-Open the db - throw:\n\n```\nException in thread \"main\" org.mapdb.DBException$DataCorruption: Header checksum broken. Store was not closed correctly and might be corrupted. Use `DBMaker.checksumHeaderBypass()` to recover your data. Use clean shutdown or enable transactions to protect the store in the future.\n        at org.mapdb.StoreDirectAbstract.fileHeaderCheck(StoreDirectAbstract.kt:109)\n        at org.mapdb.StoreDirect.<init>(StoreDirect.kt:100)\n        at org.mapdb.StoreDirect$Companion.make(StoreDirect.kt:53)\n        at org.mapdb.StoreDirect$Companion.make$default(StoreDirect.kt:52)\n        at org.mapdb.DBMaker$Maker.make(DBMaker.kt:415)\n        at org.hucompute.galaxy.Galaxy.<init>(Galaxy.java:39)\n        at org.hucompute.galaxy.Galaxy.main(Galaxy.java:154)\n\n```\n\nany idea, how to debug this? \n\nbest wishes \n"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/713", "title": "inconsistent index", "closed": "2016-05-29 15:25:37", "commitsDetails": [], "commits": {}, "ttf": 9.000277777777777, "created": "2016-05-20 02:22:10", "user": "ovear", "body": "Hello, i got this error after i insert information to mapdb.\nMy mapdb version is mapdb-3.0-beta4 (M6 are the same problem)\n\nthis is the stack trace\n\n> Error: inconsistent index\n> org.mapdb.DBException$DataCorruption: inconsistent index\n>         at org.mapdb.IndexTreeListJava.treePutSub(IndexTreeListJava.java:363)\n>         at org.mapdb.IndexTreeListJava.treePut(IndexTreeListJava.java:344)\n>         at org.mapdb.IndexTreeLongLongMap.put(IndexTreeLongLongMap.kt:72)\n>         at org.mapdb.HTreeMap.putInternal$mapdb(HTreeMap.kt:363)\n>         at org.mapdb.HTreeMap.put(HTreeMap.kt:324)\n>         and something others\n>         at java.lang.Thread.run(Thread.java:745)\n> Error: inconsistent index\n> org.mapdb.DBException$DataCorruption: inconsistent index\n>         at org.mapdb.IndexTreeListJava.treePutSub(IndexTreeListJava.java:363)\n>         at org.mapdb.IndexTreeListJava.treePut(IndexTreeListJava.java:344)\n>         at org.mapdb.IndexTreeLongLongMap.put(IndexTreeLongLongMap.kt:72)\n>         at org.mapdb.HTreeMap.putInternal$mapdb(HTreeMap.kt:363)\n>         at org.mapdb.HTreeMap.put(HTreeMap.kt:324)\n>         and something others\n>         at info.ovear.Main.lambda$syncMusic$0(Main.java:158)\n>         at java.lang.Thread.run(Thread.java:745)\n> Error: inconsistent index\n> org.mapdb.DBException$DataCorruption: inconsistent index\n>         at org.mapdb.IndexTreeListJava.treePutSub(IndexTreeListJava.java:363)\n>         at org.mapdb.IndexTreeListJava.treePut(IndexTreeListJava.java:344)\n>         at org.mapdb.IndexTreeLongLongMap.put(IndexTreeLongLongMap.kt:72)\n>         at org.mapdb.HTreeMap.putInternal$mapdb(HTreeMap.kt:363)\n>         at org.mapdb.HTreeMap.put(HTreeMap.kt:324)\n>         and something others\n>         at java.lang.Thread.run(Thread.java:745)\n> Error: inconsistent index\n\ni use follow code to init mapdb\n\n```\n    private DB db;\n    private HTreeMap<String, List<DataPoint>> dataPointDb;\n\n        db = DBMaker.fileDB(\"mydb.db2\")\n                        fileMmapEnableIfSupported().\n                        transactionEnable().\n                        closeOnJvmShutdown().\n                        make();\n        dataPointDb = db.hashMap(\"mymap\").\n                keySerializer(Serializer.STRING).\n                valueSerializer(new SerializerCompressionWrapper(Serializer.ELSA)).\n                counterEnable().\n                layout(16, 64, 4).\n                createOrOpen();\n```\n\nand just use dataPointDb.put to insert data to mapdb, and finally use db.close() to close db.\n\nThen, if i open this db again, it will throw the \u201cinconsistent index\u201d exception.\n"}, {"labels": ["3.0", "bug"], "filteredCommits": ["0b771bff43c7e9eb1901e1c42f8ee51a79a77829"], "url": "https://github.com/jankotek/mapdb/issues/706", "gitStatsSummary": {"insertions": 171, "gitFilesChange": 2, "lines": 283, "deletions": 112}, "numCommits": 1, "commits": {"0b771bff43c7e9eb1901e1c42f8ee51a79a77829": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 8.000277777777777, "user": "shyiko", "changesInPackagesSPOON": [], "changesInPackagesGIT": ["src/main/java/org/mapdb/DBMaker.kt", "src/main/java/org/mapdb/DB.kt"], "body": "Hi. This is not of immediate importance as we don't intend to use MapDB in production, but I thought it might of interest to you:\n\n``` kotlin\nval db = fileDB(...).closeOnJvmShutdown().make()\ndb.hashMap(\"...\").keySerializer(Serializer.STRING).createOrOpen()\ndb.hashMap(\"...\").keySerializer(Serializer.STRING).createOrOpen()\ndb.treeMap(\"...\").keySerializer(SerializerArrayTuple(Serializer.STRING, Serializer.STRING)).createOrOpen()\n```\n\n(db file itself - https://transfer.sh/10HejT/mapdb.corrupted)\n\nAs it says in the title - MapDB failed with \"org.mapdb.DBException$DataCorruption: Header checksum broken. Store was not closed correctly, or is corrupted\" after the reboot. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "org.mapdb.DBException$DataCorruption after reboot", "statsSkippedReason": "", "closed": "2016-05-18 16:03:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-05-18 10:15:54", "commitHash": "0b771bff43c7e9eb1901e1c42f8ee51a79a77829", "commitParents": ["4037b2febc45a2480faec906f739cab388d64aec"], "commitGHEventType": "closed", "nameRev": "0b771bff43c7e9eb1901e1c42f8ee51a79a77829 tags/mapdb-3.0.0-beta4~2", "commitGitStats": [{"insertions": 19, "lines": 33, "filePath": "src/main/java/org/mapdb/DBMaker.kt", "deletions": 14}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/ClosedThrowsExceptionTest.java", "deletions": 1}, {"insertions": 152, "lines": 250, "filePath": "src/main/java/org/mapdb/DB.kt", "deletions": 98}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.ClosedThrowsExceptionTest.closed_close()"}], "spoonFilePath": "ClosedThrowsExceptionTest.java"}], "commitMessage": "DB: rework shutdown hook, should fix #706\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-05-18 10:15:54"}], "created": "2016-05-09 19:45:48"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/689", "title": "HashSets throw IllegalAccessError", "closed": "2016-04-03 08:04:37", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2016-04-02 09:47:02", "user": "gravityfox", "body": "Version: MapDb 3.0.0-M4\n\nMaking a hashset and then trying to add things to it throws an IllegalAccessError.\n\nIt appears that it's simply trying to add to a hashmap's keyset.\n\nThis effectively makes hashsets read-only, which could be okay in some circumstances. Since it uses HTreeMap along with Hashmaps they could be used interchangably... maybe...\n\nEither way this should be fixed so that HashSets can actually be written to.\n\nThank you!\n"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/687", "title": "HTreeMap cache:", "closed": "2016-03-30 05:07:48", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2016-03-30 05:06:14", "user": "jankotek", "body": "MapDB looks interesting, but one thing I don't see there is the behaviour from Caffeine where after a cache miss only one thread is loading the value and others are blocked.\n\nhttps://www.reddit.com/r/java/comments/4cimtw/off_heap_cache/\n"}, {"labels": ["3.0", "bug"], "filteredCommits": ["a6510b48b197e2a16c54510d85cec267e2a380a0"], "url": "https://github.com/jankotek/mapdb/issues/685", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"a6510b48b197e2a16c54510d85cec267e2a380a0": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "0e69921beffcb93b06d03c9cc8e8836bd9eecc44": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 44.000277777777775, "user": "jandam", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "There is missing loading values in loadNextNode for entryIterator. findLo is OK\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 0, "MOV": 0.0}, "title": "MapDB 3: SortedTableMap - entryIterators loads only keys in loadNextNode", "statsSkippedReason": "", "closed": "2016-05-07 17:56:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-03-27 14:41:08", "commitHash": "a6510b48b197e2a16c54510d85cec267e2a380a0", "commitParents": ["bbc4e6a4c034bc32357938c5e71909d243321f60"], "commitGHEventType": "referenced", "nameRev": "a6510b48b197e2a16c54510d85cec267e2a380a0 tags/mapdb-3.0.0-M4~3", "commitGitStats": [{"insertions": 32, "lines": 32, "filePath": "src/test/java/org/mapdb/SortedTableMapTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [], "commitMessage": "SortedTableMap: add test case for #685\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-03-27 14:41:08"}, {"commitUser": "jankotek", "commitDateTime": "2016-03-31 16:14:41", "commitHash": "0e69921beffcb93b06d03c9cc8e8836bd9eecc44", "commitParents": ["2a69e08c461bb43f16c849f56c72233016757dc7"], "commitGHEventType": "referenced", "nameRev": "0e69921beffcb93b06d03c9cc8e8836bd9eecc44 tags/mapdb-3.0.0-M5~33", "commitGitStats": [{"insertions": 16, "lines": 30, "filePath": "src/test/java/org/mapdb/jsr166Tests/ConcurrentSkipListMapTest.java", "deletions": 14}, {"insertions": 21, "lines": 25, "filePath": "src/test/java/org/mapdb/SortedTableMapTest.kt", "deletions": 4}, {"insertions": 5, "lines": 5, "filePath": "src/test/java/org/mapdb/SortedTableMap_ConcurrentSkipListMapTest_JSR166Test.kt", "deletions": 0}, {"insertions": 440, "lines": 1147, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 707}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testSubMapContents()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.isReadOnly()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.check(java.util.NavigableMap,int,int,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testTailMapContents()"}, {"UPD": 1, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.isReadOnly(java.util.Map)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.bashSubMap(java.util.NavigableMap,int,int,boolean)"}, {"UPD": 1, "TOT": 8, "DEL": 2, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testRecursiveSubMaps()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testSubMapContents2()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testHeadMapContents()"}], "spoonFilePath": "ConcurrentSkipListMapTest.java"}], "commitMessage": "SortedTableMap: fix #684 and #685\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-03-31 16:14:41"}], "created": "2016-03-24 13:01:48"}, {"labels": ["3.0", "bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/684", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"0e69921beffcb93b06d03c9cc8e8836bd9eecc44": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 7.000277777777778, "user": "jandam", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "There is missing test for last value in SortedTableMap line 298.\nhttps://github.com/jankotek/mapdb/blob/master/src/main/java/org/mapdb/SortedTableMap.kt#L298\nval valsBinarySize = offset + volume.getInt(offsetWithHead+4+(pos+nodeCount+1)*4) - valOffset\n\nFixed code:\nval valsBinarySize = offset + (pos == nodeCount - 1 ? pageSize : volume.getInt(offsetWithHead + 4 + (pos + nodeCount + 1) \\* 4)) - valOffset\n\nFix is same like on other places in code.\nIs this correct to use \"pageSize\" instead of correct end offset for last value?\nI think that offset for first key can be computed from nodeCount. So it is no necessary to store it. And available space can be used for storing end offset for last value.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "MapDB 3: SortedTableMap - negative \"valsBinarySize\" in get", "statsSkippedReason": "", "closed": "2016-03-31 13:14:53", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-03-31 16:14:41", "commitHash": "0e69921beffcb93b06d03c9cc8e8836bd9eecc44", "commitParents": ["2a69e08c461bb43f16c849f56c72233016757dc7"], "commitGHEventType": "closed", "nameRev": "0e69921beffcb93b06d03c9cc8e8836bd9eecc44 tags/mapdb-3.0.0-M5~33", "commitGitStats": [{"insertions": 16, "lines": 30, "filePath": "src/test/java/org/mapdb/jsr166Tests/ConcurrentSkipListMapTest.java", "deletions": 14}, {"insertions": 21, "lines": 25, "filePath": "src/test/java/org/mapdb/SortedTableMapTest.kt", "deletions": 4}, {"insertions": 5, "lines": 5, "filePath": "src/test/java/org/mapdb/SortedTableMap_ConcurrentSkipListMapTest_JSR166Test.kt", "deletions": 0}, {"insertions": 440, "lines": 1147, "filePath": "src/main/java/org/mapdb/SortedTableMap.kt", "deletions": 707}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testSubMapContents()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.isReadOnly()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.check(java.util.NavigableMap,int,int,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testTailMapContents()"}, {"UPD": 1, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.isReadOnly(java.util.Map)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.bashSubMap(java.util.NavigableMap,int,int,boolean)"}, {"UPD": 1, "TOT": 8, "DEL": 2, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testRecursiveSubMaps()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testSubMapContents2()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.jsr166Tests.ConcurrentSkipListMapTest.testHeadMapContents()"}], "spoonFilePath": "ConcurrentSkipListMapTest.java"}], "commitMessage": "SortedTableMap: fix #684 and #685\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-03-31 16:14:41"}], "created": "2016-03-24 09:56:12"}, {"labels": ["2.0", "bug"], "filteredCommits": ["7f9c154a1b82c42aa0cf590f740b4088fa58e647"], "url": "https://github.com/jankotek/mapdb/issues/674", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"7f9c154a1b82c42aa0cf590f740b4088fa58e647": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 11.000277777777777, "user": "pozharko", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "I have plenty of IndexOutOfBoundsException errors on db.commit:\n\n```\njava.lang.IndexOutOfBoundsException\n    at org.mapdb.Volume.hash(Volume.java:459)\n    at org.mapdb.WriteAheadLog.checksum(WriteAheadLog.java:180)\n    at org.mapdb.WriteAheadLog.commit(WriteAheadLog.java:167)\n    at org.mapdb.StoreWAL.commit(StoreWAL.java:653)\n    at org.mapdb.Engine$CloseOnJVMShutdown.commit(Engine.java:487)\n    at org.mapdb.DB.commit(DB.java:2647)\n```\n\nor on DBMaker.make\n\n```\njava.lang.IndexOutOfBoundsException\n    at org.mapdb.Volume.hash(Volume.java:459)\n    at org.mapdb.WriteAheadLog.checksum(WriteAheadLog.java:180)\n    at org.mapdb.WriteAheadLog.commit(WriteAheadLog.java:167)\n    at org.mapdb.StoreWAL.commit(StoreWAL.java:653)\n    at org.mapdb.Engine$CloseOnJVMShutdown.commit(Engine.java:487)\n    at org.mapdb.BTreeMap.preinitCatalog(BTreeMap.java:183)\n    at org.mapdb.DB.reinit(DB.java:253)\n    at org.mapdb.DB.<init>(DB.java:220)\n    at org.mapdb.DBMaker$Maker.make(DBMaker.java:1297)\n```\n\nCode, that creates DB is: \n\n```\n   DBMaker.fileDB(new File(fileName))\n        .closeOnJvmShutdown()\n        .cacheSize(2048)\n        .checksumEnable()\n        .fileMmapEnable()\n        .make()\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "IndexOutOfBoundsException while db.commit", "statsSkippedReason": "", "closed": "2016-02-17 10:50:02", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-02-13 14:17:24", "commitHash": "7f9c154a1b82c42aa0cf590f740b4088fa58e647", "commitParents": ["89eb199b1af807ebf735564dd764e07b838eb714"], "commitGHEventType": "referenced", "nameRev": "7f9c154a1b82c42aa0cf590f740b4088fa58e647 tags/mapdb-2.0-beta13~5", "commitGitStats": [{"insertions": 38, "lines": 38, "filePath": "src/test/java/org/mapdb/issues/Issue674Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue674Test"}], "spoonFilePath": "Issue674Test.java"}], "commitMessage": "Add test case for #674, could not replicate problem\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 14:17:24"}], "created": "2016-02-05 11:51:34"}, {"labels": ["bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/669", "title": "SimpleQueue.isEmpty() > peek() may throw NullPointerException", "closed": "2016-02-13 12:27:46", "commitsDetails": [], "commits": {}, "ttf": 21.00027777777778, "created": "2016-01-23 06:40:34", "user": "zhoupo", "body": "MapDB version: 1.0.8.\n\nThe exception is thrown at line 117 in Queues.java with the following code snippet:\n\n```\nreturn (E) n.value;\n```\n\nI access SimpleQueue object in two different thread, and guess what causes npe is `final long head2 = head.get();` in peek() is modified or deleted somewhere. I debug the code and found \"r\" is {} in the following method, which means \"StoreWAL.get2()\" will return null.\n\n```\n@Override\nprotected <A> A get2(long ioRecid, Serializer<A> serializer) throws IOException {\n    assert(locks[Store.lockPos(ioRecid)].getWriteHoldCount()==0||\n            locks[Store.lockPos(ioRecid)].writeLock().isHeldByCurrentThread());\n\n    //check if record was modified in current transaction\n    long[] r = modified.get(ioRecid);\n    //no, read main version\n    if(r==null) return super.get2(ioRecid, serializer);\n    //check for tombstone (was deleted in current trans)\n    if(r==TOMBSTONE || r==PREALLOC || r.length==0) return null;\n```\n"}, {"labels": ["bug", "wontfix"], "filteredCommits": ["541d04ce0a3c02d9f10da9b5b19b1b559a50f6a4", "61ae8a026ff318980a952eccbd4603f4e5a80095", "e88af60d60d6308122396c30138fb579d84b8ffd"], "url": "https://github.com/jankotek/mapdb/issues/664", "gitStatsSummary": {"insertions": 46.0, "gitFilesChange": 2, "lines": 65.0, "deletions": 19.0}, "numCommits": 1, "commits": {"61ae8a026ff318980a952eccbd4603f4e5a80095": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "ca2bf1988e739e3213d69b32a08c0479693df69b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "541d04ce0a3c02d9f10da9b5b19b1b559a50f6a4": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e88af60d60d6308122396c30138fb579d84b8ffd": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 32.000277777777775, "user": "datumbox", "changesInPackagesSPOON": ["org.mapdb.BTreeMapJava.NodeSerializer", "org.mapdb.BTreeMapJava.Node"], "changesInPackagesGIT": ["src/main/java/org/mapdb", "src/main/java/org/mapdb/BTreeMap.kt"], "body": "Hello,\n\nI will try to provide as much info as possive for a bug that affects the size() method of the BTreeMap and appears randomly about 1 every 10 times.\n\nThe problem is straight forward to explain: I put 50 items in the tree, the size reports 49 but when you list all of them or use an iterator you get 50 back. Here are some screenshots that show the problem:\nhttp://postimg.org/image/s7qnxmzl1/\nhttp://postimg.org/image/nxw4fxuyh/\nhttp://postimg.org/image/ir7jei5gr/\n\nHere is a screenshot of how the iterator looks like:\nhttp://postimg.org/image/8omth78x3/\n\nAs you can see in the above screenshot the lastReturnedKey was 49 which is the 50th item (indexing starts from 0) nevertheless again the reported size is 49.\n\nThe Map was populated using multiple threads. I am using version 1.0.8 and here are the options used on mapdb:\n\n```\nDBMaker m = DBMaker.newTempFileDB().deleteFilesAfterClose();\nm = m.transactionDisable();\nm = m.compressionEnable();\nm = m.cacheDisable();\nm = m.asyncWriteEnable();\nm = m.closeOnJvmShutdown();\nDB db = m.make();\nMap<Object,Object> tmp = db.createTreeMap(name)\n                .counterEnable()\n                .makeOrGet();\n```\n\nLet me know if I can provide any additional info to assist.\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0.0, "TOT": 2.0, "DEL": 0.0, "INS": 2.0, "spoonFilesChanged": 1, "MOV": 0.0}, "title": "Size() returns less than the actual number of items in the BTreeMap", "statsSkippedReason": "", "closed": "2016-02-13 12:43:05", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-02-13 15:05:21", "commitHash": "61ae8a026ff318980a952eccbd4603f4e5a80095", "commitParents": ["e07b309b2c7433a7bc2fad7f760a213d03276d08"], "commitGHEventType": "referenced", "nameRev": "61ae8a026ff318980a952eccbd4603f4e5a80095 tags/mapdb-1.0.9~4", "commitGitStats": [{"insertions": 43, "lines": 43, "filePath": "src/test/java/org/mapdb/Issue664Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue664Test"}], "spoonFilePath": "Issue664Test.java"}], "commitMessage": "Add test for #664, not going to fix BTreeMap race condition\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 15:05:21"}, {"commitUser": "jankotek", "commitDateTime": "", "commitHash": "ca2bf1988e739e3213d69b32a08c0479693df69b", "commitParents": [], "commitGHEventType": "referenced", "nameRev": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "commitMessage": "", "spoonStatsSkippedReason": "", "authoredDateTime": ""}, {"commitUser": "jankotek", "commitDateTime": "2016-04-16 11:54:02", "commitHash": "541d04ce0a3c02d9f10da9b5b19b1b559a50f6a4", "commitParents": ["fdfa476131beb6c31cfa72ca70b62f354a82996b"], "commitGHEventType": "referenced", "nameRev": "541d04ce0a3c02d9f10da9b5b19b1b559a50f6a4 tags/mapdb-3.0.0-M6~10", "commitGitStats": [{"insertions": 27, "lines": 29, "filePath": "src/test/java/org/mapdb/BTreeMapTest.kt", "deletions": 2}, {"insertions": 42, "lines": 60, "filePath": "src/main/java/org/mapdb/BTreeMap.kt", "deletions": 18}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/issues/ParallelMaps.kt", "deletions": 2}, {"insertions": 4, "lines": 5, "filePath": "src/main/java/org/mapdb/BTreeMapJava.java", "deletions": 1}, {"insertions": 24, "lines": 24, "filePath": "src/test/java/org/mapdb/BTreeMap_ConcurrentMap_GuavaTest.kt", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapJava.NodeSerializer"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapJava.Node"}], "spoonFilePath": "BTreeMapJava.java"}], "commitMessage": "BTreeMap: fix race condition, fix #664\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-04-16 11:54:02"}, {"commitUser": "jankotek", "commitDateTime": "2016-02-13 15:38:47", "commitHash": "e88af60d60d6308122396c30138fb579d84b8ffd", "commitParents": ["f0322365ea2fdb613fa947bf6deed452d5eaed7d"], "commitGHEventType": "referenced", "nameRev": "e88af60d60d6308122396c30138fb579d84b8ffd tags/mapdb-1.0.9~2", "commitGitStats": [{"insertions": 43, "lines": 86, "filePath": "src/test/java/org/mapdb/Issue664Test.java", "deletions": 43}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Issue664Test"}], "spoonFilePath": "Issue664Test.java"}], "commitMessage": "#664 comment out Java 8 code.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 15:38:47"}], "created": "2016-01-12 00:03:12"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/660", "title": "NullPointerException in StoreCached.flush()", "closed": "2016-05-29 15:32:07", "commitsDetails": [], "commits": {}, "ttf": 144.00027777777777, "created": "2016-01-05 19:55:17", "user": "bdupras", "body": "Ran into this intermittent NPE on `org.mapdb.DB.commit()`. We were calling `commit()` unnecessarily inside a tight single-threaded loop. Observed in a system running 2.0-beta10.\n\n```\njava.lang.NullPointerException \n        at org.mapdb.StoreCached.flush(StoreCached.java:380) \n        at org.mapdb.StoreDirect.commit(StoreDirect.java:1128) \n        at org.mapdb.Engine$CloseOnJVMShutdown.commit(Engine.java:487) \n        at org.mapdb.DB.commit(DB.java:2647) \n```\n\nWe've bumped to beta12 and removed the call to `commit()` from the tight loop. Will post here if we see again.\n\n//cc @beala\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["e07b309b2c7433a7bc2fad7f760a213d03276d08", "7e529bab00d4dd08010b191d85b76d3f5c34c176", "374ca89c0a2fe80feba4e709e35f5b399840d52e"], "url": "https://github.com/jankotek/mapdb/issues/656", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 6, "deletions": 3}, "numCommits": 2, "commits": {"7e529bab00d4dd08010b191d85b76d3f5c34c176": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e07b309b2c7433a7bc2fad7f760a213d03276d08": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "374ca89c0a2fe80feba4e709e35f5b399840d52e": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 43.000277777777775, "user": "datumbox", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.isEmpty()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hello,\n\nI currently use MapDB 1.0.7 in Datumbox Machine Learning Framework and I plan to move to MapDB 2.0-beta12. While testing it I noticed that that if the counterEnable() option is used, calling isEmpty() to a non-empty map returns true. \n\nHere is an example that reproduces the problem:\n\n``` java\npublic static void main(String[] args) {\n    DBMaker.Maker m = DBMaker.tempFileDB();\n    DB db = m.make();\n\n    //Build a map with the counterEnable option\n    Map<Object, Object> mCounterEnabled = db.hashMapCreate(\"mCounterEnabled\")\n        .counterEnable()\n        .makeOrGet();\n    mCounterEnabled.put(1, 1);\n    System.out.println(\"mCounterEnabled: size() => \"+mCounterEnabled.size()+\", isEmpty() => \"+mCounterEnabled.isEmpty());\n\n    //Build a map without the counterEnable option\n    Map<Object, Object> mCounterDisabled = db.hashMapCreate(\"mCounterDisabled\")\n        .makeOrGet();\n    mCounterDisabled.put(1, 1);\n    System.out.println(\"mCounterDisabled: size() => \"+mCounterDisabled.size()+\", isEmpty() => \"+mCounterDisabled.isEmpty());\n}\n```\n\nThe output is:\nmCounterEnabled: size() => 1, isEmpty() => true\nmCounterDisabled: size() => 1, isEmpty() => false\n\nLooking forward to your reply. \n\nBest Regards,\nVasilis\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 2, "TOT": 5, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 3}, "title": "counterEnable() potentially broken, wrong isEmpty() value", "statsSkippedReason": "", "closed": "2016-02-13 13:01:18", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-02-17 12:17:41", "commitHash": "7e529bab00d4dd08010b191d85b76d3f5c34c176", "commitParents": ["0d1f24076c64292c7a98b54a57a6cc0da9a43120"], "commitGHEventType": "referenced", "nameRev": "7e529bab00d4dd08010b191d85b76d3f5c34c176 tags/mapdb-2.0-beta13~1", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 1}, {"insertions": 23, "lines": 38, "filePath": "src/test/java/org/mapdb/issues/Issue656Test.java", "deletions": 15}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue656Test.main()"}], "spoonFilePath": "Issue656Test.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 3, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.isEmpty()"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "HTreeMap: isEmpty() still broken. Fix #656 again\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-17 12:17:41"}, {"commitUser": "jankotek", "commitDateTime": "2016-02-13 14:58:01", "commitHash": "e07b309b2c7433a7bc2fad7f760a213d03276d08", "commitParents": ["85d1ef6d19d43b97912fbc32ed47f0fdb9ccd5eb"], "commitGHEventType": "referenced", "nameRev": "e07b309b2c7433a7bc2fad7f760a213d03276d08 tags/mapdb-1.0.9~5", "commitGitStats": [{"insertions": 31, "lines": 31, "filePath": "src/test/java/org/mapdb/Issue656Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue656Test"}], "spoonFilePath": "Issue656Test.java"}], "commitMessage": "#656 add test case\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 14:58:01"}, {"commitUser": "jankotek", "commitDateTime": "2016-02-13 15:01:11", "commitHash": "374ca89c0a2fe80feba4e709e35f5b399840d52e", "commitParents": ["7f9c154a1b82c42aa0cf590f740b4088fa58e647"], "commitGHEventType": "closed", "nameRev": "374ca89c0a2fe80feba4e709e35f5b399840d52e tags/mapdb-2.0-beta13~4", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 2}, {"insertions": 33, "lines": 33, "filePath": "src/test/java/org/mapdb/issues/Issue656Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue656Test"}], "spoonFilePath": "Issue656Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.HTreeMap.isEmpty()"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Fix #656, HTreeMap.isEmpty() broken with counter enabled.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 15:01:11"}], "created": "2015-12-31 23:21:17"}, {"labels": ["2.0", "bug"], "filteredCommits": ["f0322365ea2fdb613fa947bf6deed452d5eaed7d"], "url": "https://github.com/jankotek/mapdb/issues/653", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"f0322365ea2fdb613fa947bf6deed452d5eaed7d": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "049ecc0fbd3d4b6bf93021c9a442312146101cba": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 45.000277777777775, "user": "KaiStapel", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.getFields(java.lang.Class)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I'm using MapDB 1.0.8\n\nThe following code from `SerializerPojo#getFields` causes an NPE when used on an interface:\n\n```\nclazz = clazz.getSuperclass();\nstreamClass = ObjectStreamClass.lookup(clazz);\n```\n\nbecause `class.getSuperclass();` is defined to return `null` on interfaces.\n\nWhy are interfaces registered at all? In my case the `ObjectMapper` used in the `MessageSerializer` of the DB contains an interface type in the type cache of the type factory which will be registered during DB creation, because for some reason it tries to serialize its own serializer??? Why is that?\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "SerializerPojo#registerClass cannot handle interfaces: NullPointerException in getFields", "statsSkippedReason": "", "closed": "2016-02-13 13:36:39", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-02-13 15:36:01", "commitHash": "f0322365ea2fdb613fa947bf6deed452d5eaed7d", "commitParents": ["61ae8a026ff318980a952eccbd4603f4e5a80095"], "commitGHEventType": "referenced", "nameRev": "f0322365ea2fdb613fa947bf6deed452d5eaed7d tags/mapdb-1.0.9~3", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.getFields(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}], "commitMessage": "SerializerPojo#registerClass cannot handle interfaces: NullPointerException in getFields. Fix #653\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 15:36:01"}, {"commitUser": "jankotek", "commitDateTime": "2016-02-13 15:36:30", "commitHash": "049ecc0fbd3d4b6bf93021c9a442312146101cba", "commitParents": ["374ca89c0a2fe80feba4e709e35f5b399840d52e"], "commitGHEventType": "closed", "nameRev": "049ecc0fbd3d4b6bf93021c9a442312146101cba tags/mapdb-2.0-beta13~3", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.makeFieldsForClass(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}], "commitMessage": "SerializerPojo#registerClass cannot handle interfaces: NullPointerException in getFields. Fix #653\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 15:36:30"}], "created": "2015-12-30 12:13:38"}, {"labels": ["2.0", "bug"], "filteredCommits": ["0d1f24076c64292c7a98b54a57a6cc0da9a43120"], "url": "https://github.com/jankotek/mapdb/issues/648", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"0d1f24076c64292c7a98b54a57a6cc0da9a43120": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 61.000277777777775, "user": "gpeche", "changesInPackagesSPOON": ["org.mapdb.Store.Cache.WeakSoftRef.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "As of 2.0-beta12, `Store.Cache.WeakSoftRef.close()` is implemented as:\n\n``` java\n        @Override\n        public void close() {\n            Lock lock = this.lock;\n            if(lock!=null)\n                lock.lock();\n            try{\n                //TODO howto correctly shutdown queue? possible memory leak here?\n                items.clear();\n                items = null;\n                flushGCed();\n                queue = null;\n            }finally {\n                if(lock!=null)\n                    lock.unlock();\n            }\n        }\n```\n\nThe problem is that `flushGCed()` will try to access the null'ed `items` if some reference happens to be waiting in `queue` for finalization, triggering a `NullPointerException`. I think just changing\n\n``` java\n    items = null;\n    flushGCed();\n```\n\nto\n\n``` java\n    flushGCed();\n    items = null;\n```\n\nshould do the trick. Alternatively, checking inside `flushGCed()` that `items != null` before accessing `items` should also work.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 1}, "title": "Spurious NullPointerException when closing soft/weak cache", "statsSkippedReason": "", "closed": "2016-02-13 17:00:26", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2016-02-13 19:00:21", "commitHash": "0d1f24076c64292c7a98b54a57a6cc0da9a43120", "commitParents": ["049ecc0fbd3d4b6bf93021c9a442312146101cba"], "commitGHEventType": "closed", "nameRev": "0d1f24076c64292c7a98b54a57a6cc0da9a43120 tags/mapdb-2.0-beta13~2", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Store.Cache.WeakSoftRef.close()"}], "spoonFilePath": "Store.java"}], "commitMessage": "Spurious NullPointerException when closing soft/weak cache , fix #648\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-13 19:00:21"}], "created": "2015-12-14 10:04:00"}, {"labels": ["2.0", "bug"], "filteredCommits": ["d256c480c229acb87ae0a6e2a7b36473a19c901d"], "url": "https://github.com/jankotek/mapdb/issues/634", "gitStatsSummary": {"insertions": 19, "gitFilesChange": 3, "lines": 37, "deletions": 18}, "numCommits": 1, "commits": {"d256c480c229acb87ae0a6e2a7b36473a19c901d": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 1.0002777777777778, "user": "catena2w", "changesInPackagesSPOON": ["org.mapdb.StoreAppend.initOpen().1.beforeDestroyWAL()", "org.mapdb.WALCrash.crash().1.beforeDestroyWAL()", "org.mapdb.WriteAheadLog.replayWALSkipRollbacks(org.mapdb.WriteAheadLog$WALReplay)", "org.mapdb.StoreWAL.initOpen().1.beforeDestroyWAL()", "org.mapdb.WALSequence", "org.mapdb.WriteAheadLog.commit()", "org.mapdb.WALSequence.beforeDestroyWAL()", "org.mapdb.WriteAheadLog.1.beforeDestroyWAL()", "org.mapdb.WriteAheadLog.beforeDestroyWAL()", "org.mapdb.WALTruncate.test().1.beforeDestroyWAL()", "org.mapdb.WriteAheadLog.replayWAL(org.mapdb.WriteAheadLog$WALReplay)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "When I call db.commit() without any changes before db close, I get \"WAL corrupted\" error on next db load.\nE.g. this code\n\n``` scala\n  emptyCommit(0)\n  emptyCommit(1)\n\n  def emptyCommit(run: Int): Unit = {\n    println(\"run:\" + run)\n    val db =\n      DBMaker.appendFileDB(new File(\"/tmp/scorex/testApp/segmentsStorage.mapDB\"))\n        .fileMmapEnableIfSupported()\n        .closeOnJvmShutdown()\n        .checksumEnable()\n        .make()\n\n    val map: HTreeMap[Long, AuthDataBlock[DataSegment]] = db.hashMapCreate(\"segments\")\n      .keySerializer(Serializer.LONG)\n      .makeOrGet()\n\n    for (i <- 1 to 10) {\n      val value = AuthDataBlock(Random.nextString(4).getBytes, Seq())\n      map.put(i, value)\n      db.commit()\n    }\n    db.commit()\n    db.close()\n  }\n```\n\nwill print something like \n\n```\nrun:0\nrun:1\nNov 23, 2015 6:57:53 PM org.mapdb.WriteAheadLog skipRollbacks\nINFO: WAL corrupted, skipping\norg.mapdb.DBException$DataCorruption: WAL corrupted 0 - 2245\n    at org.mapdb.WriteAheadLog.skipRollbacks(WriteAheadLog.java:499)\n    at org.mapdb.WriteAheadLog.replayWALSkipRollbacks(WriteAheadLog.java:448)\n    at org.mapdb.WriteAheadLog.open(WriteAheadLog.java:347)\n    at org.mapdb.StoreAppend.initOpen(StoreAppend.java:288)\n    at org.mapdb.StoreAppend.init(StoreAppend.java:194)\n    at org.mapdb.DBMaker$Maker.makeEngine(DBMaker.java:1504)\n    at org.mapdb.DBMaker$Maker.make(DBMaker.java:1284)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 11, "UPD": 10, "TOT": 20, "DEL": 2, "INS": 1, "spoonFilesChanged": 6, "MOV": 7}, "title": "\"WAL corrupted\" on empty commit", "statsSkippedReason": "", "closed": "2015-11-25 11:48:24", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-11-25 13:48:10", "commitHash": "d256c480c229acb87ae0a6e2a7b36473a19c901d", "commitParents": ["3edd04f8985ca5af0a18f93b6bf4a48971982c13"], "commitGHEventType": "closed", "nameRev": "d256c480c229acb87ae0a6e2a7b36473a19c901d tags/mapdb-2.0-beta12~2", "commitGitStats": [{"insertions": 5, "lines": 10, "filePath": "src/test/java/org/mapdb/WALTruncate.java", "deletions": 5}, {"insertions": 38, "lines": 56, "filePath": "src/test/java/org/mapdb/WriteAheadLogTest.java", "deletions": 18}, {"insertions": 2, "lines": 7, "filePath": "src/test/java/org/mapdb/WALSequence.java", "deletions": 5}, {"insertions": 26, "lines": 26, "filePath": "src/test/java/org/mapdb/issues/IssuesTest.java", "deletions": 0}, {"insertions": 5, "lines": 9, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 4}, {"insertions": 9, "lines": 18, "filePath": "src/main/java/org/mapdb/WriteAheadLog.java", "deletions": 9}, {"insertions": 5, "lines": 10, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 5}, {"insertions": 5, "lines": 10, "filePath": "src/test/java/org/mapdb/WALCrash.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WALSequence"}, {"UPD": 3, "TOT": 4, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WALSequence.beforeDestroyWAL()"}], "spoonFilePath": "WALSequence.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLog.commit()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WriteAheadLog.1.beforeDestroyWAL()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLog.replayWALSkipRollbacks(org.mapdb.WriteAheadLog$WALReplay)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WriteAheadLog.beforeDestroyWAL()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLog.replayWAL(org.mapdb.WriteAheadLog$WALReplay)"}], "spoonFilePath": "WriteAheadLog.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WALTruncate.test().1.beforeDestroyWAL()"}], "spoonFilePath": "WALTruncate.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.IssuesTest.issue634_1()"}], "spoonFilePath": "IssuesTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WALCrash.crash().1.beforeDestroyWAL()"}], "spoonFilePath": "WALCrash.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreAppend.initOpen().1.beforeDestroyWAL()"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.initOpen().1.beforeDestroyWAL()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WriteAheadLogTest.tombstone().2.beforeDestroyWAL()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLogTest.empty_commit()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WriteAheadLogTest.testRecord(long,byte[]).1.beforeDestroyWAL()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLogTest.commit()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLogTest.rollback()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.WriteAheadLogTest.preallocate().3.beforeDestroyWAL()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.WriteAheadLogTest.open_ignores_rollback()"}], "spoonFilePath": "WriteAheadLogTest.java"}], "commitMessage": "WAL: change empty commit handling, fix #634\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-11-25 13:48:10"}], "created": "2015-11-23 16:02:25"}, {"labels": ["bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/625", "title": "java.lang.IndexOutOfBoundsException when trying to get object from mapdb", "closed": "2016-02-14 17:10:41", "commitsDetails": [], "commits": {}, "ttf": 88.00027777777778, "created": "2015-11-18 00:24:23", "user": "suyogkotecha", "body": "Hello there,\nWe at Yahoo, are using mapdb to store events and read them when the thread is idle. But we are getting following exception. We are unable to find out the real cause.\nAny pointer would be useful.\n\nThanks,\nSuyog\n\n```\nNov 17, 2015 11:54:24 PM com.google.common.util.concurrent.ServiceManager$ServiceListener failed\nSEVERE: Service AdsEventService [FAILED] has failed in the RUNNING state.\njava.lang.IndexOutOfBoundsException\n        at java.nio.Buffer.checkIndex(Buffer.java:540)\n        at java.nio.HeapByteBuffer.get(HeapByteBuffer.java:139)\n        at org.mapdb.DataInput2.readUnsignedByte(DataInput2.java:74)\n        at org.mapdb.DataInput2.read(DataInput2.java:136)\n        at java.io.InputStream.read(InputStream.java:179)\n        at java.io.ObjectInputStream$PeekInputStream.read(ObjectInputStream.java:2320)\n        at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2333)\n        at java.io.ObjectInputStream$BlockDataInputStream.readUTFBody(ObjectInputStream.java:3074)\n        at java.io.ObjectInputStream$BlockDataInputStream.readUTF(ObjectInputStream.java:2874)\n        at java.io.ObjectInputStream.readString(ObjectInputStream.java:1639)\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342)\n        at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000)\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924)\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)\n        at com.yahoo.ads.targeting.dot.action.SerializerActionState.deserialize(SerializerActionState.java:27)\n        at com.yahoo.ads.targeting.dot.action.SerializerActionState.deserialize(SerializerActionState.java:14)\n        at org.mapdb.Queues$SimpleQueue$NodeSerializer.deserialize(Queues.java:69)\n        at org.mapdb.Queues$SimpleQueue$NodeSerializer.deserialize(Queues.java:52)\n        at org.mapdb.Store.deserialize(Store.java:297)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:486)\n        at org.mapdb.StoreWAL.get2(StoreWAL.java:336)\n        at org.mapdb.StoreWAL.get(StoreWAL.java:320)\n        at org.mapdb.Caches$HashTable.get(Caches.java:246)\n        at org.mapdb.Queues$SimpleQueue.poll(Queues.java:130)\n        at com.yahoo.ads.targeting.dot.AdsEventService.processIntervalTasks(AdsEventService.java:243)\n        at com.yahoo.ads.targeting.dot.AdsEventService.runOneIteration(AdsEventService.java:231)\n        at com.yahoo.ads.targeting.dot.AdsEventService.run(AdsEventService.java:215)\n        at com.google.common.util.concurrent.AbstractExecutionThreadService$1$2.run(AbstractExecutionThreadService.java:60)\n        at com.google.common.util.concurrent.Callables$3.run(Callables.java:95)\n        at java.lang.Thread.run(Thread.java:745)\n\nException in thread \"AdsEventService\" java.lang.IndexOutOfBoundsException\n        at java.nio.Buffer.checkIndex(Buffer.java:540)\n        at java.nio.HeapByteBuffer.get(HeapByteBuffer.java:139)\n        at org.mapdb.DataInput2.readUnsignedByte(DataInput2.java:74)\n        at org.mapdb.DataInput2.read(DataInput2.java:136)\n        at java.io.InputStream.read(InputStream.java:179)\n        at java.io.ObjectInputStream$PeekInputStream.read(ObjectInputStream.java:2320)\n        at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2333)\n        at java.io.ObjectInputStream$BlockDataInputStream.readUTFBody(ObjectInputStream.java:3074)\n        at java.io.ObjectInputStream$BlockDataInputStream.readUTF(ObjectInputStream.java:2874)\n        at java.io.ObjectInputStream.readString(ObjectInputStream.java:1639)\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342)\n        at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000)\n        at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924)\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)\n        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)\n        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)\n        at com.yahoo.ads.targeting.dot.action.SerializerActionState.deserialize(SerializerActionState.java:27)\n        at com.yahoo.ads.targeting.dot.action.SerializerActionState.deserialize(SerializerActionState.java:14)\n        at org.mapdb.Queues$SimpleQueue$NodeSerializer.deserialize(Queues.java:69)\n        at org.mapdb.Queues$SimpleQueue$NodeSerializer.deserialize(Queues.java:52)\n        at org.mapdb.Store.deserialize(Store.java:297)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:486)\n        at org.mapdb.StoreWAL.get2(StoreWAL.java:336)\n        at org.mapdb.StoreWAL.get(StoreWAL.java:320)\n        at org.mapdb.Caches$HashTable.get(Caches.java:246)\n        at org.mapdb.Queues$SimpleQueue.poll(Queues.java:130)\n        at com.yahoo.ads.targeting.dot.AdsEventService.processIntervalTasks(AdsEventService.java:243)\n        at com.yahoo.ads.targeting.dot.AdsEventService.runOneIteration(AdsEventService.java:231)\n        at com.yahoo.ads.targeting.dot.AdsEventService.run(AdsEventService.java:215)\n        at com.google.common.util.concurrent.AbstractExecutionThreadService$1$2.run(AbstractExecutionThreadService.java:60)\n        at com.google.common.util.concurrent.Callables$3.run(Callables.java:95)\n        at java.lang.Thread.run(Thread.java:745)\n```\n"}, {"labels": ["2.0", "bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/621", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"2f8711e37147e9e9f2362361077e5aa68a091bad": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 103.00027777777778, "user": "dmk23", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "I am creating temporary maps using `DBMaker.tempTreeMap()`. According to the intent of DBMaker code the files are supposed to be removed after DB close or JVM shutdown. However after a shutdown using `System.exit(0)` the files still remain in the temp directory.\n\nAdditionally, I'd like to have ability to customize the temp file naming. Including the revealing prefix `mapdb` into the file name may not always be appropriate in some environments.\n\nThe problem was found in 2.0-beta8. Related issue: https://github.com/jankotek/mapdb/issues/120\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 0, "MOV": 0.0}, "title": "temp DB files not deleted after JVM shutdown", "statsSkippedReason": "", "closed": "2016-02-14 17:01:42", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-12-18 00:40:03", "commitHash": "2f8711e37147e9e9f2362361077e5aa68a091bad", "commitParents": ["b71905ee72ca692a1b3092807755917ac955a0f0", "f01ad72fc85a030e0f2eb36a3e7c30c3034378a4"], "commitGHEventType": "referenced", "nameRev": "2f8711e37147e9e9f2362361077e5aa68a091bad tags/mapdb-2.0-beta13~11", "commitGitStats": [{"insertions": 112, "lines": 112, "filePath": "src/main/java/org/mapdb/Engine.java", "deletions": 0}, {"insertions": 0, "lines": 9, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 9}, {"insertions": 3, "lines": 3, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.Maker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DeleteFileEngine"}], "spoonFilePath": "Engine.java"}], "commitMessage": "Merge pull request #649 from sysoev-a/i621\n\nfix for #621. Use special engine, which removes file on close.", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-12-18 00:40:03"}], "created": "2015-11-02 22:13:55"}, {"labels": ["2.0", "bug"], "filteredCommits": ["6028fbeae5f7c65cd35c64146fb721f90c809555", "994347510bee6ca2d8b18eb71d0a490b48773f03", "4304bce91b03ce18dba583413ac5cc9a6f97a0f3"], "url": "https://github.com/jankotek/mapdb/issues/614", "gitStatsSummary": {"insertions": 6, "gitFilesChange": 1, "lines": 10, "deletions": 4}, "numCommits": 1, "commits": {"994347510bee6ca2d8b18eb71d0a490b48773f03": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "6028fbeae5f7c65cd35c64146fb721f90c809555": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "4304bce91b03ce18dba583413ac5cc9a6f97a0f3": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 9.000277777777777, "user": "Nashatyrev", "changesInPackagesSPOON": ["org.mapdb.Volume.RandomAccessFileVol.hash(long,long,long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The following code hangs after 1 or 2 commits on Win7 (mapDB beta-8):\n\n```\n        File dbFile = new File(\"test-db/test\");\n        dbFile.getParentFile().mkdirs();\n\n        DBMaker.Maker dbMaker = DBMaker.fileDB(dbFile)\n                .closeOnJvmShutdown();\n        DB db = dbMaker.make();\n\n        HTreeMap<Object, Object> nodeStats = db.hashMapCreate(\"nodeStats\").makeOrGet();\n\n        int cnt = 0;\n        while (true) {\n            for (int i = 0; i < 10000; i++) {\n                int[] data = new int[1000];\n                data[0] = cnt;\n                nodeStats.put(i, data);\n            }\n            db.commit();\n            System.out.println(\"Comitted.\");\n            cnt++;\n        }\n```\n\nAfter changing `new int[1000]` to `new int[200]` works fine.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 4, "TOT": 7, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 1}, "title": "Hang on commit()", "statsSkippedReason": "", "closed": "2015-11-01 11:35:27", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-10-27 00:34:10", "commitHash": "994347510bee6ca2d8b18eb71d0a490b48773f03", "commitParents": ["e1994b499082f7540359cbd10b761df8a87a7c5f"], "commitGHEventType": "referenced", "nameRev": "994347510bee6ca2d8b18eb71d0a490b48773f03 tags/mapdb-2.0-beta9~6", "commitGitStats": [{"insertions": 24, "lines": 24, "filePath": "src/test/java/org/mapdb/issues/IssuesTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.IssuesTest.issue614()"}], "spoonFilePath": "IssuesTest.java"}], "commitMessage": "Issue #614: add test case\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-10-27 00:34:10"}, {"commitUser": "jankotek", "commitDateTime": "2015-10-27 00:54:54", "commitHash": "6028fbeae5f7c65cd35c64146fb721f90c809555", "commitParents": ["994347510bee6ca2d8b18eb71d0a490b48773f03"], "commitGHEventType": "referenced", "nameRev": "6028fbeae5f7c65cd35c64146fb721f90c809555 tags/mapdb-2.0-beta9~5", "commitGitStats": [{"insertions": 6, "lines": 10, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 4, "TOT": 7, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.hash(long,long,long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Issue #614: improve RAF.hash performance\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-10-27 00:54:54"}, {"commitUser": "jankotek", "commitDateTime": "2015-10-27 00:58:13", "commitHash": "4304bce91b03ce18dba583413ac5cc9a6f97a0f3", "commitParents": ["6028fbeae5f7c65cd35c64146fb721f90c809555"], "commitGHEventType": "referenced", "nameRev": "4304bce91b03ce18dba583413ac5cc9a6f97a0f3 tags/mapdb-2.0-beta9~4", "commitGitStats": [{"insertions": 0, "lines": 23, "filePath": "src/test/java/org/mapdb/issues/IssuesTest.java", "deletions": 23}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.issues.IssuesTest.issue614()"}], "spoonFilePath": "IssuesTest.java"}], "commitMessage": "Issue #614: disable test case\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-10-27 00:58:13"}], "created": "2015-10-22 14:04:14"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/610", "title": "nulls in composite keys cause DB corruption", "closed": "2016-02-14 11:33:40", "commitsDetails": [], "commits": {}, "ttf": 118.00027777777778, "created": "2015-10-19 08:20:25", "user": "dmk23", "body": "I have some code using BTreeMap with composite keys and by mistake used a null in the object array key. The write fails when actual serialization is attempted on DB shutdown:\n\n```\nException in thread \"MapDB shutdown hook\" java.lang.NullPointerException\n    at org.mapdb.DataIO$DataOutputByteArray.writeUTF(DataIO.java:1070)\n    at org.mapdb.Serializer$3.serialize(Serializer.java:111)\n    at org.mapdb.Serializer$3.serialize(Serializer.java:108)\n    at org.mapdb.BTreeKeySerializer$ArrayKeySerializer.serialize(BTreeKeySerializer.java:678)\n    at org.mapdb.BTreeKeySerializer$ArrayKeySerializer.serialize(BTreeKeySerializer.java:631)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:814)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:753)\n    at org.mapdb.Store.serialize(Store.java:304)\n    at org.mapdb.StoreCached.flushWriteCacheSegment(StoreCached.java:388)\n    at org.mapdb.StoreCached.flushWriteCache(StoreCached.java:364)\n    at org.mapdb.StoreCached.flush(StoreCached.java:320)\n    at org.mapdb.StoreDirect.close(StoreDirect.java:1071)\n    at org.mapdb.Engine$CloseOnJVMShutdown.close(Engine.java:473)\n    at org.mapdb.Engine$CloseOnJVMShutdown$1.run(Engine.java:426)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nThe problem is when the process is restarted using the same DB I try to run a diagnostic iterator on the full map to display the contents. Unfortunately this causes this hard failure -\n\n```\njava.lang.NullPointerException\n    at org.mapdb.BTreeMap.<init>(BTreeMap.java:976)\n    at org.mapdb.DB.treeMap(DB.java:1465)\n    at org.mapdb.DB$BTreeMapMaker.makeOrGet(DB.java:1224)\n        ... application code ...\n```\n\nAccidental use of nulls in keys should fail gracefully, rather than corrupt databases. It is quite disturbing that a software error in the client app could cause the loss of data...\n\nAdditionally, another set of errors could be introduced if composite keys are not validated when first used and the actual exception appears on flush/close/shutdown. There ought to be an option to enforce validation of keys whenever they are used (yes, at a performance cost, but for some applications that may still be valuable - especially in the test/debug mode).\n\nThis issue was observed in **2.0-beta8**\n"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/609", "title": "Problem with Pump.backup", "closed": "2016-02-13 17:49:57", "commitsDetails": [], "commits": {}, "ttf": 117.00027777777778, "created": "2015-10-18 20:00:52", "user": "chanderr2", "body": "While taking a backup, the entire content is not getting backed-up. \nThe following code fragment results in a) the backup not taking a full snapshot of committed data, and b) a nullpointerexception after the restore because there is no data to restore.\n\n```\n    File dbFile = new File(\"./mapdb.dat\");\n    DB db = DBMaker.fileDB(dbFile)\n            .make();\n\n    ConcurrentMap<Long,String> map = db.hashMap(\"collectionName\");\n    for(long i = 0; i < 2; i++)\n            map.put(i, \"Num_\" + i);\n    db.commit();\n\n    File backupFile = new File(\"./backup.dat\");\n    Pump.backupFull(db, new FileOutputStream(backupFile));\n    db.close();\n\n    DB db2 = Pump.backupFullRestore(\n            DBMaker.memoryDB().transactionDisable(),\n            new FileInputStream(backupFile));\n    ConcurrentMap<Long,String> m = db2.hashMap(\"collectionName\");\n    System.out.println(m);\n```\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/607", "title": "Deadlock if commit is called inside a MapListener", "closed": "2016-02-13 17:51:08", "commitsDetails": [], "commits": {}, "ttf": 119.00027777777778, "created": "2015-10-17 06:23:10", "user": "atoulme", "body": "I have a case where a record is committed, upon which a MapListener triggers, and runs code which ends up modifying the same cache. I now need to commit the data again. All this interaction should take place in the same thread to avoid race conditions and make it possible to run transaction replays.\n\nWith that in mind, it looks like the MapListener should have ways to run either before commit acquires locks, or after commit has released locks. I'm more interested in the latter case.\n\nHere is the test case I use to reproduce, I'll take a stab at figuring out a solution.\n\n``` java\n    @Test\n    public void testListenerDeadlock() {\n        final DB db = DBMaker.memoryDB().make();\n        final HTreeMap map = db.hashMap(\"test\");\n        map.modificationListenerAdd(new MapListener() {\n            @Override\n            public void update(Object key, Object oldVal, Object newVal) {\n                if (\"foo\".equals(newVal)) {\n                    map.put(\"xyz\", \"bar\");\n                }\n                db.commit();\n            }\n        });\n        map.put(\"abc\", \"foo\");\n    }\n```\n"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/602", "title": "NSE: Could not serialize unknown object: RecordSerializerN", "closed": "2016-02-13 17:54:04", "commitsDetails": [], "commits": {}, "ttf": 120.00027777777778, "created": "2015-10-16 10:10:03", "user": "jandam", "body": "RecordSerializerN is my serializable class.\n\n```\nclass RecordSerializerN extends Serializer<RecordN> implements Serializable {\n    private static final long serialVersionUID = -7712313262727669450L;\n...\n}\n```\n\nMapDB code:\n\n```\nDB dbNodeParam2 = DBMaker\n                        .fileDB(new File(\"/tmp/pokus0\"))\n                        .mmapFileEnableIfSupported()\n                        .transactionDisable()\n                        .make();\n                DB.BTreeMapMaker mm = dbNodeParam2.treeMapCreate(nameSpatialN)\n                        .keySerializer(BTreeKeySerializer.LONG)\n                        .valueSerializer(new RecordSerializerN())\n                        .nodeSize(120)\n                        .counterEnable();\n\n                Iterator<Fun.Pair> sn = (Iterator)builderN.build(progressProvider, true);\n                Pump.archiveTreeMap(sn, \"/tmp/pokus1\", Volume.MappedFileVol.FACTORY, mm);\n```\n\nException:\n\n```\njava.io.IOError: java.io.NotSerializableException: Could not serialize unknown object: com.crcdata.addin.map3dww.layer.osm.RecordSerializerN\n    at org.mapdb.Store.serialize(Store.java:388)\n    at org.mapdb.StoreArchive.put(StoreArchive.java:146)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:496)\n    at org.mapdb.StoreArchive.rewriteNamedCatalog(StoreArchive.java:193)\n    at org.mapdb.Pump.archiveTreeMap(Pump.java:964)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.io.NotSerializableException: Could not serialize unknown object: RecordSerializerN\n    at org.mapdb.SerializerBase.serializeUnknownObject(SerializerBase.java:1801)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:1000)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:946)\n    at org.mapdb.Serializer$35.serialize(Serializer.java:2237)\n    at org.mapdb.Serializer.valueArraySerialize(Serializer.java:2317)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:817)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:753)\n    at org.mapdb.Store.serialize(Store.java:309)\n    ... 13 more\n```\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["cc5e87828e5908f3d425f48023b0908d7f122b62"], "url": "https://github.com/jankotek/mapdb/issues/588", "gitStatsSummary": {"insertions": 5, "gitFilesChange": 1, "lines": 5, "deletions": 0}, "numCommits": 1, "commits": {"cc5e87828e5908f3d425f48023b0908d7f122b62": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 141.00027777777777, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.expirePurgeSegment(int,long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Looks like some sort of hashing issue.\n\nFrom mailing list:\n\n```\nDISK_DB = DBMaker.fileDB(file).cacheSize(65_536).make()\nDISK_DB.hashMapCreate(\"DISK\").keySerializer(Serializer.UUID)\n        .valueSerializer(new \nMyClass.CustomSerializer()).expireAfterWrite(6, TimeUnit.HOURS).makeOrGet()\n```\n\nI do have multiple threads but not tons of stuff going on.\n\n```\n! java.lang.NullPointerException: null\n! at org.mapdb.HTreeMap.expirePurgeSegment(HTreeMap.java:2095) \n~[bodyguard-0.0.287.jar:na]\n! at org.mapdb.HTreeMap.expirePurge(HTreeMap.java:2038) \n~[bodyguard-0.0.287.jar:na]\n! at org.mapdb.HTreeMap.put(HTreeMap.java:893) ~[bodyguard-0.0.287.jar:na]\n```\n\nAfter a will change exceptions to:\n\n```\n! org.mapdb.DBException$DataCorruption: inconsistent hash\n! at org.mapdb.HTreeMap.expirePurgeSegment(HTreeMap.java:2096) \n~[bodyguard-0.0.287.jar:na]\n! at org.mapdb.HTreeMap.expirePurge(HTreeMap.java:2038) \n~[bodyguard-0.0.287.jar:na]\n! at org.mapdb.HTreeMap.put(HTreeMap.java:893) ~[bodyguard-0.0.287.jar:na]\n```\n\nRestart does not recover it.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "NPE in HTreeMap expiration", "statsSkippedReason": "", "closed": "2016-02-13 17:54:45", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-25 15:46:09", "commitHash": "cc5e87828e5908f3d425f48023b0908d7f122b62", "commitParents": ["1b07e3a61a35b0b7cef7b622be472b8e2c4c96c2"], "commitGHEventType": "referenced", "nameRev": "cc5e87828e5908f3d425f48023b0908d7f122b62 tags/mapdb-2.0-beta8~5", "commitGitStats": [{"insertions": 5, "lines": 5, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.expirePurgeSegment(int,long)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "HTreeMap: add workaround for NPE in expiration, #588\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-25 15:46:09"}], "created": "2015-09-25 12:45:34"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/587", "title": "IndexOutOfBoundsException in HTreeMap", "closed": "2015-11-01 11:36:23", "commitsDetails": [], "commits": {}, "ttf": 41.000277777777775, "created": "2015-09-21 07:03:10", "user": "mkalinin", "body": "hey there,\nwe have faced with following problem\n\n```\njava.lang.IndexOutOfBoundsException: Index: 6, Size: 6\n  at java.util.ArrayList.rangeCheck(ArrayList.java:653) ~[na:1.8.0_60]\n  at java.util.ArrayList.get(ArrayList.java:429) ~[na:1.8.0_60]\n  at java.util.Collections$SynchronizedList.get(Collections.java:2417) ~[na:1.8.0_60]\n  at org.mapdb.StoreWAL.loadLongStackPage(StoreWAL.java:552) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.StoreCached.longStackTake(StoreCached.java:176) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.StoreDirect.freeRecidTake(StoreDirect.java:1657) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.StoreDirect.preallocate(StoreDirect.java:594) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.StoreCached.put(StoreCached.java:434) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.Engine$CloseOnJVMShutdown.put(Engine.java:448) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.HTreeMap.putInner(HTreeMap.java:1007) ~[mapdb-2.0-beta6.jar:na]\n  at org.mapdb.HTreeMap.put(HTreeMap.java:884) ~[mapdb-2.0-beta6.jar:na]\n  at org.ethereum.db.BlockQueueImpl.add(BlockQueueImpl.java:130) ~[ethereumj-core-1.0.0-stage-SNAPSHOT.jar:na]\n  at org.ethereum.net.eth.sync.SyncQueue.produceQueue(SyncQueue.java:104) [ethereumj-core-1.0.0-stage-SNAPSHOT.jar:na]\n  at org.ethereum.net.eth.sync.SyncQueue.access$000(SyncQueue.java:33) [ethereumj-core-1.0.0-stage-SNAPSHOT.jar:na]\n  at org.ethereum.net.eth.sync.SyncQueue$1.run(SyncQueue.java:78) [ethereumj-core-1.0.0-stage-SNAPSHOT.jar:na]\n  at java.lang.Thread.run(Thread.java:745) [na:1.8.0_60]\n```\n\nIt arises each time after about `10-12` hours of instant work with the structure. We use transactional database and create `HTreeMap` with following code:\n\n```\ndb.hashMapCreate(STORE_NAME)\n    .keySerializer(Serializer.LONG)\n    .valueSerializer(Serializers.BLOCK_WRAPPER)\n    .makeOrGet();\n```\n\nWhere `Serializers.BLOCK_WRAPPER` is a custom one based on `BYTE_ARRAY` serializer. \nMapDB version is `2.0-beta6`.\n\nDo you have any ideas about this problem? I can provide you with any info required to discover the reason, just let me know if I can do anything.\n\nThanks in advance\n"}, {"labels": ["2.0", "bug", "wontfix"], "filteredCommits": ["e0e9e773a8924285c658a018cec380556ff10515"], "url": "https://github.com/jankotek/mapdb/issues/583", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"e0e9e773a8924285c658a018cec380556ff10515": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "2fb0d689c41bf9c6bc9ffd85127b18b4b391efde": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 150.00027777777777, "user": "yuval-rikover", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.get(java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There's a basic functionality bug when using an in memory map linked to a disk map:\n\nWhen _getting()_ a key's value from memory (it **IS** in the map, as is evident by the _containsKey()_ call),\na null value is returned.\n\n``` java\nSet<Integer> inMemoryKeys = memoryMap.keySet();\nfor (Integer inMemoryKey : inMemoryKeys) {\n       assertThat(memoryMap.containsKey(inMemoryKey), is(true));\n       assertThat(memoryMap.get(inMemoryKey), nullValue()); // BUG\n}\n```\n\nOnly way to retrieve the value is calling _remove()_, which returns the value and expires it to the disk map.\n\nThe below test reproduces the problem (with a custom value serializer to makes sure values were serialized).\n\n``` java\nimport org.apache.commons.io.FileUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\nimport org.mapdb.HTreeMap;\nimport org.mapdb.Serializer;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.assertThat;\n\npublic class MemoryToDiskBugTest {\n\n    public static final String MAP = \"map\";\n\n    private File dbFile;\n    private Path dbDirectory;\n\n    @Before\n    public void createTempFolder() throws IOException {\n        dbDirectory = Files.createTempDirectory(\"disk-based-map\");\n        dbFile = new File(dbDirectory.toFile(), \"db\");\n    }\n\n    @After\n    public void deleteTempFolder() {\n        FileUtils.deleteQuietly(dbDirectory.toFile());\n    }\n\n    @Test\n    public void testGettingFromMemoryMapReturnsNull() {\n        DB diskDb = DBMaker.fileDB(dbFile)\n                .fileMmapEnable()\n                .transactionDisable()\n                .closeOnJvmShutdown()\n                .deleteFilesAfterClose()\n                .make();\n\n        DB memoryDb = DBMaker.memoryDB()\n                .transactionDisable()\n                .make();\n\n        AtomicInteger serializerCalls = new AtomicInteger();\n\n        HTreeMap<Integer, Value> diskMap = diskDb.hashMapCreate(MAP)\n                .keySerializer(Serializer.INTEGER)\n                .valueSerializer(new ValueSerializer(serializerCalls))\n                .make();\n\n        HTreeMap<Integer, Value> memoryMap = memoryDb.hashMapCreate(MAP)\n                .expireMaxSize(1)\n                .expireOverflow(diskMap, true)\n                .make();\n\n\n        for (int i = 0; i < 17; i++) { // 17 is minimal for disk overflow (even with cacheSize=1)\n            memoryMap.put(i, new Value(i));\n        }\n        assertThat(\"Expecting overflow to disk, but no serialization happened\", serializerCalls.get(), greaterThan(0));\n\n\n        Set<Integer> inMemoryKeys = memoryMap.keySet();\n        for (Integer inMemoryKey : inMemoryKeys) {\n            assertThat(memoryMap.containsKey(inMemoryKey), is(true));\n            assertThat(memoryMap.get(inMemoryKey), nullValue()); // BUG\n        }\n\n        Set<Integer> inDiskKeys = diskMap.keySet();\n        for (Integer inDiskKey : inDiskKeys) {\n            assertThat(diskMap.containsKey(inDiskKey), is(true));\n            assertThat(diskMap.get(inDiskKey), notNullValue());\n        }\n\n        memoryMap.close();\n        diskMap.close();\n    }\n\n\n    private static class Value implements Serializable {\n        private final int value;\n\n        private Value(int value) {\n            this.value = value;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n    }\n\n\n    private static class ValueSerializer extends Serializer<Value> {\n\n        private final AtomicInteger called;\n\n        private ValueSerializer(AtomicInteger called) {\n            this.called = called;\n        }\n\n        @Override\n        public void serialize(DataOutput out, Value value) throws IOException {\n            called.incrementAndGet();\n            out.writeInt(value.value);\n        }\n\n        @Override\n        public Value deserialize(DataInput in, int available) throws IOException {\n            return new Value(in.readInt());\n        }\n\n        @Override\n        public int fixedSize() {\n            return 4;\n        }\n    }\n\n}\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Memory map with Overflow returns null values", "statsSkippedReason": "", "closed": "2016-02-14 11:29:10", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-30 13:01:17", "commitHash": "e0e9e773a8924285c658a018cec380556ff10515", "commitParents": ["39b4ea3b1f720aa1cdbf2eb2880a749b06cfbf13"], "commitGHEventType": "closed", "nameRev": "e0e9e773a8924285c658a018cec380556ff10515 tags/mapdb-2.0-beta9~56", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 1}, {"insertions": 122, "lines": 122, "filePath": "src/test/java/org/mapdb/issues/Issue583Test.java", "deletions": 0}, {"insertions": 17, "lines": 17, "filePath": "src/test/java/org/mapdb/HTreeMap2Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.valueCreator()"}], "spoonFilePath": "HTreeMap2Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue583Test"}], "spoonFilePath": "Issue583Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.get(java.lang.Object)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "HTreeMap: valueCreator was used, even if value existed. Fix #583\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-30 13:01:17"}, {"commitUser": "jankotek", "commitDateTime": "2016-10-17 17:50:13", "commitHash": "2fb0d689c41bf9c6bc9ffd85127b18b4b391efde", "commitParents": ["e17380b40ad9594e6607cd0ed08deff792c930c1", "277b8a4832d67c25140971d2073e6a0cf9259e50"], "commitGHEventType": "referenced", "nameRev": "2fb0d689c41bf9c6bc9ffd85127b18b4b391efde remotes/origin/release-1.0", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.get(java.lang.Object)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Merge pull request #771 from ricardojlrufino/release-1.0\n\nHTreeMap. Fix #583 (for branch release-1.0 )", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-10-17 17:50:13"}], "created": "2015-09-16 13:10:37"}, {"labels": ["bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/582", "title": "NullPointerException in BTreeKeySerializer.STRING on 1.0.8", "closed": "2016-02-14 11:22:30", "commitsDetails": [], "commits": {}, "ttf": 151.00027777777777, "created": "2015-09-15 16:11:55", "user": "mattwigway", "body": "I'm seeing NullPointerExceptions in BTreeKeySerializer.STRING on MapDB 1.0.8, and I've written [a trivial test case to reproduce](https://gist.github.com/mattwigway/230b9589be891a95e7eb):\n\n```\nMatthews-MacBook-Pro:mapdb-issue matthewc$ javac -cp ~/.m2/repository/org/mapdb/mapdb/1.0.8/mapdb-1.0.8.jar StringNPE.java \nNote: StringNPE.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\nMatthews-MacBook-Pro:mapdb-issue matthewc$ java -cp ~/.m2/repository/org/mapdb/mapdb/1.0.8/mapdb-1.0.8.jar:. StringNPE\nException in thread \"main\" java.lang.NullPointerException\n    at org.mapdb.BTreeKeySerializer$3.serialize(BTreeKeySerializer.java:183)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:385)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:288)\n    at org.mapdb.Store.serialize(Store.java:154)\n    at org.mapdb.StoreWAL.put(StoreWAL.java:200)\n    at org.mapdb.Caches$HashTable.put(Caches.java:216)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:470)\n    at org.mapdb.DB.createTreeMap(DB.java:875)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:661)\n    at StringNPE.main(StringNPE.java:29)\n```\n\nAt first bluster, it looks like `keys[start]` in the serialize function is null. Some of the serializers iterate starting at `start + 1` and some (including the string serializer) start at `start`.\n\nThis does appear to be an issue with the string serializer as removing the line that uses the string serializer makes the problem go away.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["2063fb1f656e607b4cef579cd4b4d749bd813b40"], "url": "https://github.com/jankotek/mapdb/issues/581", "gitStatsSummary": {"insertions": 5, "gitFilesChange": 1, "lines": 10, "deletions": 5}, "numCommits": 1, "commits": {"2063fb1f656e607b4cef579cd4b4d749bd813b40": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 1.0002777777777778, "user": "pstutz", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.get(java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi Jan,\n\nI'm trying to use MapDB 2.0-beta6 for my project, but ran into a concurrency issue. The Scala code below inserts entries in parallel into an in-memory B-tree with `put` and immediately checks that an entry with that key exists with `containsKey`. It crashes with errors like `assertion failed: Key 52500 of entry 510 that was just added is not contained.`:\n\n``` scala\nobject MapDbConcurrencyIssue extends App {\n  val db = org.mapdb.DBMaker.memoryDB.make\n  val map = db.treeMap[Int, String](\"int2String\")\n  val entries = 1000000\n  val strings = (1 to entries).map(_.toString)\n  strings.par.foreach { s =>\n    val id = s.hashCode\n    map.put(id, s)\n    assert(map.containsKey(id), s\"Key $id of entry $s that was just added is not contained.\")\n  }\n}\n```\n\nThe same code without using the parallel collection runs fine. The documentation says that [`All classes in MapDB are thread-safe`](http://www.mapdb.org/doc/concurrency.html). Do I have to configure something differently or is this a bug?\n\nThank you very much for your help,\nPhilip\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 7, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 6}, "title": "Concurrency issue with B-tree `containsKey` right after parallel `put`", "statsSkippedReason": "", "closed": "2015-09-16 15:04:29", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-16 18:04:19", "commitHash": "2063fb1f656e607b4cef579cd4b4d749bd813b40", "commitParents": ["6024b7facfb4b4de6c39523da3241d253f166232"], "commitGHEventType": "closed", "nameRev": "2063fb1f656e607b4cef579cd4b4d749bd813b40 tags/mapdb-2.0-beta7~1", "commitGitStats": [{"insertions": 36, "lines": 36, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 0}, {"insertions": 12, "lines": 12, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 0}, {"insertions": 5, "lines": 10, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 7, "DEL": 0, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.BTreeMap.get(java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue581()"}], "spoonFilePath": "IssuesTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.findChildren2_next_link()"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "BTreeMap: get did not followed link, was broken under concurrent update. Fix #581\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-16 18:04:19"}], "created": "2015-09-14 22:15:08"}, {"labels": ["2.0", "bug"], "filteredCommits": ["5b14d76ac10326ad73c98aaacbfcf2d41bd4a187"], "url": "https://github.com/jankotek/mapdb/issues/572", "gitStatsSummary": {"insertions": 9, "gitFilesChange": 1, "lines": 9, "deletions": 0}, "numCommits": 1, "commits": {"5b14d76ac10326ad73c98aaacbfcf2d41bd4a187": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 27.00027777777778, "user": "gpeche", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Several JRockit implementations of Java 6 have a caching bug where `ObjectStreamClass.lookup(...)` may return a non-null value when invoked with a non-`Serializable` class. This makes `SerializerPojo` throw a NPE when looping in `makeFieldsForClass(...)`, as (according to the specification) the loop expects `ObjectStreamClass.lookup(Object.class) == null`. Changing the two invocations to `ObjectStreamClass.lookup(...)` in that method to invocations to the following:\n\n``` java\n    private static ObjectStreamClass fixForLookup(Class<?> c) {\n        ObjectStreamClass result = null;\n        if (Serializable.class.isAssignableFrom(c)) {\n            result = ObjectStreamClass.lookup(c);\n        }\n        return result;\n    }\n```\n\nseems to \"sort-of solve\" the issue (though I suspect the stream format will not be spec-compliant). I have tested this with JRockit R28.2.7, which is the latest publicly available JRockit release.\n\nIdeally this should be corrected in JRockit itself and not worked around in MapDB. The problem is that JRockit has been discontinued after Java 6, and getting patches for it is not straightforward at all. Using MapDB in Jrockit is very uncomfortable without the \"fix\": either you restrict yourself to types with built-in serializer implementations in MapDB, or you provide custom serializers for all your POJOs. You cannot rely on `SerializerPojo` because of this problem with `ObjectStreamClass.lookup(...)`.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "NullPointerException in SerializerPojo when serializing POJOs on JRockit", "statsSkippedReason": "", "closed": "2015-09-30 10:13:12", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-30 13:17:30", "commitHash": "5b14d76ac10326ad73c98aaacbfcf2d41bd4a187", "commitParents": ["e0e9e773a8924285c658a018cec380556ff10515"], "commitGHEventType": "referenced", "nameRev": "5b14d76ac10326ad73c98aaacbfcf2d41bd4a187 tags/mapdb-2.0-beta9~55", "commitGitStats": [{"insertions": 9, "lines": 9, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo"}], "spoonFilePath": "SerializerPojo.java"}], "commitMessage": "SerializerPojo: Log warning for JRocket JVM. See #572\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-30 13:17:30"}], "created": "2015-09-02 17:03:36"}, {"labels": ["2.0", "bug"], "filteredCommits": ["39b4ea3b1f720aa1cdbf2eb2880a749b06cfbf13"], "url": "https://github.com/jankotek/mapdb/issues/571", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"39b4ea3b1f720aa1cdbf2eb2880a749b06cfbf13": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 27.00027777777778, "user": "gpeche", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "Creating a `TreeMap` in a transaction and then inserting POJOs in another transaction fails in a caching DB when using MapDB 2.0-beta6. When the `Map` is created, MapDB stores a `SerializerPojo` in the catalog, which internally contains a reference to the `Engine` used by the current transaction. When that transaction is completed, the `Engine` is closed. If we retrieve the `Map` from another transaction, MapDB tries to fetch the `SerializerPojo` from the catalog, but the cache returns a stale entry that references the closed `Engine` associated to the first transaction.\n\nIf MapDB then tries to use that `SerializerPojo` to serialize a POJO, the closed `Engine` throws `IllegalAccessError`. Primitive types seem to work ok. If caching is disabled, the catalog is not cached and the returned `SerializerPojo` references the fresh `Engine` associated to the current transaction, so everything also works ok. If a custom serializer is used for the POJO, again everything works ok.\n\n The following JUnit test class reproduces the issue for me. \n\n``` java\npackage org.mapdb;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.commons.lang.SerializationUtils;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.io.Serializable;\n\nimport java.util.Map;\n\n/**\n *\n * @author gpeche\n */\npublic class MapDbBugTest {\n    // Dummy class for testing\n    public static class CustomValueClass implements Serializable {\n        private static final long serialVersionUID = 1L;\n    }\n\n    // Customs serializer for our dummy class. Must be Serializable so MapDB can store it in the catalog.\n    public static class CustomSerializer extends Serializer<CustomValueClass> implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public void serialize(DataOutput out, CustomValueClass value) throws IOException {\n            byte[] bs = SerializationUtils.serialize(value);\n            Serializer.BYTE_ARRAY.serialize(out, bs);\n        }\n\n        @Override\n        public CustomValueClass deserialize(DataInput in, int available) throws IOException {\n            byte[] bs = Serializer.BYTE_ARRAY.deserialize(in, available);\n            return (CustomValueClass) SerializationUtils.deserialize(bs);\n        }\n\n    }\n\n    private void performTest(DBMaker.Maker m, Object value) throws Exception {\n        performTest(m, value, null);\n    }\n\n    private void performTest(DBMaker.Maker m, Object value, Serializer<?> vs) throws Exception {\n        TxMaker maker = m.makeTxMaker();\n\n        final DB creationTrans = maker.makeTx();\n        final DB.BTreeMapMaker mapMaker = creationTrans.treeMapCreate(\"testIndex\");\n        if (vs != null) {\n            mapMaker.valueSerializer(vs);\n        }\n        mapMaker.make();\n        creationTrans.commit();\n        creationTrans.close();\n\n        final DB updateTrans1 = maker.makeTx();\n        Map map1 = updateTrans1.treeMap(\"testIndex\");\n        map1.put(\"testKey\", value);\n        try {\n            updateTrans1.commit();\n        } catch (IllegalAccessError err) {\n            err.printStackTrace();\n            throw err;\n        } finally {\n            if (!updateTrans1.isClosed()) {\n                updateTrans1.close();\n            }\n        }\n    }\n\n    @Test(expected = IllegalAccessError.class)\n    public void testCommitFailsDueToStaleEngineInCatalogValueSerializer1() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheHardRefEnable();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test(expected = IllegalAccessError.class)\n    public void testCommitFailsDueToStaleEngineInCatalogValueSerializer2() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheSoftRefEnable();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test(expected = IllegalAccessError.class)\n    public void testCommitFailsDueToStaleEngineInCatalogValueSerializer3() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheWeakRefEnable();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test(expected = IllegalAccessError.class)\n    public void testCommitFailsDueToStaleEngineInCatalogValueSerializer4() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheLRUEnable();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test(expected = IllegalAccessError.class)\n    public void testCommitFailsDueToStaleEngineInCatalogValueSerializer5() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheHashTableEnable();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test\n    public void testCommitSucceedsWhenNoCachingUsedInCatalogValueSerializer() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB();\n        performTest(m, new CustomValueClass());\n    }\n\n    @Test\n    public void testCommitSucceedsWhenNotUsingCustomObjectsAsValues() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheHardRefEnable();\n        performTest(m, \"This value is not a custom object\");\n    }\n\n    @Test\n    public void testCommitSucceedsWhenUsingCustomValueSerializer() throws Exception {\n        final DBMaker.Maker m = DBMaker.memoryDB().cacheSoftRefEnable();\n        performTest(m, new CustomValueClass(), new CustomSerializer());\n    }\n}\n\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "\"IllegalAccessError: closed\" when serializing POJOs in a caching, transactional DB", "statsSkippedReason": "", "closed": "2015-09-30 09:22:45", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-30 12:22:34", "commitHash": "39b4ea3b1f720aa1cdbf2eb2880a749b06cfbf13", "commitParents": ["bf0cd39b606b67109aa7c8848750a62126231761"], "commitGHEventType": "closed", "nameRev": "39b4ea3b1f720aa1cdbf2eb2880a749b06cfbf13 tags/mapdb-2.0-beta9~57", "commitGitStats": [{"insertions": 182, "lines": 182, "filePath": "src/test/java/org/mapdb/issues/Issue571Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue571Test"}], "spoonFilePath": "Issue571Test.java"}], "commitMessage": "Add test case, fix #571\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-30 12:22:34"}], "created": "2015-09-02 16:38:24"}, {"labels": ["2.0", "bug"], "filteredCommits": ["0931ccab756037f45ea7237249e0c66e247204b5", "4f2fc75ae2e3b4a9324acf0a823d7cbd5a689e08"], "url": "https://github.com/jankotek/mapdb/issues/570", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 338, "deletions": 336}, "numCommits": 1, "commits": {"0931ccab756037f45ea7237249e0c66e247204b5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "4f2fc75ae2e3b4a9324acf0a823d7cbd5a689e08": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 7.000277777777778, "user": "theimpostor", "changesInPackagesSPOON": [], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "It seems that after calling db.compact() and close(), the database becomes corrupted such that new instances of the database fail on commit() with the following exception:\n\norg.mapdb.DBException$PointerChecksumBroken: Bit parity in file pointer is broken, data possibly corrupted.\n        at org.mapdb.DataIO.parity4Get(DataIO.java:1153)\n        at org.mapdb.StoreWAL.loadLongStackPage(StoreWAL.java:562)\n        at org.mapdb.StoreCached.longStackTake(StoreCached.java:176)\n        at org.mapdb.StoreDirect.freeDataTakeSingle(StoreDirect.java:814)\n        at org.mapdb.StoreCached.longStackNewPage(StoreCached.java:300)\n        at org.mapdb.StoreCached.longStackPut(StoreCached.java:133)\n        at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:772)\n        at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:740)\n        at org.mapdb.StoreDirect.update2(StoreDirect.java:412)\n        at org.mapdb.StoreCached.flushWriteCacheSegment(StoreCached.java:390)\n        at org.mapdb.StoreWAL.commit(StoreWAL.java:879)\n        at org.mapdb.DB.commit(DB.java:2597)\n        at mapdb.MapDbTest.main(MapDbTest.java:47)\n\nI am able to reproduce reliably on linux x86_64 and windows 64 bit with the following small app:\n\n``` java\nimport java.io.File;\nimport java.util.Map;\n\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\npublic class MapDbTest {\n\n    public static void main(String[] args) {\n        try {\n            while (true) {\n                DB db = DBMaker.fileDB(new File(\"dbFileName\"))\n                    .make();\n                System.err.format(\"Opened DB: %s%n\", db);\n                Map<String, String> map = db.hashMap(\"testMap\");\n                System.err.format(\"Opened Map, size: %d%n\", map.size());\n\n                for (int i = 0; i < 10; i++) {\n                    map.put(Long.toString(System.currentTimeMillis()), \"someval\");\n                    db.commit();\n                    System.err.format(\"db committed, Map size: %d%n\", map.size());\n                }\n\n                db.compact();\n                System.err.format(\"db %s compacted%n\", db);\n                db.close();\n                System.err.format(\"db %s closed%n\", db);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nWhich produces the following output:\n\n```\nOpened DB: org.mapdb.DB@3930015a\nOpened Map, size: 0\ndb committed, Map size: 1\ndb committed, Map size: 2\ndb committed, Map size: 3\ndb committed, Map size: 4\ndb committed, Map size: 5\ndb committed, Map size: 6\ndb committed, Map size: 7\ndb committed, Map size: 8\ndb committed, Map size: 9\ndb committed, Map size: 10\ndb org.mapdb.DB@3930015a compacted\ndb org.mapdb.DB@3930015a closed\nOpened DB: org.mapdb.DB@1fbc7afb\nOpened Map, size: 10\norg.mapdb.DBException$PointerChecksumBroken: Bit parity in file pointer is broken, data possibly corrupted.\n        at org.mapdb.DataIO.parity4Get(DataIO.java:1153)\n        at org.mapdb.StoreWAL.loadLongStackPage(StoreWAL.java:562)\n        at org.mapdb.StoreCached.longStackTake(StoreCached.java:176)\n        at org.mapdb.StoreDirect.freeDataTakeSingle(StoreDirect.java:814)\n        at org.mapdb.StoreCached.longStackNewPage(StoreCached.java:300)\n        at org.mapdb.StoreCached.longStackPut(StoreCached.java:133)\n        at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:772)\n        at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:740)\n        at org.mapdb.StoreDirect.update2(StoreDirect.java:412)\n        at org.mapdb.StoreCached.flushWriteCacheSegment(StoreCached.java:390)\n        at org.mapdb.StoreWAL.commit(StoreWAL.java:879)\n        at org.mapdb.DB.commit(DB.java:2597)\n        at mapdb.MapDbTest.main(MapDbTest.java:47)\n```\n\nApp works fine for many iterations if I comment out the call to db.compact().\n\nI am using 2.0-beta6.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 0, "MOV": 0.0}, "title": "Commit fails after database is compacted and re-opened", "statsSkippedReason": "", "closed": "2015-09-09 17:29:06", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-06 17:41:56", "commitHash": "0931ccab756037f45ea7237249e0c66e247204b5", "commitParents": ["0db6f55c4fd015a1b3a54c7163664d582a8a87d8"], "commitGHEventType": "referenced", "nameRev": "0931ccab756037f45ea7237249e0c66e247204b5 tags/mapdb-2.0-beta7~13", "commitGitStats": [{"insertions": 22, "lines": 22, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue570()"}], "spoonFilePath": "IssuesTest.java"}], "commitMessage": "Issue #570, add failing test case\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-06 17:41:56"}, {"commitUser": "jankotek", "commitDateTime": "2015-09-09 20:28:55", "commitHash": "4f2fc75ae2e3b4a9324acf0a823d7cbd5a689e08", "commitParents": ["d2271f6665f5ed372ff89f5ae73d087d16d8392e"], "commitGHEventType": "closed", "nameRev": "4f2fc75ae2e3b4a9324acf0a823d7cbd5a689e08 tags/mapdb-2.0-beta7~7", "commitGitStats": [{"insertions": 2, "lines": 338, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 336}, {"insertions": 15, "lines": 16, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix #570, compaction broken, remove compaction from StoreWAL\n", "spoonStatsSkippedReason": "tooManyChanges", "authoredDateTime": "2015-09-09 20:28:55"}], "created": "2015-09-01 18:03:24"}, {"labels": ["2.0", "bug"], "filteredCommits": ["05898e53f8fe113fb56710dd7240e3e096a22791"], "url": "https://github.com/jankotek/mapdb/issues/567", "gitStatsSummary": {"insertions": 5, "gitFilesChange": 1, "lines": 5, "deletions": 0}, "numCommits": 1, "commits": {"05898e53f8fe113fb56710dd7240e3e096a22791": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 4.000277777777778, "user": "Irkenev", "changesInPackagesSPOON": ["org.mapdb.DBMaker.Maker.makeTxMaker()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The following code snippet results in NotSerializableException if any cache policy is enabled, but runs without problems if none was set. Tested with 2.0-beta6, 2.0-beta3 and with the necessary API changes 1.0.8.\n\n```\n    File dbFile = tempFolder.newFile(\"db1\");\n    DBMaker.Maker dbMaker = DBMaker.fileDB(dbFile).cacheSoftRefEnable();\n    TxMaker txMaker = dbMaker.makeTxMaker();\n\n    DB db1 = txMaker.makeTx();\n    db1.treeMapCreate(\"test1\").makeOrGet();\n    db1.commit();\n    db1.close();\n\n    DB db2 = txMaker.makeTx();\n    db2.treeMapCreate(\"test2\").makeOrGet();\n    db2.commit();\n    db2.close();\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "DB using cache policy causes NotSerializableException", "statsSkippedReason": "", "closed": "2015-09-01 11:30:20", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-01 14:30:12", "commitHash": "05898e53f8fe113fb56710dd7240e3e096a22791", "commitParents": ["ffc5ea3c117c5e45087577971dff65220f990004"], "commitGHEventType": "closed", "nameRev": "05898e53f8fe113fb56710dd7240e3e096a22791 tags/mapdb-2.0-beta7~16", "commitGitStats": [{"insertions": 17, "lines": 17, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 0}, {"insertions": 5, "lines": 5, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.Maker.makeTxMaker()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue567()"}], "spoonFilePath": "IssuesTest.java"}], "commitMessage": "DBMaker: disable cache with TxMaker. Fix #567\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-01 14:30:12"}], "created": "2015-08-28 08:31:25"}, {"labels": ["2.0", "bug"], "filteredCommits": ["08d7a93a7ac840233080a7d566d4cd882226d2a5"], "url": "https://github.com/jankotek/mapdb/issues/561", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 2, "lines": 17, "deletions": 6}, "numCommits": 1, "commits": {"08d7a93a7ac840233080a7d566d4cd882226d2a5": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 1.0002777777777778, "user": "mnoky", "changesInPackagesSPOON": ["org.mapdb.Queues.SimpleQueue.poll()", "org.mapdb.Queues.Queue.add(java.lang.Object)", "SPOON_EXCEPTION"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I have used mapdb 1.0.x in the past and am now trying the 2.0 releases. I'm seeing a DBException that happens when I try to perform a Queue.poll() after I do a simple DB.compact(). This used to work in version 1.0.x, but fails in 2.0 beta6 Here's the code:\n\n```\nimport java.io.File;\nimport java.util.concurrent.BlockingQueue;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\npublic class MapDBQueue {\n    public static void main(String[] args) {\n        final String dir = System.getProperty(\"user.home\");\n        final String filename = dir + \"/mapdbtest\";\n        final File file = new File(filename);\n        final String queueName = \"testqueue\";\n        DB db = DBMaker\n                .fileDB(file)\n                .fileMmapEnable()\n                .transactionDisable()\n                .cacheSize(128)\n                .closeOnJvmShutdown()\n                .make();\n        BlockingQueue<String> queue = db.getQueue(queueName);\n        String next = queue.poll();\n        System.out.println(\"poll() #1: \" +next);\n        db.compact();\n        db.commit();\n        next = queue.poll();\n        System.out.println(\"poll() #2: \" +next);\n    }\n}\n```\n\nAnd the output:\n\n```\npoll() #1: null\nException in thread \"main\" org.mapdb.DBException$EngineGetVoid: Recid passed to Engine.get() does not exist. Possible data corruption!\n    at org.mapdb.StoreDirect.indexValGet(StoreDirect.java:1565)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:316)\n    at org.mapdb.Store.get(Store.java:253)\n    at org.mapdb.Engine$CloseOnJVMShutdown.get(Engine.java:453)\n    at org.mapdb.Queues$SimpleQueue.poll(Queues.java:103)\n    at MapDBQueue.main(MapDBQueue.java:24)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 2.0, "TOT": 2.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 2, "MOV": 0.0}, "title": "DBException after compact()", "statsSkippedReason": "", "closed": "2015-08-20 16:04:35", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-08-20 18:04:25", "commitHash": "08d7a93a7ac840233080a7d566d4cd882226d2a5", "commitParents": ["4659fa952aa0186235b25becea69b6a1c0dbf712"], "commitGHEventType": "closed", "nameRev": "08d7a93a7ac840233080a7d566d4cd882226d2a5 tags/mapdb-2.0-beta7~32", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/Queues.java", "deletions": 2}, {"insertions": 9, "lines": 13, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 4}, {"insertions": 20, "lines": 20, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue561()"}], "spoonFilePath": "IssuesTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Queues.SimpleQueue.poll()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Queues.Queue.add(java.lang.Object)"}], "spoonFilePath": "Queues.java"}], "commitMessage": "Queues: Fix #561, queues fails after compaction, when their preallocated recid disappears\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-20 18:04:25"}], "created": "2015-08-19 15:15:58"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/550", "title": "org.mapdb.DBException$EngineGetVoid: Recid passed to Engine.get() does not exist. Possible data corruption!", "closed": "2015-08-07 13:22:56", "commitsDetails": [], "commits": {}, "ttf": 21.00027777777778, "created": "2015-07-17 07:38:33", "user": "lamfire", "body": "final DB db = DBMaker.fileDB(file).fileMmapEnable().fileChannelEnable().asyncWriteEnable().asyncWriteFlushDelay(1000).asyncWriteQueueSize(10000).make();\n        final BTreeMap<Long,Long> map = db.treeMap(\"TreeMap\");\n\nmapdb version: 2.0-beta2\njvm process : kill -9 xxxx\nreopen and read\nException in thread \"main\" org.mapdb.DBException$EngineGetVoid: Recid passed to Engine.get() does not exist. Possible data corruption!\n    at org.mapdb.StoreDirect.indexValGet(StoreDirect.java:1186)\n    at org.mapdb.StoreWAL.indexValGet(StoreWAL.java:469)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:645)\n    at org.mapdb.Store.get(Store.java:224)\n    at org.mapdb.BTreeMap$BTreeIterator.advance(BTreeMap.java:1328)\n    at org.mapdb.BTreeMap.sizeLong(BTreeMap.java:1795)\n    at org.mapdb.BTreeMap.size(BTreeMap.java:1782)\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["593ab8511597c601f871f5cc31bc22352322f983", "e51139cae50bb5897d181c77fce4345d3aa76d64", "1e161b465d4e4abaffa61371b53f142a6f603ba5", "7dd39481ab55ecc2b745118df8e3802a4f68230b"], "url": "https://github.com/jankotek/mapdb/issues/546", "gitStatsSummary": {"insertions": 68, "gitFilesChange": 3, "lines": 148, "deletions": 80}, "numCommits": 3, "commits": {"1e161b465d4e4abaffa61371b53f142a6f603ba5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "593ab8511597c601f871f5cc31bc22352322f983": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "7dd39481ab55ecc2b745118df8e3802a4f68230b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e51139cae50bb5897d181c77fce4345d3aa76d64": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 35.000277777777775, "user": "dmk23", "changesInPackagesSPOON": ["org.mapdb.SerializerBase.equalsBinary(java.lang.Object,java.lang.Object)", "org.mapdb.Serializer.Array", "SPOON_EXCEPTION", "org.mapdb.Serializer.4.deserialize(java.io.DataInput,int)", "org.mapdb.Serializer.4.serialize(java.io.DataOutput,java.lang.String)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "## new description\n\nMapDB 2.0 tries to store serializers as part of collection definition if Serializer implements Serializable. You are using ArraySerializer, which implements Serializable, but one of the field is your serializer, which is not serializable. And it fails. \n## old description\n\nTo increase speed/ space savings with our text-heavy data I want to serialize it as ASCII. When trying out `Serializer.STRING_ASCII` I quickly discovered that it just calls the UTF string serializer, producing identical result (with 2.0-beta2). So I decided to try and roll my own and improve interface by using CharSequence objects instead of Strings, which could represent any other number of string representation without the need of converting them / generating GC. My code is below:\n\n```\n    public static final Serializer<CharSequence> ASCII_SERIALIZER = new Serializer<CharSequence>() {\n        public void serialize(DataOutput out, CharSequence value) throws IOException {\n            int SIZE = value.length();\n            DataIO.packInt(out, SIZE);\n            for (int i = 0; i < SIZE; i++) {\n                out.writeByte((byte)value.charAt(i));\n            }\n        }\n        public CharSequence deserialize(DataInput in, int available) throws IOException {\n            int SIZE = DataIO.unpackInt(in);\n            StringBuilder result = new StringBuilder(SIZE);\n            for (int i = 0; i < SIZE; i++) {\n                result.append((char)(in.readByte() & 0xFF));\n            }\n            return result;\n        }\n        public int fixedSize() {\n            return -1;\n        }\n    };\n```\n\nUnfortunately the code would not run because MapDB tries to assert that the object is Serializable and the CharSequence interface is not:  `Exception in thread \"main\" java.io.IOError: java.io.NotSerializableException` . Why is this kind of check even necessary? As long as serializer promises to be able to properly handle CharSequence why shouldn't MapDB let it?\n\nThen I've changed my code to use String (and add a wasteful conversion step from StringBuilder to String), but the error remained. Why doesn't MapDB support serializing CharSequences (and maybe other interfaces) natively, as well as writing custom serializers for basic types like String?\n\n**NOTE:** I am using this serializer as part of a composite BTree key, like in the examples\n\n```\nCaused by: java.io.NotSerializableException: com.test.XXXX\n        at org.mapdb.SerializerPojo.assertClassSerializable(SerializerPojo.java:370)\n        at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:433)\n        at org.mapdb.SerializerBase.serialize(SerializerBase.java:985)\n        at org.mapdb.SerializerBase$17.serialize(SerializerBase.java:371)\n        at org.mapdb.SerializerBase$17.serialize(SerializerBase.java:362)\n        at org.mapdb.SerializerBase.serialize(SerializerBase.java:980)\n        at org.mapdb.SerializerBase.serialize(SerializerBase.java:931)\n        at org.mapdb.Serializer.valueArraySerialize(Serializer.java:1714)\n        at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:766)\n        at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:702)\n        at org.mapdb.Store.serialize(Store.java:270)\n        ... 7 more\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 5, "UPD": 6.0, "TOT": 22.0, "DEL": 5.0, "INS": 6.0, "spoonFilesChanged": 3, "MOV": 5.0}, "title": "ArraySerializer with non serializable fields fails", "statsSkippedReason": "", "closed": "2015-08-18 09:05:15", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-14 12:38:51", "commitHash": "7dd39481ab55ecc2b745118df8e3802a4f68230b", "commitParents": ["593ab8511597c601f871f5cc31bc22352322f983"], "commitGHEventType": "referenced", "nameRev": "7dd39481ab55ecc2b745118df8e3802a4f68230b tags/mapdb-2.0-beta3~30", "commitGitStats": [{"insertions": 83, "lines": 88, "filePath": "src/test/java/org/mapdb/SerializerTest.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.issue546()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.StringSSerializer"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.StringS"}], "spoonFilePath": "SerializerTest.java"}], "commitMessage": "Add test case for issue #546\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-14 12:38:51"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-13 22:42:29", "commitHash": "593ab8511597c601f871f5cc31bc22352322f983", "commitParents": ["d618dfbd73032469c072981c498d4063c45e3834"], "commitGHEventType": "closed", "nameRev": "593ab8511597c601f871f5cc31bc22352322f983 tags/mapdb-2.0-beta3~31", "commitGitStats": [{"insertions": 8, "lines": 18, "filePath": "src/main/java/org/mapdb/Serializer.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 7, "DEL": 2, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Serializer.4.deserialize(java.io.DataInput,int)"}, {"UPD": 4, "TOT": 13, "DEL": 3, "INS": 2, "MOV": 4, "spoonMethodName": "org.mapdb.Serializer.4.serialize(java.io.DataOutput,java.lang.String)"}], "spoonFilePath": "Serializer.java"}], "commitMessage": "Serializer.STRING_ASCII - was not using 8 bit characters, fix and BREAK COMPATIBILITY. Fix #546\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-13 22:42:29"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-18 10:15:47", "commitHash": "1e161b465d4e4abaffa61371b53f142a6f603ba5", "commitParents": ["b68609cde1de57114ea7aaefb06e3f462fbd6072"], "commitGHEventType": "referenced", "nameRev": "1e161b465d4e4abaffa61371b53f142a6f603ba5 tags/mapdb-2.0-beta6~7", "commitGitStats": [{"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/Serializer.java", "deletions": 0}, {"insertions": 9, "lines": 14, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 5}, {"insertions": 38, "lines": 38, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Serializer.Array"}], "spoonFilePath": "Serializer.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.Issue546_NonSerializableSerializer"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue546_ArraySerializer_with_non_serializable_fields()"}], "spoonFilePath": "DBTest.java"}], "commitMessage": "DB: better way to detect if Serializer is serializable, before stored in named catalog. See #546\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-18 10:15:47"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-18 11:04:06", "commitHash": "e51139cae50bb5897d181c77fce4345d3aa76d64", "commitParents": ["1e161b465d4e4abaffa61371b53f142a6f603ba5"], "commitGHEventType": "closed", "nameRev": "e51139cae50bb5897d181c77fce4345d3aa76d64 tags/mapdb-2.0-beta6~6", "commitGitStats": [{"insertions": 21, "lines": 86, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 65}, {"insertions": 29, "lines": 39, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 10}, {"insertions": 28, "lines": 28, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.equalsBinary(java.lang.Object,java.lang.Object)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.treeSet_serializers_non_serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.Issue546_SerializableSerializer"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.hashMap_serializers_non_serializable()"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.treeMap_serializers_non_serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue546_serializer_warning()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.hashSet_serializers_non_serializable()"}], "spoonFilePath": "DBTest.java"}], "commitMessage": "DB: better way to compare serialized arguments in Named Catalog, remove wrong Log warning.  Fix #546\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-18 11:04:06"}], "created": "2015-07-13 19:54:18"}, {"labels": ["2.0", "bug"], "filteredCommits": ["0ddada1d67318d1e9f1909def232521f06359891", "c8ac217410de0008b28e62a6061f1fa24a5fdaa1", "7fb6a757dfda8a5d55c8bbd4c57462721363bd00", "86a5030a5201471aacccfc2ca2bbaa25f660c581"], "url": "https://github.com/jankotek/mapdb/issues/542", "gitStatsSummary": {"insertions": 95, "gitFilesChange": 3, "lines": 139, "deletions": 44}, "numCommits": 4, "commits": {"c8ac217410de0008b28e62a6061f1fa24a5fdaa1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "0ddada1d67318d1e9f1909def232521f06359891": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "7fb6a757dfda8a5d55c8bbd4c57462721363bd00": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "12285a509f28590b6b6378fd95f106e7bdb4e9c5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "86a5030a5201471aacccfc2ca2bbaa25f660c581": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "22beb777877102fb69c16c946f6368057b489cd5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 3.000277777777778, "user": "dmk23", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.compactIndexPage(long,org.mapdb.StoreDirect,java.util.concurrent.atomic.AtomicLong,int)", "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.Store.1", "org.mapdb.DBException", "org.mapdb.StoreDirect.compact()", "org.mapdb.Store", "org.mapdb.Store.2"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Using 2.0-beta1, created direct memory DB, generated HTreeMap, populated it with records. Attempts to compact DB causes a fatal error. Note, this is not a problem if BTreeMap is used instead.\n\n```\nException in thread \"main\" java.lang.AssertionError\n        at org.mapdb.StoreDirect.compactIndexPage(StoreDirect.java:1075)\n        at org.mapdb.StoreDirect.compactIndexPages(StoreDirect.java:1023)\n        at org.mapdb.StoreDirect.compact(StoreDirect.java:920)\n        at org.mapdb.DB.compact(DB.java:2431)\n        at com.app.Test.main(Test.java:1170)\nJul 05, 2015 2:47:15 AM org.mapdb.Volume finalize\nWARNING: Open Volume was GCed, possible file handle leak.\n```\n\nThe map and the DB are static field in the main class, so they should never get GC'd\n", "filteredCommitsReason": {"duplicated": 2, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 7, "UPD": 5, "TOT": 36, "DEL": 4, "INS": 8, "spoonFilesChanged": 3, "MOV": 19}, "title": "compaction of HTreeMap causes fatal error", "statsSkippedReason": "", "closed": "2015-07-08 19:23:39", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-08 22:09:38", "commitHash": "c8ac217410de0008b28e62a6061f1fa24a5fdaa1", "commitParents": ["dd42dc1cf15ab8619f2785a0715c3f08b787d9d0"], "commitGHEventType": "referenced", "nameRev": "c8ac217410de0008b28e62a6061f1fa24a5fdaa1 tags/mapdb-2.0-beta2~6", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "StoreDirect: Fix failing test case, see  #542\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-08 22:09:38"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-09 11:32:13", "commitHash": "0ddada1d67318d1e9f1909def232521f06359891", "commitParents": ["450d11480c3393df992cc58061f8e22d6f5af51d"], "commitGHEventType": "referenced", "nameRev": "0ddada1d67318d1e9f1909def232521f06359891 tags/mapdb-2.0-beta2~2", "commitGitStats": [{"insertions": 7, "lines": 10, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 3}, {"insertions": 29, "lines": 30, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 1}, {"insertions": 48, "lines": 62, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 14}, {"insertions": 16, "lines": 30, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 14}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Store.1"}, {"UPD": 2, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Store"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Store.2"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_long()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_mixed()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_puts_record_offset_into_index()"}, {"UPD": 0, "TOT": 17, "DEL": 0, "INS": 5, "MOV": 12, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take2()"}, {"UPD": 0, "TOT": 15, "DEL": 1, "INS": 7, "MOV": 7, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_overflow()"}, {"UPD": 0, "TOT": 15, "DEL": 0, "INS": 6, "MOV": 9, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_created_after_put()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack_no_commit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take_simple()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_put_five()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take()"}], "spoonFilePath": "StoreDirectTest.java"}], "commitMessage": "StoreDirect: Fix deadlock in compaction, add some lock assertions, see #542\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-09 11:32:13"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-08 21:23:32", "commitHash": "7fb6a757dfda8a5d55c8bbd4c57462721363bd00", "commitParents": ["86a5030a5201471aacccfc2ca2bbaa25f660c581"], "commitGHEventType": "closed", "nameRev": "7fb6a757dfda8a5d55c8bbd4c57462721363bd00 tags/mapdb-2.0-beta2~8", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DBException.java", "deletions": 1}, {"insertions": 46, "lines": 72, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 26}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 6, "DEL": 2, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}, {"UPD": 0, "TOT": 16, "DEL": 1, "INS": 4, "MOV": 11, "spoonMethodName": "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBException"}], "spoonFilePath": "DBException.java"}], "commitMessage": "StoreDirect: compaction was not thread safe. Fix #542, in future have to rework this section, to improve performance.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-08 21:23:32"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-08 22:29:09", "commitHash": "12285a509f28590b6b6378fd95f106e7bdb4e9c5", "commitParents": ["22beb777877102fb69c16c946f6368057b489cd5"], "commitGHEventType": "referenced", "nameRev": "12285a509f28590b6b6378fd95f106e7bdb4e9c5 tags/mapdb-2.0-beta2~4", "commitGitStats": [{"insertions": 2, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 6, "DEL": 4, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "StoreDirect: Fix failing test case, see  #542\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-08 22:29:09"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-08 18:50:24", "commitHash": "86a5030a5201471aacccfc2ca2bbaa25f660c581", "commitParents": ["a86151e6a26c06b7c00ec9d42a181cf0506b3eb3"], "commitGHEventType": "referenced", "nameRev": "86a5030a5201471aacccfc2ca2bbaa25f660c581 tags/mapdb-2.0-beta2~9", "commitGitStats": [{"insertions": 10, "lines": 10, "filePath": "src/test/java/org/mapdb/UtilsTest.java", "deletions": 0}, {"insertions": 41, "lines": 42, "filePath": "src/test/java/org/mapdb/HTreeMap2Test.java", "deletions": 1}, {"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UtilsTest.fork(java.util.concurrent.Callable)"}], "spoonFilePath": "UtilsTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.issue542_compaction_error_while_htreemap_used()"}], "spoonFilePath": "HTreeMap2Test.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compactIndexPage(long,org.mapdb.StoreDirect,java.util.concurrent.atomic.AtomicLong,int)"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "StoreDirect: compaction could fail. Add code and test to catch #542\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-08 18:50:24"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-08 22:10:34", "commitHash": "22beb777877102fb69c16c946f6368057b489cd5", "commitParents": ["c8ac217410de0008b28e62a6061f1fa24a5fdaa1"], "commitGHEventType": "referenced", "nameRev": "22beb777877102fb69c16c946f6368057b489cd5 tags/mapdb-2.0-beta2~5", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "StoreDirect: Fix failing test case, see  #542\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-08 22:10:34"}], "created": "2015-07-05 10:06:09"}, {"labels": ["2.0", "bug"], "filteredCommits": ["47ee2b5bdd0df2faa20fa1833541dcf932190896"], "url": "https://github.com/jankotek/mapdb/issues/540", "gitStatsSummary": {"insertions": 22, "gitFilesChange": 1, "lines": 27, "deletions": 5}, "numCommits": 1, "commits": {"47ee2b5bdd0df2faa20fa1833541dcf932190896": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 2.000277777777778, "user": "ypoluektovich", "changesInPackagesSPOON": ["SPOON_EXCEPTION"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If DB.treeMap(String, BTreeKeySerializer, Serializer) gets called with a specific key and/or value serializer, and the map does not exist in the database yet, then the catalog entries written for this map will have default serializers. Shouldn't the supplied values get written instead?\n(As of 2.0-beta1. See DB.java, line 1355.)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 1, "MOV": 0.0}, "title": "Custom serializers ignored on map creation", "statsSkippedReason": "", "closed": "2015-07-04 05:08:38", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 07:08:31", "commitHash": "47ee2b5bdd0df2faa20fa1833541dcf932190896", "commitParents": ["a00380670da29548c7e2e6b4c78580ae57f86f13"], "commitGHEventType": "closed", "nameRev": "47ee2b5bdd0df2faa20fa1833541dcf932190896 tags/mapdb-2.0-beta2~18", "commitGitStats": [{"insertions": 22, "lines": 27, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 5}, {"insertions": 35, "lines": 35, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue540_btreemap_serializers()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue540_htreeset_serializers()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue540_btreeset_serializers()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.issue540_htreemap_serializers()"}], "spoonFilePath": "DBTest.java"}], "commitMessage": "DB: serializers ignored, fix #540\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 07:08:31"}], "created": "2015-07-01 14:36:20"}, {"labels": ["2.0", "bug"], "filteredCommits": ["0392d2fca4cf02f7013a84d7acd703c4b5a0f99c"], "url": "https://github.com/jankotek/mapdb/issues/538", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 12, "deletions": 4}, "numCommits": 1, "commits": {"0392d2fca4cf02f7013a84d7acd703c4b5a0f99c": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 11.000277777777777, "user": "victorbr", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.get(java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "In version 2.0-alpha3 -\nIf in-memory map is connected to on-disk map with `expireOverflow` as detailed in the section 7.3 of the manual, `get` for a non-existing key results in NPE from `putIfAbsent` called from `get` (`valueCreator` returns `null`).\n`containsKey` works correctly.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "NPE is thrown when accessing non-existing key for in-memory map with expireOverflow", "statsSkippedReason": "", "closed": "2015-07-04 05:26:34", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 07:26:29", "commitHash": "0392d2fca4cf02f7013a84d7acd703c4b5a0f99c", "commitParents": ["7d669f7b32bf11d20170fea6cb6e8208b58b9dfb"], "commitGHEventType": "closed", "nameRev": "0392d2fca4cf02f7013a84d7acd703c4b5a0f99c tags/mapdb-2.0-beta2~16", "commitGitStats": [{"insertions": 8, "lines": 12, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 4}, {"insertions": 24, "lines": 29, "filePath": "src/test/java/org/mapdb/HTreeMap2Test.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.issue538_overflow_NPE1()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.issue538_overflow_NPE2()"}], "spoonFilePath": "HTreeMap2Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.get(java.lang.Object)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "HTreeMap: fix #538, NPE when get non existing key with overflow enabled\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 07:25:31"}], "created": "2015-06-22 14:56:47"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/537", "title": "Closing might take long time with mmap files", "closed": "2015-07-04 06:02:24", "commitsDetails": [], "commits": {}, "ttf": 14.000277777777777, "created": "2015-06-19 20:04:21", "user": "jankotek", "body": "closing a huge mapdb map, (size ~ 4GB or more), takes a long time (~ 25 seconds) \nafter reading maps via multiple threads. I am just reading the map and not \nmodifying it. We are using asyncWriteEnable, Hard-ref cache, with memory-mapped \nstrategy enabled. Also we have our own custom made serializers. What can be \npossibly wrong? Can anyone suggest why its taking so long to close?\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["d1a65fbb304cf77c3ffb53686f630679bbbeef1c", "d91f859ba6cddcf1c9a0eccb18e61048597b0de2"], "url": "https://github.com/jankotek/mapdb/issues/536", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"d91f859ba6cddcf1c9a0eccb18e61048597b0de2": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "d1a65fbb304cf77c3ffb53686f630679bbbeef1c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 14.000277777777777, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.Serializer.22.deserialize(java.io.DataInput,int)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I'm trying to compare SerializerPojo, Serializer.JAVA, vs. overriding the Serializer.STRING to do some generic class storage.\n\nIs there sample code I'm missing that shows more java object storage? (\n\nI'm tempted to use gson to/from class to string... since I'm already using it for web services.. and I'm not too concerned about performance. \n\nAny suggestions welcome.. \n\nBTW, I wasn't able to get the Serializer.JAVA to work-- got the error below. Not sure if that's just a user error or bug.\n- Brad\n\n```\njava.lang.ClassCastException: org.mapdb.DataIO$DataInputByteArray cannot be cast to java.io.InputStream\n    at org.mapdb.Serializer$22.deserialize(Serializer.java:1045)\n    at org.mapdb.HTreeMap.assertHashConsistent(HTreeMap.java:172)\n    at org.mapdb.HTreeMap.access$0(HTreeMap.java:166)\n    at org.mapdb.HTreeMap$1.serialize(HTreeMap.java:137)\n    at org.mapdb.HTreeMap$1.serialize(HTreeMap.java:1)\n    at org.mapdb.Store.serialize(Store.java:239)\n    at org.mapdb.StoreDirect.put(StoreDirect.java:467)\n    at org.mapdb.Engine$CloseOnJVMShutdown.put(Engine.java:448)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:973)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:850)\n    at ss.model.explore.db.Pair.put(Pair.java:27)\n```\n\n(on the cast)\n\n```\n    public static final Serializer<Object> JAVA = new Serializer<Object>() {\n        @Override\n        public void serialize(DataOutput out, Object value) throws IOException {\n            ObjectOutputStream out2 = new ObjectOutputStream((OutputStream) out);\n            out2.writeObject(value);\n            out2.flush();\n        }\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Serializer.JAVA  broken", "statsSkippedReason": "", "closed": "2015-07-04 06:58:04", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 08:57:59", "commitHash": "d91f859ba6cddcf1c9a0eccb18e61048597b0de2", "commitParents": ["ed1119fe8a34047fc684d585c7ac95020c90dd14"], "commitGHEventType": "closed", "nameRev": "d91f859ba6cddcf1c9a0eccb18e61048597b0de2 tags/mapdb-2.0-beta2~13", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Serializer.java", "deletions": 1}, {"insertions": 25, "lines": 25, "filePath": "src/test/java/org/mapdb/SerializerTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536_with_engine()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536_with_map()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536()"}], "spoonFilePath": "SerializerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Serializer.22.deserialize(java.io.DataInput,int)"}], "spoonFilePath": "Serializer.java"}], "commitMessage": "Serializer: JAVA serializer did not work. Fix #536\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 08:57:59"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-04 08:53:17", "commitHash": "d1a65fbb304cf77c3ffb53686f630679bbbeef1c", "commitParents": ["ade719b3f1a747f9f6b89720c163d5a4b523ecad"], "commitGHEventType": "referenced", "nameRev": "d1a65fbb304cf77c3ffb53686f630679bbbeef1c tags/mapdb-renamed-1.0.8~10", "commitGitStats": [{"insertions": 28, "lines": 31, "filePath": "src/test/java/org/mapdb/SerializerTest.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536_with_engine()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536_with_map()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerTest.java_serializer_issue536()"}], "spoonFilePath": "SerializerTest.java"}], "commitMessage": "Serializer: check java serializer works. See #536\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 08:53:17"}], "created": "2015-06-19 09:46:08"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/535", "title": "BTreeKeySerializer.STRING has wrong sorting", "closed": "2015-06-12 14:50:33", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2015-06-12 14:46:06", "user": "jankotek", "body": "`BTreeKeySerializer.STRING` sorts strings by char value. However `BTreeKeySerializer.STRING.comparator()` is using `String.compareTo()` method which is Unicode based. That could lead to nasty effects including data corruption.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["6f20896258399f1cbfd4a71b8231a942018e0d7f"], "url": "https://github.com/jankotek/mapdb/issues/534", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 5, "deletions": 2}, "numCommits": 1, "commits": {"6f20896258399f1cbfd4a71b8231a942018e0d7f": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There is race condition in 1.0 and 2.0. It is caused by wrong levels. \n\n```\nCaused by: java.lang.IndexOutOfBoundsException: Index: 2, Size: 2\n        at java.util.ArrayList.rangeCheck(ArrayList.java:653)\n        at java.util.ArrayList.get(ArrayList.java:429)\n        at java.util.Collections$SynchronizedList.get(Collections.java:2417)\n        at org.mapdb.BTreeMap.put2(BTreeMap.java:1179)\n        at org.mapdb.BTreeMap.put(BTreeMap.java:1024)\n        at org.mapdb.BTreeMapParTest$1.call(BTreeMapParTest.java:42)\n        at org.mapdb.Exec$1.run(Exec.java:29)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 1}, "title": "BTreeMap throws IndexOutOfBoundsException under concurrent access", "statsSkippedReason": "", "closed": "2015-06-10 22:19:17", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-06-11 01:19:03", "commitHash": "6f20896258399f1cbfd4a71b8231a942018e0d7f", "commitParents": ["2eeb86cdda53cc791cd0ae0cd543d8f598c70847"], "commitGHEventType": "referenced", "nameRev": "6f20896258399f1cbfd4a71b8231a942018e0d7f tags/mapdb-renamed-1.0.8~17", "commitGitStats": [{"insertions": 3, "lines": 5, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "BTreeMap: fix #534, IndexOutOfBoundsException under concurrent access\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-11 01:19:03"}], "created": "2015-06-10 22:18:08"}, {"labels": ["2.0", "bug"], "filteredCommits": ["11cdfc65364283c4991e383c3754645bbc84f2ab", "f2831041f07dc03a8d84e2d9113fac216583f250"], "url": "https://github.com/jankotek/mapdb/issues/523", "gitStatsSummary": {"insertions": 24, "gitFilesChange": 1, "lines": 31, "deletions": 7}, "numCommits": 2, "commits": {"f2831041f07dc03a8d84e2d9113fac216583f250": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "11cdfc65364283c4991e383c3754645bbc84f2ab": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "7a32daf7d39ca29d3095681bd221b0ed85fc342b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 13.000277777777777, "user": "igorrogov", "changesInPackagesSPOON": ["org.mapdb.Volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If I open a database as read-only, mapdb fails to unmap the database files after db.close().\n\nHere is a sample code to reproduce the issue:\n\n``` java\nprivate MapDbReadOnlyTest() {\n    File dbFile = new File(\"r:\\\\temp\\\\mapdbtest\\\\test.db\");\n    testCreate(dbFile);\n    testRead(dbFile);\n}\n\nprivate void testCreate(File dbFile) {\n    System.out.println(\"Creating Map DB: \" + dbFile + \". Entries: \" + NUM_ENTRIES);\n    DB db = DBMaker.newFileDB(dbFile).transactionDisable().mmapFileEnablePartial().make();\n    try {\n        BTreeMap<Integer, String> map = db.createTreeMap(DB_NAME).makeOrGet();\n        for (int i = 0; i < NUM_ENTRIES; i++) {\n            map.put(i, \"value-\" + i);\n        }\n    }\n    finally {\n        db.commit();\n        db.close();\n        System.out.println(\"Closed database: \" + dbFile);\n    }\n}\n\nprivate void testRead(File dbFile) {\n    System.out.println(\"Opening database: \" + dbFile);\n    DB db = DBMaker.newFileDB(dbFile).transactionDisable().readOnly().mmapFileEnablePartial().make();\n    try {\n        BTreeMap<Integer, String> map = db.createTreeMap(DB_NAME).makeOrGet();\n        for (int i = 0; i < NUM_ENTRIES; i++) {\n            map.get(i);\n        }\n    }\n    finally {\n        db.close();\n        System.out.println(\"Closed database: \" + dbFile);\n        // check if the file is still locked\n        if (!dbFile.delete()) {\n            System.out.println(\"Index file could not be deleted. Failed to unmap.\");\n        }\n        else {\n            System.out.println(\"Index file was successfully deleted.\");\n        }\n    }\n}\n```\n\nI tried to debug the code and I found that it fails to unmap the Volume because ByteBuffer.asReadOnlyBuffer() returns an instance that is missing a Cleaner that is used to unmap the file: http://grepcode.com/file/repo1.maven.org/maven2/org.mapdb/mapdb/1.0.7/org/mapdb/Volume.java#Volume.MappedFileVol.makeNewBuffer%28long%29\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 11, "DEL": 1, "INS": 5, "spoonFilesChanged": 1, "MOV": 4}, "title": "memory mapped volume cannot be unmapped if it's opened as read-only", "statsSkippedReason": "", "closed": "2015-06-17 10:16:23", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-06-17 13:16:07", "commitHash": "f2831041f07dc03a8d84e2d9113fac216583f250", "commitParents": ["18585912961834c96bf88280b446ee9f6b8b48c3"], "commitGHEventType": "closed", "nameRev": "f2831041f07dc03a8d84e2d9113fac216583f250 tags/mapdb-2.0-beta1~21", "commitGitStats": [{"insertions": 49, "lines": 49, "filePath": "src/test/java/org/mapdb/Issue523Test.java", "deletions": 0}, {"insertions": 14, "lines": 19, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue523Test"}], "spoonFilePath": "Issue523Test.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 6, "DEL": 0, "INS": 4, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix #523, unmapd fail for readonly mmap files\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-17 13:16:07"}, {"commitUser": "jankotek", "commitDateTime": "2015-06-17 13:20:37", "commitHash": "11cdfc65364283c4991e383c3754645bbc84f2ab", "commitParents": ["7a32daf7d39ca29d3095681bd221b0ed85fc342b"], "commitGHEventType": "referenced", "nameRev": "11cdfc65364283c4991e383c3754645bbc84f2ab tags/mapdb-renamed-1.0.8~15", "commitGitStats": [{"insertions": 10, "lines": 12, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 1, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix #523, memory mapped file not unmapped after close.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-17 13:20:37"}, {"commitUser": "jankotek", "commitDateTime": "2015-06-17 12:57:37", "commitHash": "7a32daf7d39ca29d3095681bd221b0ed85fc342b", "commitParents": ["6f20896258399f1cbfd4a71b8231a942018e0d7f"], "commitGHEventType": "referenced", "nameRev": "7a32daf7d39ca29d3095681bd221b0ed85fc342b tags/mapdb-renamed-1.0.8~16", "commitGitStats": [{"insertions": 49, "lines": 49, "filePath": "src/test/java/org/mapdb/Issue523Test.java", "deletions": 0}, {"insertions": 0, "lines": 3, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue523Test"}], "spoonFilePath": "Issue523Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix #523, memory mapped file not unmapped after close.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-17 12:57:37"}], "created": "2015-06-04 09:03:55"}, {"labels": ["2.0", "bug"], "filteredCommits": ["479c6dc69e61ae1f4cd39f1810de0fa51c5751db", "9f2b180dff6f28a8fba0942337375c952070ca59"], "url": "https://github.com/jankotek/mapdb/issues/517", "gitStatsSummary": {"insertions": 32, "gitFilesChange": 1, "lines": 35, "deletions": 3}, "numCommits": 1, "commits": {"9f2b180dff6f28a8fba0942337375c952070ca59": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "479c6dc69e61ae1f4cd39f1810de0fa51c5751db": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 26.00027777777778, "user": "Groostav", "changesInPackagesSPOON": ["org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)", "org.mapdb.DB.createHashMap(org.mapdb.DB$HTreeMapMaker)", "org.mapdb.DB.createHashSet(org.mapdb.DB$HTreeSetMaker)", "org.mapdb.DB.createTreeSet(org.mapdb.DB$BTreeSetMaker)", "org.mapdb.DB.createStack(java.lang.String,org.mapdb.Serializer,boolean)", "org.mapdb.DB.createAtomicVar(java.lang.String,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.DB.createQueue(java.lang.String,org.mapdb.Serializer,boolean)", "org.mapdb.DB.createCircularQueue(java.lang.String,org.mapdb.Serializer,long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "And the follow up to #345 is that now, if you give MapDB a serializer that results in `DB.makeOrGet()` throwing, if you call it a second time it just hangs. \n\nThe first execption is, as you'd expect:\n\n```\njava.io.IOError: java.io.NotSerializableException: com.empowerops.common.Serializer$3\n    at org.mapdb.Store.serialize(Store.java:228)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:403)\n    at org.mapdb.Caches$HashTable.update(Caches.java:269)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:63)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:746)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:643)\n    at org.mapdb.DB.catPut(DB.java:112)\n    at org.mapdb.DB.createHashMap(DB.java:437)\n    at org.mapdb.DB$HTreeMapMaker.make(DB.java:216)\n    at org.mapdb.DB$HTreeMapMaker.makeOrGet(DB.java:222)\n    at com.empowerops.front_end.persistence.StoreFacade.getTable(StoreFacade.java:51)\n    //... our domain\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.io.NotSerializableException: com.empowerops.common.Serializer$3\n    at org.mapdb.SerializerPojo.assertClassSerializable(SerializerPojo.java:323)\n    at org.mapdb.SerializerPojo.registerClass(SerializerPojo.java:243)\n    at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:392)\n    at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)\n    at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:426)\n    at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)\n    at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:426)\n    at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:94)\n    at org.mapdb.SerializerPojo.serialize(SerializerPojo.java:696)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:397)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:288)\n    at org.mapdb.Store.serialize(Store.java:154)\n    ... 23 more\n```\n\nand if that second block gets called a second time, rather than failing again, it _hangs_ here:\n\n```\n    park(), in Unsafe\n    parkNanos(): 333, LockSupport\n    lock():2882, BTreeMap\n    put2()686, BTreeMap\n    put():643, BTreeMap\n        catPut():105, DB\n    createHashMap():493, DB\n    make():216, DB$HTreeMapMaker\n    makeOrGet():222DB$HTreeMapMaker\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 8, "UPD": 0, "TOT": 20, "DEL": 0, "INS": 17, "spoonFilesChanged": 1, "MOV": 3}, "title": "second call to DB.makeOrGet() hangs after first attempt throws Serializer not serializable", "statsSkippedReason": "", "closed": "2015-06-18 13:39:03", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-06-18 16:20:04", "commitHash": "9f2b180dff6f28a8fba0942337375c952070ca59", "commitParents": ["e4a449052c5c4efd3fdfef8556882ee1299158ab"], "commitGHEventType": "referenced", "nameRev": "9f2b180dff6f28a8fba0942337375c952070ca59 tags/mapdb-renamed-1.0.8~13", "commitGitStats": [{"insertions": 43, "lines": 43, "filePath": "src/test/java/org/mapdb/Issue517Test.java", "deletions": 0}, {"insertions": 32, "lines": 35, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createHashMap(org.mapdb.DB$HTreeMapMaker)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createHashSet(org.mapdb.DB$HTreeSetMaker)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.DB.createTreeSet(org.mapdb.DB$BTreeSetMaker)"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 5, "MOV": 2, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createAtomicVar(java.lang.String,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createQueue(java.lang.String,org.mapdb.Serializer,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createCircularQueue(java.lang.String,org.mapdb.Serializer,long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createStack(java.lang.String,org.mapdb.Serializer,boolean)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue517Test"}], "spoonFilePath": "Issue517Test.java"}], "commitMessage": "DB: non serializable serializer could leave name catalog in semi-locked state. Add assertion before Name Catalog is touched. Fix #517\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-18 16:20:04"}, {"commitUser": "jankotek", "commitDateTime": "2015-06-18 16:33:05", "commitHash": "479c6dc69e61ae1f4cd39f1810de0fa51c5751db", "commitParents": ["6ea1373b43537f0d0dece9679e7bcdaaac92256a"], "commitGHEventType": "referenced", "nameRev": "479c6dc69e61ae1f4cd39f1810de0fa51c5751db tags/mapdb-2.0-beta1~18", "commitGitStats": [{"insertions": 38, "lines": 38, "filePath": "src/test/java/org/mapdb/Issue517Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue517Test"}], "spoonFilePath": "Issue517Test.java"}], "commitMessage": "Add test case for #517, not problem since we allow non-serializable serializers\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-18 16:33:05"}], "created": "2015-05-23 03:26:01"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/515", "title": "java.lang.AssertionError: data were not fully read, check your serializer ", "closed": "2015-08-07 12:44:57", "commitsDetails": [], "commits": {}, "ttf": 76.00027777777778, "created": "2015-05-22 16:55:48", "user": "fabiankessler", "body": "Exception in thread \"main\" java.lang.AssertionError: data were not fully read, check your serializer \n    at org.mapdb.Store.deserialize(Store.java:299)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:336)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:320)\n    at org.mapdb.Caches$HashTable.get(Caches.java:246)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n    at org.mapdb.BTreeMap$BTreeIterator.advance(BTreeMap.java:924)\n    at org.mapdb.BTreeMap$BTreeValueIterator.next(BTreeMap.java:1066)\n    at (my code)Words.printStats(Words.java:129)\n    at (my code)printStats(SingleTypeWordsData2.java:53)\n    at (my code)DiscoveryApp2.<init>(DiscoveryApp2.java:36)\n    at (my code)App.<init>(App.java:38)\n    at (my code)App.main(App.java:43)\n\nMy environment:\nVersion 1.0.7\nWindows 8.1 64bit\nSSD Disk\n\nCommitting after every change.\nNo custom serializer, nothing special.\n\nOne program run finished successfully.\nNext the program cannot start, it aborts with this Error.\n\nThe broken db is here: \nhttps://mega.co.nz/#!WlRGWRjZ!edBjNo83zbyCi66KozO9ngY4pHsST5utcLfIORJ6Y8g\n\nI can re-generate my data, it just takes hours. Because I am committing after every change.\nWhat am I doing wrong, why do I run into corrupted DBs all the time, what can I change?\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/514", "title": "java.io.IOError: java.io.IOException: Zero Header, data corrupted", "closed": "2015-07-05 21:17:20", "commitsDetails": [], "commits": {}, "ttf": 44.000277777777775, "created": "2015-05-22 14:24:03", "user": "fabiankessler", "body": "Using MapDB 1.0.7\nWindows 8.1 64bit\nDisk=SSD\n\nI work with a map that I get with map = db.getTreeMap(identifier) and then commit after every modification in map with db.commit();\n\nI was running the program in the IDE (IntelliJ). Then IntelliJ itself run out of memory in another project, and closed (killed) all windows. Now the mapdb data is broken.\n\nThe exception happens when _accessing_ the map. Deleting the .t file did not help.\nThe broken database is available here: https://mega.co.nz/#!CkokVD5Q!rQMQZ7-NUjqjvaczr49euPIQm164pvnMnsruRWYraQw\n"}, {"labels": ["bug"], "filteredCommits": ["e4a449052c5c4efd3fdfef8556882ee1299158ab"], "url": "https://github.com/jankotek/mapdb/issues/513", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 2, "lines": 12, "deletions": 1}, "numCommits": 1, "commits": {"e4a449052c5c4efd3fdfef8556882ee1299158ab": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 28.00027777777778, "user": "jrumbinas", "changesInPackagesSPOON": ["org.mapdb.DB.getAtomicVar(java.lang.String)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Calling DB.getAtomicVar() for non existing record will result in exception error (in 1.0.7)\n#### Exception\n\n```\njava.lang.AssertionError\n    at org.mapdb.StoreWAL.put(StoreWAL.java:199)\n    at org.mapdb.Caches$HashTable.put(Caches.java:216)\n    at org.mapdb.EngineWrapper.put(EngineWrapper.java:53)\n    at org.mapdb.DB.createAtomicVar(DB.java:1393)\n    at org.mapdb.DB.getAtomicVar(DB.java:1418)\n```\n#### Cause\n\n``` java\n    synchronized public <E> Atomic.Var<E> getAtomicVar(String name){\n        ...\n        if(type==null){\n            ...\n            return createAtomicVar(name, null, getDefaultSerializer());\n        }\n        return ret;\n    }\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 0}, "title": "AssertionError in getAtomicVar", "statsSkippedReason": "", "closed": "2015-06-18 12:38:35", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-06-18 15:37:29", "commitHash": "e4a449052c5c4efd3fdfef8556882ee1299158ab", "commitParents": ["11cdfc65364283c4991e383c3754645bbc84f2ab"], "commitGHEventType": "referenced", "nameRev": "e4a449052c5c4efd3fdfef8556882ee1299158ab tags/mapdb-renamed-1.0.8~14", "commitGitStats": [{"insertions": 10, "lines": 11, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/Issue254Test.java", "deletions": 1}, {"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/Atomic.java", "deletions": 0}, {"insertions": 57, "lines": 57, "filePath": "src/test/java/org/mapdb/Issue513Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "Atomic.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DB.getAtomicVar(java.lang.String)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Issue254Test.atomic_var()"}], "spoonFilePath": "Issue254Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue513Test"}], "spoonFilePath": "Issue513Test.java"}], "commitMessage": "Atomic.Var: store does not allow `null` values. Change initial value from `null` to empty string `\"\"`. Fix #513\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-18 15:37:29"}], "created": "2015-05-20 18:59:09"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/510", "title": "java.io.IOError: java.io.IOException: The parameter is incorrect", "closed": "2015-07-05 21:45:11", "commitsDetails": [], "commits": {}, "ttf": 56.000277777777775, "created": "2015-05-10 10:14:13", "user": "fabiankessler", "body": "On this line:\n\n```\n    DB db = DBMaker.newFileDB(persistencePath)\n            .closeOnJvmShutdown()\n            .make();\n```\n\nMy disk looks fine. My last program run did not end in an exception. Now my program can't start anymore.\n\n```\nException in thread \"main\" java.io.IOError: java.io.IOException: The parameter is incorrect\n    at org.mapdb.Volume$FileChannelVol.putData(Volume.java:840)\n    at org.mapdb.StoreWAL.replayLogFile(StoreWAL.java:821)\n    at org.mapdb.StoreWAL.<init>(StoreWAL.java:84)\n    at org.mapdb.DBMaker.extendStoreWAL(DBMaker.java:928)\n    at org.mapdb.DBMaker.makeEngine(DBMaker.java:722)\n    at org.mapdb.DBMaker.make(DBMaker.java:665)\n    at my.MyClass.build(WordsBuilder.java:45)\nCaused by: java.io.IOException: The parameter is incorrect\n    at sun.nio.ch.FileDispatcherImpl.pwrite0(Native Method)\n    at sun.nio.ch.FileDispatcherImpl.pwrite(FileDispatcherImpl.java:80)\n    at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:89)\n    at sun.nio.ch.IOUtil.write(IOUtil.java:65)\n    at sun.nio.ch.FileChannelImpl.writeInternal(FileChannelImpl.java:738)\n    at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:720)\n    at org.mapdb.Volume$FileChannelVol.writeFully(Volume.java:766)\n    at org.mapdb.Volume$FileChannelVol.putData(Volume.java:838)\n    ... 9 more\n```\n\nMy (corrupted?) mapdb files for download: https://mega.co.nz/#!ThI11YrR!93DGd1hJaXVyWfoWC06a1G-xMBEfJyNX40r9wvp5Wvo\n\nIs there any way to recover, without losing data?\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/509", "title": "SEVERE: java.lang.AssertionError: unknown trans log instruction '0' at log offset: 16", "closed": "2015-08-07 12:44:47", "commitsDetails": [], "commits": {}, "ttf": 90.00027777777778, "created": "2015-05-08 18:59:05", "user": "cszamudio", "body": "I started seeing this AssertionError on MapDB version 1.0.7. \n\n```\nMay 07, 2015 11:47:01 AM org.mapdb.StoreWAL replayLogFile\nSEVERE: java.lang.AssertionError: unknown trans log instruction '0' at log offset: 16\n```\n\nI noticed that this issue was resolved in 1.0.5, but I think it might still be an issue.\n\nI am using a very simple map created as:\n\n```\ndb = DBMaker.newFileDB(dbFile)\n                .make();\n```\n\nThe map has over 2 million simple entries <Integer, Date>\nwith no concurrent access to the map.  The error occurs on the db.commit() statement.\n\n```\nMay 07, 2015 11:47:01 AM org.mapdb.StoreWAL replayLogFile\nSEVERE: java.lang.AssertionError: unknown trans log instruction '0' at log offset: 16\n     at org.mapdb.StoreWAL.replayLogFile(StoreWAL.java:827)\n     at org.mapdb.StoreWAL.commit(StoreWAL.java:606)\n     at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n     at org.mapdb.DB.commit(DB.java:1605)\n```\n\nIt's intermittent.  The MapDb file is still readable and I can subsequently add and remove to it even after the error is thrown by closing and then re-opening.\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/508", "title": "Huge_Insert Example Breaks with File Read Iterator", "closed": "2015-08-07 12:45:22", "commitsDetails": [], "commits": {}, "ttf": 92.00027777777778, "created": "2015-05-06 21:32:13", "user": "alex-ayala", "body": "The Huge_Load.java in the examples package works well when creating sample random data, but throws a NullPointerException when implementing the source Iterator to read from a file instead (using version 1.0.7 but also replicated in 1.0.6). See example below:\n\n``` java\npublic class Huge_Insert {\n    private static final String TEST_FILE_LOC = \"<PATH TO 5500 RECORD FILE>\";\n\n    public static void main(String[] args) throws IOException {\n\n        /** max number of elements to import */\n        final long max = (int) 1e6;\n\n        /**\n         * Open database in temporary directory\n         */\n        File dbFile = File.createTempFile(\"mapdb\",\"temp\");\n        DB db = DBMaker\n                .newFileDB(dbFile)\n                /** disabling Write Ahead Log makes import much faster */\n                .transactionDisable()\n                .make();\n\n\n        long time = System.currentTimeMillis();\n\n         // WORKS\n        /**\n         * Source of data which randomly generates strings.\n         * In real world this would return data from file.\n         */\n        /*Iterator<String> source = new Iterator<String>() {\n\n            long counter = 0;\n\n            @Override public boolean hasNext() {\n                return counter<max;\n            }\n\n            @Override\n            public String next() {\n                counter++;\n                return randomString(randInt(60, 100));\n            }\n\n            @Override public void remove() {}\n        };*/\n\n         // DOES NOT WORK\n        Iterator<String> source = new Iterator<String>() {\n            String line = \"\";\n            long counter = 0;\n            BufferedReader br = new BufferedReader(new FileReader(testFileLoc));\n            @Override public boolean hasNext() {\n                boolean hasNext = false;\n                try {\n                    if (counter<max && br.ready()) {\n                        hasNext = true;\n                        line = br.readLine();\n                    } else {\n                        hasNext = false;\n                        br.close();\n                    }\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n\n                return hasNext;\n            }\n\n            @Override\n            public String next() {\n                try {\n                    br.readLine();\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n                counter++;\n                return randomString(randInt(50, 90));\n            }\n\n            @Override public void remove() {}\n        };\n\n         // DOES NOT WORK\n        //Iterator<String> source = FileUtils.lineIterator(new File(TEST_FILE_LOC), \"UTF-8\");\n\n        /**\n         * BTreeMap Data Pump requires data source to be presorted in reverse order (highest to lowest).\n         * There is method in Data Pump we can use to sort data. It uses temporarly files and can handle fairly\n         * large data sets.\n         */\n        source = Pump.sort(source,\n                true, 100000,\n                Collections.reverseOrder(Fun.COMPARATOR), //reverse  order comparator\n                db.getDefaultSerializer()\n                //null //sort in single threaded mode\n                );\n\n\n\n        /**\n         * Disk space used by serialized keys should be minimised.\n         * Keys are sorted, so only difference between consequential keys is stored.\n         * This method is called delta-packing and typically saves 60% of disk space.\n         */\n        BTreeKeySerializer keySerializer = BTreeKeySerializer.STRING;\n\n\n        /**\n         * Translates Map Key into Map Value.\n         */\n        Fun.Function1<Integer,String> valueExtractor = new Fun.Function1<Integer, String>() {\n            @Override public Integer run(String s) {\n                return s.hashCode();\n            }\n        };\n\n        /**\n         * Create BTreeMap and fill it with data\n         */\n        Map<String,Integer> map = db.createTreeMap(\"map\")\n                .pumpSource(source,valueExtractor)\n                //.pumpPresort(100000) // for presorting data we could also use this method\n                .keySerializer(keySerializer)\n                .make();\n\n\n        System.out.println(\"Finished; total time: \"+(System.currentTimeMillis()-time)/1000+\"s; there are \"+map.size()+\" items in map\");\n        db.close();\n\n    }\n\n    public static String randomString(int size) {\n        String chars = \"0123456789abcdefghijklmnopqrstuvwxyz !@#$%^&*()_+=-{}[]:\\\",./<>?|\\\\\";\n        StringBuilder b = new StringBuilder(size);\n        Random r = new Random();\n        for(int i=0;i<size;i++){\n            b.append(chars.charAt(r.nextInt(chars.length())));\n        }\n        return b.toString();\n    }\n\n    public static int randInt(int min, int max) {\n\n        // NOTE: Usually this should be a field rather than a method\n        // variable so that it is not re-seeded every call.\n        Random rand = new Random();\n\n        // nextInt is normally exclusive of the top value,\n        // so add 1 to make it inclusive\n        int randomNum = rand.nextInt((max - min) + 1) + min;\n\n        return randomNum;\n    }\n}\n```\n\nAs you can see, I don't even need to be returning the line read from the file in the next() method. You'll see i'm also using apache-commons io library to create a file iterator for me in case I was doing something incorrectly, but this also causes the same issue. I generated dummy data so if you have issues replicating I can provide the data i'm using.\n\nBelow is the stacktrace of the exception:\n\n``` java\nException in thread \"main\" java.lang.NullPointerException\n    at org.mapdb.BTreeKeySerializer$3.serialize(BTreeKeySerializer.java:183)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:385)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:288)\n    at org.mapdb.Store.serialize(Store.java:154)\n    at org.mapdb.StoreDirect.put(StoreDirect.java:354)\n    at org.mapdb.Caches$HashTable.put(Caches.java:216)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:470)\n    at org.mapdb.DB.createTreeMap(DB.java:849)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:644)\n    at mapdb.examples.Huge_Insert.main(Huge_Insert.java:140)\n```\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/504", "title": "RandomAccessFileVol Error", "closed": "2015-08-27 15:30:09", "commitsDetails": [], "commits": {}, "ttf": 113.00027777777778, "created": "2015-05-06 05:14:43", "user": "whybe", "body": "After `VolumeIOError` exception occured, It spit `IndexOutOfBoundsException` out over again.\n\nI guess, it exceeded maximum count of **WAL** file, _15_. Am I right?\n\nHow can I avoid this kind of situation?\n\nI use https://github.com/jankotek/MapDB/commit/be0f1a1503e471a47674503f6d8837d99dfea582\n\n> [36704] ERROR [Thread-3]: MessageSubscriber.lambda$storeMessage$85(44) :: IO failed\n> org.mapdb.DBException$VolumeIOError: IO failed\n>     at org.mapdb.Volume$RandomAccessFileVol.<init>(Volume.java:1791)\n>     at org.mapdb.Volume$RandomAccessFileVol$1.makeVolume(Volume.java:1780)\n>     at org.mapdb.Volume$VolumeFactory.makeVolume(Volume.java:52)\n>     at org.mapdb.StoreWAL.walStartNextFile(StoreWAL.java:254)\n>     at org.mapdb.StoreWAL.commit(StoreWAL.java:829)\n>     at org.mapdb.TxEngine.superCommit(TxEngine.java:326)\n>     at org.mapdb.TxEngine$Tx.commit(TxEngine.java:549)\n>     at org.mapdb.DB.commit(DB.java:2169)\n>     at org.mapdb.TxMaker.execute(TxMaker.java:103)\n>     at com.uaps.glr.rx.store.MessageStoreService.lambda$null$22(MessageStoreService.java:50)\n>     at com.uaps.glr.rx.store.MessageStoreService.access$lambda$16(MessageStoreService.java)\n>     at com.uaps.glr.rx.store.MessageStoreService$$Lambda$29.call(Unknown Source)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable.unsafeSubscribe(Observable.java:7495)\n>     at rx.internal.operators.OnSubscribeUsing.call(OnSubscribeUsing.java:76)\n>     at rx.internal.operators.OnSubscribeUsing.call(OnSubscribeUsing.java:34)\n>     at rx.Observable.unsafeSubscribe(Observable.java:7495)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n>     at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n>     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:43)\n>     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:32)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable.subscribe(Observable.java:7585)\n>     at rx.Observable.subscribe(Observable.java:7416)\n>     at com.uaps.glr.rx.subscriber.MessageSubscriber.storeMessage(MessageSubscriber.java:39)\n>     at com.uaps.glr.rx.subscriber.MessageSubscriber.<init>(MessageSubscriber.java:32)\n>     at com.uaps.glr.SocketConnection.DataReceive(SocketConnection.java:246)\n>     at com.uaps.glr.SocketConnectionMgr.run(SocketConnectionMgr.java:108)\n> Caused by: java.io.FileNotFoundException: mapdb/store.mapdb.wal.15 (Too many open files in system)\n>     at java.io.RandomAccessFile.open(Native Method)\n>     at java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n>     at org.mapdb.Volume$RandomAccessFileVol.<init>(Volume.java:1789)\n>     ... 33 more\n\nrepeatedly spit it out\n\n> [36709] ERROR [Thread-3]: MessageSubscriber.lambda$storeMessage$85(44) :: Index: 15, Size: 15\n> java.lang.IndexOutOfBoundsException: Index: 15, Size: 15\n>     at java.util.ArrayList.RangeCheck(ArrayList.java:547)\n>     at java.util.ArrayList.get(ArrayList.java:322)\n>     at java.util.Collections$SynchronizedList.get(Collections.java:1820)\n>     at org.mapdb.StoreWAL.loadLongStackPage(StoreWAL.java:472)\n>     at org.mapdb.StoreCached.longStackPut(StoreCached.java:140)\n>     at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:540)\n>     at org.mapdb.StoreDirect.freeDataPut(StoreDirect.java:517)\n>     at org.mapdb.StoreDirect.update2(StoreDirect.java:298)\n>     at org.mapdb.StoreCached.flushWriteCacheSegment(StoreCached.java:350)\n>     at org.mapdb.StoreWAL.commit(StoreWAL.java:753)\n>     at org.mapdb.TxEngine.superCommit(TxEngine.java:326)\n>     at org.mapdb.TxEngine$Tx.commit(TxEngine.java:549)\n>     at org.mapdb.DB.commit(DB.java:2169)\n>     at org.mapdb.TxMaker.execute(TxMaker.java:103)\n>     at com.uaps.glr.rx.store.MessageStoreService.lambda$null$22(MessageStoreService.java:50)\n>     at com.uaps.glr.rx.store.MessageStoreService.access$lambda$16(MessageStoreService.java)\n>     at com.uaps.glr.rx.store.MessageStoreService$$Lambda$29.call(Unknown Source)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable.unsafeSubscribe(Observable.java:7495)\n>     at rx.internal.operators.OnSubscribeUsing.call(OnSubscribeUsing.java:76)\n>     at rx.internal.operators.OnSubscribeUsing.call(OnSubscribeUsing.java:34)\n>     at rx.Observable.unsafeSubscribe(Observable.java:7495)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185)\n>     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n>     at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n>     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:43)\n>     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:32)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable$1.call(Observable.java:144)\n>     at rx.Observable$1.call(Observable.java:136)\n>     at rx.Observable.subscribe(Observable.java:7585)\n>     at rx.Observable.subscribe(Observable.java:7416)\n>     at com.uaps.glr.rx.subscriber.MessageSubscriber.storeMessage(MessageSubscriber.java:39)\n>     at com.uaps.glr.rx.subscriber.MessageSubscriber.<init>(MessageSubscriber.java:32)\n>     at com.uaps.glr.SocketConnection.DataReceive(SocketConnection.java:246)\n>     at com.uaps.glr.SocketConnectionMgr.run(SocketConnectionMgr.java:108)\n> \n> ```\n> ```\n"}, {"labels": ["2.0", "bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/503", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"46a2e9543526d5010559fb4d951465ecc2289873": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "batterseapower", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "https://github.com/jankotek/MapDB/blob/master/src/main/java/org/mapdb/StoreWAL.java#L1193\n\nThis means you can't e.g. rename a DB that you have just created (and then closed) using the WAL.\n\nNote that you do call vol.close e.g. after replay (https://github.com/jankotek/MapDB/blob/master/src/main/java/org/mapdb/StoreWAL.java#L994), the lack of a close in the close method itself seems to be an oversight.\n\nCould be related to #457 ?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "StoreWAL.close does not call vol.close and so leaks file handles", "statsSkippedReason": "", "closed": "2015-05-05 14:09:15", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-05-05 17:09:03", "commitHash": "46a2e9543526d5010559fb4d951465ecc2289873", "commitParents": ["0f50921e0ef3d536569b31c370ba8d66c744bde7"], "commitGHEventType": "closed", "nameRev": "46a2e9543526d5010559fb4d951465ecc2289873 tags/mapdb-2.0-alpha3~52", "commitGitStats": [{"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/UnsafeStuff.java", "deletions": 0}, {"insertions": 34, "lines": 63, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 29}, {"insertions": 63, "lines": 81, "filePath": "src/test/java/org/mapdb/EngineTest.java", "deletions": 18}, {"insertions": 27, "lines": 38, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 11}, {"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreCached.java", "deletions": 0}, {"insertions": 15, "lines": 15, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 28, "lines": 30, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}, {"insertions": 13, "lines": 23, "filePath": "src/test/java/org/mapdb/StoreCachedTest.java", "deletions": 10}, {"insertions": 6, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCached.initHeadVol()"}], "spoonFilePath": "StoreCached.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.close()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UnsafeStuff.UnsafeVolume.close()"}], "spoonFilePath": "UnsafeStuff.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.test_phys_record_reused_COMPACT()"}, {"UPD": 0, "TOT": 22, "DEL": 11, "INS": 10, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirectTest.compact_keeps_volume_type()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack_no_commit()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_created_after_put()"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack_no_commit()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take_simple()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_record_delete_and_reuse_large_COMPACT()"}, {"UPD": 0, "TOT": 9, "DEL": 0, "INS": 2, "MOV": 7, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_puts_record_offset_into_index()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take2()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_put_five()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.prealloc()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_overflow()"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 9, "TOT": 10, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCachedTest.flush_write_cache()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.StoreCachedTest.put_update_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCachedTest.put_delete()"}], "spoonFilePath": "StoreCachedTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 19, "DEL": 9, "INS": 9, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_long()"}, {"UPD": 0, "TOT": 24, "DEL": 11, "INS": 12, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.compact_tx_works(boolean,boolean)"}, {"UPD": 0, "TOT": 11, "DEL": 5, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_created()"}, {"UPD": 0, "TOT": 33, "DEL": 16, "INS": 16, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_mixed()"}, {"UPD": 0, "TOT": 31, "DEL": 14, "INS": 16, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.walCompactSwap(boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.compact_tx_works(boolean,boolean).1.run()"}, {"UPD": 0, "TOT": 19, "DEL": 8, "INS": 10, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.compact_record_file_used()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.initHeadVol()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayWAL()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.initOpen()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.isClosed()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.finalize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ReadOnly.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.SingleByteArrayVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteArrayVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.close()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_larger()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact_large_record()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.put_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.first_recid()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.init()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_commit()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.put_get_large()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.reserved_recid_exists()"}, {"UPD": 0, "TOT": 14, "DEL": 6, "INS": 4, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.update_reserved_recid()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.compact()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.double_close()"}, {"UPD": 0, "TOT": 11, "DEL": 5, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.cas_uses_serializer()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.large_record_update()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.get_non_existent()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_put()"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.par_cas().3.call()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.rollback()"}, {"UPD": 0, "TOT": 13, "DEL": 4, "INS": 4, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.par_cas()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen_nocommit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_cas()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.nosize_array()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.cas_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.testSetGet()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_delete()"}, {"UPD": 0, "TOT": 17, "DEL": 8, "INS": 8, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.putGetUpdateDelete()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.large_record()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.preallocate_cas()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get_large()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 2, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.rollback_reopen()"}, {"UPD": 0, "TOT": 12, "DEL": 6, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.update_reserved_recid_large()"}, {"UPD": 0, "TOT": 13, "DEL": 0, "INS": 3, "MOV": 10, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_commit2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_update()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.compact_double_recid_reuse()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.preallocate_get_update_delete_update_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact0()"}, {"UPD": 0, "TOT": 7, "DEL": 2, "INS": 2, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.par_update_get().2.call()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.delete_and_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_delete()"}, {"UPD": 0, "TOT": 10, "DEL": 4, "INS": 3, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.par_update_get()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_get()"}, {"UPD": 0, "TOT": 25, "DEL": 12, "INS": 12, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.zero_size_serializer()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_rollback()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.get_non_existent_after_delete_and_compact()"}], "spoonFilePath": "EngineTest.java"}], "commitMessage": "Stores: fix file handle leaks. Fix #503 and #457\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-05 17:09:03"}], "created": "2015-05-04 19:26:03"}, {"labels": ["2.0", "bug"], "filteredCommits": ["9e1525e55c4745cfdb6d5cb93980a5d3380f4235"], "url": "https://github.com/jankotek/mapdb/issues/502", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 6, "deletions": 5}, "numCommits": 1, "commits": {"9e1525e55c4745cfdb6d5cb93980a5d3380f4235": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "simon-greatrix", "changesInPackagesSPOON": ["org.mapdb.Volume.FileChannelVol.ensureAvailable(long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The existing `tryAvailable` method looks like this:\n\n``` java\n        @Override\n        public boolean tryAvailable(long offset) {\n            if(hasLimit && offset>sizeLimit) return false;\n            if(offset% chunkSize !=0)\n                offset += chunkSize - offset% chunkSize; //round up to multiply of chunk size\n\n            if(offset>size)synchronized (growLock){\n                try {\n                    channel.truncate(offset);\n                    size = offset;\n                } catch (IOException e) {\n                    throw new IOError(e);\n                }\n            }\n            return true;\n        }\n```\n\nThe `FileChannel.truncate` method does not grow the file if the new size is larger than the current size. As far as I can tell the call to truncate above will never do anything and does not fulfill the methods contract to test if the storage will be available.\n\nI believe that:\n\n`channel.truncate(offset)`\n\nshould be replaced with\n\n`raf.setLength(offset)`\n\nFor reference, the JavaDoc:\n\nhttps://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#setLength(long)\n\nhttps://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#truncate(long)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "spoonFilesChanged": 1, "MOV": 0}, "title": "FileChannelVol.tryAvailable(long) does not test if storage is available (1.0.7)", "statsSkippedReason": "", "closed": "2015-05-02 20:34:37", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-05-02 23:34:29", "commitHash": "9e1525e55c4745cfdb6d5cb93980a5d3380f4235", "commitParents": ["181f8f119a4f66f0eb8789fad6e07a66f8b4bc20"], "commitGHEventType": "closed", "nameRev": "9e1525e55c4745cfdb6d5cb93980a5d3380f4235 tags/mapdb-2.0-alpha3~64", "commitGitStats": [{"insertions": 1, "lines": 6, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.ensureAvailable(long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume.FileChannel: ensure available did not increase file size. Fix #502.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-02 23:34:29"}], "created": "2015-05-01 23:14:25"}, {"labels": ["2.0", "bug"], "filteredCommits": ["881e31a4ba43c3a95aaf04e8e2191d19d2f87f31"], "url": "https://github.com/jankotek/mapdb/issues/501", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 6, "deletions": 3}, "numCommits": 1, "commits": {"881e31a4ba43c3a95aaf04e8e2191d19d2f87f31": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 2.000277777777778, "user": "batterseapower", "changesInPackagesSPOON": ["SPOON_EXCEPTION"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The gist at https://gist.github.com/batterseapower/b59125cfb831933f6a27 shows how this can occur.\n\nA simple fix is to remove the synchronized keyword from getNameForObject (the map it accesses is synchronized anyway!) and then stop mutating that map to a dummy value in close()\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "spoonFilesChanged": 1}, "title": "Possible deadlock between DB.getNameForObject and DB.commit", "statsSkippedReason": "", "closed": "2015-05-02 20:41:45", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-05-02 23:41:35", "commitHash": "881e31a4ba43c3a95aaf04e8e2191d19d2f87f31", "commitParents": ["9e1525e55c4745cfdb6d5cb93980a5d3380f4235"], "commitGHEventType": "closed", "nameRev": "881e31a4ba43c3a95aaf04e8e2191d19d2f87f31 tags/mapdb-2.0-alpha3~63", "commitGitStats": [{"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}], "commitMessage": "DB: Possible deadlock between DB.getNameForObject and DB.commit. Fix #501\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-02 23:41:35"}], "created": "2015-04-30 06:06:23"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/496", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"34da7019c2dc99cf7759f2844664baaaf0f36077": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 105.00027777777778, "user": "fasterdude7", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "Hi this is like https://github.com/jankotek/MapDB/issues/335\nthe problem is the thread is interrupted and we never close the `.p` file because when we try to close the index it throws an exeption and the phys file never gets to be closed.\nthe problem is in finally block of the constructor of StoreDirect:\n\n```\n           if(!allGood){\n                //exception was thrown, try to unlock files\n                if(index!=null){\n                    index.sync();\n                    index.close();//WARNING might throw an exception, if so the phys file is not closed.\n                    index = null;\n                }\n                if(phys!=null){\n                    phys.sync();\n                    phys.close();//I am not called if index.close() or index.sync() or phys.sync() throws an exception.\n                    phys = null;\n                }\n            }\n```\n\nI will have a solution soon, although it is getting close to beer o'clock...\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "File resource is never relases if thread is interrupted while StoreDirect is being constructed", "statsSkippedReason": "", "closed": "2015-08-07 12:44:04", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-04-28 12:24:01", "commitHash": "34da7019c2dc99cf7759f2844664baaaf0f36077", "commitParents": ["29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0"], "commitGHEventType": "referenced", "nameRev": "34da7019c2dc99cf7759f2844664baaaf0f36077 tags/mapdb-renamed-1.0.8~20", "commitGitStats": [{"insertions": 12, "lines": 21, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 9}, {"insertions": 54, "lines": 54, "filePath": "src/test/java/org/mapdb/Issue490.java", "deletions": 0}, {"insertions": 20, "lines": 29, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 9}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 9, "DEL": 0, "INS": 3, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirect"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue490"}], "spoonFilePath": "Issue490.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.AsyncWriteEngine.close()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "Release resources when StoreDirect and AsyncWriteEngine are closed\n\nFix #490, Fix #496. Merge pull request #500\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-04-28 12:24:01"}], "created": "2015-04-24 07:44:56"}, {"labels": ["2.0", "bug"], "filteredCommits": ["3f5589a518d1693e5b8e4e86f2fafa805f8662e5", "55f15b73a58a288025d1abe7074618fcc788137a", "5363e99175c8a788b08392fcaf0094903a526e58"], "url": "https://github.com/jankotek/mapdb/issues/495", "gitStatsSummary": {"insertions": 44, "gitFilesChange": 1, "lines": 80, "deletions": 36}, "numCommits": 1, "commits": {"55f15b73a58a288025d1abe7074618fcc788137a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "5363e99175c8a788b08392fcaf0094903a526e58": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "2eeb86cdda53cc791cd0ae0cd543d8f598c70847": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "3f5589a518d1693e5b8e4e86f2fafa805f8662e5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "f947e9595ff1ec2e2d44f032c6d7729b749c6038": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 126.00027777777778, "user": "RoundSparrow", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.deserializeUnknownHeader(java.io.DataInput,int,org.mapdb.FastArrayList)", "org.mapdb.SerializerPojo.createInstanceSkippinkConstructor(java.lang.Class)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "My app has no field named \"loadFactor\" - I assume it's some internal MapDB error?\n\n.RuntimeException: Could not set field value: loadFactor - class java.util.LinkedHashMap\n            at org.mapdb.SerializerPojo$FieldInfo.<init>(SerializerPojo.java:212)\n\nIt isn't happening on all uses of my Map - not sure what the factor is at this point.  Looking for suggestions on how to track it down.\n", "filteredCommitsReason": {"duplicated": 2, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 2, "TOT": 8, "DEL": 4, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Internal field failure in SerializerPojo?", "statsSkippedReason": "", "closed": "2015-08-27 15:54:40", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 09:26:10", "commitHash": "55f15b73a58a288025d1abe7074618fcc788137a", "commitParents": ["d91f859ba6cddcf1c9a0eccb18e61048597b0de2"], "commitGHEventType": "referenced", "nameRev": "55f15b73a58a288025d1abe7074618fcc788137a tags/mapdb-2.0-beta2~12", "commitGitStats": [{"insertions": 77, "lines": 80, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.MM"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace2Wrap()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.SS"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplaceWrap()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "SerializerPojo: add tests to isolate #495, no luck so far\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 09:26:10"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-27 18:52:29", "commitHash": "5363e99175c8a788b08392fcaf0094903a526e58", "commitParents": ["fb374b4d5600b10d22d9d6c78c7447d69bbdd3b5"], "commitGHEventType": "referenced", "nameRev": "5363e99175c8a788b08392fcaf0094903a526e58 tags/mapdb-2.0-beta7~21", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.java_serialization_writeReplace_in_object_graph()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.WriteReplaceBB"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.pojo_serialization_writeReplace_in_object_graph()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.WriteReplaceAA"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "Add test case to replicate issue #495\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-27 18:52:29"}, {"commitUser": "jankotek", "commitDateTime": "2015-05-27 01:56:15", "commitHash": "2eeb86cdda53cc791cd0ae0cd543d8f598c70847", "commitParents": ["67b40e65067d131ca47dc49f64e2d1e259a86f12"], "commitGHEventType": "referenced", "nameRev": "2eeb86cdda53cc791cd0ae0cd543d8f598c70847 tags/mapdb-renamed-1.0.8~18", "commitGitStats": [{"insertions": 72, "lines": 77, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.MM"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace2Wrap()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.SS"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplace()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testWriteReplaceWrap()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "SerializerPojo: add tests to isolate #495, no luck so far\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-27 01:56:15"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-27 19:07:27", "commitHash": "3f5589a518d1693e5b8e4e86f2fafa805f8662e5", "commitParents": ["f947e9595ff1ec2e2d44f032c6d7729b749c6038"], "commitGHEventType": "referenced", "nameRev": "3f5589a518d1693e5b8e4e86f2fafa805f8662e5 tags/mapdb-2.0-beta7~19", "commitGitStats": [{"insertions": 44, "lines": 80, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 36}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.deserializeUnknownHeader(java.io.DataInput,int,org.mapdb.FastArrayList)"}, {"UPD": 0, "TOT": 6, "DEL": 4, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.createInstanceSkippinkConstructor(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}], "commitMessage": "Fix previous test case. See #495\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-27 19:07:27"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-27 18:53:55", "commitHash": "f947e9595ff1ec2e2d44f032c6d7729b749c6038", "commitParents": ["5363e99175c8a788b08392fcaf0094903a526e58"], "commitGHEventType": "referenced", "nameRev": "f947e9595ff1ec2e2d44f032c6d7729b749c6038 tags/mapdb-2.0-beta7~20", "commitGitStats": [{"insertions": 4, "lines": 6, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.java_serialization_writeReplace_in_object_graph()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.pojo_serialization_writeReplace_in_object_graph()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "Fix previous test case. See #495\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-27 18:53:55"}], "created": "2015-04-23 15:37:31"}, {"labels": ["bug"], "filteredCommits": ["6dc0d44f2dac459a71e405ee941eae1f4c9b785e"], "url": "https://github.com/jankotek/mapdb/issues/490", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 4, "deletions": 2}, "numCommits": 1, "commits": {"34da7019c2dc99cf7759f2844664baaaf0f36077": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "6dc0d44f2dac459a71e405ee941eae1f4c9b785e": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 300.0002777777778, "user": "fasterdude7", "changesInPackagesSPOON": ["org.mapdb.AsyncWriteEngine.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi this is similar to the previouse issue i fixed:\nhttps://github.com/jankotek/MapDB/issues/335\n\nThe problem is nothing to do with writing to a file with a thread that has been interrrupted.\nThe problem here is the thread gets interrupted but because the thread can not write to the disk it throws an exception and we never get to close the files we opened. This is really painful on windows as we can't delete those files until the JVM shuts down.\n\nI think the problem is in AsyncWriteEngine#close()\nthe code looks like this.\n\n```\n@Override\n    public void close() {\n        commitLock.writeLock().lock();\n        try {\n            if(closeInProgress) return;\n            checkState();\n            closeInProgress = true;\n            //...\n            //Stuff to ready the actual close and a call to close here\n            //...\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            commitLock.writeLock().unlock();\n        }\n    }\n```\n\nI think the problem is in the checkState() call, where it throws an exception if the async writter thread caught an exception.\n\ni guess the solution would be to surround the checkState(); call in a try finally block.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 2}, "title": "File resources are never released after a thread is interrupted when using asyncWriteEnable()", "statsSkippedReason": "", "closed": "2016-02-15 09:38:42", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-04-28 12:24:01", "commitHash": "34da7019c2dc99cf7759f2844664baaaf0f36077", "commitParents": ["29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0"], "commitGHEventType": "referenced", "nameRev": "34da7019c2dc99cf7759f2844664baaaf0f36077 tags/mapdb-renamed-1.0.8~20", "commitGitStats": [{"insertions": 12, "lines": 21, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 9}, {"insertions": 54, "lines": 54, "filePath": "src/test/java/org/mapdb/Issue490.java", "deletions": 0}, {"insertions": 20, "lines": 29, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 9}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 9, "DEL": 0, "INS": 3, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirect"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue490"}], "spoonFilePath": "Issue490.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.AsyncWriteEngine.close()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "Release resources when StoreDirect and AsyncWriteEngine are closed\n\nFix #490, Fix #496. Merge pull request #500\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-04-28 12:24:01"}, {"commitUser": "jankotek", "commitDateTime": "2016-02-15 11:28:55", "commitHash": "6dc0d44f2dac459a71e405ee941eae1f4c9b785e", "commitParents": ["e88af60d60d6308122396c30138fb579d84b8ffd"], "commitGHEventType": "referenced", "nameRev": "6dc0d44f2dac459a71e405ee941eae1f4c9b785e tags/mapdb-1.0.9~1", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.AsyncWriteEngine.close()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "File resources are never released after a thread is interrupted when using asyncWriteEnable(), Fix #490\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2016-02-15 11:28:55"}], "created": "2015-04-20 23:55:55"}, {"labels": ["2.0", "bug"], "filteredCommits": ["cb1f659041ac04fca9e95a7c055d89c21668fff6"], "url": "https://github.com/jankotek/mapdb/issues/479", "gitStatsSummary": {"insertions": 15, "gitFilesChange": 1, "lines": 22, "deletions": 7}, "numCommits": 1, "commits": {"cb1f659041ac04fca9e95a7c055d89c21668fff6": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 23.00027777777778, "user": "jandam", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Config: BTreeMap with values outside nodes\n\nBTreeMap::put2 with parameter putOnlyIfAbsent=true, <key> is already in Map so there is nothing to change. But value is stored to engine at line 1034.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 2}, "title": "BTreeMap: possible value leak", "statsSkippedReason": "", "closed": "2015-05-03 07:38:59", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-05-03 10:06:56", "commitHash": "cb1f659041ac04fca9e95a7c055d89c21668fff6", "commitParents": ["feb207777a2175205b13b664a1aa1efb68afa6b5"], "commitGHEventType": "closed", "nameRev": "cb1f659041ac04fca9e95a7c055d89c21668fff6 tags/mapdb-2.0-alpha3~59", "commitGitStats": [{"insertions": 15, "lines": 22, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 7}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "BTreeMap: possible disk leak with value. Fix #479\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-03 10:06:56"}], "created": "2015-04-10 07:13:13"}, {"labels": ["2.0", "bug"], "filteredCommits": ["327d0162f6159f54fe6d3820ab3b2834a33cd87b"], "url": "https://github.com/jankotek/mapdb/issues/477", "gitStatsSummary": {"insertions": 259, "gitFilesChange": 2, "lines": 409, "deletions": 150}, "numCommits": 1, "commits": {"327d0162f6159f54fe6d3820ab3b2834a33cd87b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 176.00027777777777, "user": "jankotek", "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There is report in mailing list about out of order entries in BTreeMap: https://groups.google.com/forum/#!topic/mapdb/28EKRxMzxvg \n\nAs a test of MapDB to replace an older storage engine, I copied ~20 million key/value pairs, spread across about 100 BTreeMaps, some with only a handful of entries and others with up to 6.5M entries.\n\nI streamed over my source data in the old storage engine in key order, and wrote to MapDB with the UnsignedBytes.legicographicComparitor from guice.  Then after shutting down and closing the db, I opened it back up and iterated over both stores comparing the raw byte[] keys and values.\n\nMapDB had three key/value pairs out of order.  Every key/value entry is present and found when using get(key), but when iterating over the entry set, a key is very rarely out of order.  \n\nAny Idea how to track it down?  I tried adding only a small subset of data surrounding the out of place key to try and create a small reproducible case, but it seems to happen only for stores that have at least a couple million entries.  In my case the smallest BTreeMap with the issue is 3.3M entries.\n\nOne of them by chance has this as the second entry in the store (the others are all millions in), so I printed out the expected and actual values of the first 3 entries:\n\nexpected: (key=[], val=[97, 118, 114, 111, 49])\nactual: (key=[], val=[97, 118, 114, 111, 49])\n\nexpected: (key=[45, 107, 117, 121, 95, 46, 57, 54, 52, 51, 64, 104, 111, 116, 109, 97, 105, 108, 46, 99, 111, 46, 116, 104], val=[30, -14, -86, -31, -71, 19, -14, -86, -31, -71, 19, -60, -78, -69, -96, 19, -60, -78, -69, -96, 19, -12, -105, -15, -97, 19, -6, -21, -53, -16, 17, -46, -112, -18, -97, 19, -46, -112, -18, -97, 19, -46, -112, -18, -97, 19, -54, -54, -18, -97, 19, -54, -54, -18, -97, 19, -36, -19, -49, -16, 17, -106, -123, -17, -97, 19, -108, -82, -17, -97, 19, -46, -30, -87, -41, 18, 0, 0, 0, 0])\nactual: (key=[-32, -72, -73, 111, 46, 107, 101, 46, 48, 49, 49, 53, 57, 52, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109], val=[10, -92, -86, -99, -23, 19, -92, -86, -99, -23, 19, -112, -9, -81, -27, 19, -94, -71, -52, -8, 18, -94, -71, -52, -8, 18, 0, 0, 0, 0])\n\nexpected: (key=[45, 115, 117, 107, 99, 104, 97, 114, 111, 101, 110, 64, 104, 111, 116, 109, 97, 105, 108, 46, 99, 111, 109], val=[30, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -96, -23, -18, -97, 19, -96, -23, -18, -97, 19, -92, -28, -53, -16, 17, -92, -28, -53, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, -10, -106, -49, -16, 17, 0, 0, 0, 0])\nactual: (key=[45, 107, 117, 121, 95, 46, 57, 54, 52, 51, 64, 104, 111, 116, 109, 97, 105, 108, 46, 99, 111, 46, 116, 104], val=[30, -14, -86, -31, -71, 19, -14, -86, -31, -71, 19, -60, -78, -69, -96, 19, -60, -78, -69, -96, 19, -12, -105, -15, -97, 19, -6, -21, -53, -16, 17, -46, -112, -18, -97, 19, -46, -112, -18, -97, 19, -46, -112, -18, -97, 19, -54, -54, -18, -97, 19, -54, -54, -18, -97, 19, -36, -19, -49, -16, 17, -106, -123, -17, -97, 19, -108, -82, -17, -97, 19, -46, -30, -87, -41, 18, 0, 0, 0, 0])\n\nThe second expected value shows up in the third position, with the out-of order entry showing up in the middle.   The remaining millions of entries are in order.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "BTreeMap entries out of order", "statsSkippedReason": "", "closed": "2015-09-30 09:30:39", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-04-28 22:17:14", "commitHash": "327d0162f6159f54fe6d3820ab3b2834a33cd87b", "commitParents": ["c52c45e4111f110e495ea8d30e466e8452972c19"], "commitGHEventType": "referenced", "nameRev": "327d0162f6159f54fe6d3820ab3b2834a33cd87b tags/mapdb-2.0-alpha2~2", "commitGitStats": [{"insertions": 13, "lines": 13, "filePath": "src/main/java/org/mapdb/DBException.java", "deletions": 0}, {"insertions": 105, "lines": 111, "filePath": "src/test/java/org/mapdb/PumpTest.java", "deletions": 6}, {"insertions": 12, "lines": 22, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 10}, {"insertions": 246, "lines": 396, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 150}], "commitSpoonAstDiffStats": [], "commitMessage": "Pump: rewrite BTreeMap data pump. Should sort corner case issues with entries out of order.\n\nSee #477 and https://groups.google.com/forum/#!topic/mapdb/28EKRxMzxvg and https://groups.google.com/forum/#!topic/mapdb/h68ii5amcAA\n", "spoonStatsSkippedReason": "tooManyChanges", "authoredDateTime": "2015-04-28 22:17:14"}], "created": "2015-04-06 09:51:31"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/472", "title": "Guava Immutable Map Not Unserialized ", "closed": "2015-09-01 16:44:06", "commitsDetails": [], "commits": {}, "ttf": 159.00027777777777, "created": "2015-03-25 23:47:22", "user": "fabiankessler", "body": "Version: 1.0.7\n\nSetup:\n    DB db = DBMaker.newFileDB(\"localfile\")\n                .closeOnJvmShutdown()\n                .make();\n\nValue class: A POJO implementing Serializable with serialVersionUID, no default constructor.\nUsing a field of type Map<String, Integer>. \n\nThis works if the Map is a HashMap, or wrapped in Collections.unmodifiableMap(). However, if the Map is a ImmutableMap.copyOf(), unserializing fails. The Guava Map impls that are used (depending whether empty, 1 item, or more) do implement Serializable also.\n\nThe exception happens on the 2nd run, when the localfile exists already. The local field remains uninitialized in the value class.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["6205f336742f1b726e014b6f9f84ab761f91dfd9"], "url": "https://github.com/jankotek/mapdb/issues/468", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 10, "deletions": 2}, "numCommits": 1, "commits": {"6205f336742f1b726e014b6f9f84ab761f91dfd9": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 152.00027777777777, "user": "alextkachman", "changesInPackagesSPOON": ["org.mapdb.Queues.SimpleQueue.NodeSerializer.deserialize(java.io.DataInput,int)", "org.mapdb.Queues.SimpleQueue.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.Queues$SimpleQueue$Node)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "db.createCircularQueue(\"recents\", Serializer.STRING, 200) causes NPE when engine trying to serialize initial empty nodes\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 8, "DEL": 0, "INS": 5, "spoonFilesChanged": 1, "MOV": 3}, "title": "NPE on createCircularQueue", "statsSkippedReason": "", "closed": "2015-08-21 07:11:20", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-08-21 09:11:12", "commitHash": "6205f336742f1b726e014b6f9f84ab761f91dfd9", "commitParents": ["68a70468358c4c93df11e548de7eda883513b5d5"], "commitGHEventType": "closed", "nameRev": "6205f336742f1b726e014b6f9f84ab761f91dfd9 tags/mapdb-2.0-beta7~30", "commitGitStats": [{"insertions": 8, "lines": 10, "filePath": "src/main/java/org/mapdb/Queues.java", "deletions": 2}, {"insertions": 12, "lines": 14, "filePath": "src/test/java/org/mapdb/IssuesTest.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue561()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.IssuesTest.issue468()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 4, "MOV": 1, "spoonMethodName": "org.mapdb.IssuesTest.issue130()"}], "spoonFilePath": "IssuesTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 6, "DEL": 0, "INS": 4, "MOV": 2, "spoonMethodName": "org.mapdb.Queues.SimpleQueue.NodeSerializer.deserialize(java.io.DataInput,int)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Queues.SimpleQueue.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.Queues$SimpleQueue$Node)"}], "spoonFilePath": "Queues.java"}], "commitMessage": "Queues: NPE on createCircularQueue, Fix #468\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-21 09:11:12"}], "created": "2015-03-21 14:44:36"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/466", "title": "Exception on 1.0.7", "closed": "2015-08-07 12:43:30", "commitsDetails": [], "commits": {}, "ttf": 139.00027777777777, "created": "2015-03-20 18:18:52", "user": "nopper", "body": "I am using the latest stable version (1.0.7) from maven. I am building a database with:\n\n```\nval db = DBMaker.newFileDB(dbFile)\n  .transactionDisable()\n  .asyncWriteEnable()\n  .asyncWriteFlushDelay(100)\n  .make()\n```\n\nAnd reopening the archive with the following code:\n\n```\nval db = DBMaker.newFileDB(dbFile)\n    .transactionDisable()\n    .mmapFileEnableIfSupported()\n    .readOnly()\n    .make()\n```\n\nI am just using the database in read only mode and issuing queries on a ConcurrentNavigableMap as follows:\n\n```\nval m: ConcurrentNavigableMap[String, Long] = db.getTreeMap(\"mymap\")\nm.getOrDefault(\"some string\", 0)\n```\n\nUnfortunately after a little bit of querying using multiple threads I got hit by the following error:\n\n```\n[error] Exception in thread \"Thread-4\" java.lang.ArrayIndexOutOfBoundsException: 15\n[error]         at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:372)\n[error]         at org.mapdb.StoreDirect.get2(StoreDirect.java:440)\n[error]         at org.mapdb.StoreDirect.get(StoreDirect.java:428)\n[error]         at org.mapdb.Caches$HashTable.get(Caches.java:246)\n[error]         at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n[error]         at org.mapdb.BTreeMap.get(BTreeMap.java:602)\n[error]         at org.mapdb.BTreeMap.get(BTreeMap.java:589)\n[error]         at java.util.concurrent.ConcurrentMap.getOrDefault(ConcurrentMap.java:80)\n```\n\nI am now trying to rebuild the database without the async delay, but it's rather slow. I'll keep you informed.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["4288ba82cfa9aa8c261bc9d1af2da9591402749f"], "url": "https://github.com/jankotek/mapdb/issues/465", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 5, "deletions": 1}, "numCommits": 1, "commits": {"4288ba82cfa9aa8c261bc9d1af2da9591402749f": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 194.00027777777777, "user": "Vipous", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.usesAdvancedSerialization(java.lang.Class)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I  make sample with bug\nhttps://gist.github.com/Vipous/8077faaf08495b2dfc12\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "spoonFilesChanged": 1, "MOV": 1}, "title": "Wrong read operation, on Class extended from HashMap after seconf db.commit", "statsSkippedReason": "", "closed": "2015-09-30 11:26:08", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-09-30 14:26:00", "commitHash": "4288ba82cfa9aa8c261bc9d1af2da9591402749f", "commitParents": ["5b14d76ac10326ad73c98aaacbfcf2d41bd4a187"], "commitGHEventType": "closed", "nameRev": "4288ba82cfa9aa8c261bc9d1af2da9591402749f tags/mapdb-2.0-beta9~54", "commitGitStats": [{"insertions": 4, "lines": 5, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 1}, {"insertions": 6, "lines": 6, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 0}, {"insertions": 117, "lines": 117, "filePath": "src/test/java/org/mapdb/issues/Issue465Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.issues.Issue465Test"}], "spoonFilePath": "Issue465Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.usesAdvancedSerialization(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.ExtHashMap"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.java_serialization()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "SerializerPojo: useAdvancedSerialization did not respected methods in superclass. Fix #465\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-09-30 14:26:00"}], "created": "2015-03-19 21:36:00"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/464", "title": "java.io.IOException: Wrong index checksum, store was not closed properly and could be corrupted", "closed": "2015-08-07 12:42:45", "commitsDetails": [], "commits": {}, "ttf": 140.00027777777777, "created": "2015-03-19 15:44:29", "user": "zhoupo", "body": "I encountered the exception after restarting Jetty, which contains producer-consumer implementation via MapDB's Queue. I haven't call \"DBMaker.transactionDisable()\", but why did I still get the above exceptions?\n\nBefore I restarted Jetty, I found the consumer seems blocked. By jstack command, I got lots of following logs:\n\n> \"qtp1730704097-270\" #270 prio=5 os_prio=0 tid=0x00007f7b60006800\n> nid=0xb44f waiting on condition [0x00007f7986ae9000]  \n> java.lang.Thread.State: TIMED_WAITING (parking)   at\n> sun.misc.Unsafe.park(Native Method)\n> - parking to wait for  <0x000000054047c420> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n>   at\n>   java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n>   at\n>   java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n>   at\n>   org.eclipse.jetty.util.BlockingArrayQueue.poll(BlockingArrayQueue.java:342)\n>   at\n>   org.eclipse.jetty.util.thread.QueuedThreadPool.idleJobPoll(QueuedThreadPool.java:526)\n>   at\n>   org.eclipse.jetty.util.thread.QueuedThreadPool.access$600(QueuedThreadPool.java:44)\n>   at\n>   org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:572)\n>   at java.lang.Thread.run(Thread.java:745)\n>   \n>   Locked ownable synchronizers:\n> - None\n\nHere are some code fragment:\n\n```\n// Consumer code:\n\npublic void run() {\n    try {\n        while (!stopped) {\n            if (System.currentTimeMillis() - lastCheckTime > 60000) {\n                localDb.commit();\n                localDb.compact();\n                lastCheckTime = System.currentTimeMillis();\n            }\n            ...\n            for (...) {\n                queue.poll();\n            }\n            ...\n            localDb.commit();\n        }\n        localDb.commit();\n        localDb.compact();\n    } catch (InterruptedException ie) {\n        LOG.error(\"\", ie);\n    }\n}\n\n// Others code:\n\n...\nDB localDb = DBMaker.newFileDB(new File(path)).closeOnJvmShutdown().make();\nlocalDb.catPut(QUEUE_NAME + \".useLocks\", false);\nqueue = localDb.getQueue(QUEUE_NAME);\n...\n\npublic void interrupt() {\n    stopped = true;\n    localDb.close();\n}\n```\n\njava -version: java version \"1.8.0_11\"\n\nThanks!\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/463", "title": "java.lang.IllegalAccessError: WAL not empty; commit first, than compact", "closed": "2015-09-30 09:35:37", "commitsDetails": [], "commits": {}, "ttf": 194.00027777777777, "created": "2015-03-19 15:37:14", "user": "zhoupo", "body": "Hi,\n\nI put \"localDb.commit();\" before every \"localDb.compact();\" but still get the exception:\n\n> Exception in thread \"Thread-0\" java.lang.IllegalAccessError: WAL not empty; commit first, than compact\n> at org.mapdb.StoreWAL.compactPreUnderLock(StoreWAL.java:1100)\n> at org.mapdb.StoreDirect.compact(StoreDirect.java:810)\n> at org.mapdb.EngineWrapper.compact(EngineWrapper.java:130)\n> at org.mapdb.EngineWrapper.compact(EngineWrapper.java:130)\n> at org.mapdb.DB.compact(DB.java:1626)\n\nMy commit(), compact() are located in Thread.run(), and my DBMaker configuration is:\n\n```\nDB localDb = DBMaker.newFileDB(new File(filename)).closeOnJvmShutdown().make();\n```\n\nstore size: 471M, including *.compact, *.compact.p, *.p, *.t\njava -version: java version \"1.8.0_11\"\nuname -r: 2.6.32-279.el6.x86_64\n\nThanks!\n"}, {"labels": ["bug"], "filteredCommits": ["67b40e65067d131ca47dc49f64e2d1e259a86f12"], "url": "https://github.com/jankotek/mapdb/issues/457", "gitStatsSummary": {"insertions": 23, "gitFilesChange": 2, "lines": 23, "deletions": 0}, "numCommits": 1, "commits": {"46a2e9543526d5010559fb4d951465ecc2289873": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "67b40e65067d131ca47dc49f64e2d1e259a86f12": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 62.000277777777775, "user": "freakolowsky", "changesInPackagesSPOON": ["org.mapdb.Volume", "org.mapdb.Volume.MappedFileVol.close()", "org.mapdb.Volume.FileChannelVol.close()", "org.mapdb.Volume.MemoryVol.close()", "org.mapdb.StoreAppend.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "On 1.0.6 @ RHEL 6.5 (Oracle Linux Server) ...\n\nI compact db after a certain amount of data is processed. Everything works fine, but i've noticed that file descriptors remain open for the process, all descriptors for db_TSNUMBER_orig, db.p_TSNUMBER_orig and db.t ... i.e. (repeated X-times):\n\n> /proc/27073/fd/369 -> /mapdb/EB_42/state.t\n> /proc/27073/fd/370 -> /mapdb/EB_42/state_1425454206734_orig (deleted)\n> /proc/27073/fd/371 -> /mapdb/EB_42/state.p_1425454206734_orig (deleted)\n\nno direct issue, but open file descriptors are giving me false warnings as df reports wrong usage stats\n\nok, one small issue performace seems to drop slightly as the number of descriptors increase\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 5, "UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "spoonFilesChanged": 2, "MOV": 0}, "title": "File descriptors remain open", "statsSkippedReason": "", "closed": "2015-05-05 15:21:58", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-05-05 17:09:03", "commitHash": "46a2e9543526d5010559fb4d951465ecc2289873", "commitParents": ["0f50921e0ef3d536569b31c370ba8d66c744bde7"], "commitGHEventType": "referenced", "nameRev": "46a2e9543526d5010559fb4d951465ecc2289873 tags/mapdb-2.0-alpha3~52", "commitGitStats": [{"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/UnsafeStuff.java", "deletions": 0}, {"insertions": 34, "lines": 63, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 29}, {"insertions": 63, "lines": 81, "filePath": "src/test/java/org/mapdb/EngineTest.java", "deletions": 18}, {"insertions": 27, "lines": 38, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 11}, {"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreCached.java", "deletions": 0}, {"insertions": 15, "lines": 15, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 28, "lines": 30, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}, {"insertions": 13, "lines": 23, "filePath": "src/test/java/org/mapdb/StoreCachedTest.java", "deletions": 10}, {"insertions": 6, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCached.initHeadVol()"}], "spoonFilePath": "StoreCached.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.close()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UnsafeStuff.UnsafeVolume.close()"}], "spoonFilePath": "UnsafeStuff.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.test_phys_record_reused_COMPACT()"}, {"UPD": 0, "TOT": 22, "DEL": 11, "INS": 10, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirectTest.compact_keeps_volume_type()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack_no_commit()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_created_after_put()"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack_no_commit()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take_simple()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_record_delete_and_reuse_large_COMPACT()"}, {"UPD": 0, "TOT": 9, "DEL": 0, "INS": 2, "MOV": 7, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_puts_record_offset_into_index()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take2()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_put_five()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.prealloc()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_overflow()"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 9, "TOT": 10, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCachedTest.flush_write_cache()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.StoreCachedTest.put_update_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCachedTest.put_delete()"}], "spoonFilePath": "StoreCachedTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 19, "DEL": 9, "INS": 9, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_long()"}, {"UPD": 0, "TOT": 24, "DEL": 11, "INS": 12, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.compact_tx_works(boolean,boolean)"}, {"UPD": 0, "TOT": 11, "DEL": 5, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_created()"}, {"UPD": 0, "TOT": 33, "DEL": 16, "INS": 16, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.WAL_replay_mixed()"}, {"UPD": 0, "TOT": 31, "DEL": 14, "INS": 16, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.walCompactSwap(boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.compact_tx_works(boolean,boolean).1.run()"}, {"UPD": 0, "TOT": 19, "DEL": 8, "INS": 10, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.compact_record_file_used()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.initHeadVol()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayWAL()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.initOpen()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.isClosed()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.finalize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ReadOnly.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.SingleByteArrayVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteArrayVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.close()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_larger()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact_large_record()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.put_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.first_recid()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.init()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_commit()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.put_get_large()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.reserved_recid_exists()"}, {"UPD": 0, "TOT": 14, "DEL": 6, "INS": 4, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.update_reserved_recid()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.compact()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.double_close()"}, {"UPD": 0, "TOT": 11, "DEL": 5, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.cas_uses_serializer()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.large_record_update()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.get_non_existent()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_put()"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.par_cas().3.call()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.rollback()"}, {"UPD": 0, "TOT": 13, "DEL": 4, "INS": 4, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.par_cas()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen_nocommit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_cas()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.nosize_array()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.cas_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.testSetGet()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_delete()"}, {"UPD": 0, "TOT": 17, "DEL": 8, "INS": 8, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.putGetUpdateDelete()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.large_record()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.preallocate_cas()"}, {"UPD": 0, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get_large()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 2, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.rollback_reopen()"}, {"UPD": 0, "TOT": 12, "DEL": 6, "INS": 5, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.update_reserved_recid_large()"}, {"UPD": 0, "TOT": 13, "DEL": 0, "INS": 3, "MOV": 10, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_commit2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_update()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.compact_double_recid_reuse()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.preallocate_get_update_delete_update_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact0()"}, {"UPD": 0, "TOT": 7, "DEL": 2, "INS": 2, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.par_update_get().2.call()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.delete_and_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_delete()"}, {"UPD": 0, "TOT": 10, "DEL": 4, "INS": 3, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.par_update_get()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.NPE_get()"}, {"UPD": 0, "TOT": 25, "DEL": 12, "INS": 12, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.zero_size_serializer()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.snapshot_after_rollback()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.get_non_existent_after_delete_and_compact()"}], "spoonFilePath": "EngineTest.java"}], "commitMessage": "Stores: fix file handle leaks. Fix #503 and #457\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-05 17:09:03"}, {"commitUser": "jankotek", "commitDateTime": "2015-05-05 17:43:16", "commitHash": "67b40e65067d131ca47dc49f64e2d1e259a86f12", "commitParents": ["34da7019c2dc99cf7759f2844664baaaf0f36077"], "commitGHEventType": "referenced", "nameRev": "67b40e65067d131ca47dc49f64e2d1e259a86f12 tags/mapdb-renamed-1.0.8~19", "commitGitStats": [{"insertions": 2, "lines": 2, "filePath": "src/test/java/org/mapdb/StoreAppendTest.java", "deletions": 0}, {"insertions": 10, "lines": 19, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 9}, {"insertions": 28, "lines": 33, "filePath": "src/test/java/org/mapdb/EngineTest.java", "deletions": 5}, {"insertions": 26, "lines": 28, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 2}, {"insertions": 21, "lines": 21, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 0}, {"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppendTest.header_created()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppendTest.put()"}], "spoonFilePath": "StoreAppendTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.close()"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_size2IoList()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.in_memory_compact_leaves_no_temp_files()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack_no_commit()"}, {"UPD": 2, "TOT": 5, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack_no_commit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_stores_record_size()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.init()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.phys_append_alloc_link2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.second_rec_pos_round_to_16()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_puts_record_offset_into_index()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_index_inc()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_record_delete_and_reuse_large()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_put_five()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_record_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_overflow()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_phys_record_reused()"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.StoreDirectTest.test_basic_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_created_after_put()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.freeSpaceWorks()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take_simple()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_phys_inc()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_large_long_stack()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.phys_append_alloc_link3()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.phys_append_alloc()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_long_stack_put_take()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.long_stack_page_deleted_after_take()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.test_index_record_delete_and_reusef()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirectTest.prealloc()"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.header_index_ver()"}, {"UPD": 0, "TOT": 19, "DEL": 9, "INS": 9, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWALTest.replay_good_log()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.close()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen_nocommit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_larger()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.compact_large_record()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.put_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.first_recid()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.init()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_delete()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.rollback_reopen()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.EngineTest.put_get_large()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact2()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get_large()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.EngineTest.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.compact0()"}, {"UPD": 0, "TOT": 12, "DEL": 2, "INS": 2, "MOV": 8, "spoonMethodName": "org.mapdb.EngineTest.par_update_get().2.call()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.large_record_update()"}, {"UPD": 0, "TOT": 14, "DEL": 3, "INS": 4, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.par_update_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.test_store_reopen()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.EngineTest.large_record()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.EngineTest.put_reopen_get()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineTest.testSetGet()"}, {"UPD": 0, "TOT": 8, "DEL": 1, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.EngineTest.par_cas().3.call()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.EngineTest.rollback()"}, {"UPD": 0, "TOT": 13, "DEL": 3, "INS": 3, "MOV": 7, "spoonMethodName": "org.mapdb.EngineTest.par_cas()"}], "spoonFilePath": "EngineTest.java"}], "commitMessage": "Volume: add code to debug file leaks. See #457\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-05-05 17:43:16"}], "created": "2015-03-04 08:30:35"}, {"labels": ["2.0", "bug"], "filteredCommits": ["ade719b3f1a747f9f6b89720c163d5a4b523ecad"], "url": "https://github.com/jankotek/mapdb/issues/453", "gitStatsSummary": {"insertions": 7, "gitFilesChange": 1, "lines": 7, "deletions": 0}, "numCommits": 1, "commits": {"ade719b3f1a747f9f6b89720c163d5a4b523ecad": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "ed1119fe8a34047fc684d585c7ac95020c90dd14": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 129.00027777777777, "user": "mattwigway", "changesInPackagesSPOON": ["org.mapdb.Bind.histogram(org.mapdb.Bind$MapWithModificationListener,java.util.concurrent.ConcurrentMap,Fun.Function2)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If I run Bind.secondaryKeys with an empty secondary collection, the index is built. However, if I run Bind.histogram with an empty histogram map the histogram is not restored. It looks like the issue is here: https://github.com/jankotek/MapDB/blob/master/src/main/java/org/mapdb/Bind.java#L655\n\nI see that most of the secondary listeners have a conditional along the lines of `if (secondary.isEmpty) { . . . }` and that appears to be missing here.\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "Empty histograms not filled on bind", "statsSkippedReason": "", "closed": "2015-07-04 06:42:36", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 08:39:55", "commitHash": "ade719b3f1a747f9f6b89720c163d5a4b523ecad", "commitParents": ["928528e3d1cba8edaddd06105c4b6d6231877e49"], "commitGHEventType": "referenced", "nameRev": "ade719b3f1a747f9f6b89720c163d5a4b523ecad tags/mapdb-renamed-1.0.8~11", "commitGitStats": [{"insertions": 7, "lines": 7, "filePath": "src/main/java/org/mapdb/Bind.java", "deletions": 0}, {"insertions": 62, "lines": 63, "filePath": "src/test/java/org/mapdb/BindTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.issue453_histogram_not_created_on_empty_secondary_set()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.histogram()"}], "spoonFilePath": "BindTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Bind.histogram(org.mapdb.Bind$MapWithModificationListener,java.util.concurrent.ConcurrentMap,Fun.Function2)"}], "spoonFilePath": "Bind.java"}], "commitMessage": "Bind: fix #453, empty histogram was not recreated\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 08:39:41"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-04 08:42:29", "commitHash": "ed1119fe8a34047fc684d585c7ac95020c90dd14", "commitParents": ["ca23853943f5f36b4ed8c1df12913000f0d9c060"], "commitGHEventType": "closed", "nameRev": "ed1119fe8a34047fc684d585c7ac95020c90dd14 tags/mapdb-2.0-beta2~14", "commitGitStats": [{"insertions": 7, "lines": 7, "filePath": "src/main/java/org/mapdb/Bind.java", "deletions": 0}, {"insertions": 62, "lines": 63, "filePath": "src/test/java/org/mapdb/BindTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.issue453_histogram_not_created_on_empty_secondary_set()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.histogram()"}], "spoonFilePath": "BindTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Bind.histogram(org.mapdb.Bind$MapWithModificationListener,java.util.concurrent.ConcurrentMap,Fun.Function2)"}], "spoonFilePath": "Bind.java"}], "commitMessage": "Bind: fix #453, empty histogram was not recreated\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 08:42:29"}], "created": "2015-02-24 20:47:06"}, {"labels": ["2.0", "bug"], "filteredCommits": ["33d801b9a6406d03f9e3f2e753374a52c78d35b4", "3f37ab5b45feec44d9b2c23eb4fe15f94d46642c"], "url": "https://github.com/jankotek/mapdb/issues/452", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 8, "deletions": 4}, "numCommits": 1, "commits": {"33d801b9a6406d03f9e3f2e753374a52c78d35b4": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "3f37ab5b45feec44d9b2c23eb4fe15f94d46642c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 129.00027777777777, "user": "mattwigway", "changesInPackagesSPOON": ["org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)", "org.mapdb.DB.createTreeSet(org.mapdb.DB$BTreeSetMaker)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If I try to fill a database using .pumpSource(Iterator<Tuple2<K, V>) and the iterator is empty, I get an IndexOutOfBoundsException. Obviously not a big deal as it doesn't really make sense to use an empty pump source (I discovered this when implementing online backup using pump, and some of my tables were empty; just needed to add a check to skip backing those up).\n\n```\nException in thread \"main\" java.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:532)\n    at java.nio.HeapByteBuffer.get(HeapByteBuffer.java:139)\n    at org.mapdb.DataInput2.readUnsignedByte(DataInput2.java:74)\n    at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:416)\n    at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:288)\n    at org.mapdb.Store.deserialize(Store.java:297)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:368)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:352)\n    at org.mapdb.Caches$HashTable.get(Caches.java:245)\n    at org.mapdb.BTreeMap.<init>(BTreeMap.java:541)\n    at org.mapdb.DB.createTreeMap(DB.java:862)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:644)\n    at MapDBEmptyPumpSource.main(MapDBEmptyPumpSource.java:30)\n```\n\nTest case: https://gist.github.com/mattwigway/a882c7ac360836df939b . This is with MapDB 1.0.6.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 10, "DEL": 1, "INS": 4, "spoonFilesChanged": 1, "MOV": 5}, "title": "Cannot use empty pump source", "statsSkippedReason": "", "closed": "2015-07-04 08:15:52", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-04 10:13:09", "commitHash": "33d801b9a6406d03f9e3f2e753374a52c78d35b4", "commitParents": ["d1a65fbb304cf77c3ffb53686f630679bbbeef1c"], "commitGHEventType": "referenced", "nameRev": "33d801b9a6406d03f9e3f2e753374a52c78d35b4 tags/mapdb-renamed-1.0.8~9", "commitGitStats": [{"insertions": 4, "lines": 8, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 4}, {"insertions": 24, "lines": 29, "filePath": "src/test/java/org/mapdb/PumpTest.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}, {"UPD": 0, "TOT": 6, "DEL": 1, "INS": 2, "MOV": 3, "spoonMethodName": "org.mapdb.DB.createTreeSet(org.mapdb.DB$BTreeSetMaker)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.empty_iterator_issue452()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.empty_iterator_set_issue452()"}], "spoonFilePath": "PumpTest.java"}], "commitMessage": "Pump: fix empty iterator for BTreeMap(Set) creation. Fix #452\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 10:13:09"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-04 10:15:32", "commitHash": "3f37ab5b45feec44d9b2c23eb4fe15f94d46642c", "commitParents": ["55f15b73a58a288025d1abe7074618fcc788137a"], "commitGHEventType": "referenced", "nameRev": "3f37ab5b45feec44d9b2c23eb4fe15f94d46642c tags/mapdb-2.0-beta2~11", "commitGitStats": [{"insertions": 43, "lines": 45, "filePath": "src/test/java/org/mapdb/PumpTest.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.empty_iterator_issue452()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.hash_empty_iterator_set_issue452()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.empty_iterator_set_issue452()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.PumpTest.hash_empty_iterator_issue452()"}], "spoonFilePath": "PumpTest.java"}], "commitMessage": "Pump: add test cases for empty source iterators. See #452\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 10:15:32"}], "created": "2015-02-24 18:56:26"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/451", "title": "Mapdb2 and pumpSource problem", "closed": "2015-05-28 06:04:22", "commitsDetails": [], "commits": {}, "ttf": 94.00027777777778, "created": "2015-02-22 15:10:25", "user": "adridadou", "body": "Hi,\nIn my quest to work with MapDB2, I have another issue.\nI currently use pumpSource with MapDB1 and everything works fine. But when I use MapDB2, I get this error:\njava.lang.AssertionError: keys are not sorted: [315522, 315522, 646732, 774812, 878225, 1045003, 1170222, 1264551, 1314408, 1381461]\n    at org.mapdb.BTreeMap$BNode.checkStructure(BTreeMap.java:353)\n    at org.mapdb.BTreeMap$DirNode.checkStructure(BTreeMap.java:428)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:702)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:668)\n    at org.mapdb.Store.serialize(Store.java:163)\n    at org.mapdb.StoreDirect.put(StoreDirect.java:409)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:456)\n    at org.mapdb.DB.createTreeMap(DB.java:988)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:785)\n....\n\nWhat seems strange for me is that in MapDB1, there is a test that checks that the key orders is correct and here the AssertionError comes not from the Pump code but rather from checkStructure.\n\nthe BTree config I use is :\nval cubeData:BTreeMap[Long,String] = db.createTreeMap(\"data\")\n      .valueSerializer(Serializer.STRING_ASCII)\n      .pumpSource(CubeMapDbIterator(data)).make()\n\nI assume the CubeMapDBIterator is correct as it works properly with MapDB1.\n\nAny idea?\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/450", "title": "NPE if setting a key serializer without a comparator", "closed": "2015-05-28 05:57:38", "commitsDetails": [], "commits": {}, "ttf": 94.00027777777778, "created": "2015-02-22 09:01:02", "user": "adridadou", "body": "Hi,\nIf I set manually the key serializer I want to use, It seems that I have to set a comparator as well.\n\nIf I forget to do it, I get a NPE. I think it would make sens to have some kind of default comparator for each key serializer or at least a helper function to set the comprators because I cannot find the one for INT_ARRAY for example.\n\nkeep up the good work!\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/449", "title": "Queue.poll() throws NPE", "closed": "2015-09-30 09:34:56", "commitsDetails": [], "commits": {}, "ttf": 221.00027777777777, "created": "2015-02-20 19:29:03", "user": "jankotek", "body": "```\n    ... 6 more\nCaused by: java.lang.NullPointerException\n    at org.mapdb.Queues$SimpleQueue.poll(Queues.java:135)\n    at org.mapdb.Queues$SimpleQueue.take(Queues.java:240)\n    at conc.Queue$2.run(Queue.java:41)\n    at org.mapdb.Exec$1.run(Exec.java:28)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\n``````\n\n    public static void main(String[] args) {\n\n        DB db = DBMaker.newHeapDB().transactionDisable().make();\n\n        final BlockingQueue q = db.createQueue(\"name\", Serializer.STRING,true);\n\n        new Thread(){\n            @Override\n            public void run() {\n                for(long i=0;i<max;i++) {\n                    q.add(i);\n                }\n            }\n        }.start();\n\n        Exec.execNTimes(10, new Runnable() {\n            @Override\n            public void run() {\n                while(c.get()!=max){\n                    try {\n                        q.take();\n                        c.incrementAndGet();\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        });\n\n    }```\n``````\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/447", "title": "BTreeMap close() can cause ArrayOutOfBounds exception - 1.0.6", "closed": "2016-02-14 17:56:46", "commitsDetails": [], "commits": {}, "ttf": 367.0002777777778, "created": "2015-02-11 21:49:24", "user": "drcrallen", "body": "A map maker is defined as follows\n\n``` java\nprivate static final DBMaker DB_MAKER = DBMaker\n      .newMemoryDirectDB()\n      .transactionDisable()\n      .asyncWriteEnable()\n      .cacheLRUEnable()\n      .closeOnJvmShutdown()\n      .deleteFilesAfterClose()\n      .cacheSize(16384);\n```\n\nWith a BTreeMap defined as follows (from https://github.com/druid-io/druid/blob/master/processing/src/main/java/io/druid/segment/incremental/OffheapIncrementalIndex.java )\n\n``` java\n    this.facts = factsDb.createTreeMap(factDbTableName)\n                        .keySerializer(timeAndDimsSerializer)\n                        .comparator(timeAndDimsSerializer.getComparator())\n                        .valueSerializer(Serializer.INTEGER)\n                        .make();\n```\n\nWhenever `facts.clear()` is called, somehow the iterator/remover can end up in a scenario where the `findChildren` call in `remove2` returns 0, which causes `Object oldVal =   A.vals()[pos-1];` to fail.\n\nThis is overall very hard to randomly reproduce, but for the particular cases encountered can be reproduced with certainty, and circumvented by flushing the engine cache (`facts.getEngine().clearCache()`) prior to calling the `clear()` method on the BTreeMap.\n\nStack trace below\n\n```\njava.lang.ArrayIndexOutOfBoundsException: -1\nat org.mapdb.BTreeMap.remove2(BTreeMap.java:976) ~[mapdb-1.0.6.jar:?]\nat org.mapdb.BTreeMap.remove(BTreeMap.java:949) ~[mapdb-1.0.6.jar:?]\nat org.mapdb.BTreeMap$BTreeIterator.remove(BTreeMap.java:908) ~[mapdb-1.0.6.jar:?]\nat org.mapdb.BTreeMap.clear(BTreeMap.java:1028) ~[mapdb-1.0.6.jar:?]\nat org.mapdb.DB.delete(DB.java:1470) ~[mapdb-1.0.6.jar:?]\nat io.druid.segment.incremental.OffheapIncrementalIndex.close(OffheapIncrementalIndex.java:309) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\nat com.metamx.common.guava.ResourceClosingYielder.close(ResourceClosingYielder.java:41) ~[java-util-0.26.11.jar:?]\nat com.metamx.common.guava.CloseQuietly.close(CloseQuietly.java:36) ~[java-util-0.26.11.jar:?]\nat com.metamx.common.guava.YieldingSequenceBase.accumulate(YieldingSequenceBase.java:24) ~[java-util-0.26.11.jar:?]\nat io.druid.query.groupby.GroupByQueryQueryToolChest.makeIncrementalIndex(GroupByQueryQueryToolChest.java:209) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\nat io.druid.query.groupby.GroupByQueryQueryToolChest.mergeGroupByResults(GroupByQueryQueryToolChest.java:175) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\nat io.druid.query.groupby.GroupByQueryQueryToolChest.access$100(GroupByQueryQueryToolChest.java:71) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\nat io.druid.query.groupby.GroupByQueryQueryToolChest$3.run(GroupByQueryQueryToolChest.java:121) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\nat io.druid.query.FinalizeResultsQueryRunner.run(FinalizeResultsQueryRunner.java:104) ~[druid-processing-0.7.0-SNAPSHOT.jar:0.7.0-SNAPSHOT]\n```\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/445", "title": "Race condition in RECID reusal", "closed": "2015-08-07 12:42:24", "commitsDetails": [], "commits": {}, "ttf": 176.00027777777777, "created": "2015-02-11 16:13:07", "user": "jankotek", "body": "Recid gets reused and it can throw an exception. Perhaps disable recid reusal on MapDB 1.0\n\n```\njava.lang.ClassCastException: org.mapdb.HTreeMap$LinkedNode cannot be cast to org.mapdb.HTreeMap$ExpireLinkNode\n    at org.mapdb.HTreeMap.expireLinkBump(HTreeMap.java:1369)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:526)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:480)\n    at org.mapdb.HTreeMap$KeySet.add(HTreeMap.java:818)\n    at org.mapdb.Issue418Test.test_set(Issue418Test.java:53)\n```\n"}, {"labels": ["bug"], "filteredCommits": ["97029cbcbabcae605b20c75b5aa673d13d1a13ef"], "url": "https://github.com/jankotek/mapdb/issues/443", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 1, "lines": 12, "deletions": 1}, "numCommits": 1, "commits": {"97029cbcbabcae605b20c75b5aa673d13d1a13ef": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 10.000277777777777, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.compact()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 8, "DEL": 0, "INS": 7, "spoonFilesChanged": 1, "MOV": 1}, "title": "In-memory compaction does not delete temp files", "statsSkippedReason": "", "closed": "2015-02-19 12:13:31", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-11 13:12:50", "commitHash": "97029cbcbabcae605b20c75b5aa673d13d1a13ef", "commitParents": ["090b2881869f43ef381ad9039718520c7542382b"], "commitGHEventType": "referenced", "nameRev": "97029cbcbabcae605b20c75b5aa673d13d1a13ef tags/mapdb-1.0.7~19", "commitGitStats": [{"insertions": 33, "lines": 33, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 0}, {"insertions": 11, "lines": 12, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 8, "DEL": 0, "INS": 7, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.in_memory_compact_leaves_no_temp_files()"}], "spoonFilePath": "StoreDirectTest.java"}], "commitMessage": "Fix #443, in-memory compaction leaves large temporary files behind.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 13:12:50"}], "created": "2015-02-09 11:09:40"}, {"labels": ["bug"], "filteredCommits": ["5ef38a982a04fbd8e5e4714d5474b698921cbb74", "c0812223d94b37c8f722be056f7fec5243cc6421", "d1edd3b32009b563f7b5187425d41c57ee8c3cd8", "72649e80593c3f1fa476c951397a2c9dca467a9c", "ab1c6e431cc9687f819e53d2be66ee3cb6e28c08", "cb253cfce9f56c93f1768252a3afd987e3ad24c7"], "url": "https://github.com/jankotek/mapdb/issues/442", "gitStatsSummary": {"insertions": 189, "gitFilesChange": 4, "lines": 234, "deletions": 45}, "numCommits": 6, "commits": {"d1edd3b32009b563f7b5187425d41c57ee8c3cd8": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "5ef38a982a04fbd8e5e4714d5474b698921cbb74": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "cb253cfce9f56c93f1768252a3afd987e3ad24c7": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "4f4fa8352d357189597b55d6fc1e067e96b603e1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "a86151e6a26c06b7c00ec9d42a181cf0506b3eb3": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "c0812223d94b37c8f722be056f7fec5243cc6421": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "ca23853943f5f36b4ed8c1df12913000f0d9c060": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "72649e80593c3f1fa476c951397a2c9dca467a9c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "9c27cd0a976561fab6a8df43c7dfc7ee1c61de64": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "ab1c6e431cc9687f819e53d2be66ee3cb6e28c08": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 174.00027777777777, "user": "freakolowsky", "changesInPackagesSPOON": ["org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean)", "org.mapdb.Volume.MemoryVol.truncate(long)", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean)", "org.mapdb.Volume.MappedFileVol.truncate(long)", "org.mapdb.Fun.roundUp(long,long)", "org.mapdb.Volume.MappedFileVolSingle", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createTransLogVolume()", "org.mapdb.Volume.ByteBufferVol", "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)", "org.mapdb.Volume.MappedFileVol", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createPhysVolume()", "org.mapdb.DBMaker", "org.mapdb.Volume.MappedFileVolSingle.close()", "org.mapdb.Volume.MappedFileVol.sync()", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int)", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File)", "org.mapdb.DBMaker.mmapFileCleanerHackDisable()", "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int,boolean,boolean)", "org.mapdb.DBMaker.extendStoreVolumeFactory()", "org.mapdb.Volume.MappedFileVol.close()", "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int,boolean)", "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createIndexVolume()", "org.mapdb.StoreDirect.compact()", "org.mapdb.Volume.MemoryVol.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Using 1.0.6.\n\nAfter my fileDB passes 6GB i sometimes get the following JRE crash:\n\n> A fatal error has been detected by the Java Runtime Environment:\n> \n> SIGBUS (0x7) at pc=0x00007fb3d904217a, pid=2935, tid=140392178644736\n> \n> JRE version: Java(TM) SE Runtime Environment (7.0_60-b19) (build 1.7.0_60-b19)\n> Java VM: Java HotSpot(TM) 64-Bit Server VM (24.60-b09 mixed mode linux-amd64 compressed oops)\n> Problematic frame:\n> v  ~StubRoutines::jlong_disjoint_arraycopy\n\nThis happens when calling commit or compact. After restart the store is normally recovered (all i have to do is remove failed compact files).\n\nDB make code:\n\n``` java\n        DB dbState = DBMaker\n                .newFileDB(new File(location, \"state\"))\n                .asyncWriteEnable()\n                .cacheLRUEnable()\n                .cacheSize(100)\n                .mmapFileEnableIfSupported()\n                .closeOnJvmShutdown()\n                .make();\n```\n\nI'm trying it now with mmap disabled, but compacting in this state is painfully slow. Will try with mmap partial (after the current compact run finishes :D )\n", "filteredCommitsReason": {"duplicated": 3, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 24, "UPD": 6, "TOT": 101, "DEL": 10, "INS": 56, "spoonFilesChanged": 4, "MOV": 29}, "title": "SIGBUS with ~StubRoutines::jlong_disjoint_arraycopy", "statsSkippedReason": "", "closed": "2015-07-27 11:35:01", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-05 16:40:12", "commitHash": "d1edd3b32009b563f7b5187425d41c57ee8c3cd8", "commitParents": ["33d801b9a6406d03f9e3f2e753374a52c78d35b4"], "commitGHEventType": "referenced", "nameRev": "d1edd3b32009b563f7b5187425d41c57ee8c3cd8 tags/mapdb-renamed-1.0.8~8", "commitGitStats": [{"insertions": 70, "lines": 70, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 0}, {"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/Fun.java", "deletions": 0}, {"insertions": 11, "lines": 11, "filePath": "src/test/java/org/mapdb/FunTest.java", "deletions": 0}, {"insertions": 31, "lines": 32, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}, {"UPD": 0, "TOT": 5, "DEL": 1, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.FunTest.roundUp()"}], "spoonFilePath": "FunTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.roundUp(long,long)"}], "spoonFilePath": "Fun.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: preallocate mmap file buffers, write to ByteBuffer does not expand file size. It could crash JVM. See #442\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-05 16:40:12"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-05 17:53:43", "commitHash": "5ef38a982a04fbd8e5e4714d5474b698921cbb74", "commitParents": ["d1edd3b32009b563f7b5187425d41c57ee8c3cd8"], "commitGHEventType": "referenced", "nameRev": "5ef38a982a04fbd8e5e4714d5474b698921cbb74 tags/mapdb-renamed-1.0.8~7", "commitGitStats": [{"insertions": 60, "lines": 80, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 20}, {"insertions": 40, "lines": 41, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 11, "DEL": 0, "INS": 11, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MemoryVol.truncate(long)"}, {"UPD": 2, "TOT": 8, "DEL": 2, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.truncate(long)"}, {"UPD": 0, "TOT": 12, "DEL": 0, "INS": 3, "MOV": 9, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int,boolean,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MemoryVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreVolumeFactory()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.mmapFileCleanerHackDisable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "Volume: add option to disable Cleaner Hack, so JVM does not crash. See #442\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-05 17:53:43"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 14:32:26", "commitHash": "cb253cfce9f56c93f1768252a3afd987e3ad24c7", "commitParents": ["4f4fa8352d357189597b55d6fc1e067e96b603e1"], "commitGHEventType": "referenced", "nameRev": "cb253cfce9f56c93f1768252a3afd987e3ad24c7 tags/mapdb-1.0.7~16", "commitGitStats": [{"insertions": 5, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "Partial fix for #442. Disable DirectByteBuffer unmap hack if Async Writer is enabled\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 14:32:26"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 14:21:32", "commitHash": "4f4fa8352d357189597b55d6fc1e067e96b603e1", "commitParents": ["3aa54b35a6522cca132eb05a9b0c1660c8fb4181"], "commitGHEventType": "referenced", "nameRev": "4f4fa8352d357189597b55d6fc1e067e96b603e1 tags/mapdb-1.0.7~17", "commitGitStats": [{"insertions": 9, "lines": 9, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 0}, {"insertions": 13, "lines": 13, "filePath": "src/test/java/org/mapdb/UtilsTest.java", "deletions": 0}, {"insertions": 49, "lines": 57, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 8}, {"insertions": 38, "lines": 38, "filePath": "src/test/java/org/mapdb/Issue442Test.java", "deletions": 0}, {"insertions": 8, "lines": 11, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UtilsTest.randomByteArray(int)"}], "spoonFilePath": "UtilsTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.async_mmap_unmap_hack_disabled()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File).1.createTransLogVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean).1.createPhysVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean).1.createIndexVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File).1.createPhysVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean).1.createTransLogVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,int,int,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.unmap(java.nio.MappedByteBuffer)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 7, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreVolumeFactory()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue442Test"}], "spoonFilePath": "Issue442Test.java"}], "commitMessage": "Partial fix for #442. Disable DirectByteBuffer unmap hack if Async Writer is enabled\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 14:21:32"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-05 16:43:47", "commitHash": "a86151e6a26c06b7c00ec9d42a181cf0506b3eb3", "commitParents": ["3f37ab5b45feec44d9b2c23eb4fe15f94d46642c"], "commitGHEventType": "referenced", "nameRev": "a86151e6a26c06b7c00ec9d42a181cf0506b3eb3 tags/mapdb-2.0-beta2~10", "commitGitStats": [{"insertions": 58, "lines": 58, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 0}, {"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/Fun.java", "deletions": 0}, {"insertions": 10, "lines": 10, "filePath": "src/test/java/org/mapdb/FunTest.java", "deletions": 0}, {"insertions": 4, "lines": 7, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 1, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.FunTest.roundUp()"}], "spoonFilePath": "FunTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.roundUp(long,long)"}], "spoonFilePath": "Fun.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.mmap_init_size()"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: preallocate mmap file buffers, write to ByteBuffer does not expand file size. It could crash JVM. See #442\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-05 16:43:47"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-05 19:20:50", "commitHash": "c0812223d94b37c8f722be056f7fec5243cc6421", "commitParents": ["5ef38a982a04fbd8e5e4714d5474b698921cbb74"], "commitGHEventType": "referenced", "nameRev": "c0812223d94b37c8f722be056f7fec5243cc6421 tags/mapdb-renamed-1.0.8~6", "commitGitStats": [{"insertions": 11, "lines": 11, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 0}, {"insertions": 8, "lines": 12, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.cleaner_hack_disable()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createPhysVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createIndexVolume()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int,java.io.File,java.io.File,boolean,boolean).1.createTransLogVolume()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(java.io.File,int,boolean,long,int,int)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: add option to disable Cleaner Hack, so JVM does not crash. See #442.\n\nFix previous commit.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-05 19:20:50"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-04 08:08:44", "commitHash": "ca23853943f5f36b4ed8c1df12913000f0d9c060", "commitParents": ["0392d2fca4cf02f7013a84d7acd703c4b5a0f99c"], "commitGHEventType": "referenced", "nameRev": "ca23853943f5f36b4ed8c1df12913000f0d9c060 tags/mapdb-2.0-beta2~15", "commitGitStats": [{"insertions": 33, "lines": 33, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 0}, {"insertions": 3, "lines": 6, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 3}, {"insertions": 51, "lines": 70, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 19}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 1}, {"insertions": 42, "lines": 47, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.Maker.fileMmapCleanerHackEnable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 3, "MOV": 2, "spoonMethodName": "org.mapdb.DBMaker.Maker.extendStoreVolumeFactory(boolean)"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.fileMmapCleanerHack_memory()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.fileMmapCleanerHack_file()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.truncate(long)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MemoryVol.close()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MemoryVol.truncate(long)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.<unknown>.run(java.lang.String)"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: Disable cleaner hack for mmap files and direct memory. See #442 and see #437\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-04 08:08:44"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-15 09:29:08", "commitHash": "72649e80593c3f1fa476c951397a2c9dca467a9c", "commitParents": ["ab1c6e431cc9687f819e53d2be66ee3cb6e28c08"], "commitGHEventType": "referenced", "nameRev": "72649e80593c3f1fa476c951397a2c9dca467a9c tags/mapdb-2.0-beta3~23", "commitGitStats": [{"insertions": 13, "lines": 14, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: add RAF sync to mmap file volume See #442\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-15 09:29:08"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 14:34:05", "commitHash": "9c27cd0a976561fab6a8df43c7dfc7ee1c61de64", "commitParents": ["cb253cfce9f56c93f1768252a3afd987e3ad24c7"], "commitGHEventType": "referenced", "nameRev": "9c27cd0a976561fab6a8df43c7dfc7ee1c61de64 tags/mapdb-1.0.7~15", "commitGitStats": [{"insertions": 4, "lines": 5, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "Partial fix for #442. Disable DirectByteBuffer unmap hack if Async Writer is enabled\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 14:34:05"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-15 00:18:40", "commitHash": "ab1c6e431cc9687f819e53d2be66ee3cb6e28c08", "commitParents": ["5cbae4a22ca6b3ce38d18c4efdd4b046361305ee"], "commitGHEventType": "referenced", "nameRev": "ab1c6e431cc9687f819e53d2be66ee3cb6e28c08 tags/mapdb-2.0-beta3~24", "commitGitStats": [{"insertions": 28, "lines": 45, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 17}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 3, "TOT": 15, "DEL": 5, "INS": 6, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: zero out bytes in mmap files. See #442\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-15 00:18:40"}], "created": "2015-02-02 13:59:18"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/435", "title": "Disk leak at DB.getHashMap", "closed": "2015-01-26 13:42:17", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2015-01-26 13:39:44", "user": "jankotek", "body": "Following code in `DB` always allocates new recids, even if they exists. It is mean to be default allocated only if HashMap is not found. There are two locations, one for map, second for set\n\n```\n            catPut(name+\".segmentRecids\",HTreeMap.preallocateSegments(engines)),\n```\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/434", "title": "HTreeMap behaves different from java.util.HashMap", "closed": "2015-03-06 09:38:23", "commitsDetails": [], "commits": {}, "ttf": 42.000277777777775, "created": "2015-01-22 20:17:29", "user": "pweinroth", "body": "Running with Trove 3.0.3 and MapDb 1.0.6 when we insert records into the treemap and then recover them using the cache key the string values on the HTreeMap have been changed to a null.  Using a hashmap this is not occurring.  \n\nCould this be related to the handling of single quote, backslash, or utf-8 characters?\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/433", "title": "newMemoryDirectDB  - direct memory manager", "closed": "2015-04-30 20:04:01", "commitsDetails": [], "commits": {}, "ttf": 108.00027777777778, "created": "2015-01-12 15:58:50", "user": "kobikis", "body": "I've been  using MapDb with GigaSpaces XAP using newMemoryDirectDB, In the heap we are storing our indices and using MapDB for storing the data(serialized).\nNow I'm running load tests and occasionally I'm getting OOM, is there a way to monitor the MapDB direct memory size?\n\nI think a direct memory manager which monitor and alert canbe very useful and prevent OOM.\n\nThanks.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["09ad5ffff24cee29d88ebf117a13dde8d7f069d6", "e0cd5d06a2d433b31d2869c520cbc0493e290152"], "url": "https://github.com/jankotek/mapdb/issues/430", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 2, "lines": 19, "deletions": 8}, "numCommits": 2, "commits": {"09ad5ffff24cee29d88ebf117a13dde8d7f069d6": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e0cd5d06a2d433b31d2869c520cbc0493e290152": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 223.00027777777777, "user": "dstoeckel", "changesInPackagesSPOON": ["org.mapdb.Pump.sort(java.util.Comparator,boolean,java.util.Iterator[]).2.next()", "org.mapdb.Fun.filter(java.util.NavigableSet,java.lang.Object[]).16.iterator().1.moveToNext()", "org.mapdb.Fun.filter(java.util.NavigableSet,java.lang.Object[]).16.iterator()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "We created a MultiMap using a BTreeSet (as in the example). In this MultiMap, key comparison should be case-insensitive and thus we provided our own comparator. The provided Fun.filter method, however uses equals for key comparison instead of our custom comparator.\n\nThis issue is already kind of documented in the source code, but as we were bitten by it i am opening an issue here.\n\nWe work around this by simply copying the methods and hacking case insensitive comparison into it.\nAlternatively a version of filter that takes a Comparator object would be helpful.\n\nWe currently use commit 1e3b272b31fbffcda393aa93f9666fac18c1dada for development, however the issue is still present in current master.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 2, "TOT": 17, "DEL": 2, "INS": 6, "spoonFilesChanged": 2, "MOV": 7}, "title": "Fun.filter should use the comparator of the filtered set", "statsSkippedReason": "", "closed": "2015-08-18 12:32:22", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-08-18 17:30:06", "commitHash": "09ad5ffff24cee29d88ebf117a13dde8d7f069d6", "commitParents": ["e0cd5d06a2d433b31d2869c520cbc0493e290152"], "commitGHEventType": "referenced", "nameRev": "09ad5ffff24cee29d88ebf117a13dde8d7f069d6 tags/mapdb-2.0-beta6~2", "commitGitStats": [{"insertions": 3, "lines": 4, "filePath": "src/main/java/org/mapdb/Fun.java", "deletions": 1}, {"insertions": 4, "lines": 6, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.filter(java.util.NavigableSet,java.lang.Object[]).16.iterator().1.moveToNext()"}], "spoonFilePath": "Fun.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 10, "DEL": 1, "INS": 3, "MOV": 6, "spoonMethodName": "org.mapdb.Pump.sort(java.util.Comparator,boolean,java.util.Iterator[]).2.next()"}], "spoonFilePath": "Pump.java"}], "commitMessage": "Fix failing test case for #430\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-18 17:30:06"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-18 14:32:15", "commitHash": "e0cd5d06a2d433b31d2869c520cbc0493e290152", "commitParents": ["7041a7d4fb7ad6f41fc486628c4ba96c4dd2486a"], "commitGHEventType": "closed", "nameRev": "e0cd5d06a2d433b31d2869c520cbc0493e290152 tags/mapdb-2.0-beta6~3", "commitGitStats": [{"insertions": 4, "lines": 9, "filePath": "src/main/java/org/mapdb/Fun.java", "deletions": 5}, {"insertions": 17, "lines": 17, "filePath": "src/test/java/org/mapdb/FunTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.FunTest.filter()"}], "spoonFilePath": "FunTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Fun.filter(java.util.NavigableSet,java.lang.Object[]).16.iterator().1.moveToNext()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.filter(java.util.NavigableSet,java.lang.Object[]).16.iterator()"}], "spoonFilePath": "Fun.java"}], "commitMessage": "Fun: Fun.filter should use the comparator of the filtered set. Fix #430\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-18 14:32:15"}], "created": "2015-01-07 11:20:11"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/429", "title": "createTreeMap and ClassCastException", "closed": "2015-04-30 20:15:18", "commitsDetails": [], "commits": {}, "ttf": 115.00027777777778, "created": "2015-01-04 22:39:13", "user": "ghost", "body": "To avoid ClassCastException from byte[] to Comparator, I set the proper comparator.\n\n```\nConcurrentNavigableMap<byte[],byte[]> mymap = \n       db.createTreeMap(\"mymap\").comparator(Fun.BYTE_ARRAY_COMPARATOR).makeOrGet();\n```\n\nThis works, I can put and get byte[] keys just fine.\n\nHowever, the next time I run the program, the ClassCastException happens anyway. The exception happens on the code line above.\n\nAnything else I need to do?\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/427", "title": "Thread named HTreeMap expirator Use a lot of CPU", "closed": "2015-08-21 07:14:13", "commitsDetails": [], "commits": {}, "ttf": 239.00027777777777, "created": "2014-12-25 06:52:28", "user": "davy-zhang", "body": "When I use this code to create a HTreeMap instance.\nHTreeMap<Object, Object> cache=DBMaker.newMemoryDirectDB().transactionDisable().cacheLRUEnable().make().createHashMap(\"testCache\").expireMaxSize(10000).makeOrGet();\n\nIt creates a thread named HTreeMap expirator, But When the map size is 10015,the thread has been running use a lot of CPU and not sleep.\n\nThe following code if there is a problem ?\nIn ExpireRunnable Class\nMethod:expirePurge\ncode:removePerSegment=1+(size-expireMaxSize)/16;\nMethod:expirePurgeSegment\ncode:final boolean remove = ++counter < removePerSegment || ((expire!=0 || expireAccess!=0) &&  n.time+expireTimeStart<System.currentTimeMillis());\n\nWhen map size is 10015 ,the removePerSegment greater than 0 and the remove are all false.\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/425", "title": "off-heap cache does not evict entries fast enough; results in \"OutOfMemoryError: Direct buffer memory\"", "closed": "2015-10-01 09:19:09", "commitsDetails": [], "commits": {}, "ttf": 282.0002777777778, "created": "2014-12-23 07:11:18", "user": "dlg99", "body": "from https://groups.google.com/forum/#!topic/mapdb/qDbylSwpSU4\n\nI am trying to make use of MapDB as off-heap LRU cache, unfortunately all my attempts to make it expire records as expected have failed so far.\nI see that occasionally records are being removed (cache size drops) but eventually OutOfMemory is thrown.\nI tried setting cache expiration time (expireAftreWrite), changing expiremaxSize setting etc., eventually test still ends up with the same exception. Please see the code below.\n\nAm I misconfiguring something?\n\nStack:\n\n```\njava.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:658)\n    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:306)\n    at org.mapdb.Volume$MemoryVol.makeNewBuffer(Volume.java:578)\n    at org.mapdb.Volume$ByteBufferVol.tryAvailable(Volume.java:290)\n    at org.mapdb.Volume.ensureAvailable(Volume.java:49)\n    at org.mapdb.StoreDirect.freePhysTake(StoreDirect.java:1095)\n```\n\nMy jvm parameters:\n\n```\n-Xmx3g -Xms3g -XX:NewSize=1g -XX:MaxNewSize=1g -XX:MaxDirectMemorySize=6g -XX:PermSize=64m -XX:MaxPermSize=64m  -XX:+UseParNewGC -XX:MaxTenuringThreshold=2 -XX:ParallelGCThreads=10 -XX:+CMSConcurrentMTEnabled -XX:ParallelCMSThreads=6 -XX:ConcGCThreads=6 -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark -XX:SurvivorRatio=48 -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=32768 -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSClassUnloadingEnabled  -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -XX:-OmitStackTraceInFastThrow  \n```\n\nJDK 7, code compiled as jdk 6 compatible.\nMapDB 1.0.6.\n\nCode (simplified to the level of simple byte array):\n\n```\nimport org.junit.Test;\nimport org.mapdb.DBMaker;\nimport org.mapdb.Serializer;\n\nimport java.security.SecureRandom;\nimport java.util.Map;\nimport java.util.Random;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class MapDbTestUtil {\n\n  private static final Random random = new SecureRandom();\n\n  private static final int NUM_TESTS = Integer.MAX_VALUE;\n  private static final int BYTES_SIZE = 250 * 1024 - 32; // 250K minus key size\n\n  @Test\n  public void testMapDbCache() throws Exception {\n\n    final int sizeGB = 1;\n    Map<String, byte[]> cache = DBMaker\n        .newMemoryDirectDB() // off-heap, in memory\n        .transactionDisable()\n        .cacheLRUEnable()\n        .cacheDisable() //internal instance cache, too bad for GC\n        //.compressionEnable()\n        //.asyncWriteFlushDelay(50)\n        //.asyncWriteQueueSize(25)\n        //.sizeLimit(2.0d*sizeGB)\n        .make()\n        .createHashMap(\"mapdb-unit-test-expiration\")\n        .counterEnable() //for tests\n        .expireMaxSize(10000)\n        .expireStoreSize(sizeGB) // can be slightly more than this\n        .keySerializer(Serializer.STRING_ASCII) // ids are ascii, save some space\n        .valueSerializer(Serializer.BYTE_ARRAY)\n        .make();\n\n    byte[] ce = generateByteArray(BYTES_SIZE);\n    long count = 0;\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < NUM_TESTS; i++) {\n      String netId = buildId(i);\n\n      cache.put(netId, ce);\n\n      count++;\n\n      if(count == 10000) {\n        long delta = System.currentTimeMillis() - start;\n        System.out.println(\"\");\n        System.out.println(String.format(\"%d inserts in %d ms (%f/sec)\", count, delta, (double)count * 1000/delta));\n        validateOne(cache, random.nextInt(i));\n        //Thread.sleep(100);\n        start = System.currentTimeMillis();\n        count = 0;\n      } //else {\n      //  cache.get(\"missing\");\n      //}\n    }\n\n  }\n\n  private byte[] generateByteArray(int sz) {\n    byte[] res = new byte[sz];\n    random.nextBytes(res);\n    return res;\n  }\n\n  private void validateOne(Map<String, byte[]> cache, int i) {\n    System.out.println(\"\");\n    String netId = buildId(i);\n    byte[] cached = cache.get(netId);\n\n    if (cached == null) {\n      System.out.print(\"cache MISS; cache size: \" + cache.size());\n      return;\n    }\n    System.out.print(\"cache HIT;  cache size: \" + cache.size());\n\n    assertEquals(BYTES_SIZE, cached.length);\n  }\n\n  private String buildId(int i) {\n    String id = \"3dd8b8f5ed5567e11936cc572bcc572b\" + Integer.toString(i) ;\n    id = id.substring(id.length() - 32, id.length());\n    return id;\n  }\n\n}\n```\n"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/423", "title": "Assertion fault for removing index", "closed": "2016-02-14 17:51:26", "commitsDetails": [], "commits": {}, "ttf": 426.0002777777778, "created": "2014-12-15 16:04:20", "user": "mfayoub", "body": "Hi,\n\nWhen I ran canDeleteDBOnBrokenLog in the BrokenDBTest test file, the index still exists after removing it. I got this message saying \"Can't delete index\"\n\nAny thoughts about that ?\n\nThanks,\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/421", "title": "Pump: IndexOutOfBoundsException: Index: 0, Size: 0", "closed": "2015-08-12 17:55:56", "commitsDetails": [], "commits": {}, "ttf": 241.00027777777777, "created": "2014-12-14 12:05:34", "user": "jandam", "body": "Exception occurs when source iterator for Pump is empty. (MapDB master)\n\njava.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n    at java.util.ArrayList.rangeCheck(ArrayList.java:653)\n    at java.util.ArrayList.get(ArrayList.java:429)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:500)\n    at org.mapdb.DB.createTreeMap(DB.java:946)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:743)\n    at org.mapdb.DB$BTreeMapMaker.makeOrGet(DB.java:750)\n\n```\n    BTreeMap<Long, Record> spatialMapN = db.createTreeMap(\"record\")\n            .keySerializer(BTreeKeySerializer.LONG)\n            .valueSerializer(new RecordSerializer())\n            .nodeSize(120)\n            .pumpSource(Collections.emptyIterator())         // <<-- HERE \n            .pumpIgnoreDuplicates()\n            .counterEnable()\n            .makeOrGet();\n```\n"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/420", "title": "java.lang.ArrayIndexOutOfBoundsException: null BTreeMap.java:2841", "closed": "2016-02-14 17:50:23", "commitsDetails": [], "commits": {}, "ttf": 436.0002777777778, "created": "2014-12-05 07:39:56", "user": "cep21", "body": "Hi,\n\nWe're using mapdb-1.0.6.  It's a recent database that was created with this release.  I'm unable to reproduce in a small use case, but are seeing this exception in production.  Unsure how to debug this error.\n\nDB created as\n\n``` java\n        return DBMaker.newFileDB(actualFileToOpen)\n                .cacheSize(maxDatapointSize.get())\n                .closeOnJvmShutdown()\n                .checksumEnable()\n                .mmapFileEnableIfSupported()\n                .cacheLRUEnable()\n                .cacheSoftRefEnable()\n                .make();\n```\n\nWe have a separate thread running in a sleep loop:\n\n``` java\ndb.commit();\n```\n\nWe see the following exception in our logs.  Does this mean the DB is corrupted?  Is there a way to recover, or another way to resolve this issue?\n\n```\n2014-12-05T07:12:36.235Z ERROR [tsworker-1] [s.d.t.TsCreator  ] {}: Failed to create time series\njava.lang.ArrayIndexOutOfBoundsException: null\n        at org.mapdb.BTreeMap.arrayPut(BTreeMap.java:2841) ~[mapdb-1.0.6.jar:na]\n        at org.mapdb.BTreeMap.put2(BTreeMap.java:743) ~[mapdb-1.0.6.jar:na]\n        at org.mapdb.BTreeMap.put(BTreeMap.java:643) ~[mapdb-1.0.6.jar:na]\n......\n```\n"}, {"labels": ["bug"], "filteredCommits": ["b71e79ee91e9afca37167ebb60dc0b064612b7f8"], "url": "https://github.com/jankotek/mapdb/issues/419", "gitStatsSummary": {"insertions": 13, "gitFilesChange": 1, "lines": 18, "deletions": 5}, "numCommits": 1, "commits": {"b71e79ee91e9afca37167ebb60dc0b064612b7f8": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "73cd46e6ef65fecc5dec75ed12cff6c0ec30e481": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 68.00027777777778, "user": "wszyquan", "changesInPackagesSPOON": ["SPOON_EXCEPTION"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "java.lang.AssertionError\n    at org.mapdb.SerializerPojo.deserializeUnknownHeader(SerializerPojo.java:444)\n    at org.mapdb.SerializerBase.deserialize3(SerializerBase.java:1216)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:1132)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:867)\n    at org.mapdb.SerializerPojo.deserialize(SerializerPojo.java:701)\n    at org.mapdb.HTreeMap$2.deserialize(HTreeMap.java:135)\n    at org.mapdb.HTreeMap$2.deserialize(HTreeMap.java:121)\n    at org.mapdb.Store.deserialize(Store.java:297)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:368)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:352)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n    at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:333)\n    at org.mapdb.Caches$HashTable.get(Caches.java:245)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:350)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:345)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:345)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:345)\n    at org.mapdb.HTreeMap.sizeLong(HTreeMap.java:325)\n    at org.mapdb.HTreeMap.size(HTreeMap.java:305)\n    at org.mapdb.HTreeMap$KeySet.size(HTreeMap.java:795)\n    at com.snd.api.message.MapDb.dbSetFile(MapDb.java:131)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n# \n\nTest case below\n# run two times throw above error\n\n@Test\n    public void dbSetFile() {\n        // configure and open database using builder pattern.\n        // all options are available with code auto-completion.\n        DB db = DBMaker.newFileDB(new File(\"c://testdbset23\"))\n                .closeOnJvmShutdown().transactionDisable()\n                /\\* encryptionEnable(\"password\") */.make();\n\n```\n    String setName = \"hashSet2\";\n    Set<Integer> set = null;\n\n    if (!db.exists(setName)) {\n        HTreeSetMaker treeSet = db.createHashSet(setName);\n        set = treeSet.expireAfterAccess(30, TimeUnit.DAYS).make();\n        System.out.println(\"create\");\n    } else {\n        set = db.getHashSet(setName);\n        System.out.println(\"read exists\");\n    }\n\n    System.out.println(set.contains(1));\n    for (int i = 0; i < 10000; i++)\n        set.add(i);\n\n    System.out.println(set.size());\n    db.close();\n\n}\n```\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 1, "MOV": 0.0}, "title": "read hashSet dbfile error", "statsSkippedReason": "", "closed": "2015-02-11 13:14:49", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-11 15:15:35", "commitHash": "b71e79ee91e9afca37167ebb60dc0b064612b7f8", "commitParents": ["73cd46e6ef65fecc5dec75ed12cff6c0ec30e481"], "commitGHEventType": "referenced", "nameRev": "b71e79ee91e9afca37167ebb60dc0b064612b7f8 tags/mapdb-2.0-alpha2~74", "commitGitStats": [{"insertions": 13, "lines": 18, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 5}, {"insertions": 0, "lines": 61, "filePath": "src/test/java/org/mapdb/Issue419Test.java", "deletions": 61}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Issue419Test.dbSetFile()"}], "spoonFilePath": "Issue419Test.java"}], "commitMessage": "Fix #419, DB.getHashSet() does not restore expiration settings\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 15:15:35"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 15:14:31", "commitHash": "73cd46e6ef65fecc5dec75ed12cff6c0ec30e481", "commitParents": ["6896a1242a44daea82469998288de452a3c34934"], "commitGHEventType": "closed", "nameRev": "73cd46e6ef65fecc5dec75ed12cff6c0ec30e481 tags/mapdb-2.0-alpha2~75", "commitGitStats": [{"insertions": 131, "lines": 131, "filePath": "src/test/java/org/mapdb/Issue419Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue419Test"}], "spoonFilePath": "Issue419Test.java"}], "commitMessage": "Fix #419, DB.getHashSet() does not restore expiration settings\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 15:07:42"}], "created": "2014-12-05 04:46:27"}, {"labels": ["bug"], "filteredCommits": ["d0e14533fef6983096b9b06aa3e33b5a625f86a3", "29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0"], "url": "https://github.com/jankotek/mapdb/issues/418", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 4, "deletions": 2}, "numCommits": 1, "commits": {"d0e14533fef6983096b9b06aa3e33b5a625f86a3": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "016b7f8fa090178a1bcb2dfa04618b7f676d979b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "74434e7989604ecb9b7d129d34d1fe626af012d5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 70.00027777777778, "user": "davipt", "changesInPackagesSPOON": ["SPOON_EXCEPTION"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I've tried 1.0.6 and failed miserably with mmap corruption and a million other problems, so I've picked the trunk 1e3b272 and I'm failing with this simple test that enables expiration by max size, and then I can't close and reopen the db without everything breaking.\n\nNote: adding sleeps before the puts, after the puts or anywhere else won't solve it. Running the inner block alone, by running the test twice, letting the VM stop and giving enough time for threads to stop and everything doesn't solve it.\n\n``` java\n        final File tmp = new File(\"/tmp/testdb\");\n        for (final String s : Arrays.asList(\"\", \".p\", \".t\"))\n            new File(tmp.getAbsolutePath() + s).delete();\n\n        for (int o = 0; o < 2; o++) {\n            final DB db = DBMaker.newFileDB(tmp).make();\n            final HTreeMap<Object, Object> map = db.createHashMap(\"foo\").expireMaxSize(100).makeOrGet();\n\n            for (int i = 0; i < 1000; i++)\n                map.put(\"foo\" + i, \"bar\" + i);\n\n            db.commit(); map.close(); db.close();\n        }\n```\n\n``` java\nException in thread \"main\" java.lang.AssertionError\n    at org.mapdb.StoreDirect.get(StoreDirect.java:442)\n    at org.mapdb.Caches$HashTable.get(Caches.java:304)\n    at org.mapdb.HTreeMap.expireLinkBump(HTreeMap.java:1427)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:551)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:503)\n    at test.TestMapDB3.main(TestMapDB3.java:22)\n```\n", "filteredCommitsReason": {"duplicated": 2, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0.0, "TOT": 0.0, "DEL": 0.0, "INS": 0.0, "spoonFilesChanged": 1, "MOV": 0.0}, "title": "Corrupted DB when expiration is enabled", "statsSkippedReason": "", "closed": "2015-02-11 13:48:34", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-11 15:48:01", "commitHash": "d0e14533fef6983096b9b06aa3e33b5a625f86a3", "commitParents": ["b71e79ee91e9afca37167ebb60dc0b064612b7f8"], "commitGHEventType": "closed", "nameRev": "d0e14533fef6983096b9b06aa3e33b5a625f86a3 tags/mapdb-2.0-alpha2~73", "commitGitStats": [{"insertions": 59, "lines": 59, "filePath": "src/test/java/org/mapdb/Issue418Test.java", "deletions": 0}, {"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"spoonMethodName": "SPOON_EXCEPTION"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue418Test"}], "spoonFilePath": "Issue418Test.java"}], "commitMessage": "Fix #418, HTreeMap expiration was broken after reopening. This also probably fixes #418\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 15:46:58"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 15:46:58", "commitHash": "016b7f8fa090178a1bcb2dfa04618b7f676d979b", "commitParents": ["39ba84da468c5cb3e13fd51402a94506a3bf12a0"], "commitGHEventType": "referenced", "nameRev": "016b7f8fa090178a1bcb2dfa04618b7f676d979b tags/mapdb-1.0.7~13", "commitGitStats": [{"insertions": 59, "lines": 59, "filePath": "src/test/java/org/mapdb/Issue418Test.java", "deletions": 0}, {"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createHashMap(org.mapdb.DB$HTreeMapMaker)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createHashSet(org.mapdb.DB$HTreeSetMaker)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue418Test"}], "spoonFilePath": "Issue418Test.java"}], "commitMessage": "Fix #418, HTreeMap expiration was broken after reopening. This also probably fixes #418\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 15:46:58"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-28 14:49:25", "commitHash": "29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0", "commitParents": ["4bc472b356046aba046fd4f9691514a064f74b41"], "commitGHEventType": "referenced", "nameRev": "29bbde78ac2a6be31f9bcf0c92b4a2d17bb60ad0 tags/mapdb-renamed-1.0.8~21", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/Issue418Test.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Issue418Test.test()"}, {"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Issue418Test.test_set()"}], "spoonFilePath": "Issue418Test.java"}], "commitMessage": "Issue #418; HTreeMap Expirator does not work well with rollbacks\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-28 14:45:11"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-28 14:45:11", "commitHash": "74434e7989604ecb9b7d129d34d1fe626af012d5", "commitParents": ["5e2cb5ecf8bae2e996aac82ed81ca4c73468c1d1"], "commitGHEventType": "referenced", "nameRev": "74434e7989604ecb9b7d129d34d1fe626af012d5 tags/mapdb-2.0-alpha2~65", "commitGitStats": [{"insertions": 3, "lines": 3, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 0}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/Issue418Test.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Issue418Test.test()"}, {"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Issue418Test.test_set()"}], "spoonFilePath": "Issue418Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Issue #418; HTreeMap Expirator does not work well with rollbacks\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-28 14:45:11"}], "created": "2014-12-02 20:36:00"}, {"labels": ["bug"], "filteredCommits": ["b44242b43b1a82cee8ac1353050df2d363afd2a7"], "url": "https://github.com/jankotek/mapdb/issues/417", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"b44242b43b1a82cee8ac1353050df2d363afd2a7": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 70.00027777777778, "user": "lmprice", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.calculateStatistics()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There is an infinite loop in this code. I'm assuming the update portion should update \"ss\", not \"s\".\n\nfor(int size = 16;size<MAX_REC_SIZE+10;size_=2){\n            long sum = 0;\n            for(int ss=size/2;ss<size;s+=16){\n                sum+=countLongStackItems(size2ListIoRecid(ss))_ss;\n            }\n            s+=\"Size occupied by free records (size=\"+size+\") = \"+sum;\n        }\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 0}, "title": "Infinite loop in Store.calculateStatistics()", "statsSkippedReason": "", "closed": "2015-02-11 14:25:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-11 16:24:59", "commitHash": "b44242b43b1a82cee8ac1353050df2d363afd2a7", "commitParents": ["83a6e0930b344ec67ad7a70996ae5e7eb3f44c82"], "commitGHEventType": "referenced", "nameRev": "b44242b43b1a82cee8ac1353050df2d363afd2a7 tags/mapdb-1.0.7~11", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.calculateStatistics()"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "Fix #417, Infinite loop in Store.calculateStatistics()\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 16:24:59"}], "created": "2014-12-02 18:12:33"}, {"labels": ["2.0", "bug"], "filteredCommits": ["d0d1c060a0a5cdec025fe6d1c72c2bf6313e8ecf"], "url": "https://github.com/jankotek/mapdb/issues/414", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"41e3e8059121314a64ef32611bad68ab176b8a8f": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "d0d1c060a0a5cdec025fe6d1c72c2bf6313e8ecf": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 81.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.TxEngine.createSnapshotFor(org.mapdb.Engine)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "```\n// Do update\nDB db = ...;\nsynchronized (writeLock) {\n    try {\n        BTreeMap map1 = db.getTreeMap(\"map1\");\n        BTreeMap map2 = db.getTreeMap(\"map2\");\n\n        // perform reads and updates in map1/map2\n\n        db.commit(); // global commit\n    } catch (Exception e) {\n        db.rollback();\n    }\n}\n```\n\nI tried this and ran into several problems:\nthere's a bug in TxEngine that causes DB.snapshot() to always fail (I've attached the diff against master)\n\n```\ndiff --git a/src/main/java/org/mapdb/TxEngine.java b/src/main/java/org/mapdb/TxEngine.java\nindex 2d871d4..b9069e7 100644\n--- a/src/main/java/org/mapdb/TxEngine.java\n+++ b/src/main/java/org/mapdb/TxEngine.java\n@@ -85,7 +85,7 @@ public class TxEngine extends EngineWrapper {\n         if(engine instanceof TxEngine)\n             return ((TxEngine)engine).snapshot();\n         if(engine instanceof EngineWrapper)\n-            createSnapshotFor(((EngineWrapper) engine).getWrappedEngine());\n+            return createSnapshotFor(((EngineWrapper) engine).getWrappedEngine());\n         throw new UnsupportedOperationException(\"Snapshots are not enabled, use DBMaker.snapshotEnable()\");\n     }\n\n```\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "TXEngine DB.snapshot() fails", "statsSkippedReason": "", "closed": "2015-02-17 09:54:04", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-17 11:51:14", "commitHash": "d0d1c060a0a5cdec025fe6d1c72c2bf6313e8ecf", "commitParents": ["b77fd440c08cbea3f6347476fa61127052c834df"], "commitGHEventType": "referenced", "nameRev": "d0d1c060a0a5cdec025fe6d1c72c2bf6313e8ecf tags/mapdb-1.0.7~7", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/TxEngine.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.TxEngine.createSnapshotFor(org.mapdb.Engine)"}], "spoonFilePath": "TxEngine.java"}], "commitMessage": "Fix #414, snapshots were not working under some conditions\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 11:51:14"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-17 11:53:48", "commitHash": "41e3e8059121314a64ef32611bad68ab176b8a8f", "commitParents": ["8edaa511a9f5eb5548360681ac7baff277b981fd"], "commitGHEventType": "closed", "nameRev": "41e3e8059121314a64ef32611bad68ab176b8a8f tags/mapdb-2.0-alpha2~67", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/TxEngine.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.TxEngine.createSnapshotFor(org.mapdb.Engine)"}], "spoonFilePath": "TxEngine.java"}], "commitMessage": "Fix #414, snapshots were not working under some conditions\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 11:53:48"}], "created": "2014-11-27 15:00:28"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/413", "title": "Empty versus null strings", "closed": "2015-08-13 11:24:30", "commitsDetails": [], "commits": {}, "ttf": 258.0002777777778, "created": "2014-11-27 12:33:47", "user": "jankotek", "body": "I think MapDB could turn null strings into empty strings... Need more unit tests.\n\nregarding https://github.com/jankotek/MapDB/blob/517d9dd16958851eea71767e1285c2a5caa6ac60/src/main/java/org/mapdb/DataIO.java\n1. Auto morph null Strings to Empty strings.\n   public void writeUTF(final String s) throws IOException {\n   if(s == null){  packInt(0);  return; }\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/411", "title": "NPE in BTreeMap (version 1.0.4)", "closed": "2015-02-17 09:45:17", "commitsDetails": [], "commits": {}, "ttf": 84.00027777777778, "created": "2014-11-24 21:21:21", "user": "samhendley", "body": "I found one of my servers in a very unhappy state and I am trying to figure out how this occurred and if this has been fixed in a more recent version. \n\nHere is my map definition, the endpoint serializer is a trivial serializer that outputs reads and writes 2 integers.\n\n``` java\ndb.createTreeMap(\"endpointInfo\")\n                .counterEnable()\n                .keySerializer(BTreeKeySerializer.ZERO_OR_POSITIVE_INT)\n                .valueSerializer(new EndpointInformationSerializer())\n                .<Integer, EndpointInformation> makeOrGet()\n```\n\nEveryone of my queries to my map were failing with the following error NPE.\n\n```\njava.lang.NullPointerException\n        at org.mapdb.BTreeMap.get(BTreeMap.java:600)\n        at org.mapdb.BTreeMap.get(BTreeMap.java:589)\n```\n\nHere is the code from MapDb 1.0.4:\n\n``` java\n    @Override\n     public V get(Object key){\n        return (V) get(key, true);\n    }\n\n    protected Object get(Object key, boolean expandValue) {\n        if(key==null) throw new NullPointerException();\n        K v = (K) key;\n        long current = engine.get(rootRecidRef, Serializer.LONG); //get root\n\n        BNode A = engine.get(current, nodeSerializer);\n\n        //dive until  leaf\n        while(!A.isLeaf()){\n            current = nextDir((DirNode) A, v);\n            A = engine.get(current, nodeSerializer);\n        }\n```\n\nWhen I restarted the application to enable debugging I got this exception which prevented me from loading the database: \n\n```\nCaused by: java.lang.AssertionError: data were read beyond record size, check your serializer\n        at org.mapdb.Store.deserialize(Store.java:301)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n        at org.mapdb.StoreDirect.get(StoreDirect.java:428)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n        at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:401)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n        at org.mapdb.Caches$LRU.get(Caches.java:84)\n        at org.mapdb.Caches$HardRef.get(Caches.java:613)\n        at org.mapdb.BTreeMap.<init>(BTreeMap.java:541)\n        at org.mapdb.DB.getTreeMap(DB.java:788)\n        at org.mapdb.DB$BTreeMapMaker.makeOrGet(DB.java:650)\n```\n\nThere wasn't anything particular in the changelog that seemed related to this problem but the BTreeMap code has changed. Any chance this bug has been found and fixed before? I am planning to update to 1.0.6 in any case but any advice you can give me about this bug would be appreciated.\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["2b6bff82fbf2e5e1d2f2169435a03f947ac2f5c5"], "url": "https://github.com/jankotek/mapdb/issues/410", "gitStatsSummary": {"insertions": 19, "gitFilesChange": 1, "lines": 27, "deletions": 8}, "numCommits": 1, "commits": {"2b6bff82fbf2e5e1d2f2169435a03f947ac2f5c5": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 137.00027777777777, "user": "jandam", "changesInPackagesSPOON": ["org.mapdb.BTreeKeySerializer.getOffset()", "org.mapdb.BTreeKeySerializer.ByteArrayKeys.compare(int,java.lang.String)", "org.mapdb.BTreeKeySerializer.5.serialize(java.io.DataOutput,org.mapdb.BTreeKeySerializer$StringArrayKeys)", "org.mapdb.BTreeKeySerializer.CharArrayKeys.getOffset()", "org.mapdb.BTreeKeySerializer.ByteArrayKeys.getOffset()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "MapDB v. 2.0\n            BTreeMap<String, long[]> searchMapN = dbSearchIndex.createTreeMap(name)\n                    .keySerializer(BTreeKeySerializer.STRING)\n                    .valueSerializer(Serializer.LONG_ARRAY)\n                    .counterEnable()\n                    .makeOrGet();\n\njava.lang.ClassCastException: org.mapdb.BTreeKeySerializer$CharArrayKeys cannot be cast to org.mapdb.BTreeKeySerializer$ByteArrayKeys\n    at org.mapdb.BTreeKeySerializer$5.serialize(BTreeKeySerializer.java:1620)\n    at org.mapdb.BTreeKeySerializer$5.serialize(BTreeKeySerializer.java:1617)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:610)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:550)\n    at org.mapdb.Store.serialize(Store.java:164)\n    at org.mapdb.StoreDirect.update(StoreDirect.java:521)\n    at org.mapdb.Caches$HashTable.update(Caches.java:338)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:65)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:969)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:853)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 5, "UPD": 5, "TOT": 13, "DEL": 2, "INS": 5, "spoonFilesChanged": 1, "MOV": 1}, "title": "CCE: : org.mapdb.BTreeKeySerializer$CharArrayKeys cannot be cast to org.mapdb.BTreeKeySerializer$ByteArrayKeys", "statsSkippedReason": "", "closed": "2015-04-10 11:37:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-04-10 14:37:15", "commitHash": "2b6bff82fbf2e5e1d2f2169435a03f947ac2f5c5", "commitParents": ["633643c4ff67c2fa31054432ab740f54f8525120"], "commitGHEventType": "closed", "nameRev": "2b6bff82fbf2e5e1d2f2169435a03f947ac2f5c5 tags/mapdb-2.0-alpha2~26^2~1", "commitGitStats": [{"insertions": 19, "lines": 27, "filePath": "src/main/java/org/mapdb/BTreeKeySerializer.java", "deletions": 8}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeKeySerializer.ByteArrayKeys.compare(int,java.lang.String)"}, {"UPD": 3, "TOT": 6, "DEL": 2, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.5.serialize(java.io.DataOutput,org.mapdb.BTreeKeySerializer$StringArrayKeys)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.getOffset()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.ByteArrayKeys.getOffset()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.CharArrayKeys.getOffset()"}], "spoonFilePath": "BTreeKeySerializer.java"}], "commitMessage": "Fix #410, unicode String comparison is wrong. Thanks to Martin J for fixing this\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-04-10 14:37:15"}], "created": "2014-11-24 06:13:07"}, {"labels": ["2.0", "android", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/409", "title": "SerializerPojo and MappedFileVol issues - on 1.0 release", "closed": "2016-02-14 17:46:32", "commitsDetails": [], "commits": {}, "ttf": 449.0002777777778, "created": "2014-11-21 19:44:15", "user": "ZenoFuturista", "body": "Hello all,\nI found two problems on older 1.0 release:\n\n1) Consider this enum:\n\n``` java\npublic enum TestEnum {\n    test(\"abc\");\n    private String value;\n\n    private TestEnum(String value)\n    {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\nNow if you take and store this structure into mapdb on lets say oracle jre, getFields(...) function in SerializerPojo will tell you that there are no fields on this class. But if you will do the same thing on android's dalvik, there will be 4 fields - this implies serialization/deserialization format incompatibility across different VMs. \nFor now I just used this simple workaround:\n\n``` java\nprotected ObjectStreamField[] getFields(Class<?> clazz) {\n....\n    FastArrayList<ObjectStreamField> fieldsList = new FastArrayList<ObjectStreamField>();\n    while (streamClass != null && !clazz.isEnum()) {\n        for (ObjectStreamField f : streamClass.getFields()) {\n...\n}\n```\n\nI was not able to figure out some better fix. Personally I dont like this approach, maybe you will think out something better, so I will leave the decision on how to overcome this for you to make.\n\n2) I am not quite sure how I came to this issue, it was probably the change of FileChannelVol to MappedFileVol used with the same underlying mapdb or maybe chunkShift was changed, anyway this does not matter. To put it simply, if MappedFileVol was instantiated on an index or phys file smaller than some multiple of chunkSize, number of chunks was incorrectly derived. In my case StoreDirect considered my index empty (chunksCount was 0) and recreated its structure, for phys, there was one chunk missing. So I made a simple fix for this:\n\n``` java\npublic MappedFileVol(File file, boolean readOnly, long sizeLimit, int chunkShift, int sizeIncrement) {\n...\n    if(fileSize>0){\n        //map existing data\n        int chunksCount = (int) ((fileSize>>> chunkShift));\n        while(chunkSize*chunksCount < fileSize)\n             chunksCount++;\n        chunks = new ByteBuffer[chunksCount];\n...\n}\n```\n\nThis solved my problems, maybe it will help you too. :)\n\nI did a quick look on master branch and it seems that these issues apply also  (with a little difference in MappedFileVol). I hope this report will somehow help you. \nHave a nice day and hold on with this amazing project!\nZeno\n"}, {"labels": ["2.0", "bug", "document"], "url": "https://github.com/jankotek/mapdb/issues/405", "title": "After rollback AssertionError: data were read beyond record size, check your serializer is thrown", "closed": "2016-02-14 17:45:58", "commitsDetails": [], "commits": {}, "ttf": 451.0002777777778, "created": "2014-11-20 07:06:10", "user": "kobikis", "body": "Hi,\n\nI'm trying to use mapdb with transaction but i'm getting this error after rollback and get, if i'm performing commit everything is ok.\n\nException in thread \"main\" java.lang.AssertionError: data were read beyond record size, check your serializer\n    at org.mapdb.Store.deserialize(Store.java:301)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:368)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:352)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n    at org.mapdb.HTreeMap.getInner(HTreeMap.java:440)\n    at org.mapdb.HTreeMap.get(HTreeMap.java:397)\n\npublic static void main(String[] args) {\n        DB db;\n        ConcurrentMap<Serializable, Serializable> _data ;\n        db = DBMaker\n                .newMemoryDirectDB()\n                .cacheDisable()\n                .make();\n        _data = db.createHashMap(\"aaa\")\n                .make();\n        Data data = new Data();\n        data.setId(0);\n        _data.put(0, SerializationUtils.serialize(data));\n        db.rollback();\n        Serializable d = _data.get(0);\n    }\n\nThanks,\nKobi\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["056ff9cbcbcffcfe510523d7bff2be19c002cf69"], "url": "https://github.com/jankotek/mapdb/issues/403", "gitStatsSummary": {"insertions": 27, "gitFilesChange": 1, "lines": 53, "deletions": 26}, "numCommits": 1, "commits": {"056ff9cbcbcffcfe510523d7bff2be19c002cf69": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 273.0002777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.removeOrReplace(java.lang.Object,java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I have a simple prototype application BTreeMap based application which\nincludes a b-tree called \"id2entry\" mapping longs to byte arrays:\n\n```\ndb = DBMaker.newFileDB(DB_FILE)\n    .mmapFileEnableIfSupported()\n    .closeOnJvmShutdown()\n    .commitFileSyncDisable()\n    .make();\n\nid2entry = db.createTreeMap(\"id2entry\")\n    .valueSerializer(Serializer.BYTE_ARRAY)\n    .valuesOutsideNodesEnable()\n    .makeLongMap();\n\n```\n\nIf I perform repeated updates to id2entry, where a random key is selected\nand its value replaced, i.e. no new keys are added and none are deleted, I\nnotice that the DB size grows rapidly on disk at a rate proportional to the\namount of data being replaced. In other words, if I replace 10MB of values\nthe DB grows by 10MB.\n\nI have chosen to use the option valuesOutsideNodesEnable() because the\nvalues are of variable length ranging from 0.5KB to several MBs (in my\ntesting I'm only using 512B values). If I remove the option I notice that\nthe DB size remains quite stable.\n\nNote that I am using the latest MapDB 2.0 snapshot, although I have seen\nsimilar behavior with 1.0.x. Is this behavior expected? I assume it is an\nextreme manifestation of https://github.com/jankotek/MapDB/issues/97. What\ndo you think? It pretty much renders the valuesOutsideNodesEnable() option\nunusable for normal use (I don't want to have to stop the application to\nperform a compaction every few minutes). However, the side effect is that I\nmay not be able to efficiently store large values.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 10, "TOT": 43, "DEL": 9, "INS": 7, "spoonFilesChanged": 1, "MOV": 17}, "title": "Extremely fast database growth when using BTreeMapMaker.valuesOutsideNodesEnable()", "statsSkippedReason": "", "closed": "2015-08-18 16:11:20", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-08-18 18:10:47", "commitHash": "056ff9cbcbcffcfe510523d7bff2be19c002cf69", "commitParents": ["09ad5ffff24cee29d88ebf117a13dde8d7f069d6"], "commitGHEventType": "closed", "nameRev": "056ff9cbcbcffcfe510523d7bff2be19c002cf69 tags/mapdb-2.0-beta6~1", "commitGitStats": [{"insertions": 43, "lines": 43, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 0}, {"insertions": 27, "lines": 53, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 26}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 7, "TOT": 20, "DEL": 3, "INS": 2, "MOV": 8, "spoonMethodName": "org.mapdb.BTreeMap.removeOrReplace(java.lang.Object,java.lang.Object,java.lang.Object)"}, {"UPD": 3, "TOT": 23, "DEL": 6, "INS": 5, "MOV": 9, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.issue403_store_grows_with_values_outside_nodes()"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "BTreeMap: storage space leak with valuesOutsideNodesEnable(). Fix #403\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-18 18:10:47"}], "created": "2014-11-18 09:55:14"}, {"labels": ["2.0", "bug"], "filteredCommits": ["83a6e0930b344ec67ad7a70996ae5e7eb3f44c82"], "url": "https://github.com/jankotek/mapdb/issues/400", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 4, "deletions": 2}, "numCommits": 1, "commits": {"83a6e0930b344ec67ad7a70996ae5e7eb3f44c82": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "10c1baa560043b3d00d5975989180c81d2f1980b": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 97.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.expireLinkBump(int,long,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi,\n\nexpireMaxSize(1000) is fairly small. HTreeMap size works as aproximation for concurrent reasons, so my guess is that this small size couses rounding errors and empties map on each iteration. \n\nI raised new issue to fix this in 2.0:\n\nOn Thursday, October 30, 2014 00:47:59 volker.stampa@eligotech.com wrote:\n\nHi,\n\nto me it seems that a cache initialised with expireMaxSize and expireAfterWrite also expires 0ms after access. I tried the following (sorry for the scala-code, I hope it is clear enough):\n\n```\n      val map = db.createHashMap(UUID.randomUUID().toString).expireMaxSize(1000).expireAfterWrite(1, TimeUnit.DAYS).make[Int, Int]()\n      map.put(1, 1)\n//      println(map.get(1))\n      Thread.sleep(1100) // wait for MapDB cleanup thread\n      println(map.get(1))\n```\n\nThis code prints 1, which is correct. However when the commented println is un-commented it prints:\n\n```\n1\nnull\n```\n\nSo to me it seems that the first map.get records an access and the next time the cleanup-thread runs the 1 is evicted from the cache. When someone confirms that my assumptions are correct, I could open a bug.\n\nThanks\nVolker\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 4, "DEL": 2, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "HTreeMap.expireMaxSize(1000)", "statsSkippedReason": "", "closed": "2015-02-11 14:22:57", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-11 16:21:49", "commitHash": "83a6e0930b344ec67ad7a70996ae5e7eb3f44c82", "commitParents": ["016b7f8fa090178a1bcb2dfa04618b7f676d979b"], "commitGHEventType": "referenced", "nameRev": "83a6e0930b344ec67ad7a70996ae5e7eb3f44c82 tags/mapdb-1.0.7~12", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 2}, {"insertions": 80, "lines": 80, "filePath": "src/test/java/org/mapdb/Issue400Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.expireLinkBump(int,long,boolean)"}], "spoonFilePath": "HTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue400Test"}], "spoonFilePath": "Issue400Test.java"}], "commitMessage": "Fix #400,  HTreeMap.get() resets TTL to zero in some cases\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 16:21:49"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 16:22:30", "commitHash": "10c1baa560043b3d00d5975989180c81d2f1980b", "commitParents": ["d0e14533fef6983096b9b06aa3e33b5a625f86a3"], "commitGHEventType": "closed", "nameRev": "10c1baa560043b3d00d5975989180c81d2f1980b tags/mapdb-2.0-alpha2~72", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 2}, {"insertions": 80, "lines": 80, "filePath": "src/test/java/org/mapdb/Issue400Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.expireLinkBump(int,long,boolean)"}], "spoonFilePath": "HTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue400Test"}], "spoonFilePath": "Issue400Test.java"}], "commitMessage": "Fix #400,  HTreeMap.get() resets TTL to zero in some cases\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 16:21:49"}], "created": "2014-11-06 11:27:52"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/398", "title": "Race condition in Store", "closed": "2014-11-01 09:46:24", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2014-11-01 09:33:26", "user": "jankotek", "body": "MapDB uses storage uses segmented locks. There is typo and in some cases the segments are not overlaping. This can cause data corruption with concurrent access. \n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/392", "title": "Excessive memory allocation if asyncWriteEnable()", "closed": "2015-07-05 22:06:04", "commitsDetails": [], "commits": {}, "ttf": 262.0002777777778, "created": "2014-10-16 16:55:10", "user": "chemist777", "body": "If i specify `asyncWriteEnable()` for DB creation, then JVM memory usage starts grow at high rate.\nThis results in agressive GC pressure.\nCause of this: infinite loop in `AsyncWriteEngine` in which `writeCache.longMapIterator()` called and `new MapIterator()` object created every some ms.\n"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/387", "title": "UUID possibly not thread safe, ban it!", "closed": "2014-11-03 11:51:11", "commitsDetails": [], "commits": {}, "ttf": 29.00027777777778, "created": "2014-10-04 18:39:15", "user": "jankotek", "body": "I was not aware of this. I just assume that UUID is thread safe. \n\nInconsistent hash could in theory explain JVM crash. If MapDB reads value, we could end with very high file pointer, and that could crash JVM.\n\nThere is workaround. Ignore UUID.hashCode and UUID.equals methods. Use custom hasher:\n\n```\nMap hashMap = db.createHashMap()\n.hasher(new UUIDHasher).keySerializer(Serializer.UUID).makeOrGet()\n```\n\nOriginal link does not work, here is link to google cache:\nhttps://webcache.googleusercontent.com/search?q=cache:DUfO-GKxwlEJ:bugs.java.com/view_bug.do%3Fbug_id%3D6611830+&cd=1&hl=en&ct=clnk \n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["d76fd418bb62849d69b2ab9d3ef6209db0d70065", "e4992d529dfcc34c84d39a0c55abd3fa880e6ff9"], "url": "https://github.com/jankotek/mapdb/issues/385", "gitStatsSummary": {"insertions": 84, "gitFilesChange": 7, "lines": 124, "deletions": 40}, "numCommits": 2, "commits": {"d76fd418bb62849d69b2ab9d3ef6209db0d70065": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e4992d529dfcc34c84d39a0c55abd3fa880e6ff9": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 318.0002777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$LinkedNode)", "org.mapdb.HTreeMap.ExpireLinkNode.<unknown>.serialize(java.io.DataOutput,org.mapdb.ExpireLinkNode)", "org.mapdb.HTreeMap.2", "org.mapdb.Store.alreadyCopyedDataInput(java.io.DataInput,int)", "org.mapdb.HTreeMap.1.isTrusted()", "org.mapdb.HTreeMap.2.serialize(java.io.DataOutput,long[][])", "org.mapdb.HTreeMap.ExpireLinkNode.1.deserialize(java.io.DataInput,int)", "org.mapdb.HTreeMap.<unknown>.serialize(java.io.DataOutput,LinkedNode)", "org.mapdb.SerializerPojo.<unknown>.serialize(org.mapdb.DataOutput,CopyOnWriteArrayList)", "org.mapdb.HTreeMap.1.deserialize(java.io.DataInput,int)", "org.mapdb.HTreeMap.<unknown>.deserialize(java.io.DataInput,int)", "org.mapdb.HTreeMap", "org.mapdb.SerializerPojo", "org.mapdb.HTreeMap.1", "org.mapdb", "org.mapdb.HTreeMap.ExpireLinkNode", "org.mapdb.HTreeMap.<unknown>.serialize(java.io.DataOutput,long[][])", "org.mapdb.SerializerPojo.1", "org.mapdb.Store.deserialize(org.mapdb.Serializer,int,java.io.DataInput)", "org.mapdb.HTreeMap.4", "org.mapdb.HTreeMap.3", "org.mapdb.HTreeMap.ExpireLinkNode.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$ExpireLinkNode)", "org.mapdb.HTreeMap.ExpireLinkNode.1", "org.mapdb.SerializerPojo.<unknown>.deserialize(org.mapdb.DataInput,int)", "org.mapdb.SerializerPojo.1.serialize(java.io.DataOutput,java.util.concurrent.CopyOnWriteArrayList)", "org.mapdb.SerializerPojo.1.deserialize(java.io.DataInput,int)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "DataInput in MapDB does not do boundary checking. Deserialization might read data from other records if it continues far enough. \n\nWe should:\n- add new protected interface `TrustedSerializer` and let MapDB internal serializers implement it. \n- add boundary checking into `DataIO.DataInputXXX` unless serializer is trusted. \n- do boundary checking on HTreeMap  entries and BNodes unless key/value serializers are trusted.\n\nRelated issue: https://github.com/jankotek/MapDB/pull/383\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 26, "UPD": 38, "TOT": 99, "DEL": 31, "INS": 27, "spoonFilesChanged": 4, "MOV": 3}, "title": "Limit DataInput", "statsSkippedReason": "", "closed": "2015-08-15 08:54:08", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-10-01 12:49:22", "commitHash": "d76fd418bb62849d69b2ab9d3ef6209db0d70065", "commitParents": ["5dc3c9b2bd6c92a6ee239ea3a63d43ddbd53e741"], "commitGHEventType": "referenced", "nameRev": "d76fd418bb62849d69b2ab9d3ef6209db0d70065 tags/mapdb-2.0-alpha1~113", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Queues.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 2}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 3}, {"insertions": 42, "lines": 72, "filePath": "src/main/java/org/mapdb/Serializer.java", "deletions": 30}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.1"}, {"UPD": 2, "TOT": 12, "DEL": 10, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$LinkedNode)"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.2"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.ExpireLinkNode"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.<unknown>.serialize(java.io.DataOutput,long[][])"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.<unknown>.deserialize(java.io.DataInput,int)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.4"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.ExpireLinkNode.1.deserialize(java.io.DataInput,int)"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.<unknown>.serialize(java.io.DataOutput,LinkedNode)"}, {"UPD": 1, "TOT": 6, "DEL": 5, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.ExpireLinkNode.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$ExpireLinkNode)"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.ExpireLinkNode.1"}, {"UPD": 2, "TOT": 9, "DEL": 5, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.HTreeMap.1.deserialize(java.io.DataInput,int)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.3"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.2.serialize(java.io.DataOutput,long[][])"}, {"UPD": 4, "TOT": 4, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.ExpireLinkNode.<unknown>.serialize(java.io.DataOutput,org.mapdb.ExpireLinkNode)"}], "spoonFilePath": "HTreeMap.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo"}, {"UPD": 0, "TOT": 9, "DEL": 0, "INS": 9, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.<unknown>.serialize(org.mapdb.DataOutput,CopyOnWriteArrayList)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.<unknown>.deserialize(org.mapdb.DataInput,int)"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.1"}, {"UPD": 10, "TOT": 10, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.1.deserialize(java.io.DataInput,int)"}, {"UPD": 5, "TOT": 14, "DEL": 9, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.1.serialize(java.io.DataOutput,java.util.concurrent.CopyOnWriteArrayList)"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb"}], "spoonFilePath": "Serializer.java"}, {"spoonMethods": [], "spoonFilePath": "Queues.java"}], "commitMessage": "Serializer: add Trusted interface. See #385\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-10-01 12:49:22"}, {"commitUser": "jankotek", "commitDateTime": "2015-08-15 10:53:54", "commitHash": "e4992d529dfcc34c84d39a0c55abd3fa880e6ff9", "commitParents": ["b1b90e3b56571ec81ad9c4115a9f4fca8aaee331"], "commitGHEventType": "closed", "nameRev": "e4992d529dfcc34c84d39a0c55abd3fa880e6ff9 tags/mapdb-2.0-beta6~17", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 1}, {"insertions": 16, "lines": 16, "filePath": "src/main/java/org/mapdb/Serializer.java", "deletions": 0}, {"insertions": 16, "lines": 17, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.deserialize(org.mapdb.Serializer,int,java.io.DataInput)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.alreadyCopyedDataInput(java.io.DataInput,int)"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [], "spoonFilePath": "Serializer.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.1.isTrusted()"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Serializer: Limit DataInput, fix  #385\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-08-15 10:53:54"}], "created": "2014-10-01 08:04:59"}, {"labels": ["2.0", "bug"], "filteredCommits": ["2fa873ef0a9c782db566d02020825b18a51b8758", "5e2cb5ecf8bae2e996aac82ed81ca4c73468c1d1"], "url": "https://github.com/jankotek/mapdb/issues/381", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 4, "deletions": 1}, "numCommits": 2, "commits": {"2fa873ef0a9c782db566d02020825b18a51b8758": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "5e2cb5ecf8bae2e996aac82ed81ca4c73468c1d1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 153.00027777777777, "user": "niclash", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.delete(long,org.mapdb.Serializer)", "org.mapdb.StoreWAL.replayWAL()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If you run the test below TWICE on mapdb-1.0.6 it throws a nasty Exception on the second run. If it is run a third time, it gets worse.\nIf the clear() method is removed, then it can be run as many times as one wants.\n\n```\n@Test\npublic void testCorruption()\n    throws Exception\n{\n    final int INSTANCES = 100000;\n    File applicationDbFile = new File( databaseDir, \"testing\" );\n    DBMaker maker = DBMaker.newFileDB( applicationDbFile );\n    TxMaker txMaker = maker.makeTxMaker();\n    DB tx = txMaker.makeTx();\n    byte[] data = new byte[128];\n    try\n    {\n        ConcurrentMap<Long, byte[]> map = tx.getHashMap( \"persons\" );\n        map.clear();\n        for( int i = 0; i < INSTANCES; i++ )\n        {\n            map.put( (long) i, data );\n        }\n        tx.commit();\n    }\n    catch( RuntimeException ex )\n    {\n        tx.rollback();\n        throw ex;\n    }\n    finally\n    {\n        tx.close();\n    }\n}\n```\n\nAnd the Excepiton is;\n\n```\njava.lang.AssertionError: unknown trans log instruction '0' at log offset: 5111834\n    at org.mapdb.StoreWAL.replayLogFile(StoreWAL.java:858)\n    at org.mapdb.StoreWAL.commit(StoreWAL.java:637)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n    at org.mapdb.TxEngine.superCommit(TxEngine.java:310)\n    at org.mapdb.TxEngine$Tx.commit(TxEngine.java:558)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n    at org.mapdb.TxEngine.commit(TxEngine.java:287)\n    at org.mapdb.DB.commit(DB.java:1595)\n    at org.mapdb.CorruptionTest.testCorruption(CorruptionTest.java:50)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Map.clear() causes corruption of Database.", "statsSkippedReason": "", "closed": "2015-02-17 12:56:17", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-17 14:55:09", "commitHash": "2fa873ef0a9c782db566d02020825b18a51b8758", "commitParents": ["d0d1c060a0a5cdec025fe6d1c72c2bf6313e8ecf"], "commitGHEventType": "referenced", "nameRev": "2fa873ef0a9c782db566d02020825b18a51b8758 tags/mapdb-1.0.7~6", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 1}, {"insertions": 60, "lines": 60, "filePath": "src/test/java/org/mapdb/Issue381Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue381Test"}], "spoonFilePath": "Issue381Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.delete(long,org.mapdb.Serializer)"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Fix #381, small chance for WAL corruption with deletes\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 14:53:50"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-17 12:37:16", "commitHash": "5e2cb5ecf8bae2e996aac82ed81ca4c73468c1d1", "commitParents": ["41e3e8059121314a64ef32611bad68ab176b8a8f"], "commitGHEventType": "referenced", "nameRev": "5e2cb5ecf8bae2e996aac82ed81ca4c73468c1d1 tags/mapdb-2.0-alpha2~66", "commitGitStats": [{"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 35, "lines": 35, "filePath": "src/test/java/org/mapdb/Issue381Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue381Test"}], "spoonFilePath": "Issue381Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayWAL()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Fix for #381, file descriptors were not closed, causing leak\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 12:37:16"}], "created": "2014-09-16 18:09:28"}, {"labels": ["2.0", "android", "bug"], "url": "https://github.com/jankotek/mapdb/issues/378", "title": "Bug with Serialization", "closed": "2016-02-14 17:36:49", "commitsDetails": [], "commits": {}, "ttf": 521.0002777777778, "created": "2014-09-11 17:04:57", "user": "csilvav", "body": "take a look a this error. but everything was fine... it's strange.\n\n```\nException occurred in target VM: Could not instantiate class \njava.lang.RuntimeException: Could not instantiate class\n    at org.mapdb.SerializerPojo.deserializeUnknownHeader(SerializerPojo.java:483)\n    at org.mapdb.SerializerBase.deserialize3(SerializerBase.java:1216)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:1132)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:867)\n    at org.mapdb.SerializerPojo.deserialize(SerializerPojo.java:701)\n    at org.mapdb.HTreeMap$2.deserialize(HTreeMap.java:135)\n    at org.mapdb.HTreeMap$2.deserialize(HTreeMap.java:121)\n    at org.mapdb.Store.deserialize(Store.java:297)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:475)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:368)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:352)\n    at org.mapdb.Caches$HashTable.get(Caches.java:245)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:58)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:350)\n    at org.mapdb.HTreeMap.recursiveDirCount(HTreeMap.java:345)\n    at org.mapdb.HTreeMap.sizeLong(HTreeMap.java:325)\n    at org.mapdb.HTreeMap.size(HTreeMap.java:305)\n    at com.highdeveloper.helperj.Test.main(Test.java:20)\nCaused by: java.lang.IndexOutOfBoundsException: Index: 11, Size: 11\n    at java.util.ArrayList.rangeCheck(ArrayList.java:638)\n    at java.util.ArrayList.get(ArrayList.java:414)\n    at org.mapdb.SerializerPojo.deserializeUnknownHeader(SerializerPojo.java:476)\n    ... 17 more\n```\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["a79e51abfc50721ab0eb9394d6025e46b96670e5"], "url": "https://github.com/jankotek/mapdb/issues/376", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 9, "deletions": 1}, "numCommits": 1, "commits": {"a79e51abfc50721ab0eb9394d6025e46b96670e5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 165.00027777777777, "user": "jfiedler", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.freePhysPut(long,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I observed constant growing MapDB size when using a file backed queue with custom serializers. The same queue works fine when just putting strings but seems to grow constantly if persisting the same strings via a custom serializer. I created a standalone Junit test case demonstrating the problem.\n\nTest Case: https://gist.github.com/jfiedler/4c2a34e0d752dd93f22a\nGroup Discussion: https://groups.google.com/d/msg/mapdb/03m2LX7tEpg/13SL7GW9bx8J\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 4, "DEL": 1, "INS": 3, "spoonFilesChanged": 1, "MOV": 0}, "title": "Constantly growing DB file with custom serializers", "statsSkippedReason": "", "closed": "2015-02-16 15:30:23", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-12-02 23:10:59", "commitHash": "a79e51abfc50721ab0eb9394d6025e46b96670e5", "commitParents": ["97aadc996e252dc742a780f3e497e13992075ab3"], "commitGHEventType": "referenced", "nameRev": "a79e51abfc50721ab0eb9394d6025e46b96670e5 tags/mapdb-1.0.7~18^2", "commitGitStats": [{"insertions": 8, "lines": 9, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 1, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.freePhysPut(long,boolean)"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "Improve memory allocation a bit #376\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-12-02 23:10:16"}], "created": "2014-09-04 07:07:38"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/375", "title": "DB.compact() throws AssertionError on Windows", "closed": "2015-08-07 12:41:12", "commitsDetails": [], "commits": {}, "ttf": 339.0002777777778, "created": "2014-09-02 05:30:19", "user": "krajiv", "body": "DB.compact() throws AssertionError on Windows. I am facing the issue on Windows Server 2012 R2 for the test. The issue does not surface on Linux.\n\nFollowing is the exception stack\n\n<code>\njava.lang.AssertionError: could not rename file\n at org.mapdb.StoreDirect.compact(StoreDirect.java:857)\n at org.mapdb.EngineWrapper.compact(EngineWrapper.java:130)\n at org.mapdb.DB.compact(DB.java:1607)\n at  ...\n</code>\n\nI am using a persistent cache file\n\n// create the cache file\n<code>\nDB m_db = DBMaker.newFileDB(new File(m_fileName)).make()\n</code>\n// perform addition\n<code>\n...\n</code>\n//perform deletion\n<code>\n...\n</code>\n// compact the db\n<code>\nm_db.compact();\n</code>\n"}, {"labels": ["bug"], "filteredCommits": ["5a37a9f9e16ef21433a01fa0720ac05832be44df"], "url": "https://github.com/jankotek/mapdb/issues/374", "gitStatsSummary": {"insertions": 14.0, "gitFilesChange": 2, "lines": 18.0, "deletions": 4.0}, "numCommits": 1, "commits": {"2d9f88386e03919c4328ef428ae3d5ac8068c50f": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "5a37a9f9e16ef21433a01fa0720ac05832be44df": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 166.00027777777777, "user": "ocafebabe", "changesInPackagesSPOON": ["org.mapdb.DB.getHashMap(java.lang.String,Fun.Function1)", "org.mapdb.HTreeMap.get(java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Test case:\n\n```\npublic class TestSuite implements Fun.Function1<Integer, String>\n{\n    @Test\n    public void test()\n    {\n        DB db = DBMaker.newMemoryDirectDB().make();\n        Map<String, Integer> map = db.getHashMap(\"map\", this);\n        Integer v1 = map.get(\"s1\");\n        assertEquals(Integer.valueOf(Integer.MIN_VALUE), v1);\n    }\n\n    @Override\n    public Integer run(String a)\n    {\n        return Integer.MIN_VALUE;\n    }\n}\n```\n\n`java.lang.AssertionError: expected:<-2147483648> but was:<null>`\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0.0, "TOT": 6.0, "DEL": 1.0, "INS": 2.0, "spoonFilesChanged": 2, "MOV": 3.0}, "title": "Map value creator is never called!", "statsSkippedReason": "", "closed": "2015-02-12 13:45:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "", "commitHash": "2d9f88386e03919c4328ef428ae3d5ac8068c50f", "commitParents": [], "commitGHEventType": "referenced", "nameRev": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "commitMessage": "", "spoonStatsSkippedReason": "", "authoredDateTime": ""}, {"commitUser": "jankotek", "commitDateTime": "2015-02-12 15:37:53", "commitHash": "5a37a9f9e16ef21433a01fa0720ac05832be44df", "commitParents": ["b23935701d396731307ac3b62000a3b604540722"], "commitGHEventType": "referenced", "nameRev": "5a37a9f9e16ef21433a01fa0720ac05832be44df tags/mapdb-1.0.7~9", "commitGitStats": [{"insertions": 12, "lines": 16, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 4}, {"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 0}, {"insertions": 120, "lines": 124, "filePath": "src/test/java/org/mapdb/HTreeMap2Test.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.getHashMap(java.lang.String,Fun.Function1)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 1, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.HTreeMap.get(java.lang.Object)"}], "spoonFilePath": "HTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.inconsistentHash()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.AA"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.expireAfterWrite()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.test()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.test_iterate_and_remove()"}], "spoonFilePath": "HTreeMap2Test.java"}], "commitMessage": "Fix #374 - Map value creator is never called!\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-08-30 09:06:44"}], "created": "2014-08-29 18:30:34"}, {"labels": ["bug"], "filteredCommits": ["ef2bb0e9fb66e0139af1b0b11798aa0ac1afd944"], "url": "https://github.com/jankotek/mapdb/issues/373", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 6, "deletions": 3}, "numCommits": 1, "commits": {"ef2bb0e9fb66e0139af1b0b11798aa0ac1afd944": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "9ca2b673cfcb40fde91d11240cb0354391aedcde": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 173.00027777777777, "user": "bouchov", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.registerClass(java.lang.Class)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I was trying to integrate MapDB in one old project to improve performance and found problem with fields serialization of type java.lang.Class if this class is not serializable.\nThis is a test case https://github.com/bouchov/mapdb/blob/master/java/org/mapdb/SerializerPojoTest2.java  - test_Pojo fails.\nI've also made a workaround https://github.com/bouchov/mapdb/blob/master/SerializerPojo.patch\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 1}, "title": "SerializerPojo throws NotSerializableException for Class field", "statsSkippedReason": "", "closed": "2015-02-17 13:48:29", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-18 17:03:04", "commitHash": "ef2bb0e9fb66e0139af1b0b11798aa0ac1afd944", "commitParents": ["9ca2b673cfcb40fde91d11240cb0354391aedcde"], "commitGHEventType": "referenced", "nameRev": "ef2bb0e9fb66e0139af1b0b11798aa0ac1afd944 tags/mapdb-1.0.7~2", "commitGitStats": [{"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 3}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/Issue373Test.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.registerClass(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Issue373Test.serialize(java.lang.Object)"}], "spoonFilePath": "Issue373Test.java"}], "commitMessage": "Fix #373: SerializerPojo throws NotSerializableException for Class field\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-18 17:03:04"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-18 16:45:26", "commitHash": "9ca2b673cfcb40fde91d11240cb0354391aedcde", "commitParents": ["ee4231a4d97e2f36089c7b600f2c5405f154387c"], "commitGHEventType": "referenced", "nameRev": "9ca2b673cfcb40fde91d11240cb0354391aedcde tags/mapdb-1.0.7~3", "commitGitStats": [{"insertions": 82, "lines": 82, "filePath": "src/test/java/org/mapdb/Issue373Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue373Test"}], "spoonFilePath": "Issue373Test.java"}], "commitMessage": "Fix #373: SerializerPojo throws NotSerializableException for Class field\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-08-30 09:06:44"}], "created": "2014-08-28 10:07:20"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/370", "title": "I can get the issue again for ArrayIndexOutOfBoundsException on BTreeMap.put", "closed": "2016-02-14 17:33:35", "commitsDetails": [], "commits": {}, "ttf": 548.0002777777778, "created": "2014-08-15 02:51:28", "user": "zshen-talend", "body": "I create DB like that:\n<code>\ndb = DBMaker.newTempFileDB().sizeLimit(2).mmapFileEnable().deleteFilesAfterClose().cacheSize(10 \\* 1024).closeOnJvmShutdown().transactionDisable().make();\n</code>\n\nI create TreeMap like that:\n<code>\ndbMap = db\n                .createTreeMap(\"testTupleArrayKeyMap\").nodeSize(6).keySerializer(new TupleArrayKeySerializer(BTreeMap.COMPARABLE_COMPARATOR, BTreeMap.COMPARABLE_COMPARATOR, getDB().getDefaultSerializer(), getDB().getDefaultSerializer())).valueSerializer(Serializer.JAVA).make();//$NON-NLS-1$\n</code>\nYes, I used my Serializer class which name is TupleArrayKeySerializer.\nBecause of I need make the key as List<String> and the length is not certain.\n\nMy Serializer is as below:\n<code>\npackage org.talend.commons.MapDB.utils;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.Comparator;\n\nimport org.mapdb.BTreeKeySerializer;\nimport org.mapdb.BTreeMap;\nimport org.mapdb.DataInput2;\nimport org.mapdb.DataOutput2;\nimport org.mapdb.Fun;\nimport org.mapdb.Serializer;\n\npublic final class TupleArrayKeySerializer extends BTreeKeySerializer<Tuple> implements Serializable {\n\n```\nprivate static final long serialVersionUID = 2183804367032891772L;\n\nprotected final Comparator<Integer> aComparator;\n\nprotected final Comparator<String> bComparator;\n\nprotected final Serializer<Integer> aSerializer;\n\nprotected final Serializer<String> bSerializer;\n\n/**\n * Construct new Tuple2 Key Serializer. You may pass null for some value, In that case 'default' value will be used,\n * Comparable comparator and Default Serializer from DB.\n * \n * @param aComparator comparator used for first tuple value\n * @param aSerializer serializer used for first tuple value\n * @param bSerializer serializer used for second tuple value\n */\npublic TupleArrayKeySerializer(Comparator<Integer> aComparator, Comparator<String> bComparator,\n        Serializer<Integer> aSerializer, Serializer<String> bSerializer) {\n    this.aComparator = aComparator;\n    this.bComparator = bComparator;\n    this.aSerializer = aSerializer;\n    this.bSerializer = bSerializer;\n}\n\n@Override\npublic void serialize(DataOutput out, int start, int end, Object[] keys) throws IOException {\n    int acount = 0;\n    Integer[] bCount = null;\n    if (keys != null && keys[0] != null && keys.length > 0) {\n        TupleArray firstTuple = (TupleArray) keys[0];\n        bCount = new Integer[firstTuple.arrayLength];\n\n        for (int i = start; i < end; i++) {\n            TupleArray t = (TupleArray) keys[i];\n            if (acount == 0) {\n                // write new A\n                aSerializer.serialize(out, t.arrayLength);\n                // count how many A are following\n                acount = 1;\n                while (i + acount < end\n                        && aComparator.compare(t.arrayLength, ((TupleArray) keys[i + acount]).arrayLength) == 0) {\n                    acount++;\n                }\n                DataOutput2.packInt(out, acount);\n\n            }\n            for (int index = 0; index < t.keyArray.length; index++) {\n                if (bCount[index] == null || bCount[index] == 0) {\n                    bSerializer.serialize(out, t.keyArray[index].toString());\n                    //\n                    bCount[index] = 1;\n                    while (i + bCount[index] < end\n                            && bComparator.compare(t.keyArray[index], ((TupleArray) keys[i + bCount[index]]).keyArray[index]) == 0) {\n                        bCount[index]++;\n                    }\n                    DataOutput2.packInt(out, bCount[index].intValue());\n                }\n                bCount[index]--;\n            }\n        }\n        acount--;\n    }\n}\n\n/*\n * (non-Javadoc)\n * \n * @see org.mapdb.BTreeKeySerializer#deserialize(java.io.DataInput, int, int, int)\n */\n@Override\npublic Object[] deserialize(DataInput in, int start, int end, int size) throws IOException {\n\n    Object[] ret = new Object[size];\n    try {\n        Integer a = null;\n        String[] keyArray = null;\n        int acount = 0;\n        Integer[] bCount = null;\n        for (int i = start; i < end; i++) {\n            if (acount == 0) {\n                // read new A\n                a = aSerializer.deserialize(in, -1);\n                acount = DataInput2.unpackInt(in);\n\n                // init bCount array\n                if (bCount == null) {\n                    keyArray = new String[a];\n                    bCount = new Integer[a];\n                }\n            }\n\n            for (int index = 0; index < a.intValue(); index++) {\n                if (bCount[index] == null || bCount[index] == 0) {\n                    String value = bSerializer.deserialize(in, -1);\n                    bCount[index] = DataInput2.unpackInt(in);\n                    // if (bCount[index] > 2) {\n                    // System.out.println(\"fail\");\n                    // }\n                    keyArray[index] = value;\n                }\n                bCount[index]--;\n            }\n            ret[i] = new TupleArray(a, keyArray);\n            acount--;\n        }\n        assert (acount == 0);\n\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return ret;\n}\n\n@Override\npublic Comparator<Tuple> getComparator() {\n    return BTreeMap.COMPARABLE_COMPARATOR;\n}\n\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n\n    TupleArrayKeySerializer t = (TupleArrayKeySerializer) o;\n\n    return Fun.eq(aComparator, t.aComparator) && Fun.eq(bComparator, t.bComparator) && Fun.eq(aSerializer, t.aSerializer)\n            && Fun.eq(bSerializer, t.bSerializer);\n}\n\n@Override\npublic int hashCode() {\n    int result = aComparator != null ? aComparator.hashCode() : 0;\n    result = 31 * result + (aSerializer != null ? aSerializer.hashCode() : 0);\n    result = 31 * result + (aSerializer != null ? aSerializer.hashCode() : 0);\n    result = 31 * result + (bSerializer != null ? bSerializer.hashCode() : 0);\n    return result;\n}\n```\n\n}\n\n</code>\n\nMy issue is that when i used that by 100 thousand items and one item only contain 1 column.\nHere i will get a ArrayIndexOutOfBoundsException.\n\nAnd when i get the exception the all of leafnode will be same as one(null , or some data)\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/366", "title": "WAL and Index checksums are broken", "closed": "2015-02-17 13:36:55", "commitsDetails": [], "commits": {}, "ttf": 194.00027777777777, "created": "2014-08-07 09:37:38", "user": "jankotek", "body": "There is mistake in MapDB code. Index checksum and WAL checksum use `|` operator instead of `+`. As result checksum value converges to zero and renders checksum useless. \n\nSolution is to change storage format. But I am not really sure how to do it, perhaps MapDB 2.0 should be started\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["211172e1d321ed876d4cd09bc2c2af2c9bbeb6c8"], "url": "https://github.com/jankotek/mapdb/issues/365", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"211172e1d321ed876d4cd09bc2c2af2c9bbeb6c8": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 196.00027777777777, "user": "andreysaksonov", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "There is special support for java.util.Date here - https://github.com/jankotek/MapDB/blob/31ed3b47dcafeaa289f60ab20090ef68c441c1b3/src/main/java/org/mapdb/SerializerBase.java#L215\n\nBut if you put any child of java.util.Date then you wil get strange results on deserialization:\n\ne.g. if you put Timestamp.valueOf(\"2014-08-04 08:20:56.607001\") then you will get back 1970-01-01 03:00:00.607001 (nanos are OK, but fastTime is transient and not handled separately)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "java.sql.Timestamp not serialized/deserialized correctly", "statsSkippedReason": "", "closed": "2015-02-17 13:15:44", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-17 15:15:22", "commitHash": "211172e1d321ed876d4cd09bc2c2af2c9bbeb6c8", "commitParents": ["2fa873ef0a9c782db566d02020825b18a51b8758"], "commitGHEventType": "referenced", "nameRev": "211172e1d321ed876d4cd09bc2c2af2c9bbeb6c8 tags/mapdb-1.0.7~5", "commitGitStats": [{"insertions": 10, "lines": 10, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testSQLTimestamp()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "Add unit test for #365\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 15:15:22"}], "created": "2014-08-05 10:27:26"}, {"labels": ["bug"], "filteredCommits": ["ee4231a4d97e2f36089c7b600f2c5405f154387c"], "url": "https://github.com/jankotek/mapdb/issues/364", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 38, "deletions": 35}, "numCommits": 1, "commits": {"ee4231a4d97e2f36089c7b600f2c5405f154387c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 199.00027777777777, "user": "TeofilisMartisius", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.preallocate()", "org.mapdb.StoreWAL.preallocate(long[])"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi,\n\nI tried writing to a MapDb, and I get this exception. It's random, but always happens, I haven't seen this go through 1m records successfully on my machine. I think this is fairly critical, as this is a crash on basic-use, and this error makes MapDB unusable for me.\n\nIt's a simple use-case, and should work. I think it's worth adding something like this to your test suite as a sanity check.\n\nI run this testcase on Debian Linux 64 bit inside a VMWare VM on Windows-7 64 bit, multi-core CPU. Kernel version 3.2.0-4-amd64, Debian 7.6, filesystem on /tmp is ext4.\n\nIt crashes using 64bit Java 1.8.0_11 fairly quickly,after ~300k rows\nIt crashes using 64bit Java 1.6.0_32, but gets further, ~700k rows\nIt crashes using 64bit Java 1.7.0_51-b13, but gets to ~850k rows\n\nException in thread \"main\" java.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:546)\n    at java.nio.DirectByteBuffer.putLong(DirectByteBuffer.java:802)\n    at org.mapdb.Volume$ByteBufferVol.putLong(Volume.java:304)\n    at org.mapdb.StoreWAL.walIndexVal(StoreWAL.java:310)\n    at org.mapdb.StoreWAL.preallocate(StoreWAL.java:173)\n    at org.mapdb.EngineWrapper.preallocate(EngineWrapper.java:43)\n    at org.mapdb.AsyncWriteEngine.put(AsyncWriteEngine.java:301)\n    at org.mapdb.Caches$HashTable.put(Caches.java:216)\n    at org.mapdb.EngineWrapper.put(EngineWrapper.java:53)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:581)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:480)\n    at noid.CrashMapDb.main(CrashMapDb.java:24)\n\nTest case to reproduce this:\n\npackage test;\n\nimport java.io.File;\nimport java.util.Map;\nimport java.util.UUID;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\npublic class CrashMapDb {\n    public static void main(String arg[]) throws Exception {\n        DB db = DBMaker.newFileDB(new File(\"/tmp/mapdb.db\")).\n            asyncWriteEnable().closeOnJvmShutdown().mmapFileEnable().make();\n        Map<String, String> map = db.getHashMap(\"test\");\n        Runtime run = Runtime.getRuntime();\n        String value = null;\n        for (int i = 0; i < 1000000; i++) {\n            String key = UUID.randomUUID().toString();\n            if (value == null || i % 2 == 0) {\n                value = UUID.randomUUID().toString();\n            }\n            map.put(key, value);\n            if (i % 50000 == 0) {\n                double free = run.freeMemory() / 1024.0 / 1024.0;\n                double total = run.totalMemory() / 1024.0 / 1024.0;\n                System.out.format(\"read %10d free = %10.2f total=%10.2f %n\", i, free, total);\n                db.commit();\n            }\n        }\n        db.commit();\n        db.close();\n    }\n}\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 1, "TOT": 6, "DEL": 3, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "IndexOutOfBoundsException when inserting data", "statsSkippedReason": "", "closed": "2015-02-17 13:36:35", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-02-17 15:34:38", "commitHash": "ee4231a4d97e2f36089c7b600f2c5405f154387c", "commitParents": ["211172e1d321ed876d4cd09bc2c2af2c9bbeb6c8"], "commitGHEventType": "referenced", "nameRev": "ee4231a4d97e2f36089c7b600f2c5405f154387c tags/mapdb-1.0.7~4", "commitGitStats": [{"insertions": 3, "lines": 38, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 35}, {"insertions": 39, "lines": 39, "filePath": "src/test/java/org/mapdb/Issues364Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issues364Test"}], "spoonFilePath": "Issues364Test.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 5, "DEL": 3, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.preallocate(long[])"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.preallocate()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Fix #364, corrupted WAL with preallocation and Async Write\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-17 15:34:38"}], "created": "2014-08-01 15:25:09"}, {"labels": ["2.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/363", "title": "Hard faults when inserting a billion records into HTreeMap", "closed": "2015-07-05 09:04:29", "commitsDetails": [], "commits": {}, "ttf": 340.0002777777778, "created": "2014-07-29 17:05:44", "user": "xertz84", "body": "Hi,\n\nI'm trying to store about 1 billion records using mapdb as a (non-in-memory) persistence store. Unfortunately, it seems as though mapdb is only capable of storing around 150 million records. I was wondering whether anyone could verify this. I'm running mapdb on a 4-core 2.66GHz machine with 16GB RAM, the JVM has the parameters -Xms256m -Xmx15G. My input file is simply a list of big integers stored as hex. My code is as follows:\n\n```\npackage test.mapdb;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport org.mapdb.Bind;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\nimport org.mapdb.Fun;\nimport org.mapdb.HTreeMap;\n\nimport java.util.NavigableSet;\n\npublic class App \n{\n    private static int i = 0;\n\n\n    private static String BILLION_BIGINTS_PATH = \".\\billion-bigints.txt\";\n    private static String CURRENT_BIGINTS_PATH = BILLION_BIGINTS_PATH;\n    private static long CURRENT_BIGINTS_COUNT = 1000000000;\n\n    private static String MAPDB_FILENAME = \"map-billion.db\";\n\n    private static SimpleDateFormat ft = new SimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\");\n\n    public static void createMapDb() throws IOException\n    {\n        DB db = DBMaker.newFileDB(new File(MAPDB_FILENAME))\n                .mmapFileEnablePartial()\n                .closeOnJvmShutdown()\n                .cacheDisable()\n                .transactionDisable()\n                .asyncWriteEnable()\n                .make();\n\n\n        HTreeMap<Integer,BigInteger> map = db.getHashMap(\"map\");\n\n        // inverse mapping for primary map\n        //NavigableSet<Fun.Tuple2<String, Long>> inverseMapping = new TreeSet<Fun.Tuple2<String, Long>>();\n        //NOTE: you may also use Set provided by MapDB to make it persistent\n        //Set<Fun.Tuple2<BigInteger, Integer>> inverseMapping = db.getHashSet(\"set\");\n        HTreeMap<BigInteger,Integer> rMap = db.getHashMap(\"reverseMap\");\n\n        // bind inverse mapping to primary map, so it is auto-updated\n        Bind.mapInverse(map, rMap);\n\n        BufferedReader br = new BufferedReader(new FileReader(CURRENT_BIGINTS_PATH));\n        long line_count = CURRENT_BIGINTS_COUNT;\n        int ten_percent = (int) line_count / 1000;\n\n        long start = System.currentTimeMillis();\n        String line;\n        while ((line = br.readLine()) != null)\n        {\n            if(i % ten_percent == 0)\n            {\n                Date now = new Date();\n                System.out.println(\"[\" + ft.format(now) + \"] i: \" + i);\n            }\n            BigInteger b = new BigInteger(line, 16);\n            map.put(i, b);\n            i++;\n        }\n        long stop = System.currentTimeMillis();\n        long diff = stop - start;\n        double peritem = diff / (i * 1.0); \n        System.out.println(\"n: \" + i + \" total time in ms: \" + diff + \" per-item: \" + peritem);\n\n        db.commit();\n        db.close();\n    }\n\n    public static void getMapDb() throws IOException\n    {\n\n        Date now = new Date();\n        System.out.println(\"[\" + ft.format(now) + \"] reading database\");\n\n        DB db = DBMaker.newFileDB(new File(MAPDB_FILENAME))\n                .mmapFileEnable()\n                .cacheDisable()\n                .transactionDisable()\n                .asyncWriteEnable()\n                .make();\n\n        now = new Date();\n        //System.out.println(\"[\" + ft.format(now) + \"] compacting database\");\n        //db.compact();\n\n        HTreeMap<Integer,BigInteger> map = db.getHashMap(\"map\");\n\n        // inverse mapping for primary map\n        //NavigableSet<Fun.Tuple2<String, Long>> inverseMapping = new TreeSet<Fun.Tuple2<String, Long>>();\n        //NOTE: you may also use Set provided by MapDB to make it persistent\n        //Set<Fun.Tuple2<BigInteger, Integer>> inverseMapping = db.getHashSet(\"set\");\n        HTreeMap<BigInteger,Integer> rMap = db.getHashMap(\"reverseMap\");\n\n\n        // bind inverse mapping to primary map, so it is auto-updated\n        Bind.mapInverse(map, rMap);\n\n        long start = System.currentTimeMillis();\n\n\n        BufferedReader br = new BufferedReader(new FileReader(CURRENT_BIGINTS_PATH));\n        long line_count = CURRENT_BIGINTS_COUNT;\n        int ten_percent = (int) line_count / 10;\n        for(i = 0 ; i <line_count; i++)\n        {\n            if(i % ten_percent == 0)\n            {\n                long diff = System.currentTimeMillis() - start;\n                now = new Date();\n                System.out.println(\"[\" + ft.format(now) + \"] ms: \" + diff + \" i: \" + i);\n            }\n            BigInteger b = map.get(i);\n            if (b == null)\n                System.err.println(\"b is null at i = \" + i );\n        }\n        long stop = System.currentTimeMillis();\n        long diff = stop - start;\n        double peritem = diff / (i * 1.0); \n        System.out.println(\"n: \" + i + \" total time in ms: \" + diff + \" per-item: \" + peritem);\n\n        i = 0;\n        start = System.currentTimeMillis();\n        String line;\n        while((line = br.readLine()) != null)\n        {\n            if(i % ten_percent == 0)\n            {\n                diff = System.currentTimeMillis() - start;\n                now = new Date();\n                System.out.println(\"[\" + ft.format(now) + \"] ms: \" + diff + \" i: \" + i);\n            }\n            BigInteger b = new BigInteger(line, 16);\n\n            Integer out_i = rMap.get(b);\n\n            if (out_i == null)\n                System.err.println(\"out_i is null at i = \" + i );\n            i++;\n        }\n        stop = System.currentTimeMillis();\n        diff = stop - start;\n        peritem = diff / (i * 1.0); \n        System.out.println(\"n: \" + i + \" total time in ms: \" + diff + \" per-item: \" + peritem);\n\n\n        //db.commit();\n        db.close();\n        throw new IOException();\n    }\n\n    public static void main( String[] args ) throws IOException\n    {\n        try {\n            createMapDb() ;\n            //getMapDb();\n        } catch (IOException e) {\n            System.out.println(\"i was: \" + i);\n            throw e;\n        }\n    }\n}\n\n```\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["928528e3d1cba8edaddd06105c4b6d6231877e49"], "url": "https://github.com/jankotek/mapdb/issues/362", "gitStatsSummary": {"insertions": 20, "gitFilesChange": 1, "lines": 23, "deletions": 3}, "numCommits": 1, "commits": {"928528e3d1cba8edaddd06105c4b6d6231877e49": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 325.0002777777778, "user": "leznikm8", "changesInPackagesSPOON": ["org.mapdb.DBMaker.makeEngine()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Failed tests: \n  BrokenDBTest.canDeleteDBOnBrokenLog:92 Can't delete index\nTests in error: \n  StoreWALTest.discard_corrupted_log:109 \u00bb IO java.io.IOException: The requested...\nTests run: 1750, Failures: 1, Errors: 1, Skipped: 4\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "Problem with tests. Maven doesn't compile", "statsSkippedReason": "", "closed": "2015-06-19 18:03:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-06-19 21:02:54", "commitHash": "928528e3d1cba8edaddd06105c4b6d6231877e49", "commitParents": ["9f2b180dff6f28a8fba0942337375c952070ca59"], "commitGHEventType": "referenced", "nameRev": "928528e3d1cba8edaddd06105c4b6d6231877e49 tags/mapdb-renamed-1.0.8~12", "commitGitStats": [{"insertions": 20, "lines": 23, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "Fix failing unit tests on Windows. Fix #362\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-06-19 21:02:18"}], "created": "2014-07-29 13:47:27"}, {"labels": ["bug"], "filteredCommits": ["967d502ba59a1550d6f810c6ba63772c4eeeabec", "f1d406b805f8b47dd97b02da4047b5bcd3d6c329"], "url": "https://github.com/jankotek/mapdb/issues/359", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 6, "deletions": 3}, "numCommits": 2, "commits": {"967d502ba59a1550d6f810c6ba63772c4eeeabec": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e15a6a54541fa1ebf72a49d866375e81e78d9380": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e379f0a659f276f79d03ca4aa13ba76f1c7e9590": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "f1d406b805f8b47dd97b02da4047b5bcd3d6c329": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 22.00027777777778, "user": "wg", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.verifyLogFile()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hello, there seems to be an issue with multiple threads accessing a DB within the same JVM. I've reproduced this on OSX and Linux with JDK 1.7 and 1.8. Attached is a test case.\n\n```\njava.lang.AssertionError: unknown trans log instruction '0' at log offset: 4063257\n    at org.mapdb.StoreWAL.replayLogFile(StoreWAL.java:858)\n    at org.mapdb.StoreWAL.commit(StoreWAL.java:637)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:94)\n    at org.mapdb.DB.commit(DB.java:1595)\n    at com.example.CorruptionTestCase$1.run(CorruptionTestCase.java:48)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:439)\n    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:138)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n    at java.lang.Thread.run(Thread.java:695)\n```\n\n``` java\npackage com.example;\n\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\nimport java.io.File;\nimport java.security.SecureRandom;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\npublic class CorruptionTestCase {\n    public static void test(final DB db) throws Exception {\n        int threads = 4;\n        int writes = 20000;\n\n        SecureRandom random = new SecureRandom();\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n\n        BlockingQueue[] queues = new BlockingQueue[threads];\n        Future[] futures = new Future[threads];\n\n        for (int i = 0; i < threads; i++) {\n            queues[i] = db.getQueue(String.format(\"queue %d\", i));\n        }\n\n        for (int i = 0; i < writes; i++) {\n            byte[] payload = new byte[64];\n            random.nextBytes(payload);\n            queues[i % threads].put(payload);\n        }\n\n        for (int i = 0; i < threads; i++) {\n            final int threadID = i;\n            final BlockingQueue queue = queues[i];\n\n            futures[i] = executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    int count = 0;\n\n                    try {\n                        while (queue.poll(100, TimeUnit.MILLISECONDS) != null) {\n                            count++;\n                        }\n\n                        db.commit();\n\n                        System.out.printf(\"Thread %d saw %d items\\n\", threadID, count);\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                        System.exit(1);\n                    }\n                }\n            });\n        }\n\n        for (Future f : futures) {\n            f.get();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        File dir = new File(\"var\");\n        dir.mkdirs();\n\n        for (File file : dir.listFiles()) {\n            if (!file.isDirectory()) {\n                file.delete();\n            }\n        }\n\n        DB db = DBMaker.newFileDB(new File(dir, \"queue\")).closeOnJvmShutdown().checksumEnable().make();\n\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            test(db);\n            System.out.printf(\"Test %d passed\\n\", i);\n        }\n    }\n}\n```\n", "filteredCommitsReason": {"duplicated": 2, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 4, "DEL": 2, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Database corruption - java.lang.AssertionError: unknown trans log instruction '0'", "statsSkippedReason": "", "closed": "2014-08-07 10:28:59", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-07-30 22:46:01", "commitHash": "967d502ba59a1550d6f810c6ba63772c4eeeabec", "commitParents": ["815db766f93350a24fb84979a7107fec3efcd11a"], "commitGHEventType": "referenced", "nameRev": "967d502ba59a1550d6f810c6ba63772c4eeeabec tags/mapdb-2.0-alpha1~162", "commitGitStats": [{"insertions": 2, "lines": 5, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreWAL: checksum was broken, disable it. See #359\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-30 22:46:01"}, {"commitUser": "jankotek", "commitDateTime": "2014-08-07 12:40:35", "commitHash": "f1d406b805f8b47dd97b02da4047b5bcd3d6c329", "commitParents": ["46554bb23de8ffbee707b66a0a1d06344a50625d"], "commitGHEventType": "referenced", "nameRev": "f1d406b805f8b47dd97b02da4047b5bcd3d6c329 tags/mapdb-1.0.6~3", "commitGitStats": [{"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 56, "lines": 56, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.StoreWALTest.discard_corrupted_log()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreWAL: fix log verification, see #359\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-30 20:39:58"}, {"commitUser": "jankotek", "commitDateTime": "2014-07-30 20:39:58", "commitHash": "e379f0a659f276f79d03ca4aa13ba76f1c7e9590", "commitParents": ["675f2336bbd18a65b28e42f36ca1f440c92e41e2"], "commitGHEventType": "referenced", "nameRev": "e379f0a659f276f79d03ca4aa13ba76f1c7e9590 tags/mapdb-2.0-alpha1~164", "commitGitStats": [{"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 56, "lines": 56, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.StoreWALTest.discard_corrupted_log()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreWAL: fix log verification, see #359\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-30 20:39:58"}, {"commitUser": "jankotek", "commitDateTime": "2014-08-07 12:47:38", "commitHash": "e15a6a54541fa1ebf72a49d866375e81e78d9380", "commitParents": ["f1d406b805f8b47dd97b02da4047b5bcd3d6c329"], "commitGHEventType": "referenced", "nameRev": "e15a6a54541fa1ebf72a49d866375e81e78d9380 tags/mapdb-1.0.6~2", "commitGitStats": [{"insertions": 2, "lines": 5, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreWAL: checksum was broken, disable it. See #359\n\nConflicts:\n\tsrc/main/java/org/mapdb/StoreWAL.java\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-30 22:46:01"}], "created": "2014-07-16 03:49:13"}, {"labels": ["bug"], "filteredCommits": ["70723382e21238c2f685a9ac35cea67ed7c0c9b0"], "url": "https://github.com/jankotek/mapdb/issues/356", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 88, "deletions": 84}, "numCommits": 1, "commits": {"70723382e21238c2f685a9ac35cea67ed7c0c9b0": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "56b2fdcf92fe55b7b6a4126ea9df5250a604267c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 4.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.AsyncWriteEngine.close()", "org.mapdb.AsyncWriteEngine.runWriter()", "org.mapdb.AsyncWriteEngine.preallocateRollback()", "org.mapdb.AsyncWriteEngine.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.AsyncWriteEngine", "org.mapdb.AsyncWriteEngine.preallocateNoCommitLock()", "org.mapdb.AsyncWriteEngine.preallocate(long[])", "org.mapdb.AsyncWriteEngine.preallocate()", "org.mapdb.AsyncWriteEngine.preallocateRefill()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There is a bug in Async Writer. New records are not persisted if some race condition happens. Solution for now is to remove async recid preallocation, responsible for bug. \n\nProblem is reproducible by test `AsyncWriteEngineTest.async_commit()`. Sometimes it would fail under high load. Best is to run this test in circle, until it fails (less than 1 minute). \n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 9, "UPD": 1, "TOT": 16, "DEL": 14, "INS": 0, "spoonFilesChanged": 1, "MOV": 1}, "title": "Async preallocation has a race condition", "statsSkippedReason": "", "closed": "2014-07-15 13:52:24", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-07-10 18:27:18", "commitHash": "70723382e21238c2f685a9ac35cea67ed7c0c9b0", "commitParents": ["e1580d63dd4f07e2a602a05a9cb2ed5486e2a976"], "commitGHEventType": "referenced", "nameRev": "70723382e21238c2f685a9ac35cea67ed7c0c9b0 tags/mapdb-2.0-alpha1~192", "commitGitStats": [{"insertions": 4, "lines": 88, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 84}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 5, "DEL": 4, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.AsyncWriteEngine.runWriter()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateRollback()"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.close()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateNoCommitLock()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate(long[])"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateRefill()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "AsyncWriteEngine: disable recid preallocation, see #356\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-10 18:27:18"}, {"commitUser": "jankotek", "commitDateTime": "2014-07-15 15:51:31", "commitHash": "56b2fdcf92fe55b7b6a4126ea9df5250a604267c", "commitParents": ["69bc21cb59042c757ad02e17281eaeb7c58746c8"], "commitGHEventType": "referenced", "nameRev": "56b2fdcf92fe55b7b6a4126ea9df5250a604267c tags/mapdb-1.0.5~6", "commitGitStats": [{"insertions": 4, "lines": 88, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 84}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 5, "DEL": 4, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.AsyncWriteEngine.runWriter()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateRollback()"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.close()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateNoCommitLock()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate(long[])"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocateRefill()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "AsyncWriteEngine: disable recid preallocation, see #356\n\nConflicts:\n\tsrc/main/java/org/mapdb/AsyncWriteEngine.java\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-10 18:27:18"}], "created": "2014-07-10 15:13:03"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/354", "title": "BTreeMap and outside node value crash after delete", "closed": "2016-04-14 09:22:17", "commitsDetails": [], "commits": {}, "ttf": 651.0002777777778, "created": "2014-07-03 08:20:06", "user": "jankotek", "body": "Have a BTreeMap with values stored outside of nodes. If an iterator contains deserialized node with reference to an value and it gets deleted: The iterator will try to fetch non-existing recid from store and will fail with an IOError.\n\nThe outside values must be replaced with thumbstone marker for off-line deletion. Not deleted.\n"}, {"labels": ["bug"], "filteredCommits": ["c81abc30c371d99adc6ec6746c365c76cb1eb3b6"], "url": "https://github.com/jankotek/mapdb/issues/353", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"c81abc30c371d99adc6ec6746c365c76cb1eb3b6": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 18.00027777777778, "user": "ChristianValtech", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "Hi!\n\nWhile integrating MapDB into my application, I ran into an issue where iterating over the keyset of a map would give inconsistent results: a key is returned, but no according value can be retrieved.\n\nI will attach my testcase.\n\nDespite the issue, thank you very much for developing MapDB!\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "Database corruption when using HTree & Key Iterator", "statsSkippedReason": "", "closed": "2014-07-20 15:04:19", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-07-08 13:48:14", "commitHash": "c81abc30c371d99adc6ec6746c365c76cb1eb3b6", "commitParents": ["b7325d7dd9a9d5847ae585bfef1e1d2c573de4d1"], "commitGHEventType": "referenced", "nameRev": "c81abc30c371d99adc6ec6746c365c76cb1eb3b6 tags/mapdb-2.0-alpha1~197", "commitGitStats": [{"insertions": 84, "lines": 84, "filePath": "src/test/java/org/mapdb/Issue353Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue353Test"}], "spoonFilePath": "Issue353Test.java"}], "commitMessage": "Add test case for #353\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-08 13:48:14"}], "created": "2014-07-02 14:33:05"}, {"labels": ["3.0", "bug"], "url": "https://github.com/jankotek/mapdb/issues/347", "title": " DbMaker.newTemp*** would not work on android", "closed": "2016-04-14 09:23:02", "commitsDetails": [], "commits": {}, "ttf": 659.0002777777778, "created": "2014-06-24 15:23:36", "user": "jankotek", "body": "## From email\n\nSince these functions call File.newTempFile(), which will not work on android.\n\nI have the following method as a temporary solution:(By kotlin)\n\n1 add extension functions for DbMaker;\n\n2 check the platform, have the different implementations.\n\n This solution is not elegant. The good solution is to provide a cross-runtime File.newTempFile.\n## Solution from SO\n\nFor temporary internal files their are 2 options\n\n1.\n\n```\nFile file; \nfile = File.createTempFile(filename, null, this.getCacheDir());\n```\n\n2.\n\n```\n File file\n file = new File(this.getCacheDir(), filename\n```\n"}, {"labels": ["bug"], "filteredCommits": ["452feddbb4d6641b52aabacce1b9dcdae6febd52"], "url": "https://github.com/jankotek/mapdb/issues/346", "gitStatsSummary": {"insertions": 87, "gitFilesChange": 1, "lines": 172, "deletions": 85}, "numCommits": 1, "commits": {"452feddbb4d6641b52aabacce1b9dcdae6febd52": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "fcca003ecb74a414c42632eb0ed84433733ebf82": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 25.00027777777778, "user": "a7lee", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.verifyLogFile()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I'm consistently getting a \n\n\"Exception in thread \"main\" java.lang.AssertionError: unknown trans log instruction '4' at log offset: 7130\" error.\n\nI can easily get this because my program is executing a bunch of writes/commits. Unfortunately if I kill the JVM process in the middle before it closes and attempt to reload what I wrote then I get this error.\n\nIs there any reason for this?  I tested around different settings and it doesn't seem to make a difference. I've tried async enabled, memory mapped file enable. I haven't tried disabling transactions or disabling flush on commit. However, I figured the WAL should protect me against sudden shutdown.\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 2, "TOT": 30, "DEL": 5, "INS": 9, "spoonFilesChanged": 1, "MOV": 14}, "title": "WAL log corruption when killing the mapdb process.", "statsSkippedReason": "", "closed": "2014-07-15 13:51:19", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-07-15 15:42:50", "commitHash": "452feddbb4d6641b52aabacce1b9dcdae6febd52", "commitParents": ["443379a6869dc870eb0633aa14460acd8d2b1959"], "commitGHEventType": "referenced", "nameRev": "452feddbb4d6641b52aabacce1b9dcdae6febd52 tags/mapdb-2.0-alpha1~185", "commitGitStats": [{"insertions": 87, "lines": 172, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 85}, {"insertions": 59, "lines": 59, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 0}, {"insertions": 10, "lines": 20, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.discard_corrupted_log()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 30, "DEL": 5, "INS": 9, "MOV": 14, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 11, "TOT": 11, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}], "commitMessage": "StoreWAL: replay on reopen could fail if log was corrupted. See #346\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-15 15:42:50"}, {"commitUser": "jankotek", "commitDateTime": "2014-07-15 16:04:23", "commitHash": "fcca003ecb74a414c42632eb0ed84433733ebf82", "commitParents": ["9250be91a8f1f7e80e34db953162b6ead02cd984"], "commitGHEventType": "referenced", "nameRev": "fcca003ecb74a414c42632eb0ed84433733ebf82 tags/mapdb-1.0.5~1", "commitGitStats": [{"insertions": 88, "lines": 173, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 85}, {"insertions": 59, "lines": 59, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 0}, {"insertions": 10, "lines": 20, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.discard_corrupted_log()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 30, "DEL": 5, "INS": 9, "MOV": 14, "spoonMethodName": "org.mapdb.StoreWAL.verifyLogFile()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 11, "TOT": 11, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}], "commitMessage": "StoreWAL: replay on reopen could fail if log was corrupted. See #346\n\nConflicts:\n\tsrc/main/java/org/mapdb/StoreWAL.java\n\tsrc/test/java/org/mapdb/BrokenDBTest.java\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-07-15 15:42:50"}], "created": "2014-06-20 05:14:01"}, {"labels": ["bug"], "filteredCommits": ["e32910c72c6b2abde972860b47ab91684edefa93", "1d530bd3302982002886aa2f9d213f5745cae55d"], "url": "https://github.com/jankotek/mapdb/issues/332", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 55, "deletions": 47}, "numCommits": 1, "commits": {"1d530bd3302982002886aa2f9d213f5745cae55d": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e32910c72c6b2abde972860b47ab91684edefa93": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 6.000277777777778, "user": "keremhd", "changesInPackagesSPOON": ["org.mapdb.CompressLZF.expand(java.io.DataInput,byte[],int,int)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I isolated the specific byte array that is sent to the serializer, test case follows.\n\nI traced the problem in serialization and deserialization to see if it's a storage issue, compressed byte buffers were the same, it just seems like decompress(compress(problemString)) != problemString\n\nUbuntu 64 bit\nsun java javac 1.6.0_45\nMapDB 1.0.1\n\n```\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\nimport org.mapdb.Serializer;\n\nimport java.io.*;\nimport java.util.Map;\n\n/**\n * Created by paspi on 26.05.2014.\n */\npublic class Mapdbtest {\n    public static final class TestSerializer implements Serializer<String>, Serializable {\n\n        // http://stackoverflow.com/a/140430\n        private static byte[] fromHexString(final String encoded) {\n            if ((encoded.length() % 2) != 0)\n                throw new IllegalArgumentException(\"Input string must contain an even number of characters\");\n\n            final byte result[] = new byte[encoded.length()/2];\n            final char enc[] = encoded.toCharArray();\n            for (int i = 0; i < enc.length; i += 2) {\n                StringBuilder curr = new StringBuilder(2);\n                curr.append(enc[i]).append(enc[i + 1]);\n                result[i/2] = (byte) Integer.parseInt(curr.toString(), 16);\n            }\n            return result;\n        }\n\n        // http://stackoverflow.com/a/13006907\n        private static String bytArrayToHex(byte[] a) {\n            StringBuilder sb = new StringBuilder();\n            for(byte b: a)\n                sb.append(String.format(\"%02x\", b&0xff));\n            return sb.toString();\n        }\n\n\n        @Override\n        public void serialize(DataOutput out, String value) throws IOException {\n            byte [] buf = fromHexString(value);\n            out.writeInt(buf.length);\n            out.write(buf);\n        }\n\n        @Override\n        public String deserialize(DataInput in, int available) throws IOException {\n            int nsize = in.readInt();\n            byte[] buf = new byte[nsize];\n            in.readFully(buf);\n\n            return bytArrayToHex(buf);\n        }\n\n        @Override\n        public int fixedSize() {\n            return -1;\n        }\n    }\n\n    public static void main(String[] args) {\n        DB db = DBMaker.newFileDB(new File(\"/tmp/testdb\"))\n                .closeOnJvmShutdown()\n                .make();\n\n        Map<Integer, String> testMap = db.createHashMap(\"testmap\")\n                .valueSerializer(new Serializer.CompressionWrapper<String>(new TestSerializer()))\n                //.valueSerializer(new TestSerializer())\n                .makeOrGet();\n\n        // 4 length bytes will be prepended to this string: 000000ef\n        final String problem = \"76fa135e7d216e829a53845a983469ac1e4edb6120b79667d667e7d4f8560101010100000022bf456901000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac3358c8ea6433279c678846fb6e06eeccd82e2fe888f2ac203476d3918cd405790100000038ffffff9e000000be438253be43825301000000109bf45901000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac38bf80f10129594a7e949cc43c3bd6f8670ba5ab59874305f6839406738a9cf90100000038ffffff9e00000081bd175381bd1753\";\n        testMap.put(1, problem);\n        db.commit();\n        db.close();\n\n        db = null;\n        testMap = null;\n\n        //-------------------------\n        db = DBMaker.newFileDB(new File(\"/tmp/testdb\"))\n                .closeOnJvmShutdown()\n                .make();\n        testMap = db.createHashMap(\"testmap\")\n                .valueSerializer(new Serializer.CompressionWrapper<String>(new TestSerializer()))\n                .makeOrGet();\n        String deserialized = testMap.get(1);\n\n        if (problem.equals(deserialized))\n            System.out.println(\"problem.equals(deserialized)\");\n        else\n            System.out.println(\"!problem.equals(deserialized)\");\n\n        System.out.println(problem);\n        System.out.println(deserialized);\n\n        db.close();\n    }\n\n}\n```\n\nOutput\n\n```\n!problem.equals(deserialized)\n76fa135e7d216e829a53845a983469ac1e4edb6120b79667d667e7d4f8560101010100000022bf456901000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac3358c8ea6433279c678846fb6e06eeccd82e2fe888f2ac203476d3918cd405790100000038ffffff9e000000be438253be43825301000000109bf45901000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac38bf80f10129594a7e949cc43c3bd6f8670ba5ab59874305f6839406738a9cf90100000038ffffff9e00000081bd175381bd1753\n76fa135e7d216e829a53845a983469ac1e4edb6120b79667d667e7d4f8560101000000000022bf456900000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac3358c8ea6433279c678846fb6e06eeccd82e2fe888f2ac203476d3918cd405790000000038ffffff9e000000be438253be43825300000000109bf45900000000230000002102123eeaa90e2f5786ce028e60ec03702706dadecee373a90b09b88a99cc668f46ac38bf80f10129594a7e949cc43c3bd6f8670ba5ab59874305f6839406738a9cf90000000038ffffff9e00000081bd175381bd1753\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 5, "DEL": 3, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "Serializer.CompressionWrapper uncompresses differently on specific input", "statsSkippedReason": "", "closed": "2014-06-02 11:32:53", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-06-02 01:57:12", "commitHash": "1d530bd3302982002886aa2f9d213f5745cae55d", "commitParents": ["dc2e64cb092f6af5d4ead09a0320e6f95d37f0f9"], "commitGHEventType": "referenced", "nameRev": "1d530bd3302982002886aa2f9d213f5745cae55d tags/mapdb-2.0-alpha1~218", "commitGitStats": [{"insertions": 8, "lines": 55, "filePath": "src/main/java/org/mapdb/CompressLZF.java", "deletions": 47}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 3, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.CompressLZF.expand(java.io.DataInput,byte[],int,int)"}], "spoonFilePath": "CompressLZF.java"}], "commitMessage": "Revert optimization which broke compression, see #332\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-06-02 01:57:12"}, {"commitUser": "jankotek", "commitDateTime": "2014-05-27 14:35:36", "commitHash": "e32910c72c6b2abde972860b47ab91684edefa93", "commitParents": ["fa5d835e820c970f594c6bd7936341a9be2268a3"], "commitGHEventType": "referenced", "nameRev": "e32910c72c6b2abde972860b47ab91684edefa93 tags/mapdb-2.0-alpha1~220", "commitGitStats": [{"insertions": 110, "lines": 110, "filePath": "src/test/java/org/mapdb/Issue332Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue332Test"}], "spoonFilePath": "Issue332Test.java"}], "commitMessage": "Add failing test case for #332\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-05-27 14:35:36"}], "created": "2014-05-26 14:46:44"}, {"labels": ["bug"], "filteredCommits": ["86706509170a50ba088e93a50777e813816e2e7d"], "url": "https://github.com/jankotek/mapdb/issues/321", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 3, "lines": 16, "deletions": 5}, "numCommits": 1, "commits": {"86706509170a50ba088e93a50777e813816e2e7d": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "22ff10f8a168b7118063a9e9580035a8a34ca56a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 28.00027777777778, "user": "jandam", "changesInPackagesSPOON": ["org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)", "org.mapdb.Pump.sort(java.util.Iterator,boolean,int,java.util.Comparator,org.mapdb.Serializer)", "org.mapdb.CompressLZF.expand(java.io.DataInput,byte[],int,int)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Fix for \"DBMaker: Solved BTreeMap pump presort fails, #320\" introduced regression.\nThere is NPE when pumpPresort is configured without pumpSource.\n\nException in thread \"main\" java.lang.NullPointerException\n    at org.mapdb.Pump.sort(Pump.java:62)\n    at org.mapdb.DB.createTreeMap(DB.java:831)\n    at org.mapdb.DB$BTreeMapMaker.make(DB.java:644)\n    at org.mapdb.DB$BTreeMapMaker.makeOrGet(DB.java:650)\n...\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 0, "TOT": 9, "DEL": 4, "INS": 4, "spoonFilesChanged": 3, "MOV": 1}, "title": "Regression in 1.0.1: NPE when specified pumpPresort without pumpSource", "statsSkippedReason": "", "closed": "2014-06-02 11:17:54", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-06-02 13:32:12", "commitHash": "86706509170a50ba088e93a50777e813816e2e7d", "commitParents": ["d68484f45b79d8814d7b2474af9558781831c09a"], "commitGHEventType": "referenced", "nameRev": "86706509170a50ba088e93a50777e813816e2e7d tags/mapdb-1.0.2~1", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/Issue321Test.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 1}, {"insertions": 7, "lines": 10, "filePath": "src/main/java/org/mapdb/CompressLZF.java", "deletions": 3}, {"insertions": 3, "lines": 4, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue321Test"}], "spoonFilePath": "Issue321Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Pump.sort(java.util.Iterator,boolean,int,java.util.Comparator,org.mapdb.Serializer)"}], "spoonFilePath": "Pump.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 3, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.CompressLZF.expand(java.io.DataInput,byte[],int,int)"}], "spoonFilePath": "CompressLZF.java"}], "commitMessage": "DB: fix small regression in behaviour with Data Pump and presort. See #321\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-06-02 13:32:12"}, {"commitUser": "jankotek", "commitDateTime": "2014-06-02 14:13:12", "commitHash": "22ff10f8a168b7118063a9e9580035a8a34ca56a", "commitParents": ["1d530bd3302982002886aa2f9d213f5745cae55d"], "commitGHEventType": "referenced", "nameRev": "22ff10f8a168b7118063a9e9580035a8a34ca56a tags/mapdb-2.0-alpha1~217", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/Issue321Test.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 1}, {"insertions": 3, "lines": 4, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue321Test"}], "spoonFilePath": "Issue321Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Pump.sort(java.util.Iterator,boolean,int,java.util.Comparator,org.mapdb.Serializer)"}], "spoonFilePath": "Pump.java"}], "commitMessage": "DB: fix small regression in behaviour with Data Pump and presort. See #321\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-06-02 14:13:12"}], "created": "2014-05-05 09:33:01"}, {"labels": ["bug"], "filteredCommits": ["4471557e61ac9f541ffd60737fe6f2e45fdeb0a0"], "url": "https://github.com/jankotek/mapdb/issues/320", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 4, "deletions": 0}, "numCommits": 1, "commits": {"2c9e555d882b1bb6754e941ff861ee9bd9c2b63b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "4471557e61ac9f541ffd60737fe6f2e45fdeb0a0": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 1.0002777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Following code fails:\n\n``` java\n\n       List unsorted = Arrays.asList(4,7,5,12,9,10,11,0);\n\n        NavigableMap<Integer,Integer> s = DBMaker.newMemoryDB().cacheDisable().transactionDisable().make()\n                .createTreeMap(\"t\")\n                .pumpPresort(10)\n                .pumpSource(unsorted.iterator(), Fun.extractNoTransform())\n                .make();\n\n        assertEquals(Integer.valueOf(0),s.firstEntry().getKey());\n        assertEquals(Integer.valueOf(12),s.lastEntry().getKey());\n```\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "BTreeMap pump presort fails", "statsSkippedReason": "", "closed": "2014-05-04 22:13:21", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-05-03 19:50:50", "commitHash": "4471557e61ac9f541ffd60737fe6f2e45fdeb0a0", "commitParents": ["39f9a54466d7626576efeba29d79f09bb69842f5"], "commitGHEventType": "referenced", "nameRev": "4471557e61ac9f541ffd60737fe6f2e45fdeb0a0 tags/mapdb-2.0-alpha1~231", "commitGitStats": [{"insertions": 27, "lines": 31, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 4}, {"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.treeset_pump_presert()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.treemap_pump_presert()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}], "spoonFilePath": "DB.java"}], "commitMessage": "DBMaker: Solved BTreeMap pump presort fails, #320\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-05-03 19:50:50"}, {"commitUser": "jankotek", "commitDateTime": "2014-05-05 00:27:40", "commitHash": "2c9e555d882b1bb6754e941ff861ee9bd9c2b63b", "commitParents": ["fb241ae3fb37cb694771e67e1e409cd3f8dc543c"], "commitGHEventType": "referenced", "nameRev": "2c9e555d882b1bb6754e941ff861ee9bd9c2b63b tags/mapdb-1.0.1~1", "commitGitStats": [{"insertions": 27, "lines": 31, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 4}, {"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.treeset_pump_presert()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.treemap_pump_presert()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.createTreeMap(org.mapdb.DB$BTreeMapMaker)"}], "spoonFilePath": "DB.java"}], "commitMessage": "DBMaker: Solved BTreeMap pump presort fails, #320\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-05-03 19:50:50"}], "created": "2014-05-03 16:50:02"}, {"labels": ["bug"], "filteredCommits": ["63fead272a5b3a8a4599fd7c30ad70b4a43f667b", "39ba84da468c5cb3e13fd51402a94506a3bf12a0"], "url": "https://github.com/jankotek/mapdb/issues/319", "gitStatsSummary": {"insertions": 27, "gitFilesChange": 2, "lines": 45, "deletions": 18}, "numCommits": 2, "commits": {"63fead272a5b3a8a4599fd7c30ad70b4a43f667b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "39ba84da468c5cb3e13fd51402a94506a3bf12a0": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "fb241ae3fb37cb694771e67e1e409cd3f8dc543c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 33.000277777777775, "user": "kzadorozhny", "changesInPackagesSPOON": ["org.mapdb.DB.getHashSet(java.lang.String)", "org.mapdb.LongConcurrentLRUMap.PQueue"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Trying to use release version of MapDB:\n\n```\n2014-04-29 11:35:37,978 [ERROR] [pool-1-thread-1] c.t.r.a.h.StringHandler - Parser Error\njava.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Lorg.mapdb.LongConcurrentLRUMap$CacheEntry;\n    at org.mapdb.LongConcurrentLRUMap$PQueue.<init>(LongConcurrentLRUMap.java:339) ~[mapdb-1.0.0.jar:na]\n    at org.mapdb.LongConcurrentLRUMap.markAndSweep(LongConcurrentLRUMap.java:265) ~[mapdb-1.0.0.jar:na]\n    at org.mapdb.LongConcurrentLRUMap.put(LongConcurrentLRUMap.java:123) ~[mapdb-1.0.0.jar:na]\n    at org.mapdb.Caches$LRU.get(Caches.java:71) ~[mapdb-1.0.0.jar:na]\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:679) ~[mapdb-1.0.0.jar:na]\n    at org.mapdb.BTreeMap.put(BTreeMap.java:645) ~[mapdb-1.0.0.jar:na]\n[classes/:na]\n```\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 1, "TOT": 15, "DEL": 7, "INS": 7, "spoonFilesChanged": 2, "MOV": 0}, "title": "ClassCastException in the Cache.LRU markAndSweep", "statsSkippedReason": "", "closed": "2014-06-02 09:56:24", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-04-30 00:27:11", "commitHash": "63fead272a5b3a8a4599fd7c30ad70b4a43f667b", "commitParents": ["fa4db686fc512a0e260333bf7c2e3bcbd959f359"], "commitGHEventType": "referenced", "nameRev": "63fead272a5b3a8a4599fd7c30ad70b4a43f667b tags/mapdb-2.0-alpha1~233", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/LongConcurrentLRUMapTest.java", "deletions": 0}, {"insertions": 5, "lines": 9, "filePath": "src/main/java/org/mapdb/LongConcurrentLRUMap.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.LongConcurrentLRUMapTest"}], "spoonFilePath": "LongConcurrentLRUMapTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.LongConcurrentLRUMap.PQueue"}], "spoonFilePath": "LongConcurrentLRUMap.java"}], "commitMessage": "CacheLRU: fix class cast exception. See #319\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-30 00:27:11"}, {"commitUser": "jankotek", "commitDateTime": "2015-02-11 15:07:42", "commitHash": "39ba84da468c5cb3e13fd51402a94506a3bf12a0", "commitParents": ["9c27cd0a976561fab6a8df43c7dfc7ee1c61de64"], "commitGHEventType": "referenced", "nameRev": "39ba84da468c5cb3e13fd51402a94506a3bf12a0 tags/mapdb-1.0.7~14", "commitGitStats": [{"insertions": 22, "lines": 36, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 14}, {"insertions": 131, "lines": 131, "filePath": "src/test/java/org/mapdb/Issue419Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 14, "DEL": 7, "INS": 7, "MOV": 0, "spoonMethodName": "org.mapdb.DB.getHashSet(java.lang.String)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue419Test"}], "spoonFilePath": "Issue419Test.java"}], "commitMessage": "Fix #319, DB.getHashSet() does not restore expiration settings\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-02-11 15:07:42"}, {"commitUser": "jankotek", "commitDateTime": "2014-05-05 00:25:56", "commitHash": "fb241ae3fb37cb694771e67e1e409cd3f8dc543c", "commitParents": ["c74ec95cbc209abeb6ae3a7fafdd7cd925d0de1d"], "commitGHEventType": "referenced", "nameRev": "fb241ae3fb37cb694771e67e1e409cd3f8dc543c tags/mapdb-1.0.1~2", "commitGitStats": [{"insertions": 23, "lines": 23, "filePath": "src/test/java/org/mapdb/LongConcurrentLRUMapTest.java", "deletions": 0}, {"insertions": 5, "lines": 9, "filePath": "src/main/java/org/mapdb/LongConcurrentLRUMap.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.LongConcurrentLRUMapTest"}], "spoonFilePath": "LongConcurrentLRUMapTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.LongConcurrentLRUMap.PQueue"}], "spoonFilePath": "LongConcurrentLRUMap.java"}], "commitMessage": "CacheLRU: fix class cast exception. See #319\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-30 00:27:11"}], "created": "2014-04-29 18:41:02"}, {"labels": ["bug", "enhancement"], "url": "https://github.com/jankotek/mapdb/issues/316", "title": "Delete old files on opening, if they are corrupted", "closed": "2015-06-25 11:53:01", "commitsDetails": [], "commits": {}, "ttf": 429.0002777777778, "created": "2014-04-22 10:15:58", "user": "chrisdwalton", "body": "This is a feature request rather than a bug.    \n\nSince there is no way to recover from a corrupt database file, it would be nice to have a .deleteCorruptFile() option when attempting to open a database.   If the database file is not corrupt then the database is opened, otherwise the database file is deleted and a fresh database file is opened.\n\nChris \n"}, {"labels": ["bug"], "filteredCommits": ["9894bcf2331d5c1fa21ec1b9594bddc47bffee55"], "url": "https://github.com/jankotek/mapdb/issues/315", "gitStatsSummary": {"insertions": 5, "gitFilesChange": 1, "lines": 7, "deletions": 2}, "numCommits": 1, "commits": {"9894bcf2331d5c1fa21ec1b9594bddc47bffee55": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 10.000277777777777, "user": "JensBee", "changesInPackagesSPOON": ["org.mapdb.DB.delete(java.lang.String)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The following test deletes `ITEM_ONE` and `ITEM_ONE_TWO`, if delete is invoked for the first item. (tested against trunk)\n\n``` java\n@Test\n  public void test() {\n    DB db = DBMaker.newMemoryDB().make();\n\n    final String item1 = \"ITEM_ONE\";\n    final String item2 = \"ITEM_ONE_TWO\";\n\n    db.createTreeMap(item1).make();\n    db.createTreeSet(item2).make();\n\n    System.out.println(\"DB: \" + db.getAll().size());\n    for (String dbItem : db.getAll().keySet()) {\n      System.out.println(\"DB: \" + dbItem);\n    }\n\n    db.delete(item1);\n\n    System.out.println(\"DB: \" + db.getAll().size());\n    for (String dbItem : db.getAll().keySet()) {\n      System.out.println(\"DB: \" + dbItem);\n    }\n  }\n```\n\nOutput is\n\n```\nDB: 2\nDB: ITEM_ONE\nDB: ITEM_ONE_TWO\nDelete..\nDB: 0\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 1}, "title": "DB.delete(name) deletes substring matches", "statsSkippedReason": "", "closed": "2014-04-27 12:39:06", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-04-16 23:07:35", "commitHash": "9894bcf2331d5c1fa21ec1b9594bddc47bffee55", "commitParents": ["fdd3a9c868ae1dc9a90f83ccd3d7d7e36b337682"], "commitGHEventType": "referenced", "nameRev": "9894bcf2331d5c1fa21ec1b9594bddc47bffee55 tags/mapdb-1.0.0~4", "commitGitStats": [{"insertions": 5, "lines": 7, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 2}, {"insertions": 31, "lines": 31, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.DB.delete(java.lang.String)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.test_issue_315()"}], "spoonFilePath": "DBTest.java"}], "commitMessage": "DB: fix double remove. See #315\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-16 23:07:35"}], "created": "2014-04-16 19:22:43"}, {"labels": ["bug"], "filteredCommits": ["2838b4d0903433c80693e32e699368c87cf4b58c", "237b8af51a458f6309c5aab6b99dc8381c64ab49"], "url": "https://github.com/jankotek/mapdb/issues/313", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 4, "deletions": 2}, "numCommits": 2, "commits": {"2838b4d0903433c80693e32e699368c87cf4b58c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "237b8af51a458f6309c5aab6b99dc8381c64ab49": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 5.000277777777778, "user": "JensBee", "changesInPackagesSPOON": ["org.mapdb.Volume.MappedFileVol", "org.mapdb.Volume.ByteBufferVol.tryAvailable(long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The following case fails (tested against trunk), if the database file (`npTest.p`) grows larger than 2GB (last valid size is always 2147483648). Same result, if `.async*` options are turned on.\nTested on 64bit linux, so mmap should work.\n\n``` java\n  @Test\n  public void negativePositionTest() throws InterruptedException {\n    DB db = DBMaker.newFileDB(new File(\"npTest\"))\n            .mmapFileEnableIfSupported()\n            .transactionDisable()\n            //.asyncWriteEnable()\n            //.asyncWriteFlushDelay(100)\n            .make();\n\n    Map<String, String> map = db.createTreeMap(\"data\").make();\n    for (long i = 0; i < Long.MAX_VALUE; i++) {\n      map.put(\"Entry\" + i, \" some data \" + UUID.randomUUID().toString());\n    }\n  }\n```\n\nException:\n`\njava.lang.AssertionError: null\n        at org.mapdb.Volume$MappedFileVol.makeNewBuffer(Volume.java:484)\n        at org.mapdb.Volume$ByteBufferVol.tryAvailable(Volume.java:285)\n        at org.mapdb.Volume.ensureAvailable(Volume.java:49)\n        at org.mapdb.StoreDirect.freePhysTake(StoreDirect.java:1086)\n        at org.mapdb.StoreDirect.longStackPut(StoreDirect.java:972)\n        at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:1046)\n        at org.mapdb.StoreDirect.longStackTake(StoreDirect.java:946)\n        at org.mapdb.StoreDirect.freePhysTake(StoreDirect.java:1054)\n        at org.mapdb.StoreDirect.longStackPut(StoreDirect.java:972)\n        at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:1046)\n        at org.mapdb.StoreDirect.update2(StoreDirect.java:525)\n        at org.mapdb.StoreDirect.update(StoreDirect.java:491)\n        at org.mapdb.Caches$HashTable.update(Caches.java:254)\n        at org.mapdb.BTreeMap.put2(BTreeMap.java:747)\n        at org.mapdb.BTreeMap.put(BTreeMap.java:644)\n        at org.mapdb.IssueTest.negativePositionTest(IssueTest.java:38)\n`\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 6, "DEL": 1, "INS": 2, "spoonFilesChanged": 1, "MOV": 3}, "title": "Error in makeNewBuffer if DB size exceedes 2GB", "statsSkippedReason": "", "closed": "2014-04-16 07:56:23", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-04-12 17:47:01", "commitHash": "2838b4d0903433c80693e32e699368c87cf4b58c", "commitParents": ["4947f37f3971a42c559f07657fa05ce7ad9838a5"], "commitGHEventType": "referenced", "nameRev": "2838b4d0903433c80693e32e699368c87cf4b58c tags/mapdb-0.9.12~18", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.tryAvailable(long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix integer/long conversion. See #313\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-12 17:47:01"}, {"commitUser": "jankotek", "commitDateTime": "2014-04-16 10:21:39", "commitHash": "237b8af51a458f6309c5aab6b99dc8381c64ab49", "commitParents": ["0f6af24173be4fba4157b2fc8a27fd473f76eedb"], "commitGHEventType": "referenced", "nameRev": "237b8af51a458f6309c5aab6b99dc8381c64ab49 tags/mapdb-0.9.13~1", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix memory mapped files larger than 2GB. See #313\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-16 10:21:39"}], "created": "2014-04-10 13:57:04"}, {"labels": ["bug"], "filteredCommits": ["f0034d3776b5df5f78a28d6bd156f13c6b865cf2"], "url": "https://github.com/jankotek/mapdb/issues/312", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 3, "deletions": 1}, "numCommits": 1, "commits": {"f0034d3776b5df5f78a28d6bd156f13c6b865cf2": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 7.000277777777778, "user": "ghost", "changesInPackagesSPOON": ["org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)", "org.mapdb.Volume.MappedFileVol"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "this test fails:\n\n```\n@Test\n    public void test(){\n        DB db = DBMaker.newFileDB(new File(\"rotest\"))\n                .mmapFileEnableIfSupported()\n                .transactionDisable()\n                .make();\n\n        Map<Long, String> map = db.createTreeMap(\"data\").make();\n        for(long i = 0; i<100000;i++){\n            map.put(i,i + \"hi my friend \" + i);\n        }\n        db.commit();\n        db.close();\n\n        db = DBMaker.newFileDB(new File(\"rotest\"))\n                .mmapFileEnableIfSupported()\n                .transactionDisable()\n                .readOnly()\n                .make();\n\n\n    }\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "error while opening db with readonly", "statsSkippedReason": "", "closed": "2014-04-16 07:56:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-04-10 11:22:06", "commitHash": "f0034d3776b5df5f78a28d6bd156f13c6b865cf2", "commitParents": ["3ace7a206aaf788eafe7080bece1996184dfe80b"], "commitGHEventType": "referenced", "nameRev": "f0034d3776b5df5f78a28d6bd156f13c6b865cf2 tags/mapdb-0.9.12~21", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}, {"insertions": 34, "lines": 34, "filePath": "src/test/java/org/mapdb/Issue312Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue312Test"}], "spoonFilePath": "Issue312Test.java"}], "commitMessage": "Volume: fix IllegalArgumentException with readonly mmap files. See #312\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-10 11:22:06"}], "created": "2014-04-08 11:51:04"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/311", "title": "crash mapDB when application using mapDB stopped forcing", "closed": "2016-02-15 11:41:27", "commitsDetails": [], "commits": {}, "ttf": 683.0002777777778, "created": "2014-04-02 13:25:31", "user": "roopannava", "body": "I use mapDB in my android application. When I stopped the application via Application Manager -> Force Stop and start it again I get the following error : \n\njava.io.IOError: java.io.EOFException\n        at org.mapdb.Volume$FileChannelVol.getLong(Volume.java:806)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:440)\n        at org.mapdb.StoreWAL.get2(StoreWAL.java:352)\n        at org.mapdb.StoreWAL.get(StoreWAL.java:336)\n        at org.mapdb.Caches$HashTable.get(Caches.java:230)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n        at org.mapdb.TxEngine.get(TxEngine.java:176)\n        at org.mapdb.TxEngine$Tx.getNoLock(TxEngine.java:411)\n        at org.mapdb.TxEngine$Tx.get(TxEngine.java:386)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n        at org.mapdb.TxEngine.get(TxEngine.java:176)\n        at org.mapdb.BTreeMap.<init>(BTreeMap.java:542)\n        at org.mapdb.DB.getTreeMap(DB.java:796)\n\nAny idea?\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/309", "title": "ArrayIndexOutOfBoundsException on createHashMap().makeOrGet[A,B]() in cycle", "closed": "2014-04-13 19:34:06", "commitsDetails": [], "commits": {}, "ttf": 17.00027777777778, "created": "2014-03-27 15:13:27", "user": "kushti", "body": "Code to reproduce(Scala, MapDB 0.9.11):\n\n```\nval memMappedFile = DBMaker.newFileDB(new File(\"/tmp/griddb\"))\n                                  .mmapFileEnable()\n                                  .closeOnJvmShutdown()\n                                  .make()\n\nfor(i <- 1 to 10000){\n    memMappedFile.createHashMap(s\"coll$i\").makeOrGet[String,Int]()\n}\n```\n\ngives:\n\njava.lang.ArrayIndexOutOfBoundsException\n    at java.lang.System.arraycopy(Native Method)\n    at org.mapdb.BTreeKeySerializer.leadingValuePackRead(BTreeKeySerializer.java:231)\n    at org.mapdb.BTreeKeySerializer$3.deserialize(BTreeKeySerializer.java:195)\n    at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:467)\n    at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:288)\n    at org.mapdb.Store.deserialize(Store.java:274)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:361)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:336)\n    at org.mapdb.Caches$HashTable.get(Caches.java:230)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n    at org.mapdb.BTreeMap.get(BTreeMap.java:603)\n    at org.mapdb.BTreeMap.get(BTreeMap.java:590)\n    at org.mapdb.DB.catGet(DB.java:100)\n    at org.mapdb.DB$HTreeMapMaker.makeOrGet(DB.java:222)\n"}, {"labels": ["bug"], "filteredCommits": ["97d7bb0649ca2ff16d7fcb964e35dfa55e0db084"], "url": "https://github.com/jankotek/mapdb/issues/308", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 3, "deletions": 1}, "numCommits": 1, "commits": {"97d7bb0649ca2ff16d7fcb964e35dfa55e0db084": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 21.00027777777778, "user": "fmannhardt", "changesInPackagesSPOON": ["org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I updated to MapDB 0.9.11 and I'm now getting a ArrayIndexOutOfBoundsException on BTreeMap.put after adding several entries. Looking at the MapDB file while adding entries it never exceed the size of 16 MB, whereas it was growing bigger before (~800MB). \n\nI'm running on Win7 64bit, Java JDK 1.7.0_25 using DBMaker.newFileDB to create the DB. The same error happens also if I disable the cache or the asyncWrite feature. I will try to create a test case, but maybe this helps already.\n\n```\njava.lang.ArrayIndexOutOfBoundsException: 147448\n    at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:327)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:440)\n    at org.mapdb.StoreDirect.get(StoreDirect.java:428)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n    at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:399)\n    at org.mapdb.Caches$HashTable.get(Caches.java:230)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:664)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:644)\n```\n\nThe ArrayIndexOutOfBoundsException is always at different sizes.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 3, "DEL": 1, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "ArrayIndexOutOfBoundsException with BTreeMap.put using v0.9.11", "statsSkippedReason": "", "closed": "2014-04-16 07:56:51", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-04-05 22:02:51", "commitHash": "97d7bb0649ca2ff16d7fcb964e35dfa55e0db084", "commitParents": ["55880c0c4cd50b52b40f956e8ca9d06d20302144"], "commitGHEventType": "referenced", "nameRev": "97d7bb0649ca2ff16d7fcb964e35dfa55e0db084 tags/mapdb-0.9.12~33", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}, {"insertions": 40, "lines": 40, "filePath": "src/test/java/org/mapdb/Issue308Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue308Test"}], "spoonFilePath": "Issue308Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 1, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: fix random errors at mmap files. See #308\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-04-05 22:02:51"}], "created": "2014-03-25 20:17:32"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/306", "title": "infinit loop when HashMap iteration", "closed": "2015-09-18 15:58:33", "commitsDetails": [], "commits": {}, "ttf": 543.0002777777778, "created": "2014-03-24 15:52:44", "user": "OBOne", "body": "Hi,\nJust to inform you about a bug.\nWhen i use mapdb and want to iterate over key values, i fell in an infinit loop.\nMy \"for each\" statement return me the same object key again and again (same system id).\nI profile it and and i see all the time is consume by next, moveToNext and advance at line 972 of file HTreeMap. The advance method return always new list again and again.\nAfter that, i must delete my mapDB file if i want to run correctly my program.\nI hope you find it and try to reproduct it.\n\nSincerly,\n"}, {"labels": ["2.0", "bug"], "filteredCommits": ["00a8930ff0dbd0cf3cc9520013037706899b867d", "87559765832f4c123b9ce5aa5269b70925bf62ba"], "url": "https://github.com/jankotek/mapdb/issues/305", "gitStatsSummary": {"insertions": 268, "gitFilesChange": 10, "lines": 367, "deletions": 99}, "numCommits": 2, "commits": {"00a8930ff0dbd0cf3cc9520013037706899b867d": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "87559765832f4c123b9ce5aa5269b70925bf62ba": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 479.0002777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.Volume.MappedFileVol.2", "org.mapdb.UnsafeStuff.UnsafeVolume.getFileLocked()", "org.mapdb.Volume.RandomAccessFileVol.length()", "org.mapdb.Volume.MappedFileVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)", "org.mapdb.StoreDirect", "org.mapdb.Volume.MappedFileVol.factory(java.lang.String,boolean,int,boolean)", "org.mapdb.Volume.RandomAccessFileVol.getFileLocked()", "org.mapdb.Volume.MemoryVol.getFileLocked()", "org.mapdb.Volume.ReadOnly.getFileLocked()", "org.mapdb.Volume.FileChannelVol.close()", "org.mapdb.Volume.RandomAccessFileVol", "org.mapdb.UnsafeStuff.UnsafeVolume.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean)", "org.mapdb.Volume.lockFile(java.io.File,java.io.RandomAccessFile,boolean,boolean)", "org.mapdb.Volume.RandomAccessFileVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Volume.MappedFileVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Volume.MappedFileVol.2.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.DBException.FileLocked", "org.mapdb.Volume.FileChannelVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Volume.MappedFileVol.2.makeVolume(java.lang.String,boolean,int,long,boolean)", "org.mapdb.StoreCached", "org.mapdb.StoreWAL", "org.mapdb.Volume.RandomAccessFileVol.close()", "org.mapdb.Volume.RandomAccessFileVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)", "org.mapdb.Volume.MappedFileVol.close()", "org.mapdb.Volume.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Store", "org.mapdb.DBMaker.Maker.fileLockDisable()", "org.mapdb.StoreAppend.init()", "org.mapdb.StoreDirect.compact()", "org.mapdb.Volume.RandomAccessFileVol.sync()", "org.mapdb.Volume.MappedFileVolSingle", "org.mapdb.Volume.MemoryVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.DBMaker", "org.mapdb.StoreWAL.replayWAL()", "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,int,long,boolean)", "org.mapdb.StoreHeap", "org.mapdb.StoreWAL.walStartNextFile()", "org.mapdb.Volume.MappedFileVol.1", "org.mapdb.Volume.MemoryVolSingle.getFileLocked()", "org.mapdb.Volume.MappedFileVolSingle.getFileLocked()", "org.mapdb.Volume.MappedFileVol.getFileLocked()", "org.mapdb.StoreAppend", "org.mapdb.DBMaker.Maker.makeEngine()", "org.mapdb.Volume.MappedFileVol", "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,boolean)", "org.mapdb.Volume.FileChannelVol", "org.mapdb.StoreWAL.initOpen()", "org.mapdb.Volume.SingleByteArrayVol.getFileLocked()", "org.mapdb.Volume.MappedFileVolSingle.close()", "org.mapdb.Volume.getFileLocked()", "org.mapdb.Volume.ByteArrayVol.getFileLocked()", "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.Volume.MemoryVol.2.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.StoreWAL.compact()", "org.mapdb.Volume.MappedFileVol.factory(java.lang.String,boolean,boolean,int,boolean)", "org.mapdb.Volume.FileChannelVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)", "org.mapdb.Volume.ByteArrayVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)", "org.mapdb.StoreWAL.commit()", "org.mapdb.Volume.FileChannelVol.getFileLocked()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "hello,\n\nrunning 2 processes on the same dbmap file (start the same java application twice) corrupts the file.\nboth processes get an exception.\n\ni suggest to add a lock file when opening a file to make sure that only one process has access:\n\nhere sample code:\n\n```\n    private static void createLock(String file) throws Exception\n    {\n        String lockFileName = file+\".lck\";\n        File f = new File(lockFileName);\n        if (!f.getAbsoluteFile().getParentFile().exists())\n            f.mkdirs();\n        FileChannel fc;\n        try {\n            FileOutputStream lockStream = new FileOutputStream(lockFileName);\n            fc = lockStream.getChannel();\n        } catch (IOException ix) {\n            // We got an IOException while trying to open the file.\n            throw ix;\n        }\n        try {\n            FileLock fl = fc.tryLock();\n            if (fl == null) {\n                // We failed to get the lock.  Try next file.\n            throw new RuntimeException(\"error creating lock file for \"+file);\n            }\n            // We got the lock OK.\n        } catch (IOException ix) {\n            throw ix;\n        }\n        f.deleteOnExit();\n\n    }\n```\n\nFile locking is also discussed at H2 DB: http://www.h2database.com/html/features.html#database_file_locking\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 60, "UPD": 11, "TOT": 190, "DEL": 13, "INS": 105, "spoonFilesChanged": 10, "MOV": 61}, "title": "Exclusive file lock", "statsSkippedReason": "", "closed": "2015-07-16 22:02:52", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2015-07-17 01:15:56", "commitHash": "00a8930ff0dbd0cf3cc9520013037706899b867d", "commitParents": ["87559765832f4c123b9ce5aa5269b70925bf62ba"], "commitGHEventType": "referenced", "nameRev": "00a8930ff0dbd0cf3cc9520013037706899b867d tags/mapdb-2.0-beta3~21", "commitGitStats": [{"insertions": 24, "lines": 26, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 2}, {"insertions": 24, "lines": 64, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 40}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle"}, {"UPD": 2, "TOT": 6, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 3, "TOT": 13, "DEL": 2, "INS": 2, "MOV": 6, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol"}, {"UPD": 1, "TOT": 7, "DEL": 3, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.FileChannelVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.lockFile(java.io.File,java.io.RandomAccessFile,boolean,boolean)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.lock_double_open()"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: update file locking, see #305\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-17 01:15:56"}, {"commitUser": "jankotek", "commitDateTime": "2015-07-17 00:02:33", "commitHash": "87559765832f4c123b9ce5aa5269b70925bf62ba", "commitParents": ["72649e80593c3f1fa476c951397a2c9dca467a9c"], "commitGHEventType": "closed", "nameRev": "87559765832f4c123b9ce5aa5269b70925bf62ba tags/mapdb-2.0-beta3~22", "commitGitStats": [{"insertions": 12, "lines": 12, "filePath": "src/main/java/org/mapdb/DBException.java", "deletions": 0}, {"insertions": 42, "lines": 42, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 0}, {"insertions": 13, "lines": 25, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 12}, {"insertions": 4, "lines": 5, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 1}, {"insertions": 3, "lines": 5, "filePath": "src/main/java/org/mapdb/StoreCached.java", "deletions": 2}, {"insertions": 12, "lines": 23, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 11}, {"insertions": 3, "lines": 6, "filePath": "src/test/java/org/mapdb/StoreDirectTest2.java", "deletions": 3}, {"insertions": 6, "lines": 11, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 5}, {"insertions": 1, "lines": 1, "filePath": "src/test/java/org/mapdb/StoreCacheHashTableTest.java", "deletions": 0}, {"insertions": 7, "lines": 8, "filePath": "src/main/java/org/mapdb/UnsafeStuff.java", "deletions": 1}, {"insertions": 1, "lines": 1, "filePath": "src/test/java/org/mapdb/StoreAppendTest.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreHeap.java", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/DBHeaderTest.java", "deletions": 2}, {"insertions": 27, "lines": 27, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 0}, {"insertions": 1, "lines": 1, "filePath": "src/test/java/org/mapdb/StoreCachedTest.java", "deletions": 0}, {"insertions": 167, "lines": 203, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 36}, {"insertions": 5, "lines": 7, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCached"}], "spoonFilePath": "StoreCached.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.Maker.fileLockDisable()"}, {"UPD": 0, "TOT": 22, "DEL": 1, "INS": 6, "MOV": 15, "spoonMethodName": "org.mapdb.DBMaker.Maker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBException.FileLocked"}], "spoonFilePath": "DBException.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UnsafeStuff.UnsafeVolume.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UnsafeStuff.UnsafeVolume.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}], "spoonFilePath": "UnsafeStuff.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreHeap"}], "spoonFilePath": "StoreHeap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppendTest.WithChecksums.openEngine()"}], "spoonFilePath": "StoreAppendTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCachedTest.flush_write_cache()"}], "spoonFilePath": "StoreCachedTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.walStartNextFile()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayWAL()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.commit()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.compact()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.initOpen()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest2.reopen_after_insert().1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest2.reopen_after_insert()"}], "spoonFilePath": "StoreDirectTest2.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Store"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreCacheHashTableTest.openEngine()"}], "spoonFilePath": "StoreCacheHashTableTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.init()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.compact_keeps_volume_type()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.compact_keeps_volume_type().1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.single_mmap_grow()"}, {"UPD": 2, "TOT": 7, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.<unknown>.run(java.lang.String)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.all()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 4, "MOV": 2, "spoonMethodName": "org.mapdb.VolumeTest.mmap_init_size()"}], "spoonFilePath": "VolumeTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.file_locked_disabled_append()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.file_locked_disabled()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.file_locked_disabled_wal()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.file_locked()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.sync()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.2"}, {"UPD": 0, "TOT": 18, "DEL": 4, "INS": 7, "MOV": 7, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.length()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteArrayVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle.close()"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.factory(java.lang.String,boolean,int,boolean)"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.1"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ReadOnly.getFileLocked()"}, {"UPD": 0, "TOT": 6, "DEL": 1, "INS": 3, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.getFileLocked()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.getFileLocked()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 3, "MOV": 2, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.factory(java.lang.String,boolean,boolean,int,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.2.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.SingleByteArrayVol.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVolSingle.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteArrayVol.getFileLocked()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.2.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.2.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.1.makeVolume(java.lang.String,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.close()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.VolumeFactory.makeVolume(java.lang.String,boolean,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.1.makeVolume(java.lang.String,boolean,boolean,int,long,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.RandomAccessFileVol.close()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVolSingle.getFileLocked()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBHeaderTest.fail_on_unknown_bit()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBHeaderTest.getBitField()"}], "spoonFilePath": "DBHeaderTest.java"}], "commitMessage": "Volume: add exclusive file locking, also add `DBMaker.fileLockDisable()` option. Fix #305\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2015-07-17 00:02:33"}], "created": "2014-03-24 11:02:15"}, {"labels": ["bug"], "filteredCommits": ["1ae9efcd313a10ad655a5b881ef9d875d442abb9"], "url": "https://github.com/jankotek/mapdb/issues/304", "gitStatsSummary": {"insertions": 11, "gitFilesChange": 1, "lines": 19, "deletions": 8}, "numCommits": 1, "commits": {"1ae9efcd313a10ad655a5b881ef9d875d442abb9": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 22.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi, I'm unsure if i hit a bug or doing something wrong here.\n\nI'm accessing a BTreeMap concurrently and trying to update some value, if it's already there.\n\nThe following code snipped causes MapDB (0.9.10) to throw a \n`ArrayIndexOutOfBoundsException at org.mapdb.BTreeMap.replace(BTreeMap.java:1171):`\n(The idxTermsMap is shared between threads.)\n\n```\nfinal long ttf = termsEnum.totalTermFreq(); // get a new long value\n\n// add value up for all fields, field is a string \n// BytesWrap is a immutable object simply wrapping a bytes array\nfinal Fun.Tuple2<String, BytesWrap> fieldTerm = Fun.t2(field, bw.clone());\n\nLong oldValue = idxTermsMap.putIfAbsent(fieldTerm, ttf);\nif (oldValue != null) {\n  for (;;) {\n    oldValue = idxTermsMap.get(fieldTerm);\n    if (idxTermsMap.replace(fieldTerm, oldValue, oldValue + ttf)) { // exception cause\n      break;\n    }\n  } \n} \n```\n\nIf I add some debugging code printing to the console (which slows down execution a bit) the error does not occur. Also the values when it throws an error are always different. \n\nI'm thankful for any help :)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 13, "DEL": 5, "INS": 5, "spoonFilesChanged": 1, "MOV": 3}, "title": "ArrayIndexOutOfBounds in BTreeMap.replace() under concurrent access", "statsSkippedReason": "", "closed": "2014-04-16 07:57:02", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-03-27 16:39:52", "commitHash": "1ae9efcd313a10ad655a5b881ef9d875d442abb9", "commitParents": ["0ae1507c41b26cfd8322c593d03f7cd61c234f92"], "commitGHEventType": "referenced", "nameRev": "1ae9efcd313a10ad655a5b881ef9d875d442abb9 tags/mapdb-0.9.12~37", "commitGitStats": [{"insertions": 11, "lines": 19, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 8}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 2, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 8, "DEL": 3, "INS": 3, "MOV": 2, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "BTreeMap: fix ArrayIndexOutOfBoundsException in `replace` and `put` methods. See #304\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-03-27 16:37:49"}], "created": "2014-03-24 09:54:46"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/303", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"b84df1ab7522f9d0e6161dee0cb0261cf8e07297": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 12.000277777777777, "user": "jankotek", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "When HashMap is accessed concurrently, it might fail with assertion error:\n\n```\nException in thread \"Thread-1\" Exception in thread \"Thread-0\" java.lang.AssertionError: data were not fully read, check your serializer 14  - 5785824 - 5785837  -  org.mapdb.HTreeMap$ExpireLinkNode@2c091cee\n    at org.mapdb.Store.deserialize(Store.java:272)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:470)\n    at org.mapdb.StoreDirect.get(StoreDirect.java:423)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n    at org.mapdb.HTreeMap.expireLinkBump(HTreeMap.java:1378)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:505)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:459)\n    at examples.Benchmark$1.run(Benchmark.java:59)\n    at java.lang.Thread.run(Thread.java:662)\n```\n\n```\npackage examples;\n\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\nimport org.mapdb.HTreeMap;\nimport org.mapdb.Serializer;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Random;\n\n\npublic class Benchmark {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n\n\n        DB db = DBMaker.newMemoryDirectDB()\n                .transactionDisable()\n                .cacheDisable()\n                .make();\n\n\n        final HTreeMap map = db.createHashMap(\"test\")\n                .keySerializer(Serializer.STRING_ASCII)\n                .valueSerializer(Serializer.STRING_ASCII)\n                .expireMaxSize(5000000) // 5000000\n                .make();\n\n        int keySize = 32;\n        int valSize = 512;\n        int threadNum =6;\n        final int numIter = 1000000;\n\n        StringBuffer sb = new StringBuffer();\n        sb.setLength(0);\n        for (int i = 0; i < keySize; i++) sb.append(\"x\");\n        final String key = sb.toString();\n\n        sb.setLength(0);\n        for (int i = 0; i < valSize; i++) sb.append(\"x\");\n        final String val = sb.toString();\n\n        long time = System.currentTimeMillis();\n\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                Random r = new Random();\n                for (int i = 1; i <= numIter; i++) {\n                    String key2 = key\n                            +i;\n                    map.put(key2, i+val);\n\n                }\n            }\n        };\n\n        ArrayList<Thread> t = new ArrayList<Thread>();\n\n        for(int i=0;i<threadNum;i++){\n            Thread t1 = new Thread(r);\n            t1.start();\n            t.add(t1);\n        }\n\n\n        for(Thread t1:t){\n            t1.join();\n        }\n\n        System.out.printf(\"second %,d\\n\",System.currentTimeMillis()-time);\n        db.close();\n\n    }\n}\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "HashMap cache fails under concurrent access.", "statsSkippedReason": "", "closed": "2014-03-24 12:44:27", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-03-21 20:55:50", "commitHash": "b84df1ab7522f9d0e6161dee0cb0261cf8e07297", "commitParents": ["d9b73c45511ef0b8c33beb61fc4aee5d635a6d32"], "commitGHEventType": "referenced", "nameRev": "b84df1ab7522f9d0e6161dee0cb0261cf8e07297 tags/mapdb-0.9.11~7", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapContainsKeyTest.java", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapTest2.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java", "deletions": 1}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/TestFile.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapLargeValsTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java", "deletions": 1}, {"insertions": 8, "lines": 18, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 10}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 1}, {"insertions": 2, "lines": 3, "filePath": "src/test/java/org/mapdb/StoreAppendTest.java", "deletions": 1}, {"insertions": 3, "lines": 6, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 3}, {"insertions": 5, "lines": 28, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 23}, {"insertions": 54, "lines": 215, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 161}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/HTreeSetTest.java", "deletions": 1}, {"insertions": 4, "lines": 8, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 4}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/HTreeMap3Test.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/TxEngineTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppendTest.compact_file_deleted()"}], "spoonFilePath": "StoreAppendTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 4, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreVolumeFactory()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreWAL(org.mapdb.Volume$Factory)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreDirect(org.mapdb.Volume$Factory)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.fullChunkAllocationEnable()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngineTest"}], "spoonFilePath": "TxEngineTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper_ImmutabilityCheckEngine.test()"}], "spoonFilePath": "EngineWrapper_ImmutabilityCheckEngine.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap3Test"}], "spoonFilePath": "HTreeMap3Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest2"}], "spoonFilePath": "BTreeMapTest2.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.header_index_ver()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapLargeValsTest"}], "spoonFilePath": "BTreeMapLargeValsTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest"}], "spoonFilePath": "DBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeSetTest"}], "spoonFilePath": "HTreeSetTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.rollover()"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_index_inc()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_phys_inc()"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapContainsKeyTest"}], "spoonFilePath": "BTreeMapContainsKeyTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 5, "DEL": 4, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 3, "TOT": 7, "DEL": 2, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.tryAvailable(long)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createPhysVolume()"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.isEmpty()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createTransLogVolume()"}, {"UPD": 0, "TOT": 14, "DEL": 11, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.MemoryVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,java.io.File,long,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 3, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createTransLogVolume()"}, {"UPD": 7, "TOT": 20, "DEL": 7, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 1, "TOT": 26, "DEL": 10, "INS": 4, "MOV": 11, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.tryAvailable(long)"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol"}, {"UPD": 4, "TOT": 16, "DEL": 11, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 14, "DEL": 9, "INS": 0, "MOV": 5, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}, {"UPD": 2, "TOT": 3, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,boolean)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createIndexVolume()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.makeNewBuffer(long)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createIndexVolume()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createPhysVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.isEmpty()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TestFile"}], "spoonFilePath": "TestFile.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectFreeSpaceTest"}], "spoonFilePath": "StoreDirectFreeSpaceTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "Volume: change 'chunk size' from 1GB to 16MB and disable incremental allocation. The 'full chunk allocation' option was removed and is now on by default.\n\nThis change completely changes  storage format, there is no backward compatibility with previous versions.\n\nThis solves race conditions while byte[] was being copied inside in-memory store. It solves issues #302 and #303\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-03-21 20:55:50"}], "created": "2014-03-11 20:14:57"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/302", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"b84df1ab7522f9d0e6161dee0cb0261cf8e07297": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 12.000277777777777, "user": "martinlansler", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "I encountered the following exception:\n\n```\nException in thread \"main\" java.lang.AssertionError: unknown trans log instruction '4' at log offset: 2678772\n        at org.mapdb.StoreWAL.verifyLogFile(StoreWAL.java:754)\n        at org.mapdb.StoreWAL.<init>(StoreWAL.java:66)\n        at org.mapdb.DBMaker.extendStoreWAL(DBMaker.java:923)\n        at org.mapdb.DBMaker.makeEngine(DBMaker.java:718)\n        at org.mapdb.DBMaker.makeTxMaker(DBMaker.java:686)\n       <Application specific code>\n```\n\nThe error occurred after loading a file based map store heavily under roughly 4 minutes from four threads and abruptly killing the Java process. Test was run on Windows 7, using Java 7 and a SSD disk. It seemed in this case that the WAL did not get a chance to completely flush it's entries to disk leaving it in an invalid state.\n\nAfter removing the <code>.t</code> file the store opens fine. The corrupt <code>.t</code> is available and can be provided (it's about 2.5 MB in size)\n\nAs the WAL file always runs the risk of being corrupted on disk I think a more robust handling would be good, I see some alternatives (without knowing all the internal details):\n- The WAL is parsed and only the valid entries are applied, incomplete entries are discarded\n- A policy setting automatically removes the corrupted WAL file allowing the rest of the application to bootstrap\n\nIn both cases suitable warning messages should of course be logged.\n\nThe code that interacted with the HashMap is below (it's a Hazelcast <code>MapStore</code> implementation):\n\n```\npublic class MapDbMapStoreV2 implements MapStore<Object, Object>, MapLoaderLifecycleSupport {\n    private HTreeMap<Object, Object> dbReadOnlyMap;\n    private DB readOnlyDb;\n    private TxMaker txMaker;\n    private String mapName;\n\n    @Override\n    public void init(HazelcastInstance hazelcastInstance, Properties properties, String mapName) {\n        File dbFile = new File(properties.getProperty(\"dbFile\"));\n        dbFile = dbFile.getAbsoluteFile();\n        this.mapName = mapName;\n        //\n        txMaker = DBMaker.newFileDB(dbFile).closeOnJvmShutdown().makeTxMaker();\n        // NB! For DB initially does not exists the read-only must be opened after the TxMaker which will create the files on disk\n        readOnlyDb = DBMaker.newFileDB(dbFile).transactionDisable().readOnly().closeOnJvmShutdown().make();\n        dbReadOnlyMap = readOnlyDb.getHashMap(mapName);\n    }\n\n    private abstract class MapStoreTxBlock implements TxBlock {\n        @Override\n        public void tx(DB db) throws TxRollbackException {\n            doMapTx(db.getHashMap(mapName));\n        }\n\n        public abstract void doMapTx(HTreeMap<Object, Object> txMap);\n    }\n\n    private void doTx(MapStoreTxBlock txBlock) {\n        txMaker.execute(txBlock);\n    }\n\n    @Override\n    public void destroy() {\n        if (readOnlyDb != null && !readOnlyDb.isClosed()) {\n            readOnlyDb.close();\n            readOnlyDb = null;\n        }\n        if (txMaker != null) {\n            txMaker.close();\n            txMaker = null;\n        }\n    }\n\n    @Override\n    public Object load(Object key) {\n        return dbReadOnlyMap.get(key);\n    }\n\n    @Override\n    public Map<Object, Object> loadAll(Collection<Object> keys) {\n        HashMap<Object, Object> valueMap = new HashMap<>(keys.size());\n        for (Object key : keys) {\n            valueMap.put(key, dbReadOnlyMap.get(key));\n        }\n        return valueMap;\n    }\n\n    @Override\n    public Set<Object> loadAllKeys() {\n        return dbReadOnlyMap.keySet();\n    }\n\n    @Override\n    public void store(final Object key, final Object value) {\n        doTx(new MapStoreTxBlock() {\n            @Override\n            public void doMapTx(HTreeMap<Object, Object> txMap) {\n                txMap.put(key, value);\n            }\n        });\n    }\n\n    @Override\n    public void storeAll(final Map<Object, Object> map) {\n        doTx(new MapStoreTxBlock() {\n            @Override\n            public void doMapTx(HTreeMap<Object, Object> txMap) {\n                txMap.putAll(map);\n            }\n        });\n    }\n\n    @Override\n    public void delete(final Object key) {\n        doTx(new MapStoreTxBlock() {\n            @Override\n            public void doMapTx(HTreeMap<Object, Object> txMap) {\n                txMap.remove(key);\n            }\n        });\n    }\n\n    @Override\n    public void deleteAll(final Collection<Object> keys) {\n        doTx(new MapStoreTxBlock() {\n            @Override\n            public void doMapTx(HTreeMap<Object, Object> txMap) {\n                for (Object key : keys) {\n                    txMap.remove(key);\n                }\n            }\n        });\n    }\n}\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "Recovery from corrupt WAL entry", "statsSkippedReason": "", "closed": "2014-03-24 12:44:17", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-03-21 20:55:50", "commitHash": "b84df1ab7522f9d0e6161dee0cb0261cf8e07297", "commitParents": ["d9b73c45511ef0b8c33beb61fc4aee5d635a6d32"], "commitGHEventType": "referenced", "nameRev": "b84df1ab7522f9d0e6161dee0cb0261cf8e07297 tags/mapdb-0.9.11~7", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapContainsKeyTest.java", "deletions": 1}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/StoreWALTest.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapTest2.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BrokenDBTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java", "deletions": 1}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/TestFile.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapLargeValsTest.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java", "deletions": 1}, {"insertions": 8, "lines": 18, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 10}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 1}, {"insertions": 2, "lines": 3, "filePath": "src/test/java/org/mapdb/StoreAppendTest.java", "deletions": 1}, {"insertions": 3, "lines": 6, "filePath": "src/test/java/org/mapdb/StoreDirectTest.java", "deletions": 3}, {"insertions": 5, "lines": 28, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 23}, {"insertions": 54, "lines": 215, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 161}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/HTreeSetTest.java", "deletions": 1}, {"insertions": 4, "lines": 8, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 4}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/HTreeMap3Test.java", "deletions": 1}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/TxEngineTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppendTest.compact_file_deleted()"}], "spoonFilePath": "StoreAppendTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 4, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreVolumeFactory()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreWAL(org.mapdb.Volume$Factory)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendStoreDirect(org.mapdb.Volume$Factory)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.fullChunkAllocationEnable()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngineTest"}], "spoonFilePath": "TxEngineTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper_ImmutabilityCheckEngine.test()"}], "spoonFilePath": "EngineWrapper_ImmutabilityCheckEngine.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap3Test"}], "spoonFilePath": "HTreeMap3Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest2"}], "spoonFilePath": "BTreeMapTest2.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWALTest.header_index_ver()"}], "spoonFilePath": "StoreWALTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapLargeValsTest"}], "spoonFilePath": "BTreeMapLargeValsTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest"}], "spoonFilePath": "DBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeSetTest"}], "spoonFilePath": "HTreeSetTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.rollover()"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_index_inc()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectTest.header_phys_inc()"}], "spoonFilePath": "StoreDirectTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapContainsKeyTest"}], "spoonFilePath": "BTreeMapContainsKeyTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 5, "DEL": 4, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 3, "TOT": 7, "DEL": 2, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.tryAvailable(long)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createPhysVolume()"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.isEmpty()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createTransLogVolume()"}, {"UPD": 0, "TOT": 14, "DEL": 11, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.MemoryVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,java.io.File,long,boolean)"}, {"UPD": 0, "TOT": 4, "DEL": 3, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createTransLogVolume()"}, {"UPD": 7, "TOT": 20, "DEL": 7, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 1, "TOT": 26, "DEL": 10, "INS": 4, "MOV": 11, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.tryAvailable(long)"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol"}, {"UPD": 4, "TOT": 16, "DEL": 11, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 14, "DEL": 9, "INS": 0, "MOV": 5, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}, {"UPD": 2, "TOT": 3, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeForFile(java.io.File,boolean,boolean,long,boolean)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createIndexVolume()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol.makeNewBuffer(long)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File).1.createIndexVolume()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MemoryVol"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.memoryFactory(boolean,long,boolean).2.createPhysVolume()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.isEmpty()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.fileFactory(boolean,int,long,boolean,java.io.File,java.io.File,java.io.File)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TestFile"}], "spoonFilePath": "TestFile.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectFreeSpaceTest"}], "spoonFilePath": "StoreDirectFreeSpaceTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BrokenDBTest.canDeleteDBOnBrokenLog()"}], "spoonFilePath": "BrokenDBTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "Volume: change 'chunk size' from 1GB to 16MB and disable incremental allocation. The 'full chunk allocation' option was removed and is now on by default.\n\nThis change completely changes  storage format, there is no backward compatibility with previous versions.\n\nThis solves race conditions while byte[] was being copied inside in-memory store. It solves issues #302 and #303\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-03-21 20:55:50"}], "created": "2014-03-11 13:01:47"}, {"labels": ["bug"], "filteredCommits": ["18146ebd03cf0f6f842ff73fdf2288f275c9733a"], "url": "https://github.com/jankotek/mapdb/issues/300", "gitStatsSummary": {"insertions": 6, "gitFilesChange": 1, "lines": 7, "deletions": 1}, "numCommits": 1, "commits": {"18146ebd03cf0f6f842ff73fdf2288f275c9733a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 36.000277777777775, "user": "rainerWJY", "changesInPackagesSPOON": ["org.mapdb.Queues.SimpleQueue.offer(java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "in java.util.Queue \noffer()  returns true if the element was added to this queue, else\n     \\*      false\n\nbut now , queue will wait until there have a new position to add this element .\n\nsize() Returns the number of elements in this collection. \n\nbut now , It's simply throw UnsupportedOperationException()\u3002\n\nI think offer() is the very important method in Concurrent execution, for you can replace the original queue in ThreadPoolExecutor , and enhance the gc problem :) .. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "Queues.queue need implements offer() and size() correctly", "statsSkippedReason": "", "closed": "2014-04-16 07:57:09", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-03-24 11:12:58", "commitHash": "18146ebd03cf0f6f842ff73fdf2288f275c9733a", "commitParents": ["d3819a5afe95f8a7a17b8b0a69292192550617b8"], "commitGHEventType": "referenced", "nameRev": "18146ebd03cf0f6f842ff73fdf2288f275c9733a tags/mapdb-0.9.11~3", "commitGitStats": [{"insertions": 6, "lines": 7, "filePath": "src/main/java/org/mapdb/Queues.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Queues.SimpleQueue.offer(java.lang.Object)"}], "spoonFilePath": "Queues.java"}], "commitMessage": "Queues: fix offer method not returning false. See #300\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-03-24 11:12:58"}], "created": "2014-03-11 04:55:48"}, {"labels": ["bug"], "filteredCommits": ["39220a0963747d1a31d9c70302ddf4ed820bc524"], "url": "https://github.com/jankotek/mapdb/issues/298", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 10, "deletions": 2}, "numCommits": 1, "commits": {"39220a0963747d1a31d9c70302ddf4ed820bc524": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 4.000277777777778, "user": "Toilal", "changesInPackagesSPOON": ["org.mapdb.Volume.MappedFileVol.sync()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "When using nnapFileEnabled(), performance are greatly improved. But it seems that Java7 is slower than Java6 in this case (about 2x slower in my test case).\n\nIf using syncOnCommitDisable(), both version have the same performance (about 3x faster than Java6 previous test metric).\n\nAny idea or possible tweak to have the same performance in Java7 using memory map and sync on commit ?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 8, "DEL": 2, "INS": 3, "spoonFilesChanged": 1, "MOV": 3}, "title": "nnapFileEnabled() Java7 Performance", "statsSkippedReason": "", "closed": "2014-03-03 12:50:26", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-03-03 14:28:27", "commitHash": "39220a0963747d1a31d9c70302ddf4ed820bc524", "commitParents": ["ca9d5fea5d9358ba97f5c9afae2c5c39f17d8d10"], "commitGHEventType": "referenced", "nameRev": "39220a0963747d1a31d9c70302ddf4ed820bc524 tags/mapdb-0.9.11~14", "commitGitStats": [{"insertions": 8, "lines": 10, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 8, "DEL": 2, "INS": 3, "MOV": 3, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: mmap file chunks were synced multiple times, causing slow sync. See #298\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-03-03 14:28:27"}], "created": "2014-02-27 09:32:05"}, {"labels": ["bug"], "filteredCommits": ["d345d70626a6fc3cfe8940903528cfe6291c0be6"], "url": "https://github.com/jankotek/mapdb/issues/297", "gitStatsSummary": {"insertions": 14, "gitFilesChange": 1, "lines": 25, "deletions": 11}, "numCommits": 1, "commits": {"d345d70626a6fc3cfe8940903528cfe6291c0be6": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 49.000277777777775, "user": "cataphract", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I'm using mapdb 0.9.10. Given this code\n\n``` groovy\nclass BackingMap implements AutoCloseable {\n\n    private static final String  MAPDB_TABLE_NAME     = 'Rmodules_jobs_table'\n    private static final int     NODE_SIZE            = 16\n\n    private DB db\n\n    private BTreeMap<Fun.Tuple3<String, Integer, String>, Object> map\n\n    private TreeMultimap<Fun.Tuple2<Integer, String>, String> contextsIndex\n\n\n    BackingMap(int numColumns, List<Closure<Object>> valueTransformers) {\n        db = DBMaker.newTempFileDB().transactionDisable().make()\n        map = db.createTreeMap(MAPDB_TABLE_NAME).\n                nodeSize(NODE_SIZE).\n                keySerializer(BTreeKeySerializer.TUPLE3).\n                make()\n\n        contextsIndex = TreeMultimap.create(Fun.TUPLE2_COMPARATOR, Ordering.natural())\n\n        map.addModificationListener(this.&updateContextIndex as Bind.MapListener)\n    }\n\n    private void updateContextIndex(Fun.Tuple3<String, Integer, String> key,\n                                    Object oldValue,\n                                    Object newValue) {\n        callsToNotify.incrementAndGet()\n        if (newValue != null) { // insert/update\n            if (oldValue) {\n                throw new IllegaStateException(\"Unexpected update\")\n            }\n            def res = contextsIndex.put(Fun.t2(key.b, key.c), key.a)\n            if (!res) {\n                throw new IllegalStateException('Replacement with key ' + key)\n            }\n        } else { // removal\n            throw new IllegalStateException('Unexpected removal')\n            contextsIndex.remove(Fun.t2(key.b, key.c), key.a)\n        }\n    }\n\n    // ...\n}\n```\n\nand always inserting with different keys, I'm finding I nonetheless hit the `Replacement with key...` exception. Looking at the stack frames, I find an odd state:\n\n```\n notify():278, BTreeMap {org.mapdb}\n     key=Tuple3[GSE8581GSM212849, 2, ]\n     oldValue=null\n put2():755, BTreeMap {org.mapdb}\n     v=Tuple3[GSE8581GSM212849, 2, ]\n put():644, BTreeMap {org.mapdb}\n     key=Tuple3[GSE8581GSM213035, 2, ]\n```\n\nAt some point the key seems to change. By inspection, it seems this can only happen at line 797, when `v` is changed:\n\n``` java\nunlock(nodeLocks, current);\np = q;\nv = (K) A.highKey();\nlevel = level+1;\nif(stackPos!=-1){ //if stack is not empty\n    current = stackVals[stackPos--];\n```\n\nand indeed if I breakpoint there I can see `GSE8581GSM213035` changing into `GSE8581GSM212849`.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 4, "UPD": 4, "TOT": 19, "DEL": 2, "INS": 11, "spoonFilesChanged": 1, "MOV": 2}, "title": "Listener seems to be called with wrong the key in some circumstances", "statsSkippedReason": "", "closed": "2014-04-16 07:57:17", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-26 14:03:41", "commitHash": "d345d70626a6fc3cfe8940903528cfe6291c0be6", "commitParents": ["60a3839ca7e0a27b91f623082567fa4eae55936b"], "commitGHEventType": "referenced", "nameRev": "d345d70626a6fc3cfe8940903528cfe6291c0be6 tags/mapdb-0.9.11~17", "commitGitStats": [{"insertions": 85, "lines": 85, "filePath": "src/test/java/org/mapdb/BindTest.java", "deletions": 0}, {"insertions": 14, "lines": 25, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 11}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.htreemap_listeners()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.mapListeners(org.mapdb.Bind$MapWithModificationListener)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BindTest.btreemap_listeners()"}], "spoonFilePath": "BindTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 1, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 6, "DEL": 1, "INS": 4, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)"}, {"UPD": 4, "TOT": 6, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "BTreeMap: modification listener could be called with wrong key. See #297\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-26 14:03:41"}], "created": "2014-02-25 16:07:06"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/295", "title": "Android default constructor workaround broken from 4.2 onwards", "closed": "2015-08-12 12:49:07", "commitsDetails": [], "commits": {}, "ttf": 534.0002777777778, "created": "2014-02-24 01:35:58", "user": "nadavwr", "body": "See Objenesis [issue 23](https://code.google.com/p/objenesis/issues/detail?id=23): Davlik support broken for Android 4.2\n\n> The signature of ObjectStreamClass methods have changed in Android 4.2.  newInstance now takes a long instead of an int as the 2nd argument, and returns a long instead of an int from getConstructorId.  The VENDOR_VERSION used to identify the newer VM is 1.6.0.\n\nThis impacts code in [SerializerPojo.java:525](https://github.com/jankotek/MapDB/blob/970b748e50b939d1bede6ee9c670cf2896911bb8/src/main/java/org/mapdb/SerializerPojo.java#L525-L527), referenced here from latest commit at this time.\n\nPerhaps another 'androidConstructorJelly' can be added, in line with 'androidConstructorGinger'.\n"}, {"labels": ["bug"], "filteredCommits": ["e877f64dc30037c4604f61237439449325fdd529"], "url": "https://github.com/jankotek/mapdb/issues/288", "gitStatsSummary": {"insertions": 19, "gitFilesChange": 3, "lines": 24, "deletions": 5}, "numCommits": 1, "commits": {"e877f64dc30037c4604f61237439449325fdd529": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.StoreAppend.compact()", "org.mapdb.StoreDirect", "org.mapdb.StoreAppend", "org.mapdb.StoreDirect.compact()", "org.mapdb.Volume.MappedFileVol.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Log file is closed just before it is discarded. The Volume.mmapFile.close() calls sync, which make it slow, even if sync  is disabled.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 5, "UPD": 0, "TOT": 19, "DEL": 1, "INS": 15, "spoonFilesChanged": 3, "MOV": 3}, "title": "syncOnCommitDisable() does not work at WAL", "statsSkippedReason": "", "closed": "2014-02-18 14:54:06", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-18 14:38:53", "commitHash": "e877f64dc30037c4604f61237439449325fdd529", "commitParents": ["7f72ff0132a8572a4daf50364f2b98d60afd6c05"], "commitGHEventType": "referenced", "nameRev": "e877f64dc30037c4604f61237439449325fdd529 tags/mapdb-0.9.10~6", "commitGitStats": [{"insertions": 4, "lines": 6, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}, {"insertions": 11, "lines": 14, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 3}, {"insertions": 4, "lines": 4, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.compact()"}, {"UPD": 0, "TOT": 13, "DEL": 0, "INS": 10, "MOV": 3, "spoonMethodName": "org.mapdb.StoreAppend"}], "spoonFilePath": "StoreAppend.java"}], "commitMessage": "Volume: remove call to sync() from commit() method in mmapfile volume, see #288\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-18 14:38:53"}], "created": "2014-02-18 12:37:23"}, {"labels": ["2.0", "bug", "wontfix"], "url": "https://github.com/jankotek/mapdb/issues/283", "title": "BTreeMap.descendingMap() not working properly", "closed": "2016-02-15 11:59:52", "commitsDetails": [], "commits": {}, "ttf": 732.0002777777778, "created": "2014-02-12 23:10:54", "user": "xiao-cheng", "body": "I have a BTreeMap<String,Object> map of size 5896250 and upon calling any of its descendingMap() or descendingKeySet() methods results in collections of size 228115.\n"}, {"labels": ["bug"], "filteredCommits": ["61e216a1b5740f285be7d914b63b78557eb4ac62"], "url": "https://github.com/jankotek/mapdb/issues/282", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"61e216a1b5740f285be7d914b63b78557eb4ac62": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 5.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.DB.checkNameNotExists(java.lang.String)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "`DB.checkNameExists()` was broken for several months. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "DB.createXXX() does not throw exception if collection already exists.", "statsSkippedReason": "", "closed": "2014-02-18 14:55:39", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-12 17:41:17", "commitHash": "61e216a1b5740f285be7d914b63b78557eb4ac62", "commitParents": ["4cec7a9b483682c6a902ea6fb46775f65e90c41f"], "commitGHEventType": "referenced", "nameRev": "61e216a1b5740f285be7d914b63b78557eb4ac62 tags/mapdb-0.9.10~18", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 1}, {"insertions": 19, "lines": 19, "filePath": "src/test/java/org/mapdb/DBTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.checkNameNotExists(java.lang.String)"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.testAtomicExists()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.testQueueExists()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBTest.testCollectionExists()"}], "spoonFilePath": "DBTest.java"}], "commitMessage": "DB: fixed DB.createXXX() does not throw exception if collection already exists. See #282\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-12 17:41:17"}], "created": "2014-02-12 15:40:35"}, {"labels": ["bug"], "filteredCommits": ["30e17d451a5d942b722be7e04f340a8a3f2ba9b1"], "url": "https://github.com/jankotek/mapdb/issues/281", "gitStatsSummary": {"insertions": 13, "gitFilesChange": 2, "lines": 16, "deletions": 3}, "numCommits": 1, "commits": {"30e17d451a5d942b722be7e04f340a8a3f2ba9b1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "be6579d9e6242833e41b9e30909f562b0cb0b0ef": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 6.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.TxMaker", "org.mapdb.TxMaker.makeTx()", "org.mapdb.DBMaker.makeTxMaker()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Maybe I'm missing something, but if I run this code:\n\n```\n    TxMaker txMaker = DBMaker\n            .newFileDB(new File(\"/tmp/foo\"))\n            .snapshotEnable()\n            .makeTxMaker();\n\n    DB snapshot = txMaker.makeTx().snapshot();\n```\n\nI get this error:\n\nException in thread \"main\" java.lang.UnsupportedOperationException: Snapshots are not enabled, use DBMaker.snapshotEnable()\n    at org.mapdb.TxEngine.createSnapshotFor(TxEngine.java:72)\n    at org.mapdb.TxEngine.createSnapshotFor(TxEngine.java:71)\n    at org.mapdb.DB.snapshot(DB.java:1530)\n\nThis is with mapdb 0.9.9 from maven central. Is this is a bug or am I doing something wrong?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 0, "TOT": 14, "DEL": 0, "INS": 13, "spoonFilesChanged": 2, "MOV": 1}, "title": "txMaker.makeTx().snapshot() does not work", "statsSkippedReason": "", "closed": "2014-02-18 14:52:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-18 16:20:55", "commitHash": "30e17d451a5d942b722be7e04f340a8a3f2ba9b1", "commitParents": ["780c1e590dbcf0a564112a308a682e93bb6c7b98"], "commitGHEventType": "referenced", "nameRev": "30e17d451a5d942b722be7e04f340a8a3f2ba9b1 tags/mapdb-0.9.10~1", "commitGitStats": [{"insertions": 12, "lines": 14, "filePath": "src/main/java/org/mapdb/TxMaker.java", "deletions": 2}, {"insertions": 36, "lines": 36, "filePath": "src/test/java/org/mapdb/TxMakerTest.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 7, "DEL": 0, "INS": 7, "MOV": 0, "spoonMethodName": "org.mapdb.TxMaker"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 4, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.makeTx()"}], "spoonFilePath": "TxMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.txSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.txSnapshot2()"}], "spoonFilePath": "TxMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeTxMaker()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "TxMaker: fix snapshots on transactions. See #281\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-18 16:20:55"}, {"commitUser": "jankotek", "commitDateTime": "2014-02-14 18:25:28", "commitHash": "be6579d9e6242833e41b9e30909f562b0cb0b0ef", "commitParents": ["717b008da75918aae78156e9cb999af987f1e326"], "commitGHEventType": "referenced", "nameRev": "be6579d9e6242833e41b9e30909f562b0cb0b0ef tags/mapdb-0.9.10~13", "commitGitStats": [{"insertions": 18, "lines": 19, "filePath": "src/main/java/org/mapdb/TxEngine.java", "deletions": 1}, {"insertions": 8, "lines": 8, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 0}, {"insertions": 12, "lines": 12, "filePath": "src/main/java/org/mapdb/Engine.java", "deletions": 0}, {"insertions": 40, "lines": 40, "filePath": "src/main/java/org/mapdb/EngineWrapper.java", "deletions": 0}, {"insertions": 6, "lines": 10, "filePath": "src/main/java/org/mapdb/TxMaker.java", "deletions": 4}, {"insertions": 1, "lines": 5, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.canSnapshot()"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [{"UPD": 4, "TOT": 7, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker"}], "spoonFilePath": "TxMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngine.Tx.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngine.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngine.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxEngine.Tx.snapshot()"}], "spoonFilePath": "TxEngine.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.SynchronizedEngineWrapper.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.1.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.1.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.ReadOnlyEngine.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.ReadOnlyEngine.canSnapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.SynchronizedEngineWrapper.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.snapshot()"}], "spoonFilePath": "EngineWrapper.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.snapshot()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.canSnapshot()"}], "spoonFilePath": "Engine.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 3, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeTxMaker()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "Engine & TxMaker: make snapshots part of Engine interface.\n\nThis makes architecture bit clearer, and prepares us for Append-Only store #241 and native Store snapshots #200. Also makes fix for #281 easiyer\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-14 18:25:28"}], "created": "2014-02-12 09:19:40"}, {"labels": ["bug"], "filteredCommits": ["03b4800fc519cc2bd1c1d5a585cf094d5e10d96a"], "url": "https://github.com/jankotek/mapdb/issues/280", "gitStatsSummary": {"insertions": 12, "gitFilesChange": 1, "lines": 12, "deletions": 0}, "numCommits": 1, "commits": {"03b4800fc519cc2bd1c1d5a585cf094d5e10d96a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 6.000277777777778, "user": "andygrove", "changesInPackagesSPOON": ["org.mapdb.Volume.FileChannelVol.checkFolder(java.io.File,boolean)", "org.mapdb.Volume.MappedFileVol", "org.mapdb.Volume.FileChannelVol"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Code:\n\n DBMaker\n                .newFileDB(file)\n                .snapshotEnable()\n                .syncOnCommitDisable()\n                .makeTxMaker();\n\nIf file refers to /tmp/a/mydb.db and /tmp/a does not exist then the code fails with:\n\n java.lang.NullPointerException\n    at org.mapdb.StoreWAL.close(StoreWAL.java:1081)\n    at org.mapdb.StoreDirect.<init>(StoreDirect.java:217)\n    at org.mapdb.StoreWAL.<init>(StoreWAL.java:57)\n    at org.mapdb.DBMaker.extendStoreWAL(DBMaker.java:857)\n    at org.mapdb.DBMaker.makeEngine(DBMaker.java:639)\n    at org.mapdb.DBMaker.makeTxMaker(DBMaker.java:606)\n\nThis is using mapdb-0.9.9-20140104.115606-2.jar\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "spoonFilesChanged": 1, "MOV": 0}, "title": "NPE when creating a database if parent path does not exist", "statsSkippedReason": "", "closed": "2014-02-18 14:53:29", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-18 16:07:33", "commitHash": "03b4800fc519cc2bd1c1d5a585cf094d5e10d96a", "commitParents": ["709d2254c8d194db50984713a3560a5e3bfc8b94"], "commitGHEventType": "referenced", "nameRev": "03b4800fc519cc2bd1c1d5a585cf094d5e10d96a tags/mapdb-0.9.10~3", "commitGitStats": [{"insertions": 22, "lines": 23, "filePath": "src/test/java/org/mapdb/DBMakerTest.java", "deletions": 1}, {"insertions": 12, "lines": 12, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.nonExistingFolder2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.nonExistingFolder3()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMakerTest.nonExistingFolder()"}], "spoonFilePath": "DBMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol.checkFolder(java.io.File,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.FileChannelVol"}], "spoonFilePath": "Volume.java"}], "commitMessage": "Volume: check parent folder before opening db. See #280\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-18 16:07:33"}], "created": "2014-02-11 18:49:24"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/278", "title": "Issues with StoreWAL / TreeMap with 0.9.9", "closed": "2014-02-17 22:07:15", "commitsDetails": [], "commits": {}, "ttf": 7.000277777777778, "created": "2014-02-10 00:10:06", "user": "flavor8", "body": "I keep getting errors like the following after upgrading to 0.9.9; they usually seem to happen after cycling the JVM a couple of times. I am running on Java 8. I'll try Java 7 for a while and see if they reoccur, although it's unlikely to be a cause.\n\nMy setup is quite simple:\n            db = DBMaker.newFileDB(dbFile)\n                    .closeOnJvmShutdown()\n                    .make();\n\n! java.io.IOError: java.io.IOException: Zero Header, data corrupted\n! at org.mapdb.SerializerBase.deserialize(SerializerBase.java:825) \n! at org.mapdb.SerializerBase.deserialize(SerializerBase.java:811) \n! at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:451) \n! at org.mapdb.BTreeMap$NodeSerializer.deserialize(BTreeMap.java:288)\n! at org.mapdb.Store.deserialize(Store.java:270) \n! at org.mapdb.StoreDirect.get2(StoreDirect.java:468) \n! at org.mapdb.StoreWAL.get2(StoreWAL.java:347)\n! at org.mapdb.StoreWAL.get(StoreWAL.java:331)\n! at org.mapdb.Caches$HashTable.get(Caches.java:230)\n! at org.mapdb.BTreeMap.<init>(BTreeMap.java:542)\n! at org.mapdb.DB.getTreeMap(DB.java:778) \n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/276", "title": "how to configure memory limit", "closed": "2014-02-18 14:55:14", "commitsDetails": [], "commits": {}, "ttf": 12.000277777777777, "created": "2014-02-06 06:29:20", "user": "os72", "body": "(1) If I set a DB memory limit and the consumption goes beyond it throws exception:\n\nException in thread \"main\" java.io.IOError: java.io.IOException: no free space to expand Volume\n\n(2) If I set a limit on number of records in HTreeMap it manages that (applies evictions) and continues to operate\n\nIs there a way to get behavior (2) with DB memory limit? (Evict, don't throw exception)\n\nThanks!\n\n```\n    DB db = DBMaker.newDirectMemoryDB()\n            .transactionDisable()\n            .syncOnCommitDisable()\n            //.asyncWriteEnable()\n            .closeOnJvmShutdown()\n            .sizeLimit(1) // in GB\n            //.cacheSize(1000)\n            //.cacheLRUEnable()\n            .make();\n\n    HTreeMap<Integer,String> map = db.createHashMap(\"foo1\")\n            .expireMaxSize(100000)\n            .make();\n```\n"}, {"labels": ["bug"], "filteredCommits": ["95bf81e83a85b7f1a4dd5a8d81a536f5fc0bd9bf", "a86f61f117f0167884df2549bc3d923df48618a7"], "url": "https://github.com/jankotek/mapdb/issues/275", "gitStatsSummary": {"insertions": 113, "gitFilesChange": 3, "lines": 180, "deletions": 67}, "numCommits": 2, "commits": {"95bf81e83a85b7f1a4dd5a8d81a536f5fc0bd9bf": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "a86f61f117f0167884df2549bc3d923df48618a7": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 14.000277777777777, "user": "os72", "changesInPackagesSPOON": ["org.mapdb.DBMaker", "org.mapdb.AsyncWriteEngine.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.DBMaker.asyncWriteQueueSize(int)", "org.mapdb.AsyncWriteEngine", "org.mapdb", "org.mapdb.AsyncWriteEngine.compact()", "org.mapdb.AsyncWriteEngine.WriterRunnable.run()", "org.mapdb.AsyncWriteEngine.clearCache()", "org.mapdb.AsyncWriteEngine.waitForAction(int)", "org.mapdb.AsyncWriteEngine.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.AsyncWriteEngine.commit()", "org.mapdb.DBMaker.extendAsyncWriteEngine(org.mapdb.Engine)", "org.mapdb.AsyncWriteEngine.rollback()", "org.mapdb.AsyncWriteEngine.WriterRunnable", "org.mapdb.AsyncWriteEngine.runWriter()", "org.mapdb.AsyncWriteEngine.preallocate(long[])", "org.mapdb.AsyncWriteEngine.preallocate()", "org.mapdb.AsyncWriteEngine.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Using mapdb 0.9.8, modified \"hello world\" to populate ~10GB data (5M keys), it fails with:\n\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\nLove the concepts behind mapdb, but I can't think of a much simpler test, isn't mapdb supposed to help with Java heap mgmt?... (Separately, commit inside the loop makes it run extremely slow)\n\nCode below:\n\n```\npublic static void main(String[] args) throws IOException {\n\n    //Configure and open database using builder pattern.\n    //All options are available with code auto-completion.\n    //File dbFile = File.createTempFile(\"mapdb\",\"db\");\n    File dbFile = new File(\"mapdb.db\");\n    DB db = DBMaker.newFileDB(dbFile)\n            .mmapFileEnable()\n            .transactionDisable()\n            .asyncWriteEnable()\n            .syncOnCommitDisable()\n            .closeOnJvmShutdown()\n            .make();\n\n    //open an collection, TreeMap has better performance then HashMap\n    ConcurrentNavigableMap<Integer,String> map = db.getTreeMap(\"collectionName\");\n\n    map.put(1,\"one\");\n    map.put(2,\"two\");\n    //map.keySet() is now [1,2] even before commit\n\n    db.commit();  //persist changes into disk\n\n    map.put(3,\"three\");\n    //map.keySet() is now [1,2,3]\n    //db.rollback(); //revert recent changes\n    //map.keySet() is now [1,2]\n\n    long st;\n    long et;\n    double dt;\n\n    StringBuffer sb = new StringBuffer();\n    for (int i = 0; i < 2048; i++) sb.append(\"x\");\n    String val = sb.toString();\n    System.out.println(val.length());\n\n    st = System.currentTimeMillis();\n    for (int i = 0; i < 5000000; i++) {\n        map.put(i, i+val);\n        //db.commit();  // extremely slow\n        if (i % 100000 == 0) System.out.println(i);\n    }\n    et = System.currentTimeMillis();\n    dt = (et-st)/1000.0;\n    System.out.println(dt);\n\n    st = System.currentTimeMillis();\n    db.commit();  //persist changes into disk\n    et = System.currentTimeMillis();\n    dt = (et-st)/1000.0;\n    System.out.println(dt);\n\n    System.out.println(map.size());\n\n    db.close();\n}\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 18, "UPD": 12, "TOT": 108, "DEL": 10, "INS": 38, "spoonFilesChanged": 3, "MOV": 48}, "title": "AsyncWrite fails with OOM error", "statsSkippedReason": "", "closed": "2014-02-18 14:56:23", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-04 14:44:40", "commitHash": "95bf81e83a85b7f1a4dd5a8d81a536f5fc0bd9bf", "commitParents": ["a86f61f117f0167884df2549bc3d923df48618a7"], "commitGHEventType": "referenced", "nameRev": "95bf81e83a85b7f1a4dd5a8d81a536f5fc0bd9bf tags/mapdb-0.9.10~28", "commitGitStats": [{"insertions": 33, "lines": 43, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 11, "DEL": 1, "INS": 4, "MOV": 6, "spoonMethodName": "org.mapdb.AsyncWriteEngine.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 2, "MOV": 2, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate(long[])"}, {"UPD": 1, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.AsyncWriteEngine.preallocate()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "AsyncWriteEngine: fix deadlock in preallocation, see #275\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-04 14:44:40"}, {"commitUser": "jankotek", "commitDateTime": "2014-02-04 14:19:23", "commitHash": "a86f61f117f0167884df2549bc3d923df48618a7", "commitParents": ["a7c6b0158ee1eb90660a39ef2c0026ea83919fc8"], "commitGHEventType": "referenced", "nameRev": "a86f61f117f0167884df2549bc3d923df48618a7 tags/mapdb-0.9.10~29", "commitGitStats": [{"insertions": 63, "lines": 119, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 56}, {"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/CC.java", "deletions": 0}, {"insertions": 16, "lines": 17, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.asyncWriteQueueSize(int)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendAsyncWriteEngine(org.mapdb.Engine)"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb"}], "spoonFilePath": "CC.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 15, "DEL": 1, "INS": 3, "MOV": 11, "spoonMethodName": "org.mapdb.AsyncWriteEngine.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 3, "TOT": 13, "DEL": 3, "INS": 0, "MOV": 7, "spoonMethodName": "org.mapdb.AsyncWriteEngine.commit()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine"}, {"UPD": 5, "TOT": 13, "DEL": 2, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.AsyncWriteEngine.rollback()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.WriterRunnable"}, {"UPD": 1, "TOT": 8, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.AsyncWriteEngine.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.waitForAction(int)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.AsyncWriteEngine.WriterRunnable.run()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.AsyncWriteEngine.runWriter()"}, {"UPD": 1, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.clearCache()"}, {"UPD": 0, "TOT": 15, "DEL": 3, "INS": 4, "MOV": 8, "spoonMethodName": "org.mapdb.AsyncWriteEngine.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "AsyncWriter: introduce size limit on Write Queue, fix memory leak. See #275\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-04 14:19:23"}], "created": "2014-02-04 06:15:18"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/274", "title": "FileNotFoundException: C:\\testbed\\database.index.t (Access is denied) on windows", "closed": "2014-03-24 12:45:00", "commitsDetails": [], "commits": {}, "ttf": 53.000277777777775, "created": "2014-01-30 05:20:57", "user": "cmacnaug", "body": "On windows I see the following exception on Windows in mapdb 0.9.6:\n\nException in thread \"main\" java.io.IOError: java.io.FileNotFoundException: C:\\testbed\\database.index.t (Access is denied)\n    at org.mapdb.Volume$MappedFileVol.<init>(Volume.java:460)\n    at org.mapdb.Volume.volumeForFile(Volume.java:185)\n    at org.mapdb.Volume$1.createTransLogVolume(Volume.java:216)\n    at org.mapdb.StoreWAL.openLogIfNeeded(StoreWAL.java:97)\n    at org.mapdb.StoreWAL.put(StoreWAL.java:188)\n    at org.mapdb.Caches$HashTable.put(Caches.java:187)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:704)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:566)\n    at java.lang.Thread.run(Thread.java:662)\nCaused by: java.io.FileNotFoundException: C:\\testbed\\database.index.t (Access is denied)\n    at java.io.RandomAccessFile.open(Native Method)\n    at java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n    at org.mapdb.Volume$MappedFileVol.<init>(Volume.java:438)\n    ... 13 more\n\nThis happens more frequently under heavy load, but also happens intermittently at lower loads. I added a bit of tracing an I can see that the transaction log is not always successfully deleted during commit ... not sure if this is do to file locking or just windows being slow to delete. I created the database with:\n\n```\ndb = maker.closeOnJvmShutdown() \n        .asyncWriteDisable() \n                .syncOnCommitDisable() \n                .make(); \n```\n\nSo Volume.MappedFileVol is being used for the transaction log.\n\nBut also hit this exception with I also hit this exception when creating the database with \n\n```\ndb = maker.closeOnJvmShutdown() \n        .asyncWriteDisable() \n                .syncOnCommitDisable() \n                .randomAccessFileEnableKeepIndexMapped()\n                .make();\n```\n\nand the issue also occurred when Volume.FileChannelVol was used.\n\nI applied the following to Volume.MappedFileVol constructor to retry file open and this solved my issue. It typically only takes about one retry to successfully open the file (patch below based on 0.9.6 tag.\n\n```\n        //PATCH HACK, attempt to open log file in loop to catch cases where windows is slow\n        //to unlock/delete a file:\n        RandomAccessFile openedFile = null;\n        int openAttempts = 0;\n        while (openedFile == null) {\n            try {\n                openedFile = new java.io.RandomAccessFile(file, readOnly ? \"r\" : \"rw\");\n            }\n            catch (IOException ioe) {\n                openAttempts++;\n                if (openAttempts == 10) {\n                    throw ioe;\n                }\n                else {\n                    System.err.println(\"Failed to open \" + file + \" \" + (10 - openAttempts) + \" remaining\");\n                }\n                try {\n                    Thread.sleep(100);\n                }\n                catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                    throw ioe;\n                }\n            }\n        }\n\n        //this.raf = new java.io.RandomAccessFile(file, readOnly?\"r\":\"rw\");\n        this.raf = openedFile;\n        //End PATCH/HACK\n        this.fileChannel = raf.getChannel();\n```\n"}, {"labels": ["bug"], "filteredCommits": ["a7c6b0158ee1eb90660a39ef2c0026ea83919fc8", "2353ab68949d7bebf1854f0c1b730865d4a8694c"], "url": "https://github.com/jankotek/mapdb/issues/272", "gitStatsSummary": {"insertions": 60, "gitFilesChange": 2, "lines": 93, "deletions": 33}, "numCommits": 2, "commits": {"2353ab68949d7bebf1854f0c1b730865d4a8694c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "a7c6b0158ee1eb90660a39ef2c0026ea83919fc8": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 19.00027777777778, "user": "tea-dragon", "changesInPackagesSPOON": ["org.mapdb.EngineWrapper.CloseOnJVMShutdown", "org.mapdb.DBMaker.extendShutdownHookAfter(org.mapdb.Engine)", "org.mapdb.DBMaker.extendShutdownHookBefore(org.mapdb.Engine)", "org.mapdb.DBMaker.makeEngine().1.run()", "org.mapdb.DBMaker.makeTxMaker()", "org.mapdb.DBMaker.makeEngine()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "You have each engine register a shutdown hook with an anonymous class creation. Each of those threads has a reference to the engine being made (not that leaking threads themselves is great). These are kept in a special jdk store and will prevent garbage collection. You can unregister shutdown hooks if you keep a reference to them or you could lazily register a single static hook equipped with something similar to a listenable future and add/remove things to/from it.\n\nDefinitely not what you want to happen if you naively try to do something like create a temporary map for disk backed sorts.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 6, "UPD": 0, "TOT": 16, "DEL": 7, "INS": 8, "spoonFilesChanged": 2, "MOV": 1}, "title": "Memory leak when using closeOnJvmShutdown (eg. any tmp map)", "statsSkippedReason": "", "closed": "2014-02-18 14:56:54", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-02-10 14:07:45", "commitHash": "2353ab68949d7bebf1854f0c1b730865d4a8694c", "commitParents": ["dacdd0165c0353ffd81bf81e5e429be1dcaba0f7"], "commitGHEventType": "referenced", "nameRev": "2353ab68949d7bebf1854f0c1b730865d4a8694c tags/mapdb-0.9.10~21", "commitGitStats": [{"insertions": 39, "lines": 39, "filePath": "src/main/java/org/mapdb/EngineWrapper.java", "deletions": 0}, {"insertions": 1, "lines": 30, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 29}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.CloseOnJVMShutdown"}], "spoonFilePath": "EngineWrapper.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendShutdownHookBefore(org.mapdb.Engine)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.extendShutdownHookAfter(org.mapdb.Engine)"}, {"UPD": 0, "TOT": 6, "DEL": 5, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "DBMaker: cleanup JVM shutdown code. See #272\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-10 14:07:45"}, {"commitUser": "jankotek", "commitDateTime": "2014-02-02 20:34:08", "commitHash": "a7c6b0158ee1eb90660a39ef2c0026ea83919fc8", "commitParents": ["c52b02d9ce625c085555e82b7050a917efeb2a2d"], "commitGHEventType": "referenced", "nameRev": "a7c6b0158ee1eb90660a39ef2c0026ea83919fc8 tags/mapdb-0.9.10~30", "commitGitStats": [{"insertions": 20, "lines": 24, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeEngine().1.run()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeTxMaker()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 4, "MOV": 1, "spoonMethodName": "org.mapdb.DBMaker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "DBMaker: fix memory leak in shutdown hooks. WSee #272\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-02 20:34:08"}], "created": "2014-01-30 00:44:00"}, {"labels": ["bug"], "filteredCommits": ["970b748e50b939d1bede6ee9c670cf2896911bb8"], "url": "https://github.com/jankotek/mapdb/issues/266", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 12, "deletions": 4}, "numCommits": 1, "commits": {"970b748e50b939d1bede6ee9c670cf2896911bb8": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 14.000277777777777, "user": "Toilal", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.serializeUnknownObject(java.io.DataOutput,java.lang.Object,org.mapdb.FastArrayList)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "When using advanced enum with custom methods, MapDB doesn't load name and ordinal properties of the enum.\n\nFailing enum:\n\n```\npublic enum AdvancedEnum {\n    A() {\n        @Override\n        public void dummy() {\n            System.out.println(\"dummy1\");\n        }\n    },\n    B() {\n        @Override\n        public void dummy() {\n            System.out.println(\"dummy2\");\n        }\n    },\n    C() {\n        @Override\n        public void dummy() {\n            System.out.println(\"dummy3\");\n        }\n    };\n\n    public abstract void dummy();\n}\n```\n\nUnitTest:   \n\n```\nimport java.io.File;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\npublic class EnumTest { \n    @Test\n    public void testEnum() {\n        DB db = DBMaker.newFileDB(new File(\"enum\")).make();\n\n        AdvancedEnum testEnumValue = AdvancedEnum.C;\n\n        Set<Object> set = db.createHashSet(\"set\").makeOrGet();\n        set.clear();\n\n        set.add(testEnumValue);\n        db.commit();\n\n        db.close();\n\n        db = DBMaker.newFileDB(new File(\"enum\")).make();\n\n        set = db.createHashSet(\"set\").makeOrGet();\n        AdvancedEnum enumValue = (AdvancedEnum)set.iterator().next();\n\n        Assert.assertNotNull(enumValue);\n\n        Assert.assertEquals(\"Invalid Enum.name()\", enumValue.name(), testEnumValue.name());\n        Assert.assertEquals(\"Invalid Enum.ordinal()\", enumValue.ordinal(), testEnumValue.ordinal());\n    }\n}\n```\n\nname is null and ordinal is 0, causing the loaded enum to be unusable.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 2, "TOT": 12, "DEL": 3, "INS": 4, "spoonFilesChanged": 1, "MOV": 3}, "title": "Serialization fail on Advanced Enums", "statsSkippedReason": "", "closed": "2014-01-29 11:32:51", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-28 17:01:41", "commitHash": "970b748e50b939d1bede6ee9c670cf2896911bb8", "commitParents": ["3a31747706876e94e0c0c12855587d8f2c240bde"], "commitGHEventType": "referenced", "nameRev": "970b748e50b939d1bede6ee9c670cf2896911bb8 tags/mapdb-0.9.9~5", "commitGitStats": [{"insertions": 8, "lines": 12, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 4}, {"insertions": 80, "lines": 80, "filePath": "src/test/java/org/mapdb/Issue266Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 12, "DEL": 3, "INS": 4, "MOV": 3, "spoonMethodName": "org.mapdb.SerializerPojo.serializeUnknownObject(java.io.DataOutput,java.lang.Object,org.mapdb.FastArrayList)"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.AdvancedEnum"}], "spoonFilePath": "Issue266Test.java"}], "commitMessage": "SerializerPojo: fix handling of subclassed Enums. See #266\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-01-28 17:01:41"}], "created": "2014-01-15 10:41:27"}, {"labels": ["bug"], "filteredCommits": ["7b803345bed27933c1f0e5b493e7c70d9343419b"], "url": "https://github.com/jankotek/mapdb/issues/265", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"7b803345bed27933c1f0e5b493e7c70d9343419b": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 15.000277777777777, "user": "krausik", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.compact()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I discovered problem in compact method if HashMap is used (in case of TreeMap all is ok). I have very simple example:\n\n```\nDBMaker dbMaker = DBMaker.newMemoryDB()\n  //.transactionDisable() // breaks functionality even in version 0.9.7\n  .cacheLRUEnable()\n  .cacheSize(10000);\nDB db = dbMaker.make();\n  try {\n    Map<Integer, String> map = db.getHashMap(\"HashMap\");\n    map.put(1, \"one\");\n    map.put(2, \"two\");\n    map.remove(1);\n    db.commit();\n    db.compact();\n    Assert.assertEquals(1, map.size());\n  } finally {\n    db.close();\n  }\n```\n\nHere is a error, which I got:\n\n```\njava.lang.AssertionError: wrong ioList: 33096\n    at org.mapdb.StoreDirect.longStackPut(StoreDirect.java:931)\n    at org.mapdb.StoreDirect.compact(StoreDirect.java:779)\n    at org.mapdb.EngineWrapper.compact(EngineWrapper.java:118)\n    at org.mapdb.DB.compact(DB.java:1514)\n```\n\nI can simulate the problem in version 0.9.8 and 0.9.9-SNAPSHOT. The example works in version 0.9.7, but when I disable transaction I got the similar problem in this version too.\n\nEnvironment:\n- Linux 3.7.10-1.24-desktop # 1 SMP PREEMPT Wed Oct 2 11:15:18 UTC 2013 (375b8b4) x86_64 x86_64 x86_64 GNU/Linux\n- Java(TM) SE Runtime Environment (build 1.6.0_45-b06), Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "spoonFilesChanged": 1, "MOV": 0}, "title": "AssertionError in compact() method if HashMap is used", "statsSkippedReason": "", "closed": "2014-01-29 11:32:42", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-28 18:09:27", "commitHash": "7b803345bed27933c1f0e5b493e7c70d9343419b", "commitParents": ["970b748e50b939d1bede6ee9c670cf2896911bb8"], "commitGHEventType": "referenced", "nameRev": "7b803345bed27933c1f0e5b493e7c70d9343419b tags/mapdb-0.9.9~4", "commitGitStats": [{"insertions": 47, "lines": 47, "filePath": "src/test/java/org/mapdb/Issue265Test.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue265Test"}], "spoonFilePath": "Issue265Test.java"}], "commitMessage": "Store: compaction was broken. See #265\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-01-28 18:09:27"}], "created": "2014-01-14 08:07:07"}, {"labels": ["bug"], "filteredCommits": ["4a2ba3b29e8fd2da2e72318c94efbddebc7ac01a"], "url": "https://github.com/jankotek/mapdb/issues/264", "gitStatsSummary": {"insertions": 25, "gitFilesChange": 2, "lines": 32, "deletions": 7}, "numCommits": 1, "commits": {"4a2ba3b29e8fd2da2e72318c94efbddebc7ac01a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 16.00027777777778, "user": "jrumbinas", "changesInPackagesSPOON": ["org.mapdb.StoreDirect", "org.mapdb.StoreWAL"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "``` java\njava.lang.NullPointerException\n    at org.mapdb.StoreDirect.close(StoreDirect.java:685)\n    at org.mapdb.StoreDirect.<init>(StoreDirect.java:217)\n    at org.mapdb.DBMaker.extendStoreDirect(DBMaker.java:847)\n    at org.mapdb.DBMaker.makeEngine(DBMaker.java:639)\n    at org.mapdb.DBMaker.make(DBMaker.java:599)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 13, "DEL": 2, "INS": 5, "spoonFilesChanged": 2, "MOV": 6}, "title": "NPE instead of IOError if exception occurs while volumes are not properly initialized", "statsSkippedReason": "", "closed": "2014-01-29 11:32:37", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-28 18:17:38", "commitHash": "4a2ba3b29e8fd2da2e72318c94efbddebc7ac01a", "commitParents": ["7b803345bed27933c1f0e5b493e7c70d9343419b"], "commitGHEventType": "referenced", "nameRev": "4a2ba3b29e8fd2da2e72318c94efbddebc7ac01a tags/mapdb-0.9.9~3", "commitGitStats": [{"insertions": 9, "lines": 13, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 4}, {"insertions": 16, "lines": 19, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 1, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 9, "DEL": 1, "INS": 2, "MOV": 6, "spoonMethodName": "org.mapdb.StoreWAL"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Store: rework file release in case of an error while opening. See #264\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-01-28 18:17:38"}], "created": "2014-01-13 08:51:05"}, {"labels": ["bug"], "filteredCommits": ["870f82b8263c8e0dc8dac90e4e815e53777e5092"], "url": "https://github.com/jankotek/mapdb/issues/262", "gitStatsSummary": {"insertions": 2, "gitFilesChange": 1, "lines": 3, "deletions": 1}, "numCommits": 1, "commits": {"870f82b8263c8e0dc8dac90e4e815e53777e5092": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 17.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.TxEngine.Tx.commit()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "SerializerPojo will always modify class info, So if there are two concurrent transaction, second will always fail, even if no data were modified.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "TxMaker concurrent transaction always fails with conflict", "statsSkippedReason": "", "closed": "2014-01-29 11:33:00", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-11 06:51:05", "commitHash": "870f82b8263c8e0dc8dac90e4e815e53777e5092", "commitParents": ["519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456"], "commitGHEventType": "referenced", "nameRev": "870f82b8263c8e0dc8dac90e4e815e53777e5092 tags/mapdb-0.9.9~12", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/TxEngine.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.TxEngine.Tx.commit()"}], "spoonFilePath": "TxEngine.java"}], "commitMessage": "TxEngine: concurrent transactions always failed with conflict. See #262\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-01-11 06:51:05"}], "created": "2014-01-11 13:50:20"}, {"labels": ["bug"], "filteredCommits": ["e517b3225f6074fca82d61e449c98a1ade38a627", "dd39d3c56c2c53e38e85c38e4381a20f7488bc93"], "url": "https://github.com/jankotek/mapdb/issues/261", "gitStatsSummary": {"insertions": 9, "gitFilesChange": 1, "lines": 17, "deletions": 8}, "numCommits": 1, "commits": {"dd39d3c56c2c53e38e85c38e4381a20f7488bc93": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "e517b3225f6074fca82d61e449c98a1ade38a627": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 39.000277777777775, "user": "jrumbinas", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.commit()", "org.mapdb.StoreDirect.close()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Here's a little background. I have a DB with 5m records (15GB).\nThen 53k records are inserted. After insertion I try to reopen DB in read-only mode (on the same thread) and this exception is thrown.\nI can repeat this every time I do massive insert. \nTested on master (519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456)\nUpdate: committing and compacting after insert (before re-open) works perfectly however this doesn't fix the situation\n\n``` java\nDBMaker dbmaker = DBMaker\n        .newFileDB(path.toFile())\n        .closeOnJvmShutdown();\n        .transactionDisable();\n        .cacheSize(32768)\n        .mmapFileEnablePartial()\n        .cacheLRUEnable()\n        .fullChunkAllocationEnable();\n\ndb.createTreeMap(MAIN_TREE_MAP)\n            .counterEnable()\n            .valuesOutsideNodesEnable()\n            .makeOrGet();\n\nException in thread \"main\" java.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:532)\n    at java.nio.HeapByteBuffer.get(HeapByteBuffer.java:139)\n    at org.mapdb.DataInput2.readUnsignedByte(DataInput2.java:74)\n    at org.mapdb.DataInput2.unpackInt(DataInput2.java:142)\n    at org.mapdb.SerializerBase.deserializeString(SerializerBase.java:802)\n    at org.mapdb.DataInput2.readUTF(DataInput2.java:131)\n    at org.mapdb.SerializerPojo$1.deserialize(SerializerPojo.java:74)\n    at org.mapdb.SerializerPojo$1.deserialize(SerializerPojo.java:39)\n    at org.mapdb.Store.deserialize(Store.java:270)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:456)\n    at org.mapdb.StoreDirect.get(StoreDirect.java:409)\n    at org.mapdb.Store.getSerializerPojo(Store.java:86)\n    at org.mapdb.EngineWrapper.getSerializerPojo(EngineWrapper.java:123)\n    at org.mapdb.EngineWrapper.getSerializerPojo(EngineWrapper.java:123)\n    at org.mapdb.DB.<init>(DB.java:82)\n    at org.mapdb.DBMaker.make(DBMaker.java:599)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 2}, "title": "Failed to deserialize SerializerPojo", "statsSkippedReason": "", "closed": "2014-02-18 14:51:25", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-13 18:55:44", "commitHash": "dd39d3c56c2c53e38e85c38e4381a20f7488bc93", "commitParents": ["f240461445c439b2258960fb4a0e05fe89e12618"], "commitGHEventType": "referenced", "nameRev": "dd39d3c56c2c53e38e85c38e4381a20f7488bc93 tags/mapdb-0.9.9~9", "commitGitStats": [{"insertions": 53, "lines": 53, "filePath": "src/test/java/org/mapdb/Issues261Test.java", "deletions": 0}, {"insertions": 3, "lines": 4, "filePath": "src/test/java/org/mapdb/UtilsTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issues261Test"}], "spoonFilePath": "Issues261Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.UtilsTest.randomInt()"}], "spoonFilePath": "UtilsTest.java"}], "commitMessage": "#261 add test case\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-01-13 18:55:44"}, {"commitUser": "jankotek", "commitDateTime": "2014-02-14 17:31:30", "commitHash": "e517b3225f6074fca82d61e449c98a1ade38a627", "commitParents": ["48de52ac35aba8572843b54cc69a25fdddc0788a"], "commitGHEventType": "referenced", "nameRev": "e517b3225f6074fca82d61e449c98a1ade38a627 tags/mapdb-0.9.10~15", "commitGitStats": [{"insertions": 9, "lines": 17, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 8}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirect.commit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirect.close()"}], "spoonFilePath": "StoreDirect.java"}], "commitMessage": "StoreDirect: SerializerPojo could get  corrupted on close. See #261\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2014-02-14 17:31:30"}], "created": "2014-01-10 12:35:55"}, {"labels": ["bug"], "filteredCommits": ["5c363e4e996421959f3b33ad3f9554db06ca34db"], "url": "https://github.com/jankotek/mapdb/issues/259", "gitStatsSummary": {"insertions": 76, "gitFilesChange": 3, "lines": 143, "deletions": 67}, "numCommits": 1, "commits": {"5c363e4e996421959f3b33ad3f9554db06ca34db": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 29.00027777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.SerializerBase.readBooleanArray(java.io.DataInput)", "org.mapdb.BTreeMap.get(java.lang.Object)", "org.mapdb.SerializerBase.readBooleanArray(int,java.io.DataInput)", "org.mapdb.SerializerBase.deserialize2(int,java.io.DataInput)", "org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)", "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)", "org.mapdb.Pump.buildTreeMap(java.util.Iterator,org.mapdb.Engine,Fun.Function1,Fun.Function1,boolean,int,boolean,long,org.mapdb.BTreeKeySerializer,org.mapdb.Serializer,java.util.Comparator)", "org.mapdb.BTreeMap.lastEntryRecur(org.mapdb.BTreeMap$BNode)", "org.mapdb.BTreeMap.NodeSerializer.deserialize(java.io.DataInput,int)", "org.mapdb.BTreeMap.firstEntry()", "org.mapdb.BTreeMap.findSmallerRecur(org.mapdb.BTreeMap$BNode,java.lang.Object,boolean)", "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.findLarger(java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "There was serious issue reported in mailing list:\nhttps://groups.google.com/forum/#!topic/mapdb/J0_mqc9JfyA\n\nAfter number of entries are deleted from TreeMap the getFirstKey throws NPE. \n\nOn TreeSet it is really bad, since TreeSet does not seem to detect deleted values at all. \n\nThis has been fixed already in trunk. Fix required change in TreeSet format. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 13, "UPD": 2, "TOT": 83, "DEL": 29, "INS": 11, "spoonFilesChanged": 3, "MOV": 41}, "title": "BTreeMap & TreeSet returns incorrect values after entries were deleted. ", "statsSkippedReason": "", "closed": "2014-01-29 11:33:08", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-12-31 10:13:35", "commitHash": "5c363e4e996421959f3b33ad3f9554db06ca34db", "commitParents": ["09b51b56dd243db0522fa436f81c268ccef58bb6"], "commitGHEventType": "referenced", "nameRev": "5c363e4e996421959f3b33ad3f9554db06ca34db tags/mapdb-0.9.9~14", "commitGitStats": [{"insertions": 18, "lines": 41, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 23}, {"insertions": 131, "lines": 135, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 4}, {"insertions": 2, "lines": 5, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 3}, {"insertions": 56, "lines": 97, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 41}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerBase.readBooleanArray(java.io.DataInput)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserialize2(int,java.io.DataInput)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.readBooleanArray(int,java.io.DataInput)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.get(java.lang.Object)"}, {"UPD": 1, "TOT": 15, "DEL": 2, "INS": 5, "MOV": 7, "spoonMethodName": "org.mapdb.BTreeMap.lastEntryRecur(org.mapdb.BTreeMap$BNode)"}, {"UPD": 0, "TOT": 5, "DEL": 1, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.BTreeMap.NodeSerializer.deserialize(java.io.DataInput,int)"}, {"UPD": 0, "TOT": 7, "DEL": 3, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.findSmallerRecur(org.mapdb.BTreeMap$BNode,java.lang.Object,boolean)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.firstEntry()"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.findLarger(java.lang.Object,boolean)"}, {"UPD": 1, "TOT": 6, "DEL": 1, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)"}, {"UPD": 0, "TOT": 16, "DEL": 9, "INS": 0, "MOV": 7, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 22, "DEL": 8, "INS": 2, "MOV": 12, "spoonMethodName": "org.mapdb.Pump.buildTreeMap(java.util.Iterator,org.mapdb.Engine,Fun.Function1,Fun.Function1,boolean,int,boolean,long,org.mapdb.BTreeKeySerializer,org.mapdb.Serializer,java.util.Comparator)"}], "spoonFilePath": "Pump.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.WriteDBInt_lastKey()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.WriteDBInt_lastKey_middle()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.WriteDBInt_lastKey_set_middle()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.WriteDBInt_lastKey_set()"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "BTreeMap: fix handling of deleted values. This changes storage format for TreeSet. See #259\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-12-31 10:13:35"}], "created": "2013-12-31 07:59:44"}, {"labels": ["bug"], "filteredCommits": ["519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456"], "url": "https://github.com/jankotek/mapdb/issues/258", "gitStatsSummary": {"insertions": 155, "gitFilesChange": 2, "lines": 267, "deletions": 112}, "numCommits": 1, "commits": {"519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 31.00027777777778, "user": "ghost", "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If I run the test case below two times, the second run fails with the exception pasted.\n\nRemoving \"asyncWriteEnable\" seems to \"fix\" the problem.\n\n```\nException in thread \"main\" java.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:290)\n    at org.mapdb.AsyncWriteEngine.update(AsyncWriteEngine.java:389)\n    at org.mapdb.Caches$LRU.compareAndSwap(Caches.java:114)\n    at org.mapdb.Atomic$Long.compareAndSet(Atomic.java:338)\n    at org.mapdb.Queues$SimpleQueue.poll(Queues.java:108)\n    at org.mapdb.Queues$SimpleQueue.clear(Queues.java:161)\n        at TestMapDB.java:311\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 205\n    at org.mapdb.StoreWAL.longStackPut(StoreWAL.java:984)\n    at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:992)\n    at org.mapdb.StoreWAL.delete(StoreWAL.java:521)\n    at org.mapdb.EngineWrapper.delete(EngineWrapper.java:74)\n    at org.mapdb.AsyncWriteEngine.access$001(AsyncWriteEngine.java:72)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:203)\n    at org.mapdb.AsyncWriteEngine$WriterRunnable.run(AsyncWriteEngine.java:156)\n    at java.lang.Thread.run(Unknown Source)\nException in thread \"MapDB shutdown\" java.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:290)\n    at org.mapdb.AsyncWriteEngine.close(AsyncWriteEngine.java:443)\n    at org.mapdb.EngineWrapper.close(EngineWrapper.java:81)\n    at org.mapdb.Caches$LRU.close(Caches.java:130)\n    at org.mapdb.DBMaker$1.run(DBMaker.java:724)\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 205\n    at org.mapdb.StoreWAL.longStackPut(StoreWAL.java:984)\n    at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:992)\n    at org.mapdb.StoreWAL.delete(StoreWAL.java:521)\n    at org.mapdb.EngineWrapper.delete(EngineWrapper.java:74)\n    at org.mapdb.AsyncWriteEngine.access$001(AsyncWriteEngine.java:72)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:203)\n    at org.mapdb.AsyncWriteEngine$WriterRunnable.run(AsyncWriteEngine.java:156)\n    at java.lang.Thread.run(Unknown Source)\n\n```\n\nTest case:\n\n```\n\nFile tmpDir = new File(System.getProperty(\"user.home\")+\"/.demo\");\ntmpDir.mkdir();\nFile tmp = new File(tmpDir.getAbsolutePath()+\"/demo_undolog.txt\");\n\nDB db = DBMaker.newFileDB(tmp)\n        .closeOnJvmShutdown()\n        .compressionEnable()\n        .cacheLRUEnable()\n        .asyncWriteEnable()                \n        .make();        \n\nBlockingQueue<Object> map = db.getStack(\"undolog\");\n\n// Show first 100, if any\nfor(int j=0; !map.isEmpty() && j < 100; j++)\n{\n    Object obj = map.poll();\n    System.out.println(obj.toString());\n}\n\n// Write out 100K elements\nmap.clear();\n\nfor (int i=0; i < 100_000; i++)\n{\n    CmdPut cmd = new CmdPut(null, 199+i, (char)('a'+(i%26)));\n    map.add(cmd);\n}\n\ndb.commit();\ndb.close();\n```\n\nIf I remove  closeOnJvmShutdown, I get a slightly different, but similar exception.\n\nJDK 7, Win8 64 bit, built with top of git tree as of now.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {}, "title": "Writer thread failed exception with stack", "statsSkippedReason": "", "closed": "2014-01-29 11:33:04", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2014-01-04 13:55:11", "commitHash": "519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456", "commitParents": ["5c363e4e996421959f3b33ad3f9554db06ca34db"], "commitGHEventType": "referenced", "nameRev": "519f779a3ae6f0ae5f6c8a4feb4d26602f1b0456 tags/mapdb-0.9.9~13", "commitGitStats": [{"insertions": 154, "lines": 266, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 112}, {"insertions": 2, "lines": 4, "filePath": "src/test/java/org/mapdb/Issue132Test.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/Issue112Test.java", "deletions": 1}, {"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 0}, {"insertions": 49, "lines": 49, "filePath": "src/test/java/org/mapdb/Issue258Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [], "commitMessage": "StoreWAL: rewrite LongStack to solve misaligned page sizes. Changes format of Write-Ahead-Log. See #258\n", "spoonStatsSkippedReason": "tooManyChanges", "authoredDateTime": "2014-01-04 13:55:11"}], "created": "2013-12-28 22:36:49"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/252", "title": "Windows and Java6 locking problem", "closed": "2014-03-24 12:44:54", "commitsDetails": [], "commits": {}, "ttf": 99.00027777777778, "created": "2013-12-15 10:35:47", "user": "jankotek", "body": "I've been having some trouble with BTrees on java6 and was wondering if anyone else was having similar issues.  Looking through the mailing lists, it looks like java 7 is preferred, but I don't see where that's marked as a hard requirement.  It looks like the bug has been fixed in java 7: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4938372.  The problem also seems to go away if I turn off transactions.  Posting to the mailing lists first in case this is really just user error or an incompatibility rather than a bug in mapDB.\n\nOracle jdk 1.6.0_31 running on Win7.\n\nTest code:\n\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport org.mapdb.BTreeMap;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\npublic class Test\n{\n\n```\npublic static void main(String[] args) throws IOException {\n    URLConnection conn = new URL(\"http://www.mapdb.org\").openConnection();\n    DataInputStream is = new DataInputStream(conn.getInputStream());\n    int avail = is.available();\n    byte[] bytes = new byte[avail];\n    String data = null;\n    try {\n        is.readFully(bytes);\n        System.out.println(bytes.length);\n        data = new String(bytes);\n    }\n    finally {\n        is.close();\n    }\n    int tCnt = 0;\n\n    DB db = DBMaker.newFileDB(new File(\"C:\\\\data\\\\play\\\\test\")).make();\n    BTreeMap<Object, Object> map = db.getTreeMap(\"foo\");\n    for (int i = 0; i < 3000000; i++) {\n        map.put(tCnt, data);\n        if (tCnt % 10000 == 0) {\n            System.out.println(tCnt);\n            db.commit();\n        }\n        tCnt++;\n    }\n    db.commit();\n    db.close();\n\n}\n```\n\n}\n\nAnd the error I see:\n\njava.lang.Error: Cleaner terminated abnormally\n    at sun.misc.Cleaner$1.run(Cleaner.java:130)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at sun.misc.Cleaner.clean(Cleaner.java:127)\n    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:124)\nCaused by: java.io.IOException: The process cannot access the file because another process has locked a portion of the file\n    at sun.nio.ch.FileChannelImpl.unmap0(Native Method)\n    at sun.nio.ch.FileChannelImpl.access$100(FileChannelImpl.java:32)\n    at sun.nio.ch.FileChannelImpl$Unmapper.run(FileChannelImpl.java:667)\n    at sun.misc.Cleaner.clean(Cleaner.java:125)\n    ... 1 more\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/246", "title": "Unexpected EOFException during Pump.copy", "closed": "2013-12-25 09:16:34", "commitsDetails": [], "commits": {}, "ttf": 20.00027777777778, "created": "2013-12-04 10:28:25", "user": "tbsalling", "body": "When I try to copy an in-memory database (both off-heap and on-heap fails) - I get this stack trace:\n\n11:22:52,194 ERROR [main] [StatBuilderApp] Uncaught exception in thread java.lang.Thread: java.io.EOFException\njava.io.IOError: java.io.EOFException\n    at org.mapdb.Volume$FileChannelVol.getLong(Volume.java:804)\n    at org.mapdb.StoreDirect.update2(StoreDirect.java:455)\n    at org.mapdb.StoreDirect.update(StoreDirect.java:447)\n    at org.mapdb.StoreDirect.updateRaw(StoreDirect.java:1062)\n    at org.mapdb.Pump.copy(Pump.java:27)\n    at org.mapdb.Pump.copy(Pump.java:15)\n    at dk.xxx.stat.db.mapdb.DataRepositoryMapDB.close(DataRepositoryMapDB.java:147)\n        ...\nCaused by: java.io.EOFException\n    at org.mapdb.Volume$FileChannelVol.readFully(Volume.java:774)\n    at org.mapdb.Volume$FileChannelVol.getLong(Volume.java:801)\n\nI am not able to determine the cause. What does imply? Is it a bug in MapDB?\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/243", "title": "NullPointerException in getNameForObject when multiple threads commit to a fileDB", "closed": "2013-12-24 10:54:23", "commitsDetails": [], "commits": {}, "ttf": 27.00027777777778, "created": "2013-11-26 22:20:07", "user": "tdsdevelopment", "body": "My application uses MapDB as a persistent cache. When multiple threads are used, the following exception is thrown very often, under heavy load. Adding Thread.sleep(x) does not help to fix the bug.\n\n```\njava.lang.NullPointerException\n    at org.mapdb.DB.getNameForObject(DB.java:96)\n    at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:417)\n    at org.mapdb.SerializerBase.serialize2(SerializerBase.java:464)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:148)\n    at org.mapdb.SerializerBase.serialize(SerializerBase.java:92)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:376)\n    at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:275)\n    at org.mapdb.Store.serialize(Store.java:121)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:372)\n    at org.mapdb.Caches$HashTable.update(Caches.java:246)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:66)\n    at org.mapdb.TxEngine.superUpdate(TxEngine.java:286)\n    at org.mapdb.TxEngine$Tx.commit(TxEngine.java:517)\n    at org.mapdb.DB.commit(DB.java:1371)\n    at org.mapdb.TxMaker.execute(TxMaker.java:47)\n    at hu.tds.mapdb.MapDbImageCache.put(MapDbImageCache.java:187)\n    at hu.tds.mapdb.ExceptionTest.doTestMmcCache(ExceptionTest.java:103)\n    at hu.tds.mapdb.ExceptionTest$1.run(ExceptionTest.java:53)\n```\n\nwhere MapDbImageCache is a simple wrapper for 10 FileDB instances, to do an additional hash step to reduce MapDB file size.\n\nMapdbImageCache.put uses TxBlock and transactions:\n\n```\n    public static void put(final String key, final SerializableBufferedImage value) {\n        if (cacheSeconds == -1) {\n            return;\n        }\n\n        int i = Math.abs(key.hashCode() % 10);\n        if (DEBUG) {\n            System.out.println(\"PUT to [\" + i + \"]\" + key);\n        }\n\n        if (key == null) System.out.println(\"KEY IS NULL\");\n        if (value == null) System.out.println(\"VALUE IS NULL:\" +  key);\n\n        db[i].execute(new TxBlock() {\n            @Override\n            public void tx(DB db) throws TxRollbackException {\n                Map<String, SerializableBufferedImage> dbMap = db.get(\"cache\");\n                dbMap.put(key, value);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException ex) {\n                    ex.printStackTrace();\n                }\n            }\n        });\n\n    }\n```\n\nand db[i] is a FileDB actually:\n\n```\n                db[i] = DBMaker.newFileDB(dbFile)\n                        .closeOnJvmShutdown()\n                        .sizeLimit(1)\n                        //.asyncWriteDisable()\n                        .makeTxMaker();\n                DB tx1 = db[i].makeTx();\n                dbMap[i] = tx1.get(\"cache\");\n                if (dbMap[i] == null) {\n                    if (DEBUG) {\n                        System.out.println(\"CREATING db \" + i);\n                    }\n                    dbMap[i] = tx1.createTreeMap(\"cache\").makeStringMap();\n                }\n                dbMap[i].put(\"test\", new SerializableBufferedImage(\"test\", null));\n                tx1.commit();\n                tx1.close();\n```\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/242", "title": "IndexOutOfBoundsException thrown when writing large data set to temp file DB", "closed": "2013-12-10 11:15:06", "commitsDetails": [], "commits": {}, "ttf": 13.000277777777777, "created": "2013-11-26 17:11:12", "user": "jrumbinas", "body": "Exception occurs only when DB is created like this: DBMaker.newTempFileDB()\nThis is not the case for newFileDB or newAppendFileDB\n\n``` java\nDBMaker.newFileDB(new File(\"/tmp/tmpdb\"))\n            .transactionDisable()\n            .deleteFilesAfterClose()\n            .closeOnJvmShutdown()\n            .make();\n```\n\nStack trace:\n\n```\nCaused by: java.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:538)\n    at java.nio.DirectByteBuffer.getLong(DirectByteBuffer.java:766)\n    at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:352)\n    at org.mapdb.StoreWAL.getLongStackPage(StoreWAL.java:706)\n    at org.mapdb.StoreWAL.longStackPut(StoreWAL.java:803)\n    at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:983)\n    at org.mapdb.StoreWAL.longStackTake(StoreWAL.java:760)\n    at org.mapdb.StoreDirect.freePhysTake(StoreDirect.java:1002)\n    at org.mapdb.StoreDirect.physAllocate(StoreDirect.java:608)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:387)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:66)\n    at org.mapdb.AsyncWriteEngine.access$101(AsyncWriteEngine.java:72)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:206)\n    at org.mapdb.AsyncWriteEngine$WriterRunnable.run(AsyncWriteEngine.java:156)\n    at java.lang.Thread.run(Thread.java:724)\n```\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/240", "title": "Adding entries and lookup become slower as input data files grow in size", "closed": "2015-08-15 08:25:13", "commitsDetails": [], "commits": {}, "ttf": 627.0002777777778, "created": "2013-11-26 06:23:25", "user": "wcarus", "body": "Open TreeSet using any combination (or none) of transactionEnable and compressionEnable. Master input file contains approx. 725K key-value entries. Randomly sampled 1, 5, 10, 15, 16, 17, 18, 19, and 20% of entries of master file. Performance storing and looking up entries increases roughly linearly until about 19% of master file (approx. 138K entries). Lookup then slows down dramatically (it is about 30% of time to store for smaller sized input files; and then becomes almost 200% of time to store at around 19K entries).\n"}, {"labels": ["bug"], "filteredCommits": ["f88f591252326fe7d402c5fd1db9f9ecdcfba3f5", "39fcb241cc1890e7bbc2031cc23bc8b8ac84d6e3"], "url": "https://github.com/jankotek/mapdb/issues/237", "gitStatsSummary": {"insertions": 16, "gitFilesChange": 2, "lines": 22, "deletions": 6}, "numCommits": 2, "commits": {"39fcb241cc1890e7bbc2031cc23bc8b8ac84d6e3": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "f88f591252326fe7d402c5fd1db9f9ecdcfba3f5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 3.000277777777778, "user": "kminder", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.delete(long,org.mapdb.Serializer)", "org.mapdb.StoreAppend", "org.mapdb.StoreWAL.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "If you reopen a database with asyncWriteDisabled() and then use DB.getQueue(), and  you get the error below.\njava.lang.AssertionError\n    at org.mapdb.StoreDirect.freePhysPut(StoreDirect.java:980)\n    at org.mapdb.StoreWAL.compareAndSwap(StoreWAL.java:437)\n    at org.mapdb.Caches$HashTable.compareAndSwap(Caches.java:273)\n    at org.mapdb.Queues$Queue.add(Queues.java:354)\n\nHere is a test that reproduces the issue.  \nThe test testReopenAsync() shows it working.\nThe test testReopenSync() shows it failing.\nBTW I'm on 0.9.8-SNAPSHOT\n\npackage test;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mapdb.DB;\nimport org.mapdb.DBMaker;\n\nimport java.io.File;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class MapDbReopenTest {\n\n  File file = new File( \"test-database.mapdb\" );\n\n  @Before\n  public void before() {\n    file.delete();\n  }\n\n  @After\n  public void after() {\n    file.delete();\n  }\n\n  @Test\n  public void testReopenAsync() throws InterruptedException {\n    DB database = DBMaker.newFileDB( file ).make();\n    testQueue( database );\n\n```\ndatabase = DBMaker.newFileDB( file ).make();\ntestQueue( database );\n```\n\n  }\n\n  @Test\n  public void testReopenSync() throws InterruptedException {\n    File file = new File( \"test-database.mapdb\" );\n    file.delete();\n\n```\nDB database = DBMaker.newFileDB( file ).asyncWriteDisable().make();\ntestQueue( database );\n\ndatabase = DBMaker.newFileDB( file ).asyncWriteDisable().make();\ntestQueue( database );\n```\n\n  }\n\n  private void testQueue( DB database ) throws InterruptedException {\n    BlockingQueue<String> queue = database.getQueue( \"test-queue\" );\n    queue.add( \"test-value\" );\n    database.commit();\n    assertThat( queue.take(), is( \"test-value\" ) );\n    database.commit();\n    database.close();\n  }\n\n}\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 2, "TOT": 11, "DEL": 0, "INS": 7, "spoonFilesChanged": 2, "MOV": 2}, "title": "DB.getQueue() fails when DB with DBMaker.asyncWriteDisable() reopened", "statsSkippedReason": "", "closed": "2013-11-17 08:55:28", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-11-17 10:55:21", "commitHash": "39fcb241cc1890e7bbc2031cc23bc8b8ac84d6e3", "commitParents": ["d811c6ba794e958541b170027735b30c9150972d"], "commitGHEventType": "closed", "nameRev": "39fcb241cc1890e7bbc2031cc23bc8b8ac84d6e3 tags/mapdb-0.9.8~53", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 2}, {"insertions": 46, "lines": 46, "filePath": "src/test/java/org/mapdb/Issue237Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.delete(long,org.mapdb.Serializer)"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue237Test"}], "spoonFilePath": "Issue237Test.java"}], "commitMessage": "StoreWAL: Fix #237, assertion fails with archived records\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-11-17 10:55:21"}, {"commitUser": "jankotek", "commitDateTime": "2013-11-17 11:09:27", "commitHash": "f88f591252326fe7d402c5fd1db9f9ecdcfba3f5", "commitParents": ["39fcb241cc1890e7bbc2031cc23bc8b8ac84d6e3"], "commitGHEventType": "referenced", "nameRev": "f88f591252326fe7d402c5fd1db9f9ecdcfba3f5 tags/mapdb-0.9.8~52", "commitGitStats": [{"insertions": 14, "lines": 18, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 7, "DEL": 0, "INS": 7, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend"}], "spoonFilePath": "StoreAppend.java"}], "commitMessage": "StoreAppend: Fix #237, StoreAppend dont close volume on corrupted file\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-11-17 11:09:27"}], "created": "2013-11-13 14:12:51"}, {"labels": ["bug"], "filteredCommits": ["06b099139f315ca2b996d674ddbbce9ac8640aad", "e6e4dba73682396e7d7247d84d151f4a8efd7eed"], "url": "https://github.com/jankotek/mapdb/issues/232", "gitStatsSummary": {"insertions": 183, "gitFilesChange": 4, "lines": 287, "deletions": 104}, "numCommits": 1, "commits": {"06b099139f315ca2b996d674ddbbce9ac8640aad": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "e6e4dba73682396e7d7247d84d151f4a8efd7eed": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 2.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.SerializerBase.deserialize3(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList,int)", "org.mapdb.SerializerBase.deserialize2(int,java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)", "org.mapdb.Fun.ArrayComparator", "org.mapdb.BTreeKeySerializer.Tuple2KeySerializer", "org.mapdb.SerializerBase.deserializeMapDB(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)", "org.mapdb.BTreeKeySerializer.Tuple3KeySerializer", "org.mapdb.BTreeKeySerializer.BasicKeySerializer", "org.mapdb.Fun.Tuple4", "org.mapdb.Fun.Tuple3Comparator", "org.mapdb.SerializerBase.serialize2(java.io.DataOutput,java.lang.Object,org.mapdb.SerializerBase$FastArrayList,java.lang.Class)", "org.mapdb.Atomic.Var", "org.mapdb.Fun.Tuple3", "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)", "org.mapdb.Fun.Tuple2Comparator", "org.mapdb.BTreeKeySerializer.Tuple4KeySerializer", "org.mapdb.Fun.Tuple4Comparator", "org.mapdb.Fun.Tuple2"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "```\n        File file=Utils.tempDbFile();\n        DB db = DBMaker.newFileDB(file)\n                .closeOnJvmShutdown()\n                .cacheDisable()\n                .transactionDisable()\n                .asyncWriteDisable()\n//                .compressionEnable()\n                .make();\n        Map m = db.getHashMap(\"data\");\n        for (int img=0;img<10200;img++){\n            for (int f=0;f<1000;f++){\n                m.put(Fun.t2(img,f),new long[64]);\n            }\n        }\n```\n\ngives\n\n```\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1\n    at org.mapdb.SerializerBase.deserialize3(SerializerBase.java:1105)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:1088)\n    at org.mapdb.SerializerBase.deserialize2(SerializerBase.java:1269)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:1073)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:823)\n    at org.mapdb.HTreeMap$1.deserialize(HTreeMap.java:117)\n    at org.mapdb.HTreeMap$1.deserialize(HTreeMap.java:103)\n    at org.mapdb.Store.deserialize(Store.java:263)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:431)\n    at org.mapdb.StoreDirect.get(StoreDirect.java:384)\n    at org.mapdb.HTreeMap.putInner(HTreeMap.java:487)\n    at org.mapdb.HTreeMap.put(HTreeMap.java:449)\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 17, "UPD": 8, "TOT": 93, "DEL": 12, "INS": 36, "spoonFilesChanged": 4, "MOV": 37}, "title": "Serialization: object stack handling is broken", "statsSkippedReason": "", "closed": "2013-11-05 17:50:59", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-11-05 19:50:54", "commitHash": "06b099139f315ca2b996d674ddbbce9ac8640aad", "commitParents": ["e6e4dba73682396e7d7247d84d151f4a8efd7eed"], "commitGHEventType": "closed", "nameRev": "06b099139f315ca2b996d674ddbbce9ac8640aad tags/mapdb-0.9.8~71", "commitGitStats": [{"insertions": 55, "lines": 55, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.object_stack_array()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.object_stack_list()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.object_stack_map()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.object_stack_set()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest"}], "spoonFilePath": "SerializerBaseTest.java"}], "commitMessage": "SerializerBase: add more tests for object stack, fix #232\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-11-05 19:50:54"}, {"commitUser": "jankotek", "commitDateTime": "2013-11-05 13:16:33", "commitHash": "e6e4dba73682396e7d7247d84d151f4a8efd7eed", "commitParents": ["461ee2dfb2a75977881f1f67fd1f5df1cc8097aa"], "commitGHEventType": "referenced", "nameRev": "e6e4dba73682396e7d7247d84d151f4a8efd7eed tags/mapdb-0.9.8~72", "commitGitStats": [{"insertions": 60, "lines": 60, "filePath": "src/main/java/org/mapdb/Fun.java", "deletions": 0}, {"insertions": 39, "lines": 40, "filePath": "src/main/java/org/mapdb/BTreeKeySerializer.java", "deletions": 1}, {"insertions": 65, "lines": 120, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 55}, {"insertions": 73, "lines": 176, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 103}, {"insertions": 11, "lines": 11, "filePath": "src/main/java/org/mapdb/Atomic.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.Tuple4KeySerializer"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.BasicKeySerializer"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.Tuple2KeySerializer"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeKeySerializer.Tuple3KeySerializer"}], "spoonFilePath": "BTreeKeySerializer.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 8, "DEL": 4, "INS": 0, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerBase.deserialize2(int,java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}, {"UPD": 0, "TOT": 9, "DEL": 1, "INS": 4, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerBase.deserialize3(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList,int)"}, {"UPD": 0, "TOT": 53, "DEL": 6, "INS": 18, "MOV": 29, "spoonMethodName": "org.mapdb.SerializerBase.serialize2(java.io.DataOutput,java.lang.Object,org.mapdb.SerializerBase$FastArrayList,java.lang.Class)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}, {"UPD": 8, "TOT": 9, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserializeMapDB(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Atomic.Var"}], "spoonFilePath": "Atomic.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_singleton_reverse()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBoolean1()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testIntSize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_tuple_key_serializer()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testArrayList()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testTreeSet()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_All_Hasher_Fields_Serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testNoArgumentConstructorInJavaSerialization()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_All_Fun_Fields_Serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testHeaderUniqueMapDB()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_All_Serializer_Fields_Serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testByteArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testDouble()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testFloatArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_multi_dim_large_array()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testNegativeShortArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testChar()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testString()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_multi_dim_array2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testShort()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_issue_38()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testArray()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLinkedHashMap()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_multi_dim_array()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testCharArray()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBigDecimal()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_strings_var_sizes()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testHashSet()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBigInteger()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testHeaderUnique()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_static_objects()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testUUID()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_atomic_ref_serializable()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testInt()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBigString()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testTreeMap()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testUnicodeString()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLinkedHashSet()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_Named()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testProperties()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBooleanArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testDoubleArray()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testDate()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testHashMap()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_extended_chars()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.object_stack_issue232_n2()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testNegativeIntArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLongSize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testNegativeLongsArray()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLong()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testFloat()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testClass()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testBooleanArray2()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLinkedList()"}, {"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerBaseTest.testPackedLongCollection()"}], "spoonFilePath": "SerializerBaseTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple4"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple2"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.ArrayComparator"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple3"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple3Comparator"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple4Comparator"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Fun.Tuple2Comparator"}], "spoonFilePath": "Fun.java"}], "commitMessage": "SerializerBase: partial fix for object stack handling. Related to #232. Need to add more unit tests\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-11-05 13:16:33"}], "created": "2013-11-02 21:25:29"}, {"labels": ["bug"], "filteredCommits": ["a4f891de80046f93d14a89a8f23467081a31a5b2"], "url": "https://github.com/jankotek/mapdb/issues/229", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 2, "deletions": 1}, "numCommits": 1, "commits": {"a4f891de80046f93d14a89a8f23467081a31a5b2": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 13.000277777777777, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.Store.serialize(java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "> Hello!\n> \n> I am using the following test to see the effects of compression on a \n> Map<Integer, String>:\n> \n> package test;\n> \n> import java.io.File;\n> import java.util.HashMap;\n> import java.util.Map;\n> import java.util.Random;\n> \n> import org.junit.BeforeClass;\n> import org.junit.Test;\n> import org.mapdb.DB;\n> import org.mapdb.DBMaker;\n> \n> public class CompressedDBTest {\n> private static Map<Integer, String> testMap;\n> private static int totalSize;\n> \n> @BeforeClass\n> public static void setUp() {\n> testMap = createMap();\n> System.out.println(\"\\ncompressed\\tfile size\\tmap strings size\");\n> }\n> \n> public static DB createFileStore(File path, boolean compressed) {\n> if (compressed) {\n> return \n> DBMaker.newFileDB(path).asyncWriteDisable().compressionEnable().make();\n> } else {\n> return DBMaker.newFileDB(path).make();\n> }\n> }\n> \n> @Test\n> public void normalTreeMap() {\n> putMapToDB(\"/tmp/normal\", testMap, false);\n> }\n> \n> @Test\n> public void compressedTreeMap() {\n> putMapToDB(\"/tmp/compressed\", testMap, true);\n> }\n> \n> private void putMapToDB(String dbPath, Map<Integer, String> map,\n> boolean compressed) {\n> File path = new File(dbPath);\n> File resultFile = new File(dbPath + \".p\");\n> DB db = createFileStore(path, compressed);\n> Map<Integer, String> dbMap = db.getTreeMap(\"treeMap\");\n> dbMap.putAll(map);\n> db.commit();\n> db.compact();\n> db.close();\n> System.out.println(compressed + \"\\t\\t\" + resultFile.length() + \"\\t\\t\"\n> - totalSize);\n>   }\n> \n> private static Map<Integer, String> createMap() {\n> Map<Integer, String> map = new HashMap<Integer, String>();\n> Random rand = new Random(98); // not that the seed matters but just to\n> // standardize the test\n> \n> // 10000 records\n> totalSize = 0;\n> for (int i = 0; i < 10000; i++) {\n> // generate strings with len > 50 and < 300\n> StringBuilder sb = new StringBuilder();\n> for (int j = 0; j < rand.nextInt(250) + 50; j++) {\n> sb.append((char) (rand.nextInt(64) + 63));\n> }\n> String string = sb.toString();\n> System.out.print(\".\");\n> map.put(i, string);\n> totalSize += string.length();\n> }\n> return map;\n> }\n> \n> }\n> \n> I get the following output:\n> compressed file size map strings size\n> true 1275008 684867\n> false 1268224 684867\n> \n> The compressed size is always slightly bigger as the normal size, and\n> for each case about twice as big as the total size of the strings\n> contained in the map...\n> \n> What do I miss here to make compression work correctly?\n> \n> Thanks a lot in advance,\n> \n> S\u00e9bastien Druon\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "spoonFilesChanged": 1, "MOV": 0}, "title": "Verify compression", "statsSkippedReason": "", "closed": "2013-11-02 21:23:16", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-11-02 23:23:11", "commitHash": "a4f891de80046f93d14a89a8f23467081a31a5b2", "commitParents": ["8f00a052851aac19ebb395e0171513f73b82a140"], "commitGHEventType": "closed", "nameRev": "a4f891de80046f93d14a89a8f23467081a31a5b2 tags/mapdb-0.9.8~76", "commitGitStats": [{"insertions": 52, "lines": 52, "filePath": "src/test/java/org/mapdb/StoreTest.java", "deletions": 0}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreTest"}], "spoonFilePath": "StoreTest.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Store.serialize(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "Store.java"}], "commitMessage": "Store: compression was not working. Fix #229\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-11-02 23:23:11"}], "created": "2013-10-20 10:12:50"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/224", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"cd33cfa8a4389884f8ec7d12d27355f102e8a289": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 4.000277777777778, "user": "vadimzv", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "Create empty file db, create several (e.g. eight) BTreeMaps, write considerable (e.g. three million) number of records in each map, close db. Then again create db from previously written file and try to initialize those maps - the initialization will likely hangs, or will take a very long (minutes) time.\n\nHere is the code to reproduce:\n\n```\nprivate static final Logger log = LoggerFactory.getLogger(TestBTreeMapInitHangs.class);\n\npublic static void main(String[] args) throws Exception\n{\n    log.info(\"Starting TestMapDB\");\n    File dbFile = new File(\"target/mapdbfiles\");\n    DB db = DBMaker.newFileDB(dbFile)\n            .transactionDisable()\n            .freeSpaceReclaimQ(5)\n            .randomAccessFileEnableKeepIndexMapped()\n            .make();\n    log.info(\"DB created\");\n\n    final int mapsNumber = 8;\n    @SuppressWarnings(\"unchecked\")\n    BTreeMap<Integer, byte[]>[] maps = new BTreeMap[mapsNumber];\n    for (int i = 0; i < mapsNumber; i++)\n    {\n        log.info(\"Start getTreeMap map\" + i);\n        maps[i] = db.getTreeMap(\"map\" + i);\n        log.info(\"Done getTreeMap map\" + i);\n    }\n\n    byte[] data = getData();\n    for (int i = 0; i < 3000000; i++)\n    {\n        for (int j = 0; j < mapsNumber; j++)\n        {\n            maps[j].put(i, data);\n        }\n\n        if (i % 100000 == 0)\n        {\n            db.commit();\n        }\n    }\n    db.close();\n}\n\nstatic byte[] getData()\n{\n    return (\"<cap>5476731380550.3881</cap><max_value>9440.61</max_value>\" +\n            \"<min_value>9393.84</min_value><moment>23.08.2013 23:50:00</moment><name>RTSSTD</name>\" +\n            \"<open_value>9393.84</open_value><prev_close_value>9393.84</prev_close_value>\" +\n            \"<replAct>0</replAct><replID>10128927106</replID><replRev>10128927106</replRev>\" +\n            \"<usd_rate>33.0287</usd_rate><value>9440.61</value><volume>214452299.31</volume><volume2>214452299.88</volume2>\").getBytes();\n}\n```\n\nRun it twice, and on the second run I get something like this output:\n\n```\n10:04:30,245 Starting TestMapDB\n10:04:30,709 DB created\n10:04:30,710 Start getTreeMap map0\n10:04:30,724 Done getTreeMap map0\n10:04:30,724 Start getTreeMap map1\n10:04:30,732 Done getTreeMap map1\n10:04:30,732 Start getTreeMap map2\n10:04:30,734 Done getTreeMap map2\n10:04:30,734 Start getTreeMap map3\n10:04:30,736 Done getTreeMap map3\n10:04:30,736 Start getTreeMap map4\n```\n\nThe application hanged on map4 (waited more then 5 minutes).\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 1, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "BTreeMap initialization hangs on existing db", "statsSkippedReason": "", "closed": "2013-10-18 09:17:56", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-18 12:17:50", "commitHash": "cd33cfa8a4389884f8ec7d12d27355f102e8a289", "commitParents": ["05d1da4a3b815be2c9054a83f8c8d5d156746591"], "commitGHEventType": "closed", "nameRev": "cd33cfa8a4389884f8ec7d12d27355f102e8a289 tags/mapdb-0.9.7~31", "commitGitStats": [{"insertions": 8, "lines": 18, "filePath": "src/main/java/org/mapdb/WeakIdentityHashMap.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.put(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.getEntry(java.lang.Object)"}, {"UPD": 0, "TOT": 7, "DEL": 2, "INS": 2, "MOV": 3, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.Entry.equals(java.lang.Object)"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.get(java.lang.Object)"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.containsValue(java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.entrySet().1.contains(java.lang.Object)"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.WeakIdentityHashMap.remove(java.lang.Object)"}], "spoonFilePath": "WeakIdentityHashMap.java"}], "commitMessage": "WeakIdentityHashMap: fix equals methods. Also fix #224\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-18 12:17:50"}], "created": "2013-10-14 06:23:41"}, {"labels": ["bug"], "filteredCommits": ["603a43707eb87f825c9d3ba5e13444a014783b85"], "url": "https://github.com/jankotek/mapdb/issues/222", "gitStatsSummary": {"insertions": 77, "gitFilesChange": 2, "lines": 109, "deletions": 32}, "numCommits": 1, "commits": {"603a43707eb87f825c9d3ba5e13444a014783b85": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 15.000277777777777, "user": "rfox", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.compact()", "org.mapdb.Volume.volumeTransfer(long,org.mapdb.Volume,org.mapdb.Volume)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "The Expiry mechanism seems to write to the direct memory db which will fill eventually fill up Direct Memory.  Once Direct Memory is full MapDB does not function.  One cannot even do a get.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 58, "DEL": 3, "INS": 9, "spoonFilesChanged": 2, "MOV": 46}, "title": "DirectMemoryDB - Expiry writes to DB and can fill up memory", "statsSkippedReason": "", "closed": "2013-10-25 11:04:29", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-23 21:52:07", "commitHash": "603a43707eb87f825c9d3ba5e13444a014783b85", "commitParents": ["ecf6de30d1386656cec9de62a77cd341bab15dce"], "commitGHEventType": "referenced", "nameRev": "603a43707eb87f825c9d3ba5e13444a014783b85 tags/mapdb-0.9.7~19", "commitGitStats": [{"insertions": 15, "lines": 15, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 0}, {"insertions": 14, "lines": 16, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 2}, {"insertions": 63, "lines": 93, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 30}, {"insertions": 15, "lines": 19, "filePath": "src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 57, "DEL": 3, "INS": 8, "MOV": 46, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.volumeTransfer(long,org.mapdb.Volume,org.mapdb.Volume)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirectFreeSpaceTest.in_memory_compact()"}], "spoonFilePath": "StoreDirectFreeSpaceTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.VolumeTest.MemoryVolumeTest.transfer()"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "VolumeDirect & VolumeWAL: allow compaction of in-memory store. Improve #222\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-23 21:52:07"}], "created": "2013-10-10 00:07:49"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/219", "title": " IllegalAccessError: WAL not empty; commit first", "closed": "2013-10-26 10:59:22", "commitsDetails": [], "commits": {}, "ttf": 16.00027777777778, "created": "2013-10-09 19:31:03", "user": "jankotek", "body": "So I'm not doing any puts/writes before my compact thread kicks in,  but \nI'm getting this error, what is the WAL ? This happens right after a make.\n\nCaused by: java.lang.IllegalAccessError: WAL not empty; commit first, than \ncompact\nat org.mapdb.StoreWAL.compact(StoreWAL.java:742)\nat org.mapdb.EngineWrapper.compact(EngineWrapper.java:111)\n\nShould I be reading the MapDb source code to solve my issues or is this an \nappropriate forum to post questions?\n\ncredit: Jay Houghton\n"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/218", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"f909e34d7551f81d0367cb05dfb6fe20faa4441f": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 14.000277777777777, "user": "jankotek", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "```\nAsyncWriteEngine.java:290:in `checkState': java.lang.RuntimeException:\nWriter thread failed\n        from AsyncWriteEngine.java:490:in `commit'\n        from EngineWrapper.java:95:in `commit'\n        from DB.java:1229:in `commit'\n        from null:-1:in `invoke'\n        from DelegatingMethodAccessorImpl.java:43:in `invoke'\n        from Method.java:606:in `invoke'\n        from JavaMethod.java:440:in `invokeDirectWithExceptionHandling'\n        from JavaMethod.java:304:in `invokeDirect'\n        from InstanceMethodInvoker.java:52:in `call'\n        from InstanceMethodInvoker.java:113:in `call'\n        from RubyClass.java:527:in `finvoke'\n        from RubyBasicObject.java:1504:in `send19'\n        from RubyBasicObject$INVOKER$i$send19.gen:-1:in `call'\n        from CachingCallSite.java:177:in `callBlock'\n        from CachingCallSite.java:183:in `call'\n        from CallSpecialArgBlockPassNode.java:64:in `interpret'\n        from NewlineNode.java:105:in `interpret'\n        from RescueNode.java:221:in `executeBody'\n        from RescueNode.java:116:in `interpret'\n        from BeginNode.java:83:in `interpret'\n        from NewlineNode.java:105:in `interpret'\n        from ASTInterpreter.java:74:in `INTERPRET_METHOD'\n        from InterpretedMethod.java:139:in `call'\n        from DefaultMethod.java:182:in `call'\n        from extract.rb:32:in `block_0$RUBY$__file__'\n        from extract$block_0$RUBY$__file__:-1:in `call'\n        from CompiledBlock19.java:135:in `yield'\n        from Block.java:142:in `yield'\n        from RubyArray.java:1606:in `eachCommon'\n        from RubyArray.java:1613:in `each'\n        from MethodHandle.java:599:in `invokeWithArguments'\n        from InvocationLinker.java:230:in `invocationFallback'\n        from extract.rb:13:in `__file__'\n        from extract.rb:-1:in `load'\n        from Ruby.java:811:in `runScript'\n        from Ruby.java:804:in `runScript'\n        from Ruby.java:673:in `runNormally'\n        from Ruby.java:522:in `runFromMain'\n        from Main.java:395:in `doRunFromMain'\n        from Main.java:290:in `internalRun'\n        from Main.java:217:in `run'\n        from Main.java:197:in `main'\nCaused by:\nVolume.java:487:in `close': java.io.IOError: java.io.IOException: The\nprocess cannot access the file because another process has locked a portion\nof the file\n        from StoreWAL.java:648:in `replayLogFile'\n        from StoreWAL.java:555:in `commit'\n        from EngineWrapper.java:95:in `commit'\n        from AsyncWriteEngine.java:72:in `access$201'\n        from AsyncWriteEngine.java:230:in `runWriter'\n        from AsyncWriteEngine.java:156:in `run'\n        from Thread.java:724:in `run'\nCaused by:\nMappedByteBuffer.java:-2:in `force0': java.io.IOException: The process\ncannot access the file because another process has locked a portion of the\nfile\n        from MappedByteBuffer.java:203:in `force'\n        from Volume.java:499:in `sync'\n        from Volume.java:471:in `close'\n        from StoreWAL.java:648:in `replayLogFile'\n        from StoreWAL.java:555:in `commit'\n        from EngineWrapper.java:95:in `commit'\n        from AsyncWriteEngine.java:72:in `access$201'\n        from AsyncWriteEngine.java:230:in `runWriter'\n        from AsyncWriteEngine.java:156:in `run'\n        from Thread.java:724:in `run'\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "StoreWAL commit fails on Windows ", "statsSkippedReason": "", "closed": "2013-10-24 16:43:38", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-24 19:43:33", "commitHash": "f909e34d7551f81d0367cb05dfb6fe20faa4441f", "commitParents": ["ae28170d07376d7465fd7006f7829325d24dfd98"], "commitGHEventType": "closed", "nameRev": "f909e34d7551f81d0367cb05dfb6fe20faa4441f tags/mapdb-0.9.7~13", "commitGitStats": [{"insertions": 18, "lines": 21, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 3}, {"insertions": 60, "lines": 82, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 22}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}, {"UPD": 2, "TOT": 17, "DEL": 2, "INS": 6, "MOV": 7, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 1, "TOT": 5, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 5, "TOT": 21, "DEL": 2, "INS": 7, "MOV": 7, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.VolumeTest.MappedFileVolumeTest.getVolume()"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.VolumeTest.MappedFileVolumeTest"}, {"UPD": 3, "TOT": 10, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.VolumeTest.testConstants()"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: fix compaction on Windows with memory mapped files. Also fix size increments. Should fix #218 and fix #192\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-24 19:43:33"}], "created": "2013-10-09 19:25:04"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/212", "title": "ClassCastException: org.mapdb.BTreeMap$DirNode cannot be cast to org.mapdb.BTreeMap$LeafNode", "closed": "2013-10-08 21:27:06", "commitsDetails": [], "commits": {}, "ttf": 3.000277777777778, "created": "2013-10-04 23:00:00", "user": "brenttheisen", "body": "Getting a ClassCastException when attempting to add to a tree set using 0.9.6. MapDB specific exception/stack looks like this...\n\n```\njava.lang.ClassCastException: org.mapdb.BTreeMap$DirNode cannot be cast to org.mapdb.BTreeMap$LeafNode\n        at org.mapdb.BTreeMap.put2(BTreeMap.java:629)\n        at org.mapdb.BTreeMap.put(BTreeMap.java:566)\n        at org.mapdb.BTreeMap$KeySet.add(BTreeMap.java:1661)\n```\n\nHaven't looked in to why MapDB is attempting to cast dir nodes to lead nodes but did inspect the variable causing the cast...\n\n![screen shot 2013-10-04 at 5 55 00 pm](https://f.cloud.github.com/assets/658541/1273442/996758c4-2d48-11e3-81e4-4511c5918dd0.png)\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/211", "title": "ArrayIndexOutOfBoundsException in getAll() shortly after startup (0.9.6)", "closed": "2013-10-07 12:49:22", "commitsDetails": [], "commits": {}, "ttf": 3.000277777777778, "created": "2013-10-03 20:42:49", "user": "andrewclegg", "body": "I am evaluating MapDB for a project, and I have some integration tests on a class which brings up a MapDB database like this:\n\n```\n        final DBMaker dbMaker = DBMaker.newFileDB(new File(dataFile));\n        _db = dbMaker.make();\n        _txMaker = dbMaker.makeTxMaker();\n\n        // Start performing admin operations on data saved from last session\n        final Set<String> toDelete = newHashSet();\n        final Map<String, Object> objects = _db.getAll();\n```\n\nHowever, on running the first test in the suite, the getAll() call often fails:\n\n```\njava.lang.ArrayIndexOutOfBoundsException: -833835923\n    at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:349)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:373)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:292)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:279)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n    at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:361)\n    at org.mapdb.Caches$HashTable.get(Caches.java:213)\n    at org.mapdb.BTreeMap$BTreeIterator.pointToStart(BTreeMap.java:809)\n    at org.mapdb.BTreeMap$BTreeIterator.<init>(BTreeMap.java:776)\n    at org.mapdb.BTreeMap$BTreeKeyIterator.<init>(BTreeMap.java:962)\n    at org.mapdb.BTreeMap.keyIterator(BTreeMap.java:1495)\n    at org.mapdb.BTreeMap$KeySet.iterator(BTreeMap.java:1594)\n    at org.mapdb.DB.getAll(DB.java:1134)\n    ...\n```\n\nThe strange thing is, every test after this starts up fine (using the same initialization code).\n"}, {"labels": ["bug"], "filteredCommits": ["7d0c7338c9890e2f28b060f2d905aeaad911be12"], "url": "https://github.com/jankotek/mapdb/issues/209", "gitStatsSummary": {"insertions": 38, "gitFilesChange": 1, "lines": 51, "deletions": 13}, "numCommits": 1, "commits": {"7d0c7338c9890e2f28b060f2d905aeaad911be12": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 1.0002777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.BTreeMap", "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)", "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Tests with large number of threads (>100) suggests BTreeMap is not thread safe\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 6, "UPD": 0, "TOT": 29, "DEL": 4, "INS": 23, "spoonFilesChanged": 1, "MOV": 2}, "title": "BTreeMap not thread safe", "statsSkippedReason": "", "closed": "2013-10-02 14:56:29", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-02 17:56:24", "commitHash": "7d0c7338c9890e2f28b060f2d905aeaad911be12", "commitParents": ["4b0c7f416c77fea4953f210a449bfdd05a9d251b"], "commitGHEventType": "closed", "nameRev": "7d0c7338c9890e2f28b060f2d905aeaad911be12 tags/mapdb-0.9.7~49", "commitGitStats": [{"insertions": 38, "lines": 51, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 13}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)"}, {"UPD": 0, "TOT": 19, "DEL": 4, "INS": 13, "MOV": 2, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "BTreeMap: fix #209, put operation was not thread safe.\n\nSolved by fixing three TODOs (root locking, tree levels and left most node jump)\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-02 17:56:24"}], "created": "2013-10-01 05:42:32"}, {"labels": ["bug"], "filteredCommits": ["fb7e90e0250aadeb6a1ae7b48056f8c4082c7097", "e376503fad7bfb4a1154701528c50f837049618e", "6ebc2e388d863c7bab7df725bca6b4ebeab50c94"], "url": "https://github.com/jankotek/mapdb/issues/202", "gitStatsSummary": {"insertions": 22, "gitFilesChange": 1, "lines": 31, "deletions": 9}, "numCommits": 3, "commits": {"6ebc2e388d863c7bab7df725bca6b4ebeab50c94": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "fb7e90e0250aadeb6a1ae7b48056f8c4082c7097": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "e376503fad7bfb4a1154701528c50f837049618e": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 7.000277777777778, "user": "ycuicui", "changesInPackagesSPOON": ["org.mapdb.SerializerBase.serializeLong(java.io.DataOutput,java.lang.Object)", "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)", "org.mapdb.SerializerBase.serializeInt(java.io.DataOutput,java.lang.Object)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I have a HTreeMap with Long key. Fore some negative key values, they cannot be retreived after the db was closed.\n\nHere is a test case to reproduce the bug. I don't test for Integer or other types\n\npublic class MapDbNegNumberKeyTest {\n\n```\n// This fail\n@Test\npublic void testNegLongKO() {\n    doTest(0x80FFFFFFFFFFFFFFL);\n}\n\n// But not this one\n@Test\npublic void testNegLongOK() {\n    // Only one bit difference!!\n    doTest(0x81FFFFFFFFFFFFFFL);\n}\n\nprivate void doTest(Long negVal) {\n    File dbFile = testDbFile();\n    if (dbFile.exists())\n        dbFile.delete();\n\n    DBMaker maker = DBMaker.newFileDB(dbFile).closeOnJvmShutdown();\n\n    DB db = maker.make();\n    HTreeMap<Long, String> map = db.getHashMap(\"TestNegKey\");\n\n    map.put(1, \"one\");\n    map.put(negVal, \"neg\");\n\n    // This test is fine\n    Assert.assertNotNull(map.get(negVal));\n    db.commit();\n\n    // This test is still fine\n    Assert.assertNotNull(map.get(negVal));\n\n    db.close();\n\n    // reopen\n    db = maker.make();\n    map = db.getHashMap(\"TestNegKey\");\n\n    // \"regular\" key always fine\n    Assert.assertNotNull(map.get(1));\n    try {\n        // This test now fail for some values\n        Assert.assertNotNull(map.get(negVal));\n    } finally {\n        db.close();\n        dbFile.delete();\n    }\n}\n\n/**\n * Create temporary file in temp folder. All associated db files are not\n * deleted on JVM exit.\n */\nprivate static File testDbFile() {\n    try {\n        final File index = File.createTempFile(\"mapdb\", \"db\");\n        // index.deleteOnExit();\n        new File(index.getPath() + StoreDirect.DATA_FILE_EXT)\n        /* .deleteOnExit() */;\n        new File(index.getPath() + StoreWAL.TRANS_LOG_FILE_EXT)\n        /* .deleteOnExit() */;\n\n        return index;\n    } catch (final IOException e) {\n        throw new IOError(e);\n    }\n}\n```\n\n}\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 2, "TOT": 28, "DEL": 8, "INS": 12, "spoonFilesChanged": 1, "MOV": 6}, "title": "Some key values cannot be retreived after db closed", "statsSkippedReason": "", "closed": "2013-10-04 11:21:39", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-04 15:37:18", "commitHash": "6ebc2e388d863c7bab7df725bca6b4ebeab50c94", "commitParents": ["e376503fad7bfb4a1154701528c50f837049618e"], "commitGHEventType": "referenced", "nameRev": "6ebc2e388d863c7bab7df725bca6b4ebeab50c94 tags/mapdb-0.9.7~46", "commitGitStats": [{"insertions": 43, "lines": 44, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 1}, {"insertions": 10, "lines": 14, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 11, "DEL": 2, "INS": 4, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerBase.serializeLong(java.io.DataOutput,java.lang.Object)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.serializeInt(java.io.DataOutput,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testIntSize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLongSize()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.serSize(int,java.lang.Object)"}], "spoonFilePath": "SerializerBaseTest.java"}], "commitMessage": "SerializerBase: negative longs and integers were not packed. Fixed and added unit tests for size\n\nRelated to #202\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-04 15:37:18"}, {"commitUser": "jankotek", "commitDateTime": "2013-10-04 14:21:35", "commitHash": "fb7e90e0250aadeb6a1ae7b48056f8c4082c7097", "commitParents": ["7d0c7338c9890e2f28b060f2d905aeaad911be12"], "commitGHEventType": "closed", "nameRev": "fb7e90e0250aadeb6a1ae7b48056f8c4082c7097 tags/mapdb-0.9.7~48", "commitGitStats": [{"insertions": 7, "lines": 9, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 2}, {"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testInt()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLong()"}], "spoonFilePath": "SerializerBaseTest.java"}], "commitMessage": "SerializerBase: fix #202, deserialization fails for some negative long values\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-04 14:21:35"}, {"commitUser": "jankotek", "commitDateTime": "2013-10-04 15:12:09", "commitHash": "e376503fad7bfb4a1154701528c50f837049618e", "commitParents": ["fb7e90e0250aadeb6a1ae7b48056f8c4082c7097"], "commitGHEventType": "referenced", "nameRev": "e376503fad7bfb4a1154701528c50f837049618e tags/mapdb-0.9.7~47", "commitGitStats": [{"insertions": 8, "lines": 15, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 7}, {"insertions": 10, "lines": 13, "filePath": "src/main/java/org/mapdb/SerializerBase.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 8, "DEL": 2, "INS": 4, "MOV": 2, "spoonMethodName": "org.mapdb.SerializerBase.serializeInt(java.io.DataOutput,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBase.deserialize(java.io.DataInput,org.mapdb.SerializerBase$FastArrayList)"}], "spoonFilePath": "SerializerBase.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 9, "DEL": 3, "INS": 3, "MOV": 3, "spoonMethodName": "org.mapdb.SerializerBaseTest.testInt()"}, {"UPD": 0, "TOT": 9, "DEL": 3, "INS": 2, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerBaseTest.testLong()"}], "spoonFilePath": "SerializerBaseTest.java"}], "commitMessage": "SerializerPojo: fix Integer serialization, negative values would always consume 5 bytes, no optimization was applied, negative integers now consume between 2 to 5 bytes.\n\n Related to #202\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-04 15:12:09"}], "created": "2013-09-27 10:33:53"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/201", "title": "Concurrent transaction failure", "closed": "2013-10-26 09:46:55", "commitsDetails": [], "commits": {}, "ttf": 29.00027777777778, "created": "2013-09-27 08:02:53", "user": "jankotek", "body": "One test case fails sometimes: `TxMakerTest.concurrent_tx()`. I am not sure if problem is in `TxMaker` or underlying `StoreWAL`. This error is present in 0.9.6. \n\nThis problem only manifests on in-memory stores. On-disk store do not show it. This would suggest race condition.\n\n```\njava.lang.AssertionError\n    at org.mapdb.HTreeMap$1.deserialize(HTreeMap.java:114)\n    at org.mapdb.HTreeMap$1.deserialize(HTreeMap.java:101)\n    at org.mapdb.Store.deserialize(Store.java:248)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:408)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:292)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:279)\n    at org.mapdb.Caches$HashTable.get(Caches.java:213)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:60)\n    at org.mapdb.TxEngine.get(TxEngine.java:75)\n    at org.mapdb.TxEngine.updateNoLock(TxEngine.java:94)\n    at org.mapdb.TxEngine.access$200(TxEngine.java:19)\n    at org.mapdb.TxEngine$TX.commit(TxEngine.java:383)\n    at org.mapdb.DB.commit(DB.java:1229)\n    at org.mapdb.TxMaker.execute(TxMaker.java:47)\n    at org.mapdb.TxMakerTest$1.run(TxMakerTest.java:73)\n```\n"}, {"labels": ["bug"], "filteredCommits": ["af3ae29e5ef5c6f18defbc4a96ae025ba8e444ec", "fef89960d233f5f7e85b67f6c2b3dbd258005fa7"], "url": "https://github.com/jankotek/mapdb/issues/198", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 11, "deletions": 3}, "numCommits": 1, "commits": {"fef89960d233f5f7e85b67f6c2b3dbd258005fa7": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "af3ae29e5ef5c6f18defbc4a96ae025ba8e444ec": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 1.0002777777777778, "user": "dwing4g", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.preallocate(long[])", "org.mapdb.StoreWAL.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StoreWAL.get2(long,org.mapdb.Serializer)", "org.mapdb.StoreWAL.preallocate()", "org.mapdb.StoreWAL.getLinkedRecordsFromLog(long)", "org.mapdb.StoreWAL"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "// This is a sample for the bug (tested on git head)\n\nDB db = DBMaker.newFileDB(new File(\"testdb\")).closeOnJvmShutdown().randomAccessFileEnable().make();\nBTreeMap<Integer, Integer> map = db.createTreeMap(\"testmap\").makeOrGet();\nfor(int i = 1; i <= 3000; ++i)\n    map.put(i, i);\ndb.commit();\ndb.close();\n\n// It will throw this exception in mapdb except for no randomAccessFileEnable():\nException in thread \"main\" java.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:290)\n    at org.mapdb.AsyncWriteEngine.commit(AsyncWriteEngine.java:490)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:95)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:95)\n    at org.mapdb.TxEngine.commit(TxEngine.java:138)\n    at org.mapdb.DB.commit(DB.java:1229)\n    at TestMapDBBug.main(TestMapDBBug.java:16)\nCaused by: java.io.IOError: java.io.EOFException\n    at org.mapdb.Volume$FileChannelVol.getLong(Volume.java:755)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:337)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:66)\n    at org.mapdb.AsyncWriteEngine.access$1(AsyncWriteEngine.java:1)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:206)\n    at org.mapdb.AsyncWriteEngine$WriterRunnable.run(AsyncWriteEngine.java:156)\n    at java.lang.Thread.run(Thread.java:724)\nCaused by: java.io.EOFException\n    at org.mapdb.Volume$FileChannelVol.readFully(Volume.java:725)\n    at org.mapdb.Volume$FileChannelVol.getLong(Volume.java:752)\n    ... 6 more\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 6, "UPD": 2, "TOT": 7, "DEL": 0, "INS": 4, "spoonFilesChanged": 1, "MOV": 1}, "title": "randomAccessFileEnable doesn't work", "statsSkippedReason": "", "closed": "2013-09-25 15:41:01", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-09-25 17:36:20", "commitHash": "fef89960d233f5f7e85b67f6c2b3dbd258005fa7", "commitParents": ["0282b5629311d09ef0ade2978aff1e9d3dad5424"], "commitGHEventType": "referenced", "nameRev": "fef89960d233f5f7e85b67f6c2b3dbd258005fa7 tags/mapdb-0.9.6~11", "commitGitStats": [{"insertions": 21, "lines": 21, "filePath": "src/test/java/org/mapdb/Issue198Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue198Test"}], "spoonFilePath": "Issue198Test.java"}], "commitMessage": "RAF: add test case for #198\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-25 17:36:20"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-25 18:40:56", "commitHash": "af3ae29e5ef5c6f18defbc4a96ae025ba8e444ec", "commitParents": ["fef89960d233f5f7e85b67f6c2b3dbd258005fa7"], "commitGHEventType": "closed", "nameRev": "af3ae29e5ef5c6f18defbc4a96ae025ba8e444ec tags/mapdb-0.9.6~10", "commitGitStats": [{"insertions": 8, "lines": 11, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}, {"insertions": 3, "lines": 5, "filePath": "src/test/java/org/mapdb/Issue198Test.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.Issue198Test.main(java.lang.String[])"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue198Test.main()"}], "spoonFilePath": "Issue198Test.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.preallocate(long[])"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.get2(long,org.mapdb.Serializer)"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.preallocate()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.getLinkedRecordsFromLog(long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreWAL: fix #198, incorrect handling of prealloc recid\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-25 18:40:56"}], "created": "2013-09-24 15:10:41"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/196", "title": "encrypted File access failed lead to lock on file.", "closed": "2013-10-24 16:44:21", "commitsDetails": [], "commits": {}, "ttf": 31.00027777777778, "created": "2013-09-23 13:58:14", "user": "aymeric-soubrouillard", "body": "I have created append-only database stored in file with encryption, insert a data inside and then close it. Then i have tried to create a db from the same file, but without encryption option. As expected an expection is trownn, great. But then i want to delete the file, but i cannot: its locks by the JVM.\n\nIt should release lock when exception is thrown during creation.\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/193", "title": "BTreeMap needs compaction", "closed": "2013-10-29 10:59:46", "commitsDetails": [], "commits": {}, "ttf": 42.000277777777775, "created": "2013-09-17 09:02:44", "user": "vadimzv", "body": "EDIT by JanKotek: changed title from `BTreeMap<Long, Integer> file grows though records number is constant`\n\nMapDB fits great for our market storage application, but there is a problem.\nOur application stores updatable records, and each record has id and revision. When record is updated, revision is incremented. Revision is globally unique.\nThere is a BTreeMap<Long, Integer> that contains revisions and ids. When we update record, we remove old revision from map and immediatly put new incremented revision with the same id. But it seems like mapdb doesn't always reuse a free space, that left after old map entry removal. So files are growing and speed seriously slows.\nI wrote a simple app to demonstate this case - there are two million unique records and we update all records' revision ten times. That's the output I got on my desktop:\n\n```\nmapdbfile: 1054960, mapdbfile.p: 22235040\nmapdbfile: 2109936, mapdbfile.p: 44470176\nmapdbfile: 4219888, mapdbfile.p: 44470176\nmapdbfile: 4219888, mapdbfile.p: 44470176\nmapdbfile: 8439792, mapdbfile.p: 44470176\nmapdbfile: 8439792, mapdbfile.p: 44470176\nmapdbfile: 8439792, mapdbfile.p: 44470176\nmapdbfile: 8439792, mapdbfile.p: 88940448\nmapdbfile: 16879600, mapdbfile.p: 88940448\nmapdbfile: 16879600, mapdbfile.p: 88940448\n```\n\nHere is the code:\n\n```\nfinal int SIZE = 2000000;\nFile dbFile = new File(\"target/mapdbfile\");\nDB db = DBMaker.newFileDB(dbFile)\n        .transactionDisable()\n        .freeSpaceReclaimQ(5)\n        .make();\n\nConcurrentNavigableMap<Long, Integer> revIdMap = db.getTreeMap(\"revIdMap\");\n\nfor (int i = 0; i < 10; i++)\n{\n    long lastOldId = revIdMap.isEmpty() ? SIZE : revIdMap.lastKey();\n    long firstOldRev = revIdMap.isEmpty() ? 0 : revIdMap.firstKey();\n\n    for (long rev = firstOldRev; rev < lastOldId; rev++)\n    {\n        revIdMap.remove(rev);\n        revIdMap.put(rev + SIZE, (int)rev);\n\n        if (rev % 100000 == 0) db.commit();\n    }\n    db.commit();\n\n    System.out.println(\"mapdbfile: \" + new File(\"target/mapdbfile\").length() + \n            \", mapdbfile.p: \" + new File(\"target/mapdbfile.p\").length());\n}\ndb.close();\n```\n"}, {"labels": ["bug"], "filteredCommits": [], "url": "https://github.com/jankotek/mapdb/issues/192", "gitStatsSummary": {"insertions": 0, "gitFilesChange": 0, "lines": 0, "deletions": 0}, "numCommits": 0, "commits": {"f909e34d7551f81d0367cb05dfb6fe20faa4441f": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 38.000277777777775, "user": "ycuicui", "changesInPackagesSPOON": [], "changesInPackagesGIT": [], "body": "Hi\nAbout once a day i got the following error :\n\n<pre>\njava.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:263)\n    at org.mapdb.AsyncWriteEngine.close(AsyncWriteEngine.java:408)\n    at org.mapdb.EngineWrapper.close(EngineWrapper.java:74)\n    at org.mapdb.DBMaker$1.run(DBMaker.java:710)\nCaused by: java.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:514)\n    at java.nio.DirectByteBuffer.put(DirectByteBuffer.java:259)\n    at org.mapdb.Volume$ByteBufferVol.putByte(Volume.java:333)\n    at org.mapdb.StoreWAL.commit(StoreWAL.java:446)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:85)\n    at org.mapdb.AsyncWriteEngine.access$201(AsyncWriteEngine.java:72)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:229)\n    at org.mapdb.AsyncWriteEngine$WriterRunnable.run(AsyncWriteEngine.java:155)\n    at java.lang.Thread.run(Thread.java:619)\n</pre>\n\nI use MapDB version 0.9.5 in a maven project under eclipse Juno\nMy Database containts two HMap and a counter, is quite huge in size (4-5 Gb) but with not so much objects (about 140 000).\nAfter this error, my eclipse instance is often corrupted ;-((\n\nhere is the initialization code:\n\n<pre>\nprivate DB dataBase;\nprivate HTreeMap<Integer, byte[]> blockData;\nprivate HTreeMap<String, Integer> hashIndex;\nprivate Atomic.Long counter;\n\ndataBase = DBMaker.newFileDB(BLOCK_DATA_FILE).closeOnJvmShutdown()\n                .cacheDisable().make();\nblockData = dataBase.getHashMap(\"BlockData\"); //$NON-NLS-1$\nhashIndex = dataBase.getHashMap(\"HashIndex\"); //$NON-NLS-1$\ncounter = dataBase.getAtomicLong(\"BlockCount\"); //$NON-NLS-1$\nBind.size(blockData, counter);\n</pre>\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 1}, "spoonStatsSummary": {"spoonMethodsChanged": 0, "UPD": 0, "TOT": 0, "DEL": 0, "INS": 0, "spoonFilesChanged": 0, "MOV": 0}, "title": "Writer thread failed", "statsSkippedReason": "", "closed": "2013-10-24 16:43:38", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-10-24 19:43:33", "commitHash": "f909e34d7551f81d0367cb05dfb6fe20faa4441f", "commitParents": ["ae28170d07376d7465fd7006f7829325d24dfd98"], "commitGHEventType": "closed", "nameRev": "f909e34d7551f81d0367cb05dfb6fe20faa4441f tags/mapdb-0.9.7~13", "commitGitStats": [{"insertions": 18, "lines": 21, "filePath": "src/test/java/org/mapdb/VolumeTest.java", "deletions": 3}, {"insertions": 60, "lines": 82, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 22}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.sync()"}, {"UPD": 2, "TOT": 17, "DEL": 2, "INS": 6, "MOV": 7, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.close()"}, {"UPD": 1, "TOT": 5, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFileVol"}, {"UPD": 5, "TOT": 21, "DEL": 2, "INS": 7, "MOV": 7, "spoonMethodName": "org.mapdb.Volume.MappedFileVol.makeNewBuffer(long,java.nio.ByteBuffer[])"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.VolumeTest.MappedFileVolumeTest.getVolume()"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.VolumeTest.MappedFileVolumeTest"}, {"UPD": 3, "TOT": 10, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.VolumeTest.testConstants()"}], "spoonFilePath": "VolumeTest.java"}], "commitMessage": "Volume: fix compaction on Windows with memory mapped files. Also fix size increments. Should fix #218 and fix #192\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-10-24 19:43:33"}], "created": "2013-09-16 15:19:42"}, {"labels": ["bug"], "filteredCommits": ["a1b1508733312b506243cabd15372924fe3c8ea3", "78997fd128e46f3cbefeae19b97def0c96f76c04", "77664bd5749413f09c95d1b2e26f510a807e65c5", "16becd4cfa393c94dd03a4261e8766d70a170978", "d79580d7a5e0d968c564bb29d70ce727e25c083e"], "url": "https://github.com/jankotek/mapdb/issues/191", "gitStatsSummary": {"insertions": 90, "gitFilesChange": 6, "lines": 159, "deletions": 69}, "numCommits": 4, "commits": {"78997fd128e46f3cbefeae19b97def0c96f76c04": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "77664bd5749413f09c95d1b2e26f510a807e65c5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "d79580d7a5e0d968c564bb29d70ce727e25c083e": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "16becd4cfa393c94dd03a4261e8766d70a170978": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "c533f6b18bb1b960bc7275b8ebae1366268e2bd3": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "a1b1508733312b506243cabd15372924fe3c8ea3": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 4.000277777777778, "user": "nitianyi", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.checkLogRounding()", "org.mapdb.StoreWAL.openLogIfNeeded()", "org.mapdb.StoreAppend.updateNoLock(long,org.mapdb.DataOutput2)", "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.TxMaker.TxEngine.rollback()", "org.mapdb.StoreDirect", "org.mapdb.StoreAppend.compact()", "org.mapdb.StoreAppend.commit()", "org.mapdb.StoreDirect.delete(long,org.mapdb.Serializer)", "org.mapdb.StoreWAL.replayLogFile()", "org.mapdb.Store.lockAllWrite()", "org.mapdb.StoreDirect.longStackPut(long,long,boolean)", "org.mapdb.StoreDirect.close()", "org.mapdb.Store.unlockAllWrite()", "org.mapdb.StoreDirect.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.TxMaker.makeTx()", "org.mapdb.StoreAppend", "org.mapdb.Store", "org.mapdb.StoreWAL.logAllocate(long[])", "org.mapdb.StoreAppend.rollback()", "org.mapdb.StoreDirect.compact()", "org.mapdb.StoreDirect.update2(org.mapdb.DataOutput2,long)", "org.mapdb.StoreWAL.rollback()", "org.mapdb.TxMaker.TxEngine.delete(long,org.mapdb.Serializer)", "org.mapdb.StoreAppend.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.TxMaker.TxEngine.commit()", "org.mapdb.StoreWAL", "org.mapdb.TxMaker.TxEngine.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StoreDirect.get(long,org.mapdb.Serializer)", "org.mapdb.StoreAppend.put(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StoreWAL.close()", "org.mapdb.StoreAppend.delete(long,org.mapdb.Serializer)", "org.mapdb.StoreWAL.commit()", "org.mapdb.TxMaker.TxEngine.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StoreDirect.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.DBMaker.makeTxMaker()", "org.mapdb.StoreAppend.get(long,org.mapdb.Serializer)", "org.mapdb.StoreDirect.longStackTake(long,boolean)", "org.mapdb.StoreAppend.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi\uff0cJan\uff01\n\nWhen I run thre code as follows below with single-thread mode ,it works well,but it throws TxRollbackException with multi-thread mode.\n\ntxMaker.execute(new TxBlock(){\n            @Override public void tx(DB db) throws TxRollbackException {\n                Map m = db.getHashMap(\"test\");\n                m.put(\"test\",\"test\");\n//                db.getQueue(\"test1\").offer(\"test\");\n            }\n        });\n\nThe strack trace information is like this:\norg.mapdb.TxRollbackException\n    at org.mapdb.TxMaker$TxEngine.lockGlobalMods(TxMaker.java:117)\n    at org.mapdb.TxMaker$TxEngine.update(TxMaker.java:145)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:638)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:566)\n    at examples.TransactionTest$1InnerThread$1.tx(TransactionTest.java:46)\n    at org.mapdb.TxMaker.execute(TxMaker.java:58)\n\nBesides, map works well with single-thread,queue does not no matter with single-thread or multi-thread mode\n", "filteredCommitsReason": {"duplicated": 1, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 39, "UPD": 15, "TOT": 103, "DEL": 50, "INS": 20, "spoonFilesChanged": 6, "MOV": 18}, "title": "concurrent exception\uff1aorg.mapdb.TxRollbackException", "statsSkippedReason": "", "closed": "2013-09-20 13:30:49", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-09-17 13:51:49", "commitHash": "78997fd128e46f3cbefeae19b97def0c96f76c04", "commitParents": ["a1b1508733312b506243cabd15372924fe3c8ea3"], "commitGHEventType": "referenced", "nameRev": "78997fd128e46f3cbefeae19b97def0c96f76c04 tags/mapdb-0.9.6~35", "commitGitStats": [{"insertions": 17, "lines": 28, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 11}, {"insertions": 10, "lines": 27, "filePath": "src/main/java/org/mapdb/TxMaker.java", "deletions": 17}, {"insertions": 14, "lines": 20, "filePath": "src/test/java/org/mapdb/TxMakerTest.java", "deletions": 6}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.delete(long,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 6, "DEL": 3, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.rollback()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.commit()"}], "spoonFilePath": "TxMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.init().1.run()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.concurrent_tx().1.run()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.concurrent_tx()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.init()"}], "spoonFilePath": "TxMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.checkLogRounding()"}, {"UPD": 2, "TOT": 4, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayLogFile()"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.StoreWAL"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.openLogIfNeeded()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.logAllocate(long[])"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Make locking more stricts, add concurrency assertions. Hope to solve #191\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 13:51:49"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-17 12:37:16", "commitHash": "77664bd5749413f09c95d1b2e26f510a807e65c5", "commitParents": ["939644c06afd0fad14c8a3c6287b2538fce85964"], "commitGHEventType": "referenced", "nameRev": "77664bd5749413f09c95d1b2e26f510a807e65c5 tags/mapdb-0.9.6~39", "commitGitStats": [{"insertions": 46, "lines": 46, "filePath": "src/test/java/org/mapdb/TxMakerTest.java", "deletions": 0}, {"insertions": 3, "lines": 3, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.init()"}], "spoonFilePath": "TxMakerTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.DBMaker.makeTxMaker()"}], "spoonFilePath": "DBMaker.java"}], "commitMessage": "TXMaker:   #191 rework TX init so it does not fail, remove deadlocks in St\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 12:37:16"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-17 12:38:06", "commitHash": "d79580d7a5e0d968c564bb29d70ce727e25c083e", "commitParents": ["77664bd5749413f09c95d1b2e26f510a807e65c5"], "commitGHEventType": "referenced", "nameRev": "d79580d7a5e0d968c564bb29d70ce727e25c083e tags/mapdb-0.9.6~38", "commitGitStats": [{"insertions": 6, "lines": 18, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 12}, {"insertions": 17, "lines": 17, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 0}, {"insertions": 7, "lines": 21, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 14}, {"insertions": 4, "lines": 14, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 10}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.lockAllWrite()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.Store"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Store.unlockAllWrite()"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.close()"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.longStackTake(long,boolean)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.get(long,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.update2(org.mapdb.DataOutput2,long)"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.delete(long,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.longStackPut(long,long,boolean)"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.rollback()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.updateNoLock(long,org.mapdb.DataOutput2)"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.put(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.compareAndSwap(long,java.lang.Object,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.compact()"}, {"UPD": 0, "TOT": 3, "DEL": 3, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.delete(long,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 2, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.get(long,org.mapdb.Serializer)"}, {"UPD": 2, "TOT": 4, "DEL": 2, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.commit()"}], "spoonFilePath": "StoreAppend.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 5, "DEL": 3, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.close()"}, {"UPD": 1, "TOT": 5, "DEL": 3, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.rollback()"}, {"UPD": 1, "TOT": 5, "DEL": 3, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.commit()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Store:   #191 rework locking sequence to prevent deadlocks\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 12:38:06"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-17 15:15:16", "commitHash": "16becd4cfa393c94dd03a4261e8766d70a170978", "commitParents": ["c533f6b18bb1b960bc7275b8ebae1366268e2bd3"], "commitGHEventType": "referenced", "nameRev": "16becd4cfa393c94dd03a4261e8766d70a170978 tags/mapdb-0.9.6~32", "commitGitStats": [{"insertions": 0, "lines": 1, "filePath": "src/test/java/org/mapdb/TxMakerTest.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.concurrent_tx()"}], "spoonFilePath": "TxMakerTest.java"}], "commitMessage": "#191: improve unit tests\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 15:15:16"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-17 15:14:51", "commitHash": "c533f6b18bb1b960bc7275b8ebae1366268e2bd3", "commitParents": ["37a6e59b6aa984813fb1b67bd75158088e8d468b"], "commitGHEventType": "referenced", "nameRev": "c533f6b18bb1b960bc7275b8ebae1366268e2bd3 tags/mapdb-0.9.6~33", "commitGitStats": [{"insertions": 7, "lines": 9, "filePath": "src/test/java/org/mapdb/TxMakerTest.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.TxMakerTest.concurrent_tx().1.run().1.tx(org.mapdb.DB)"}, {"UPD": 0, "TOT": 5, "DEL": 1, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.TxMakerTest.concurrent_tx()"}], "spoonFilePath": "TxMakerTest.java"}], "commitMessage": "#191: improve unit tests\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 15:14:51"}, {"commitUser": "jankotek", "commitDateTime": "2013-09-17 13:20:08", "commitHash": "a1b1508733312b506243cabd15372924fe3c8ea3", "commitParents": ["17b983d5e5bb986b303e5eefe5062f02ebaf18b4"], "commitGHEventType": "referenced", "nameRev": "a1b1508733312b506243cabd15372924fe3c8ea3 tags/mapdb-0.9.6~36", "commitGitStats": [{"insertions": 26, "lines": 31, "filePath": "src/main/java/org/mapdb/TxMaker.java", "deletions": 5}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 7, "DEL": 1, "INS": 2, "MOV": 4, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.commit()"}, {"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.makeTx()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.TxMaker.TxEngine.put(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "TxMaker.java"}], "commitMessage": "TxMaker: another improvement on #191\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-17 13:20:08"}], "created": "2013-09-16 08:46:42"}, {"labels": ["bug"], "filteredCommits": ["1863c2c2658e9161b6acf166b705e1692c170397"], "url": "https://github.com/jankotek/mapdb/issues/186", "gitStatsSummary": {"insertions": 33, "gitFilesChange": 2, "lines": 35, "deletions": 2}, "numCommits": 1, "commits": {"1863c2c2658e9161b6acf166b705e1692c170397": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 0.0002777777777777778, "user": "nitianyi", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.checkHeaders()", "org.mapdb.StoreWAL.replayLogFile()", "org.mapdb.StoreDirect.checkHeaders()", "org.mapdb.StoreDirect.close()", "org.mapdb.StoreDirect", "org.mapdb.StoreDirect.commit()", "org.mapdb.StoreDirect.createStructure()", "org.mapdb.StoreWAL", "org.mapdb.StoreDirect.indexHeaderChecksum()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi,Jan\nI have used MapDB.It seems usually works very well,so  I test the failover case,namely I kill the process of my app,then reboot the app and continue to store something,however exception occurs as follows below:\n\njava.lang.InternalError: data were not fully read, check your serializer\n        at org.mapdb.Store.deserialize(Store.java:212)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:337)\n        at org.mapdb.StoreDirect.get(StoreDirect.java:294)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n        at org.mapdb.BTreeMap.put2(BTreeMap.java:583)\n        at org.mapdb.BTreeMap.put(BTreeMap.java:566)\n\nPS: I look through the issues ,finding that you have closed the issue 126 similar to this one, so I wonder if you have fixed it.\n\n```\n                                                            Best regards\n```\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 9, "UPD": 0, "TOT": 14, "DEL": 0, "INS": 12, "spoonFilesChanged": 2, "MOV": 2}, "title": "java.lang.InternalError: data were not fully read, check your serializer", "statsSkippedReason": "", "closed": "2013-09-05 19:16:36", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-09-05 19:15:00", "commitHash": "1863c2c2658e9161b6acf166b705e1692c170397", "commitParents": ["3cd5bcff8ac398c759a6c5895c5d2eff1b728469"], "commitGHEventType": "referenced", "nameRev": "1863c2c2658e9161b6acf166b705e1692c170397 tags/mapdb-0.9.6~49", "commitGitStats": [{"insertions": 13, "lines": 13, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 20, "lines": 22, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.createStructure()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.checkHeaders()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirect.close()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.StoreDirect.commit()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.indexHeaderChecksum()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.checkHeaders()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.replayLogFile()"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "StoreDirect: add checksum which checks if store was closed correctly. If not it throws an exception and prevents (possibly corrupted) store to be opened.\n\nThis is related to bug report #186. This assertion should decrease reported number of data-corruption errors caused by direct mode.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-09-05 19:15:00"}], "created": "2013-09-05 02:52:48"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/181", "title": "ClassCastException: org.mapdb.BTreeMap$DirNode cannot be cast to org.mapdb.BTreeMap$LeafNode", "closed": "2013-08-25 18:38:56", "commitsDetails": [], "commits": {}, "ttf": 3.000277777777778, "created": "2013-08-22 16:11:06", "user": "flavor8", "body": "java.lang.ClassCastException: org.mapdb.BTreeMap$DirNode cannot be cast to org.mapdb.BTreeMap$LeafNode\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:626)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:561)\n    at org.mapdb.BTreeMap$KeySet.add(BTreeMap.java:1658)\n\nTriggered at approximately line 730k of my 1.5M row file when using TreeSet. \n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/178", "title": "ArrayIndexOutOfBoundsException on BTreeMap.put", "closed": "2013-08-25 18:38:38", "commitsDetails": [], "commits": {}, "ttf": 4.000277777777778, "created": "2013-08-21 15:03:34", "user": "flavor8", "body": "Initialized via:\n\n```\n    final DB db = DBMaker\n            .newDirectMemoryDB()\n            .transactionDisable()\n            .asyncFlushDelay(100)\n            .make();\n\n    buffer = db.getTreeMap(\"test\");\n```\n\nAfter 700k writes I get:\n\njava.lang.ArrayIndexOutOfBoundsException\n    at org.mapdb.Utils.arrayPut(Utils.java:168)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:662)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:561)\n"}, {"labels": ["bug"], "filteredCommits": ["7731be01d18476affed01e7d553093132ece2794"], "url": "https://github.com/jankotek/mapdb/issues/170", "gitStatsSummary": {"insertions": 105, "gitFilesChange": 2, "lines": 191, "deletions": 86}, "numCommits": 1, "commits": {"7731be01d18476affed01e7d553093132ece2794": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 4.000277777777778, "user": "wcarus", "changesInPackagesSPOON": ["org.mapdb.CompressLZF.expand(java.nio.ByteBuffer,int,int,byte[],int,int)", "org.mapdb.Store.deserialize(org.mapdb.Serializer,int,org.mapdb.DataInput2)", "org.mapdb.CompressLZF.expand(byte[],int,int,byte[],int,int)", "org.mapdb.Store.serialize(java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "This LZF compression-related exception only appeared with the recent releases of MapDB. The Jython application works correctly without LZF compression, but fails with the following cascade of exceptions when LZF compression is used:\n\nself.DB=self.DBMaker.writeAheadLogDisable().asyncWriteDisable().compressionEnable().make()\n\nHere are the errors generated by Jython:\n\n  File \"/Users/infoextract/work/seq-dict/IesSeqDict.py\", line 220, in get\n    for val in mapdb.Bind.findSecondaryKeys(self.INDEX,lcaseKey):\njava.lang.ArrayStoreException\n    at java.lang.System.arraycopy(Native Method)\n    at org.mapdb.CompressLZF.expand(CompressLZF.java:296)\n    at org.mapdb.Store.deserialize(Store.java:184)\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:336)\n    at org.mapdb.StoreDirect.get(StoreDirect.java:293)\n    at org.mapdb.Caches$HashTable.get(Caches.java:212)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:51)\n    at org.mapdb.BTreeMap.findLargerNode(BTreeMap.java:1372)\n    at org.mapdb.BTreeMap$BTreeIterator.<init>(BTreeMap.java:783)\n    at org.mapdb.BTreeMap$BTreeKeyIterator.<init>(BTreeMap.java:964)\n    at org.mapdb.BTreeMap$SubMap.keyIterator(BTreeMap.java:2172)\n    at org.mapdb.BTreeMap$KeySet.iterator(BTreeMap.java:1594)\n    at org.mapdb.Bind$5.iterator(Bind.java:273)\n    at org.python.core.PyJavaType$IteratorIter.<init>(PyJavaType.java:862)\n    at org.python.core.PyJavaType$16.**call**(PyJavaType.java:920)\n    at org.python.core.PyObjectDerived.**iter**(PyObjectDerived.java:828)\n    at IesSeqDict$py.get$21(/Users/infoextract/work/seq-dict/IesSeqDict.py:245)\n    at IesSeqDict$py.call_function(/Users/infoextract/work/seq-dict/IesSeqDict.py)\n    at org.python.core.PyTableCode.call(PyTableCode.java:165)\n    at org.python.core.PyBaseCode.call(PyBaseCode.java:301)\n    at org.python.core.PyBaseCode.call(PyBaseCode.java:141)\n    at org.python.core.PyFunction.**call**(PyFunction.java:327)\n    at org.python.core.PyMethod.**call**(PyMethod.java:124)\n    at org.python.pycode._pyx0.test1$25(IesSeqDict.py:349)\n    at org.python.pycode._pyx0.call_function(IesSeqDict.py)\n    at org.python.core.PyTableCode.call(PyTableCode.java:165)\n    at org.python.core.PyBaseCode.call(PyBaseCode.java:120)\n    at org.python.core.PyFunction.__call__(PyFunction.java:307)\n    at IesCore$py.timeIt$2(/Users/infoextract/work/seq-dict/IesCore.py:54)\n    at IesCore$py.call_function(/Users/infoextract/work/seq-dict/IesCore.py)\n    at org.python.core.PyTableCode.call(PyTableCode.java:165)\n    at org.python.core.PyBaseCode.call(PyBaseCode.java:134)\n    at org.python.core.PyFunction.**call**(PyFunction.java:317)\n    at org.python.pycode._pyx0.f$0(IesSeqDict.py:357)\n    at org.python.pycode._pyx0.call_function(IesSeqDict.py)\n    at org.python.core.PyTableCode.call(PyTableCode.java:165)\n    at org.python.core.PyCode.call(PyCode.java:18)\n    at org.python.core.Py.runCode(Py.java:1275)\n    at org.python.util.PythonInterpreter.execfile(PythonInterpreter.java:235)\n    at org.python.util.jython.run(jython.java:247)\n    at org.python.util.jython.main(jython.java:129)\n\njava.lang.ArrayStoreException: java.lang.ArrayStoreException\n\nThe data being stored is Medcin (medical) phrases and associated medical categories.\n\nWhen a small subset of the data is run with and without compression, the application works correctly. Remarkably, the exception seems to be appearing at almost the identical line number (line number equal to or close to 254994) in all of the the input files I've tested (but doesn't depend on the specific content of this line since I have created multiple randomly selected versions from a much larger input file to test for this).\n\nIf you would like me to send the application and the input data, please let me know.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 4, "UPD": 16, "TOT": 80, "DEL": 9, "INS": 15, "spoonFilesChanged": 2, "MOV": 40}, "title": "java.lang.ArrayStoreException related to LZF compression", "statsSkippedReason": "", "closed": "2013-08-20 11:20:32", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-08-20 12:20:23", "commitHash": "7731be01d18476affed01e7d553093132ece2794", "commitParents": ["36ab1106f61744c7e9553c22edc4e885089fc5ed"], "commitGHEventType": "closed", "nameRev": "7731be01d18476affed01e7d553093132ece2794 tags/mapdb-0.9.5~7", "commitGitStats": [{"insertions": 22, "lines": 22, "filePath": "src/test/java/org/mapdb/Issue170Test.java", "deletions": 0}, {"insertions": 52, "lines": 89, "filePath": "src/main/java/org/mapdb/Store.java", "deletions": 37}, {"insertions": 53, "lines": 102, "filePath": "src/main/java/org/mapdb/CompressLZF.java", "deletions": 49}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 8, "TOT": 31, "DEL": 2, "INS": 4, "MOV": 17, "spoonMethodName": "org.mapdb.Store.deserialize(org.mapdb.Serializer,int,org.mapdb.DataInput2)"}, {"UPD": 8, "TOT": 32, "DEL": 2, "INS": 7, "MOV": 15, "spoonMethodName": "org.mapdb.Store.serialize(java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "Store.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 13, "DEL": 4, "INS": 4, "MOV": 5, "spoonMethodName": "org.mapdb.CompressLZF.expand(java.nio.ByteBuffer,int,int,byte[],int,int)"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.CompressLZF.expand(byte[],int,int,byte[],int,int)"}], "spoonFilePath": "CompressLZF.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue170Test"}], "spoonFilePath": "Issue170Test.java"}], "commitMessage": "Fix #170, compression was not working some times\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-08-20 12:20:23"}], "created": "2013-08-15 19:46:47"}, {"labels": ["bug"], "filteredCommits": ["c26b48839e09df5b4643b829e9e2ba7db8c0fefc", "ad2ff9c46d82caded70ed090d6a91aa87c4b3537"], "url": "https://github.com/jankotek/mapdb/issues/165", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 4, "deletions": 1}, "numCommits": 1, "commits": {"c26b48839e09df5b4643b829e9e2ba7db8c0fefc": {"commitUser": "jankotek", "commitGHEventType": "closed"}, "ad2ff9c46d82caded70ed090d6a91aa87c4b3537": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 2.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.Pump.sort(java.util.Iterator,int,java.util.Comparator,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I kind of solved it.\n\nThe error is raised because of the deserialization of the former serialized term \"\u4eba\u53e3, \u65e5\u672c\u3001\u4eba\u53e3, \u65e5\u672c\u306e\u516c\u5f0f\u7d71\u8a08\".\nThe serialized form becomes a char array with all characters set to \"\\u0000\" which later raises an exception when deserializing.\n\nOn Monday, July 29, 2013 11:10:55 PM UTC+2, Philipp Steinwender wrote:\nBtw both types A and B are Strings.\n\nOn Monday, July 29, 2013 10:49:26 PM UTC+2, Philipp Steinwender wrote:\nHi!\n\nI'm trying to create a large index with Pump.\nBut I cannot get it working.\n\nI have a large text file with 2 label types A and B.\nI want to have A's as keys and B's as values.\nKey A can have multiple values B.\n\nSorting works.\nBut the call for buildBTreeMap raises a EOFException:\n\njava.io.IOError: java.io.EOFException\n    at org.mapdb.Pump$1.next(Pump.java:109)\n    at org.mapdb.Pump$2.next(Pump.java:176)\n    at org.mapdb.Pump.buildTreeMap(Pump.java:433)\nCaused by: java.io.EOFException\n    at java.io.DataInputStream.readUnsignedByte(DataInputStream.java:290)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:768)\n    at org.mapdb.SerializerBase.deserialize(SerializerBase.java:761)\n    at org.mapdb.Pump$1.next(Pump.java:102)\n    ... 29 more\n\nI cannot figure out why this exception occurs.\n\nBut I also see no handling of collisions of multiple values per key. Is this an issue?\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 2, "TOT": 8, "DEL": 1, "INS": 3, "spoonFilesChanged": 1, "MOV": 2}, "title": "Pump.sort problem", "statsSkippedReason": "", "closed": "2013-08-02 09:09:48", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-08-02 10:09:37", "commitHash": "c26b48839e09df5b4643b829e9e2ba7db8c0fefc", "commitParents": ["c00b86794d70ab840ae3c81dd7fbaf0c7bf7229c"], "commitGHEventType": "closed", "nameRev": "c26b48839e09df5b4643b829e9e2ba7db8c0fefc tags/mapdb-0.9.4~25", "commitGitStats": [{"insertions": 3, "lines": 4, "filePath": "src/main/java/org/mapdb/Pump.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 2, "TOT": 8, "DEL": 1, "INS": 3, "MOV": 2, "spoonMethodName": "org.mapdb.Pump.sort(java.util.Iterator,int,java.util.Comparator,org.mapdb.Serializer)"}], "spoonFilePath": "Pump.java"}], "commitMessage": "Fix #165, EOFException while sorting data\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-08-02 10:09:37"}, {"commitUser": "jankotek", "commitDateTime": "2013-07-30 21:31:39", "commitHash": "ad2ff9c46d82caded70ed090d6a91aa87c4b3537", "commitParents": ["28b7fd27c3460e2cd058ca73633edbfa36fbf684"], "commitGHEventType": "referenced", "nameRev": "ad2ff9c46d82caded70ed090d6a91aa87c4b3537 tags/mapdb-0.9.4~38", "commitGitStats": [{"insertions": 6, "lines": 6, "filePath": "src/test/java/org/mapdb/SerializerBaseTest.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerBaseTest.test_extended_chars()"}], "spoonFilePath": "SerializerBaseTest.java"}], "commitMessage": "Add test case for #165\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-07-30 21:31:39"}], "created": "2013-07-30 20:28:45"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/163", "title": "java.io.EOFException and possible fix", "closed": "2013-08-21 13:37:06", "commitsDetails": [], "commits": {}, "ttf": 22.00027777777778, "created": "2013-07-30 05:15:19", "user": "essiembre", "body": "I am processing thousands of items which trigger many update delete on the engine.\nWith the latest code (as of this writing), I always get the following at some point, at random:\n\n```\njava.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:259)\n    at org.mapdb.AsyncWriteEngine.commit(AsyncWriteEngine.java:439)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:86)\n    at org.mapdb.EngineWrapper.commit(EngineWrapper.java:86)\n    at org.mapdb.DB.commit(DB.java:1094)\n    ...\nCaused by: java.io.IOError: java.io.EOFException\n    at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:356)\n    at org.mapdb.StoreWAL.getLinkedRecordsFromLog(StoreWAL.java:706)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:240)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:57)\n    at org.mapdb.AsyncWriteEngine.access$1(AsyncWriteEngine.java:1)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:189)\n    at org.mapdb.AsyncWriteEngine$1.run(AsyncWriteEngine.java:138)\n    at java.lang.Thread.run(Thread.java:662)\nCaused by: java.io.EOFException\n```\n\nAfter investigating, it turns out the `offset` in `StoreWAL.getLinkedRecordsFromLog` is on rare occasions set to zero.  This causes -8 to be passed to the `Volume.getLong` method and leads to an ArrayIndexOutOfBoundsException.\n\nWithout knowing all the implications, checking for the offset value in the `getLinkedRecordsFromLog` method seems to fix this issue:\n\n```\n        for(int i=0;i<ret0.length;i++){\n            long offset = ret0[i] & LOG_MASK_OFFSET;\n            // the following check seems to do it:\n            if (offset < 8) {\n                return null;\n            }\n            //offset now points to log file, read phys offset from log file\n            ret[i] =  log.getLong(offset-8);\n        }\n```\n\nIf you think the offset being zero is not an indicator of a bigger issue, is this a fix you can put in?\n\nThanks!\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/160", "title": "\"Writer thread failed\" and \"InternalError: wrong ioList\"", "closed": "2013-08-02 10:42:39", "commitsDetails": [], "commits": {}, "ttf": 16.00027777777778, "created": "2013-07-16 21:08:26", "user": "essiembre", "body": "Hello,\nWe are considering using MapDB has the default DB implementation for our open source project Norconex HTTP Collector.  It is really fast and performance cost vs number of entries appear to grow in a linear fashion.  I have been working with it quite a bit but now I am at a stage where no matter how I try it, I cannot have a successful run that involved a compact.  I tried working with both the snapshot release and source code (as I need the rename method).\n\nI tried many different database initialization settings, but let's just take this last one I tried:\n\n```\nreturn DBMaker.newFileDB(dbFile)\n    .closeOnJvmShutdown()\n    .cacheSoftRefEnable()\n    .randomAccessFileEnableIfNeeded()\n    .make();\n```\n\nI get the following when compacting:\n\n```\njava.lang.RuntimeException: Writer thread failed\n    at org.mapdb.AsyncWriteEngine.checkState(AsyncWriteEngine.java:236)\n    at org.mapdb.AsyncWriteEngine.compact(AsyncWriteEngine.java:476)\n    at org.mapdb.EngineWrapper.compact(EngineWrapper.java:109)\n    at org.mapdb.EngineWrapper.compact(EngineWrapper.java:109)\n    at org.mapdb.DB.compact(DB.java:1088)\n    [...]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n    at java.lang.Thread.run(Thread.java:662)\nCaused by: java.lang.InternalError: wrong ioList: 34704\n    at org.mapdb.StoreDirect.longStackPut(StoreDirect.java:740)\n    at org.mapdb.StoreDirect.compact(StoreDirect.java:630)\n    at org.mapdb.StoreWAL.compact(StoreWAL.java:730)\n    at org.mapdb.EngineWrapper.compact(EngineWrapper.java:109)\n    at org.mapdb.AsyncWriteEngine.access$401(AsyncWriteEngine.java:68)\n    at org.mapdb.AsyncWriteEngine.runWriter(AsyncWriteEngine.java:207)\n    at org.mapdb.AsyncWriteEngine$1.run(AsyncWriteEngine.java:138)\n    ... 1 more\n```\n\nI am testing this on Windows 64-bit.  If you suspect it can be OS-related, let me know and I can test the same settings on a different OS.\n\nSometimes the error I get tells me to commit before compacting, which I am always doing. I suspect some kind of concurrency issue even if I tried accessing MapDB HashMap with single and multi-threads (writer thread vs a compacting thread?).\n\nAny idea what might be going on?\n"}, {"labels": ["bug"], "filteredCommits": ["baad84983e82e63239ee8dff410a97b08563cbdb"], "url": "https://github.com/jankotek/mapdb/issues/157", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 1, "lines": 6, "deletions": 2}, "numCommits": 1, "commits": {"baad84983e82e63239ee8dff410a97b08563cbdb": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)", "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Inserting into a treemap from 2 threads gives me odd results.\nThere are duplicate keys that have null values.\nFirst run gave me 25 duplicates, second 38 and third 23.\n\nSo BtreeMap does not seem as concurrent as it says it is...\n\n```\npublic class Test {\n\n    public static void main(String[] args) {\n        try {\n            File f = new File(\"/opt/dev/tmp/test\");\n            DBMaker dbMaker = DBMaker.newAppendFileDB(f);\n            DB db = dbMaker.make();\n            final Map<Integer, String> map = db.getTreeMap(\"COL_2\");\n            map.clear();\n\n            Thread t1 = new Thread() {\n                public void run() {\n                    for(int i=0; i<=10000; i++) {\n                        map.put(i, \"foo\");\n                    }\n                }\n            };\n\n            Thread t2 = new Thread() {\n                public void run() {\n                    for(int i=10000; i>=0; i--) {\n                        map.put(i, \"bar\");\n                    }\n                }\n            };\n\n            t1.start();\n            t2.start();\n\n            t1.join();\n            t2.join();\n\n            printMap(\"Results\", map);\n\n        }\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    static void printMap(String header, Map<Integer, String> map) {\n        System.out.println(header);\n        for(Map.Entry entry : map.entrySet()) {\n            System.out.println(entry.getKey() + \" => \" + entry.getValue());\n        }\n        System.out.println();\n    }\n}\n```\n\nCredit Rami Ojares\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "BTreeMap not thread safe", "statsSkippedReason": "", "closed": "2013-07-13 07:14:30", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-07-13 08:14:24", "commitHash": "baad84983e82e63239ee8dff410a97b08563cbdb", "commitParents": ["6d1561ba64e00d980ce47f20ec052a596babb0f6"], "commitGHEventType": "closed", "nameRev": "baad84983e82e63239ee8dff410a97b08563cbdb tags/mapdb-0.9.4~70", "commitGitStats": [{"insertions": 4, "lines": 6, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.NodeSerializer.serialize(java.io.DataOutput,org.mapdb.BTreeMap$BNode)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "Fix #157, BTreeMap not thread safe under some conditions\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-07-13 08:14:24"}], "created": "2013-07-12 20:07:20"}, {"labels": ["bug"], "filteredCommits": ["7167ce8c37511f3ead33b786072cea3feafeb961", "599b419e743dc1e2ccd2ea71a274c686c71de08a"], "url": "https://github.com/jankotek/mapdb/issues/156", "gitStatsSummary": {"insertions": 8, "gitFilesChange": 1, "lines": 12, "deletions": 4}, "numCommits": 2, "commits": {"7167ce8c37511f3ead33b786072cea3feafeb961": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "599b419e743dc1e2ccd2ea71a274c686c71de08a": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 24.00027777777778, "user": "vtomanov", "changesInPackagesSPOON": ["org.mapdb.HTreeMap.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$LinkedNode)", "org.mapdb.HTreeMap.HashIterator.findNextLinkedNode(int)", "org.mapdb.HTreeMap.1.deserialize(java.io.DataInput,int)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "this code leads to endless loop...\n\n....\nprivate HTreeMap<String, Long> indexByHash;\nprivate DB recManIndexByHash = null;\n...\n\nrecManIndexByHash = DBMaker.newFileDB(new File(blockChainFolderPath + \"/\" + fileNameBlockTransactions)).closeOnJvmShutdown().randomAccessFileEnable().make();\n                indexByHash = recManIndexByHash.getHashMap(recordName);\n....\n\nCollection<Long> indexByHashValues = indexByHash.values();\n\nfor (Long l : indexByHashValues)\n{\n ..\n}\n\nif you give me a email I can send you the  data 22488 records\n\nemail : vt@b2net.net\nVasko\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 0, "TOT": 7, "DEL": 0, "INS": 4, "spoonFilesChanged": 1, "MOV": 3}, "title": "Iterator issue", "statsSkippedReason": "", "closed": "2013-08-02 11:00:38", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-07-13 12:54:19", "commitHash": "7167ce8c37511f3ead33b786072cea3feafeb961", "commitParents": ["599b419e743dc1e2ccd2ea71a274c686c71de08a"], "commitGHEventType": "referenced", "nameRev": "7167ce8c37511f3ead33b786072cea3feafeb961 tags/mapdb-0.9.4~65", "commitGitStats": [{"insertions": 5, "lines": 9, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 4}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.1.serialize(java.io.DataOutput,org.mapdb.HTreeMap$LinkedNode)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.HashIterator.findNextLinkedNode(int)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.HTreeMap.1.deserialize(java.io.DataInput,int)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Some stuff for #156; save byte per entry if ExpireLink is not used\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-07-13 12:54:19"}, {"commitUser": "jankotek", "commitDateTime": "2013-07-13 12:47:18", "commitHash": "599b419e743dc1e2ccd2ea71a274c686c71de08a", "commitParents": ["4b996af8d714bf858c0453fb57619e904a256fdf"], "commitGHEventType": "referenced", "nameRev": "599b419e743dc1e2ccd2ea71a274c686c71de08a tags/mapdb-0.9.4~66", "commitGitStats": [{"insertions": 3, "lines": 3, "filePath": "src/main/java/org/mapdb/HTreeMap.java", "deletions": 0}, {"insertions": 11, "lines": 11, "filePath": "src/test/java/org/mapdb/HTreeMap2Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap2Test.testSingleIter()"}], "spoonFilePath": "HTreeMap2Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.HTreeMap.HashIterator.findNextLinkedNode(int)"}], "spoonFilePath": "HTreeMap.java"}], "commitMessage": "Add some stuff to support #156\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-07-13 12:47:18"}], "created": "2013-07-08 14:54:45"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/155", "title": "Serial: j.u.TreeMap comparator may not be serialized", "closed": "2013-08-02 11:01:58", "commitsDetails": [], "commits": {}, "ttf": 35.000277777777775, "created": "2013-06-27 11:28:06", "user": "jankotek", "body": ""}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/154", "title": "Rollback doesn't affect removed items (MapDB 0.9.3)", "closed": "2013-06-25 19:07:59", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2013-06-24 21:42:22", "user": "diamondq", "body": "Removing an item in a transaction, then rolling back the transaction, doesn't show the item anymore (ie. the item removal was committed). This appears to happen with both Memory and File DB's.\n\n``` java\n        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();\n\n        /* Add the item */\n\n        DB db1 = txMaker.makeTx();\n        HTreeMap<Object, Object> map1 = db1.getHashMap(\"simple\");\n        map1.put(\"a\", \"b\");\n        db1.commit();\n\n        /* Remove the item */\n\n        DB db2 = txMaker.makeTx();\n        HTreeMap<Object, Object> map2 = db2.getHashMap(\"simple\");\n        Object result2 = map2.get(\"a\");\n        // Make sure the item is still there\n        if (\"b\".equals(result2) == false)\n            throw new IllegalArgumentException(\"The put was not persisted\");\n        map2.remove(\"a\");\n        // ROLLBACK the removal (in theory)\n        db2.rollback();\n\n        /* Check for the rolled back item */\n\n        DB db3 = txMaker.makeTx();\n        HTreeMap<Object, Object> map3 = db3.getHashMap(\"simple\");\n        Object result3 = map3.get(\"a\");\n        // ***************\n        // THIS IS WHERE IT FAILS, but the object should be the same, since it the remove was rolled back\n        // ***************\n        if (\"b\".equals(result3) == false)\n            throw new IllegalArgumentException(\"The remove was not rolled back\");\n\n        db3.close();\n```\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/153", "title": "exception on commit() after removing an entry, Win7", "closed": "2013-06-21 21:50:20", "commitsDetails": [], "commits": {}, "ttf": 0.0002777777777777778, "created": "2013-06-20 23:56:11", "user": "lucandrea", "body": "Hi, I am using the following construction for the DB:\n\n```\n  ConcurrentNavigableMap<String, byte[]> treeMap;\n\n  mapDB = DBMaker.newFileDB(new File(dbFileName))\n          .closeOnJvmShutdown()\n          .randomAccessFileEnable()\n          .asyncWriteDisable()\n          .make();\n\n  treeMap = mapDB.getTreeMap(userName);\n```\n\nAfter inserting, it calls:\n\ntreeMap.remove(key);\n\nMapDB throws an exception during the next commit():\n\nVerboseTestNG] java.lang.InternalError: unknown trans log instruction: 12 at log offset: 1679\n[VerboseTestNG]            at org.mapdb.StoreWAL.replayLogFile(StoreWAL.java:514)\n[VerboseTestNG]            at org.mapdb.StoreWAL.commit(StoreWAL.java:440)\n[VerboseTestNG]            at org.mapdb.EngineWrapper.commit(EngineWrapper.java:83)\n[VerboseTestNG]            at org.mapdb.EngineWrapper.commit(EngineWrapper.java:83)\n[VerboseTestNG]            at org.mapdb.DB.commit(DB.java:441)\n\nIf I disable the WAL (writeAheadLogDisable()) the program runs with no problems.\n"}, {"labels": ["bug"], "filteredCommits": ["f61cbbffd6b023b99f5d3c87c48bb57936adb823"], "url": "https://github.com/jankotek/mapdb/issues/149", "gitStatsSummary": {"insertions": 134, "gitFilesChange": 1, "lines": 209, "deletions": 75}, "numCommits": 1, "commits": {"f61cbbffd6b023b99f5d3c87c48bb57936adb823": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "klehmann", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.BTreeEntryIterator.next()", "org.mapdb.BTreeMap.valueIterator()", "org.mapdb.BTreeMap.size()", "org.mapdb.BTreeMap.SubMap.Iter", "org.mapdb.BTreeMap.entryIterator()", "org.mapdb.BTreeMap.SubMap.valueIterator()", "org.mapdb.BTreeMap.SubMap.entryIterator().3.next()", "org.mapdb.BTreeMap.BTreeValueIterator.next()", "org.mapdb.BTreeMap.BTreeIterator.remove()", "org.mapdb.BTreeMap.BTreeIterator.pointToStart()", "org.mapdb.BTreeMap.BTreeIterator", "org.mapdb.BTreeMap.BTreeEntryIterator", "org.mapdb.BTreeMap.BTreeIterator.moveToNext()", "org.mapdb.BTreeMap.SubMap.keyIterator()", "org.mapdb.BTreeMap.SubMap.keyIterator().1.next()", "org.mapdb.BTreeMap.BTreeKeyIterator.next()", "org.mapdb.BTreeMap.BTreeValueIterator", "org.mapdb.BTreeMap.findLargerNode(java.lang.Object,boolean)", "org.mapdb.BTreeMap.BTreeIterator.advance()", "org.mapdb.BTreeMap.SubMap.Iter.hasNext()", "org.mapdb.BTreeMap.keyIterator()", "org.mapdb.BTreeMap.BTreeKeyIterator", "org.mapdb.BTreeMap.SubMap.valueIterator().2.next()", "org.mapdb.BTreeMap.SubMap.Iter.advance()", "org.mapdb.BTreeMap.SubMap.entryIterator()", "org.mapdb.BTreeMap.SubMap.Iter.remove()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I tried to create a sub map of a BTreeMap and traversed its keys via BTreeMap.subMap(Object, boolean, Object, boolean).keySet().iterator(), but performance was a lot slower than going through the whole BTreeMap.keySet().iterator()  (e.g. 670ms instead of 80ms for 40.000 entries).\nIf possible, it would be good to have an improved key iterator for this purpose, even if it is not compatible with the JDK Map class.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 26, "UPD": 29, "TOT": 113, "DEL": 8, "INS": 39, "spoonFilesChanged": 1, "MOV": 37}, "title": "BTreeMap.subMap(...).keySet().iterator() slow", "statsSkippedReason": "", "closed": "2013-06-14 12:59:38", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-06-14 13:59:32", "commitHash": "f61cbbffd6b023b99f5d3c87c48bb57936adb823", "commitParents": ["6a4852f365b0b5bc73fab1a61433148e32d7cdd4"], "commitGHEventType": "closed", "nameRev": "f61cbbffd6b023b99f5d3c87c48bb57936adb823 tags/mapdb-0.9.4~112", "commitGitStats": [{"insertions": 134, "lines": 209, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 75}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 1, "TOT": 7, "DEL": 0, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.BTreeMap.BTreeIterator.moveToNext()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.valueIterator()"}, {"UPD": 0, "TOT": 7, "DEL": 0, "INS": 7, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeIterator.pointToStart()"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.size()"}, {"UPD": 3, "TOT": 6, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.Iter.advance()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.Iter"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.entryIterator()"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.valueIterator()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.entryIterator().3.next()"}, {"UPD": 1, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeValueIterator.next()"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.BTreeIterator.remove()"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeKeyIterator"}, {"UPD": 5, "TOT": 30, "DEL": 1, "INS": 6, "MOV": 18, "spoonMethodName": "org.mapdb.BTreeMap.BTreeIterator"}, {"UPD": 1, "TOT": 6, "DEL": 0, "INS": 5, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeEntryIterator"}, {"UPD": 1, "TOT": 5, "DEL": 2, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeEntryIterator.next()"}, {"UPD": 0, "TOT": 3, "DEL": 1, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.keyIterator()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.keyIterator()"}, {"UPD": 1, "TOT": 5, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeValueIterator"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.findLargerNode(java.lang.Object,boolean)"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeIterator.advance()"}, {"UPD": 2, "TOT": 4, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.Iter.hasNext()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.BTreeKeyIterator.next()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.valueIterator().2.next()"}, {"UPD": 1, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.keyIterator().1.next()"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.entryIterator()"}, {"UPD": 4, "TOT": 7, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.BTreeMap.SubMap.Iter.remove()"}], "spoonFilePath": "BTreeMap.java"}], "commitMessage": "Fix #149, BTreeMap.subMap(...).keySet().iterator() slow\n\nUnify map and submap iterators.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-06-14 13:59:32"}], "created": "2013-06-13 17:30:39"}, {"labels": ["bug"], "filteredCommits": ["700d81239a72f70492a2ad9ce41d528d441747ac"], "url": "https://github.com/jankotek/mapdb/issues/148", "gitStatsSummary": {"insertions": 6, "gitFilesChange": 1, "lines": 7, "deletions": 1}, "numCommits": 1, "commits": {"700d81239a72f70492a2ad9ce41d528d441747ac": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "dev13", "changesInPackagesSPOON": ["org.mapdb.StoreAppend.replayLog()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I did some test using MapDB::HTreeMap about how works when replacing values for a key.\n\n I create mapdb and new HTreeMap with custom value class using custom value serializer. Before closing that db, I put some data and did replace the value for a key to new one. The Result of dumping contents of the db looked fine.\n\n But once it closed, any change of HTreeMap getting from that mapdb re-opened is not reflected.\n\nPlease give a word for this result.\n\n==Here is my code snippet==\n\n/*\\* main code _/\nimport java.io._;\nimport java.util._;\nimport org.mapdb._;\n\npublic class ReplaceTest {\n\n```\npublic static void main(String[] args){\n\n    // 1 : Create HTreeMap, put some values , Commit and Close;\n    File mapdbFile = new File(\"mabdb\");\n    DB mapdb = DBMaker.newAppendFileDB(mapdbFile).closeOnJvmShutdown().make();\n\n    Serializer<CustomValue> valueSerializer = new CustomValueSerializer();\n    HTreeMap<String, CustomValue> users = mapdb.createHashMap(\"users\", true, null, valueSerializer);\n    users.put(\"jhon\", new CustomValue(\"jhon\",  32));\n    users.put(\"mike\", new CustomValue(\"mike\",  30));\n    mapdb.commit();\n\n    System.out.println(\"Create and Fisrt Put [\\\"jhon\\\"->32, \\\"mike\\\"->30]\");\n    dumpUserDB(users);\n\n    users.replace(\"mike\", new CustomValue(\"mike\",  33));\n    mapdb.commit();\n\n    System.out.println(\"Replace Before Close : [\\\"mike\\\"->33] looks as works\");\n    dumpUserDB(users);\n\n    mapdb.close();\n\n\n    // 2 : Open HTreeMap, replace some values , Commit and Close;\n    mapdb = DBMaker.newAppendFileDB(mapdbFile).closeOnJvmShutdown().make();\n    users = mapdb.getHashMap(\"users\");\n\n    System.out.println(\"Just Reopen : all values ar good\");\n    dumpUserDB(users);\n\n    users.replace(\"jhon\", new CustomValue(\"jhon\", 31));\n    mapdb.commit();\n    System.out.println(\"Do Replacement on Reopen : [\\\"jhon\\\"->31] looks as works\");\n    dumpUserDB(users);\n    mapdb.close();\n\n\n    // 3 : Open HTreeMap, Dump\n    mapdb = DBMaker.newAppendFileDB(mapdbFile).closeOnJvmShutdown().make();\n    users = mapdb.getHashMap(\"users\");\n    System.out.println(\"But final value is not changed\");\n    dumpUserDB(users);\n    mapdb.close();\n\n}\n\n\npublic static void dumpUserDB(HTreeMap<String, CustomValue> users){\n\n    Set<String> keyset = users.keySet();\n    if(keyset==null){\n        return;\n    }\n\n    for( String key : keyset ){\n        CustomValue cv = users.get(key);\n        System.out.format(\"%s(%b) : %d\\n\", key, key.equals(cv.name), cv.age);\n    }\n\n    System.out.println(\"\");\n}\n```\n\n}\n\n/*\\* Custom Value and Serializer **/\n\npublic class CustomValue implements Serializable {\n\n```\nprivate static final long serialVersionUID = -7585177565368493580L;\nfinal String name;\nfinal int age;\n\npublic CustomValue(String name, int age){\n\n    this.name = name;\n    this.age = age;\n}\n\n@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + age;\n    result = prime * result + ((name == null) ? 0 : name.hashCode());\n    return result;\n}\n\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    CustomValue other = (CustomValue) obj;\n    if (age != other.age)\n        return false;\n    if (name == null) {\n        if (other.name != null)\n            return false;\n    } else if (!name.equals(other.name))\n        return false;\n    return true;\n}\n```\n\n}\n\npublic class CustomValueSerializer implements Serializer<CustomValue>, Serializable {\n\n```\nprivate static final long serialVersionUID = -6987588810823227467L;\n\npublic void serialize(DataOutput out, CustomValue value) throws IOException {\n\n    out.writeUTF(value.name);\n    out.writeInt(value.age);\n}\n\npublic CustomValue deserialize(DataInput in, int available)\n        throws IOException {\n\n    return new CustomValue( in.readUTF(), in.readInt() );\n}\n```\n\n}\n\n================ My Code Snippet======================\n\nThanks to develop MapDB\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 5, "DEL": 1, "INS": 1, "spoonFilesChanged": 1, "MOV": 3}, "title": "HTreeMap replace methods not works after closing DB ", "statsSkippedReason": "", "closed": "2013-06-13 12:03:05", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-06-13 13:02:58", "commitHash": "700d81239a72f70492a2ad9ce41d528d441747ac", "commitParents": ["e4945e6b20dc7a610990efe10559ab5c787d297c"], "commitGHEventType": "closed", "nameRev": "700d81239a72f70492a2ad9ce41d528d441747ac tags/mapdb-0.9.4~117", "commitGitStats": [{"insertions": 173, "lines": 173, "filePath": "src/test/java/org/mapdb/Issue148Test.java", "deletions": 0}, {"insertions": 6, "lines": 7, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue148Test"}], "spoonFilePath": "Issue148Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 1, "INS": 1, "MOV": 3, "spoonMethodName": "org.mapdb.StoreAppend.replayLog()"}], "spoonFilePath": "StoreAppend.java"}], "commitMessage": "Fix #148, StoreAppend would not handle multiple commit&reopen.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-06-13 13:02:58"}], "created": "2013-06-13 04:46:19"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/147", "title": "NoSuchFieldError during serialization", "closed": "2013-06-14 04:55:27", "commitsDetails": [], "commits": {}, "ttf": 1.0002777777777778, "created": "2013-06-13 00:30:20", "user": "jmgrosen", "body": "When trying to load an object back in, I get this error:\n\n``` java\njava.lang.NoSuchFieldError: class com.example.Thing.foo\n        at org.mapdb.SerializerPojo.setFieldValue(SerializerPojo.java:444)\n        at org.mapdb.SerializerPojo.deserializeUnknownHeader(SerializerPojo.java:537)\n        at org.mapdb.SerializerBase.deserialize(SerializerBase.java:1192)\n        at org.mapdb.SerializerBase.deserialize(SerializerBase.java:761)\n        at org.mapdb.BTreeMap$1.deserialize(BTreeMap.java:406)\n        at org.mapdb.BTreeMap$1.deserialize(BTreeMap.java:286)\n        at org.mapdb.StoreDirect.get2(StoreDirect.java:236)\n        at org.mapdb.StoreWAL.get2(StoreWAL.java:194)\n        at org.mapdb.StoreWAL.get(StoreWAL.java:181)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n        at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:309)\n        at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n        at org.mapdb.CacheHashTable.get(CacheHashTable.java:92)\n        at org.mapdb.BTreeMap$BTreeIterator.<init>(BTreeMap.java:814)\n        at org.mapdb.BTreeMap$BTreeKeyIterator.<init>(BTreeMap.java:952)\n        at org.mapdb.BTreeMap.keyIterator(BTreeMap.java:1424)\n        at org.mapdb.BTreeMap$KeySet.iterator(BTreeMap.java:1523)\n        at com.example.StorageManager.getAllThings(StorageManager.java:125)\n        ...\n```\n\nprefaced by:\n\n``` java\njava.lang.IllegalArgumentException: invalid value for field\n        at java.lang.reflect.Field.setField(Native Method)\n        at java.lang.reflect.Field.set(Field.java:588)\n        at org.mapdb.SerializerPojo.setFieldValue(SerializerPojo.java:437)\n        at org.mapdb.SerializerPojo.deserializeUnknownHeader(SerializerPojo.java:537)\n        ...as above\n```\n\nI should also note that this is on Android, although I don't see why that would make a difference. I'm using 0.9.3, but I didn't see any commits that would have changed this. Help?\n"}, {"labels": ["bug"], "filteredCommits": ["84cc790e6f0bb37b9ff837034a3ac5f47a18b624"], "url": "https://github.com/jankotek/mapdb/issues/136", "gitStatsSummary": {"insertions": 1, "gitFilesChange": 1, "lines": 4, "deletions": 3}, "numCommits": 1, "commits": {"84cc790e6f0bb37b9ff837034a3ac5f47a18b624": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 2.000277777777778, "user": "robshep", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.rollback()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Hi,\n\nI find an occasional error with starting MapDB.\n\nHere is the stacktrace:\n\n```\nCaused by: java.lang.InternalError: data were not fully read, check your serializier 16760\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:233)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:192)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:179)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n    at org.mapdb.CacheHashTable.get(CacheHashTable.java:92)\n    at org.mapdb.HTreeMap.get(HTreeMap.java:424)\n    at org.mapdb.DB.getTreeMap(DB.java:179)\n    at solarfields.ModuleActivityService.initialise(ModuleActivityService.groovy:110)\n```\n\nhere is my setup code: \n\n```\nlog.fatal('initialise user activty cache')\nFile cacheFile = new File(path)\ndb = DBMaker.newFileDB(cacheFile).closeOnJvmShutdown().asyncWriteDisable().make();\nupdates = db.getTreeMap(\"updates\")\nuserObserves = db.getTreeMap(\"userObserves\")\n```\n\nMy usage of mapDB is for storing updates and observations of particular entities to determine if some has changed since a user last viewed an item.\n\nIt works great - however Occasionally when starting the app with an existing file-set, I see the following error.  The only way to proceed is to delete the file-set. \n\nI don't need the data-store to be 100% consistent (mem->file) but I do need it to be crash resistant and recover from \"some\" point in time.\n\nI have periodic jobs as follows\n\n```\nsynchronized void commitDB() {\n    db.commit() // @2mins\n}\n\nsynchronized void compactDB() {\n    db.compact() // @10mins\n}\n```\n\nWiping the data will not be a suitable workaround for when the applciation goes live.\n\nI currently use TreeMaps using Strings as keys and Dates as values. I do not supply any custom serialisers - just the code that you see.\n\nI cannot tell the situation that causes the failure to occur - it is only occasional during dev-restarts (many times a day) - and probably occurs around 1 in 5 restarts.\n\nIt may be that I am using MapDB incorrectly for my usage - so in this case, apologies for the issue report.\n\nBest regards - and Thanks for MapDB!\n\nRob\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "spoonFilesChanged": 1, "MOV": 1}, "title": "Occasional: Internal Error ", "statsSkippedReason": "", "closed": "2013-05-30 17:02:10", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-05-30 17:58:49", "commitHash": "84cc790e6f0bb37b9ff837034a3ac5f47a18b624", "commitParents": ["aa792e8307e103a2a6537940a516e8f637240d38"], "commitGHEventType": "referenced", "nameRev": "84cc790e6f0bb37b9ff837034a3ac5f47a18b624 tags/mapdb-0.9.3~9", "commitGitStats": [{"insertions": 1, "lines": 4, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.StoreWAL.rollback()"}], "spoonFilePath": "StoreWAL.java"}], "commitMessage": "Fix Issue #136, InternalError on commit and reopen\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-05-30 17:58:49"}], "created": "2013-05-28 15:40:22"}, {"labels": ["bug"], "filteredCommits": ["249b5a87780b7740862f601b0ddc3128b8b7c1ea"], "url": "https://github.com/jankotek/mapdb/issues/132", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 3, "deletions": 0}, "numCommits": 1, "commits": {"249b5a87780b7740862f601b0ddc3128b8b7c1ea": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 6.000277777777778, "user": "konrade", "changesInPackagesSPOON": ["org.mapdb.StoreWAL.rollback()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "It seems like something gets corrupt in HTreeMap (when used as Set) when doing inserts in a sequence with rollbacks and commits.\n\nCode to reproduce the problem (on MapDB 0.9.2):\nhttps://gist.github.com/konrade/5608771\n\nException thrown:\nException in thread \"main\" java.lang.InternalError: data were not fully read, check your serializier 16920\n    at org.mapdb.StoreDirect.get2(StoreDirect.java:232)\n    at org.mapdb.StoreWAL.get2(StoreWAL.java:189)\n    at org.mapdb.StoreWAL.get(StoreWAL.java:176)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n    at org.mapdb.HTreeMap$HashIterator.findNextLinkedNodeRecur(HTreeMap.java:996)\n    at org.mapdb.HTreeMap$HashIterator.findNextLinkedNodeRecur(HTreeMap.java:1026)\n    at org.mapdb.HTreeMap$HashIterator.findNextLinkedNodeRecur(HTreeMap.java:1026)\n    at org.mapdb.HTreeMap$HashIterator.findNextLinkedNodeRecur(HTreeMap.java:1026)\n    at org.mapdb.HTreeMap$HashIterator.findNextLinkedNode(HTreeMap.java:984)\n    at org.mapdb.HTreeMap$HashIterator.<init>(HTreeMap.java:908)\n    at org.mapdb.HTreeMap$KeyIterator.<init>(HTreeMap.java:1038)\n    at org.mapdb.HTreeMap$3.iterator(HTreeMap.java:766)\n    at com.konraderiksson.TestMapDBRollback.expectCount(TestMapDBRollback.java:42)\n    at com.konraderiksson.TestMapDBRollback.<init>(TestMapDBRollback.java:36)\n    at com.konraderiksson.TestMapDBRollback.main(TestMapDBRollback.java:57)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "spoonFilesChanged": 1, "MOV": 0}, "title": "Inconsistency in HTreeMap after rollback+commit sequence", "statsSkippedReason": "", "closed": "2013-05-26 16:36:12", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-05-26 17:21:19", "commitHash": "249b5a87780b7740862f601b0ddc3128b8b7c1ea", "commitParents": ["195a182c326451af723f91cd322ca3b67dee1d40"], "commitGHEventType": "referenced", "nameRev": "249b5a87780b7740862f601b0ddc3128b8b7c1ea tags/mapdb-0.9.3~14", "commitGitStats": [{"insertions": 3, "lines": 3, "filePath": "src/main/java/org/mapdb/StoreWAL.java", "deletions": 0}, {"insertions": 100, "lines": 100, "filePath": "src/test/java/org/mapdb/Issue132Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StoreWAL.rollback()"}], "spoonFilePath": "StoreWAL.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue132Test"}], "spoonFilePath": "Issue132Test.java"}], "commitMessage": "Fix issue #132 : Inconsistency in HTreeMap after rollback+commit sequence\n\nForgot to clear info on rollback\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-05-26 17:21:19"}], "created": "2013-05-19 20:02:07"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/120", "title": "Temp files not getting deleted after close", "closed": "2013-04-13 12:59:09", "commitsDetails": [], "commits": {}, "ttf": 2.000277777777778, "created": "2013-04-11 01:10:11", "user": "pg93162", "body": "I am using mapdb-0.9.0.jar and noticed that when a new database is created, mapdb also creates a .p file which is not always deleted when the database is closed. It seems there are still some open references to this file that's preventing its deletion.\n\nHere is the pseudo code I am using:\n\n```\n        File tempFile = File.createTempFile(\"markedFiles\", null);\n        db = DBMaker.newFileDB(tempFile)\n                .writeAheadLogDisable()\n                .deleteFilesAfterClose()\n                .make();\n        Set s = db.createTreeSet(\"markedFiles\", 32, false, null, null);\n        db.close();\n```\n"}, {"labels": ["bug"], "filteredCommits": ["c0ddea1d9235497c99f252d0674c32ed30277520", "0c1d4435faa95836cba06b50595c96b0b9dbbba1"], "url": "https://github.com/jankotek/mapdb/issues/119", "gitStatsSummary": {"insertions": 43, "gitFilesChange": 2, "lines": 46, "deletions": 3}, "numCommits": 2, "commits": {"0c1d4435faa95836cba06b50595c96b0b9dbbba1": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "c0ddea1d9235497c99f252d0674c32ed30277520": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 7.000277777777778, "user": "Yrlec", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)", "org.mapdb.Utils.unlockAll(org.mapdb.LongConcurrentHashMap)", "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)", "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)", "org.mapdb.Utils.assertNoLocks(org.mapdb.LongConcurrentHashMap)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Sometimes I get the following exception when I call put on a BTreeMap. \n\njava.lang.InternalError: node already locked by current thread: 24\n    at org.mapdb.Utils.lock(Utils.java:349)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:641)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:599)\n\nUnfortunately I don't have an easily reproducible test-case. I will let you know if I manage to create one.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 6, "UPD": 0, "TOT": 21, "DEL": 1, "INS": 5, "spoonFilesChanged": 2, "MOV": 15}, "title": "Lock issue when calling put", "statsSkippedReason": "", "closed": "2013-04-17 22:55:24", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-04-13 15:25:11", "commitHash": "0c1d4435faa95836cba06b50595c96b0b9dbbba1", "commitParents": ["f2fc046bf15094f12d35ca744e33cd2a6098d189"], "commitGHEventType": "referenced", "nameRev": "0c1d4435faa95836cba06b50595c96b0b9dbbba1 tags/mapdb-0.9.1~2", "commitGitStats": [{"insertions": 2, "lines": 3, "filePath": "src/main/java/org/mapdb/Utils.java", "deletions": 1}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 1, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.Utils.assertNoLocks(org.mapdb.LongConcurrentHashMap)"}], "spoonFilePath": "Utils.java"}], "commitMessage": "add assertion for issue #119\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-13 15:25:11"}, {"commitUser": "jankotek", "commitDateTime": "2013-04-17 23:51:03", "commitHash": "c0ddea1d9235497c99f252d0674c32ed30277520", "commitParents": ["d6f389716821a3ecf9d3727bf8770ddf5ac0bad1"], "commitGHEventType": "referenced", "nameRev": "c0ddea1d9235497c99f252d0674c32ed30277520 tags/mapdb-0.9.2~35", "commitGitStats": [{"insertions": 8, "lines": 8, "filePath": "src/main/java/org/mapdb/Utils.java", "deletions": 0}, {"insertions": 33, "lines": 35, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 7, "DEL": 0, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 1, "MOV": 5, "spoonMethodName": "org.mapdb.BTreeMap.replace(java.lang.Object,java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.remove2(java.lang.Object,java.lang.Object)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.put2(java.lang.Object,java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Utils.unlockAll(org.mapdb.LongConcurrentHashMap)"}], "spoonFilePath": "Utils.java"}], "commitMessage": "Possible fix for #119 - BTreeMap does not release locks if exception happens\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-17 23:51:03"}], "created": "2013-04-10 12:02:30"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/118", "title": "FileNotFoundException when calling org.mapdb.BTreeMap.put", "closed": "2013-05-19 16:15:14", "commitsDetails": [], "commits": {}, "ttf": 39.000277777777775, "created": "2013-04-10 12:01:46", "user": "Yrlec", "body": "Sometimes I get the following exception when I call put on a BTreeMap. \n\njava.io.IOError: java.io.FileNotFoundException: databases-FileDataBlockTest\\SN\\SN.t (\u00c5tkomst nekad)\n    at org.mapdb.Volume$MappedFileVol.<init>(Volume.java:435)\n    at org.mapdb.Volume.volumeForFile(Volume.java:140)\n    at org.mapdb.Volume$1.createTransLogVolume(Volume.java:170)\n    at org.mapdb.StoreWAL.openLogIfNeeded(StoreWAL.java:63)\n    at org.mapdb.StoreWAL.update(StoreWAL.java:227)\n    at org.mapdb.EngineWrapper$ByteTransformEngine.update(EngineWrapper.java:213)\n    at org.mapdb.EngineWrapper.update(EngineWrapper.java:55)\n    at org.mapdb.SnapshotEngine.update(SnapshotEngine.java:81)\n    at org.mapdb.CacheHashTable.update(CacheHashTable.java:106)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:665)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:599)\n\nUnfortunately I don't have an easily reproducible test-case. I will let you know if I manage to create one.\n"}, {"labels": ["bug"], "filteredCommits": ["7de378271c651a4c59f0e4700564a0572d445b97"], "url": "https://github.com/jankotek/mapdb/issues/111", "gitStatsSummary": {"insertions": 4, "gitFilesChange": 3, "lines": 7, "deletions": 3}, "numCommits": 1, "commits": {"7de378271c651a4c59f0e4700564a0572d445b97": {"commitUser": "jankotek", "commitGHEventType": "closed"}}, "ttf": 0.0002777777777777778, "user": "wcarus", "changesInPackagesSPOON": ["org.mapdb.StoreDirect.compact()", "org.mapdb.Volume.ByteBufferVol.ensureAvailable(long)", "org.mapdb.AsyncWriteEngine.rollback()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "For large data sets the DB.compact() method in mapdb-0.9-20130401.190504-65.jar fails with java.lang.IndexOutOfBoundsException. The following is the error message after adding 100k entries to a TreeSet and running compact() on the resulting data store. (This example is run from Jython.) I have not been able to duplicate this behavior with small data sets (hundred or thousands of entries).\n\n> > > kvts.DB.compact()  \n> > > Traceback (most recent call last):\n> > >   File \"<stdin>\", line 1, in <module>\n> > >     at java.nio.Buffer.checkIndex(Buffer.java:538)\n> > >     at java.nio.DirectByteBuffer.putLong(DirectByteBuffer.java:796)\n> > >     at org.mapdb.Volume$ByteBufferVol.putLong(Volume.java:265)\n> > >     at org.mapdb.StoreDirect.put2(StoreDirect.java:140)\n> > >     at org.mapdb.StoreDirect.compact(StoreDirect.java:480)\n> > >     at org.mapdb.EngineWrapper.compact(EngineWrapper.java:99)\n> > >     at org.mapdb.EngineWrapper.compact(EngineWrapper.java:99)\n> > >     at org.mapdb.EngineWrapper.compact(EngineWrapper.java:99)\n> > >     at org.mapdb.DB.compact(DB.java:422)\n> > >     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n> > >     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n> > >     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n> > >     at java.lang.reflect.Method.invoke(Method.java:601)\n\njava.lang.IndexOutOfBoundsException: java.lang.IndexOutOfBoundsException\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 3, "UPD": 1, "TOT": 5, "DEL": 0, "INS": 3, "spoonFilesChanged": 3, "MOV": 1}, "title": "DB.compact() method fails with large data sets", "statsSkippedReason": "", "closed": "2013-04-02 22:20:14", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-04-02 23:20:05", "commitHash": "7de378271c651a4c59f0e4700564a0572d445b97", "commitParents": ["6459ff23dbff54b165ad21be661a95c90ec26654"], "commitGHEventType": "closed", "nameRev": "7de378271c651a4c59f0e4700564a0572d445b97 tags/mapdb-0.9.1~25", "commitGitStats": [{"insertions": 2, "lines": 4, "filePath": "src/main/java/org/mapdb/AsyncWriteEngine.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 1}, {"insertions": 1, "lines": 1, "filePath": "src/main/java/org/mapdb/StoreDirect.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreDirect.compact()"}], "spoonFilePath": "StoreDirect.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.Volume.ByteBufferVol.ensureAvailable(long)"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 1, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.AsyncWriteEngine.rollback()"}], "spoonFilePath": "AsyncWriteEngine.java"}], "commitMessage": "Fix #111 DB.compact() method fails with large data sets\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-02 23:20:05"}], "created": "2013-04-02 03:31:07"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/107", "title": "NullPointerException", "closed": "2013-04-03 23:32:17", "commitsDetails": [], "commits": {}, "ttf": 2.000277777777778, "created": "2013-04-01 17:33:43", "user": "Yrlec", "body": "After upgrading to the latest Maven snapshot (upgraded today) I am occasionally getting NullPointerExceptions when opening the db. Here's the stack-trace:\n\nCaused by: java.lang.NullPointerException: null\n    at org.mapdb.Volume$ByteBufferVol.getLong(:299) \n    at org.mapdb.StoreDirect.checkHeaders(:104) \n    at org.mapdb.StoreDirect.<init>(:92) \n    at org.mapdb.StoreWAL.<init>(:40) \n    at org.mapdb.DBMaker.makeEngine(:572) \n    at org.mapdb.DBMaker.make(:546)\n\nI am creating the db like this:\n\nDB db = dbMaker\n        .closeOnJvmShutdown()\n        .asyncWriteDisable()\n        .cacheSoftRefEnable()\n        .checksumEnable()\n        .make();\n\nAny idea on what might cause this?\n"}, {"labels": ["bug"], "filteredCommits": ["994cc73ca2378c4f9462a56cb53da547597e478d", "826cbf2b64b9aff4c7983acbe946a979b4f2ce35"], "url": "https://github.com/jankotek/mapdb/issues/90", "gitStatsSummary": {"insertions": 14, "gitFilesChange": 2, "lines": 21, "deletions": 7}, "numCommits": 1, "commits": {"994cc73ca2378c4f9462a56cb53da547597e478d": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "826cbf2b64b9aff4c7983acbe946a979b4f2ce35": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 5.000277777777778, "user": "GuidoDechamps", "changesInPackagesSPOON": ["org.mapdb.CompressLZF.1.serialize(java.io.DataOutput,byte[])", "org.mapdb.DBMaker.makeEngine()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Using a disabled cache throws an exception when a counter is bound to a map.\nReproduced in test below\n\n``` java\nimport org.junit.Test;\nimport org.mapdb.*;\nimport java.io.File;\n\npublic class MapDBIndexExceptionTest {\n\n    @Test\n    public void testCounter() throws Exception {\n        final DB mapDb = createTempMapDb();\n        final Atomic.Long myCounter = Atomic.getLong(mapDb, \"MyCounter\");\n\n        final BTreeMap<String, Fun.Tuple2<String, Integer>> treeMap = mapDb.getTreeMap(\"map\");\n        Bind.size(treeMap, myCounter);\n\n        for (int i = 0; i < 3; i++) {\n            treeMap.put(\"key_\" + i, new Fun.Tuple2<String, Integer>(\"value_\", i));\n        }\n    }\n\n\n    private DB createTempMapDb() throws Exception {\n        final File wordDataFile = Utils.tempDbFile();\n        return createMapDB(wordDataFile);\n    }\n\n    private DB createMapDB(File file) {\n        return DBMaker.newAppendFileDB(file)\n                .closeOnJvmShutdown()\n                .compressionEnable()\n                //This is the cause of the exception. If cache is use, no exception occurs.\n                .cacheDisable()\n                .make();\n    }\n\n}\n```\n\nThis results in \n\njava.lang.IndexOutOfBoundsException\n    at java.nio.Buffer.checkIndex(Buffer.java:538)\n    at java.nio.HeapByteBuffer.getLong(HeapByteBuffer.java:410)\n    at org.mapdb.DataInput2.readLong(DataInput2.java:105)\n    at org.mapdb.Serializer$2.deserialize(Serializer.java:89)\n    at org.mapdb.Serializer$2.deserialize(Serializer.java:81)\n    at org.mapdb.EngineWrapper$ByteTransformEngine.get(EngineWrapper.java:199)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n    at org.mapdb.Atomic$Long.get(Atomic.java:445)\n    at org.mapdb.Atomic$Long.incrementAndGet(Atomic.java:536)\n    at org.mapdb.Bind$2.update(Bind.java:70)\n    at org.mapdb.BTreeMap.notify(BTreeMap.java:2143)\n    at org.mapdb.BTreeMap.put2(BTreeMap.java:690)\n    at org.mapdb.BTreeMap.put(BTreeMap.java:577)\n        at MapDBIndexExceptionTest.testCounter(MapDBIndexExceptionTest.java:25)\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 6, "DEL": 0, "INS": 3, "spoonFilesChanged": 2, "MOV": 3}, "title": "Compression+counters do not work (was Binding counter throws IndexOutOfBoundsException)", "statsSkippedReason": "", "closed": "2013-04-01 12:08:25", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-03-31 13:37:06", "commitHash": "994cc73ca2378c4f9462a56cb53da547597e478d", "commitParents": ["4e428b3d514575952aa0decb2607f9a6950d4e39"], "commitGHEventType": "referenced", "nameRev": "994cc73ca2378c4f9462a56cb53da547597e478d tags/mapdb-0.9.0~11", "commitGitStats": [{"insertions": 37, "lines": 37, "filePath": "src/test/java/org/mapdb/Issue90Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue90Test"}], "spoonFilePath": "Issue90Test.java"}], "commitMessage": "Add test for Issue #90\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-03-31 13:37:06"}, {"commitUser": "jankotek", "commitDateTime": "2013-04-01 12:54:33", "commitHash": "826cbf2b64b9aff4c7983acbe946a979b4f2ce35", "commitParents": ["ac0498bd31c20cc8b5e981ee5da7ffc8551d4c0b"], "commitGHEventType": "referenced", "nameRev": "826cbf2b64b9aff4c7983acbe946a979b4f2ce35 tags/mapdb-0.9.0~8", "commitGitStats": [{"insertions": 10, "lines": 25, "filePath": "src/test/java/org/mapdb/Issue90Test.java", "deletions": 15}, {"insertions": 6, "lines": 7, "filePath": "src/main/java/org/mapdb/CompressLZF.java", "deletions": 1}, {"insertions": 8, "lines": 14, "filePath": "src/main/java/org/mapdb/DBMaker.java", "deletions": 6}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 4, "DEL": 0, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.CompressLZF.1.serialize(java.io.DataOutput,byte[])"}], "spoonFilePath": "CompressLZF.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 2, "spoonMethodName": "org.mapdb.DBMaker.makeEngine()"}], "spoonFilePath": "DBMaker.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 2, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue90Test.testCounter()"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Issue90Test.createTempMapDb()"}, {"UPD": 0, "TOT": 2, "DEL": 1, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.Issue90Test.createMapDB(java.io.File)"}], "spoonFilePath": "Issue90Test.java"}], "commitMessage": "Fix Issue #90, serialization was failing with compression enabled.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-01 12:54:33"}], "created": "2013-03-27 07:30:23"}, {"labels": ["bug"], "filteredCommits": ["acd38a6452bea5ae8c259cf5b992fec3a7820985"], "url": "https://github.com/jankotek/mapdb/issues/89", "gitStatsSummary": {"insertions": 9, "gitFilesChange": 1, "lines": 16, "deletions": 7}, "numCommits": 1, "commits": {"acd38a6452bea5ae8c259cf5b992fec3a7820985": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 8.000277777777777, "user": "GuidoDechamps", "changesInPackagesSPOON": ["org.mapdb.StoreAppend.getNoLock(long,org.mapdb.Serializer)", "org.mapdb.StoreAppend.replayLog()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Running the test below twice results in an exception. The first run is ok. The second  or third run, trying to append to an existing datafile, often fails.\n\nThe resulting error is \n\njava.lang.InternalError\n    at org.mapdb.StorageAppend.replayLog(StorageAppend.java:91)\n    at org.mapdb.StorageAppend.<init>(StorageAppend.java:57)\n    at org.mapdb.DBMaker.makeEngine(DBMaker.java:577)\n    at org.mapdb.DBMaker.make(DBMaker.java:546)\n    at MapDBAppendTest.createMapDB(MapDBAppendTest.java:34) \n\n``` java\npublic class MapDBAppendTest {\n\n    @Test\n    public void testAppend() throws Exception {\n        final DB myTestDataFile = createMapDB(\"myTestDataFile\");\n        final NavigableSet<Object> testTreeSet = myTestDataFile.getTreeSet(\"TestTreeSet\");\n        testTreeSet.add(\"DummyContent\");\n        myTestDataFile.commit();\n    }\n\n    public DB createMapDB(String fileName) {\n        final File file = new File(fileName);\n        return createMapDB(file);\n    }\n\n    public DB createMapDB(File file) {\n        Preconditions.checkNotNull(file);\n        return DBMaker.newAppendFileDB(file)\n                .compressionEnable()\n                .closeOnJvmShutdown()\n                .make();\n    }\n}\n```\n\nLet me also point out that when i initially forgot the commit line in my quick test, this results in the error:\n\njava.lang.NullPointerException\n    at org.mapdb.Volume$ByteBufferVol.getLong(Volume.java:278)\n    at org.mapdb.StorageAppend.getNoLock(StorageAppend.java:200)\n    at org.mapdb.StorageAppend.get(StorageAppend.java:188)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n    at org.mapdb.AsyncWriteEngine.get(AsyncWriteEngine.java:163)\n    at org.mapdb.EngineWrapper$ByteTransformEngine.get(EngineWrapper.java:193)\n    at org.mapdb.EngineWrapper.get(EngineWrapper.java:50)\n    at org.mapdb.CacheHashTable.get(CacheHashTable.java:85)\n    at org.mapdb.DB.<init>(DB.java:49)\n    at org.mapdb.DBMaker.make(DBMaker.java:546)\n    at MapDBAppendTest.createMapDB(MapDBAppendTest.java:33) \n\nInvoking the commit solves this. Just in case someone else encounters this. The exception handling has some room for improvement here i think.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 2, "UPD": 0, "TOT": 19, "DEL": 9, "INS": 10, "spoonFilesChanged": 1, "MOV": 0}, "title": "Storage append to an existing file fails.", "statsSkippedReason": "", "closed": "2013-04-04 00:06:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-04-04 01:06:00", "commitHash": "acd38a6452bea5ae8c259cf5b992fec3a7820985", "commitParents": ["88f3f0cc854aa9871f009b2cdec3bc6b63b119d8"], "commitGHEventType": "referenced", "nameRev": "acd38a6452bea5ae8c259cf5b992fec3a7820985 tags/mapdb-0.9.1~21", "commitGitStats": [{"insertions": 9, "lines": 16, "filePath": "src/main/java/org/mapdb/StoreAppend.java", "deletions": 7}, {"insertions": 77, "lines": 77, "filePath": "src/test/java/org/mapdb/Issue89Test.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Issue89Test"}], "spoonFilePath": "Issue89Test.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 18, "DEL": 9, "INS": 9, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.replayLog()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StoreAppend.getNoLock(long,org.mapdb.Serializer)"}], "spoonFilePath": "StoreAppend.java"}], "commitMessage": "Fix Issue #89, StoreAppend reopening failed\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-04 01:06:00"}], "created": "2013-03-26 14:15:11"}, {"labels": ["bug"], "filteredCommits": ["97d73671867b262f477802d46084e8bff59063bf"], "url": "https://github.com/jankotek/mapdb/issues/50", "gitStatsSummary": {"insertions": 3, "gitFilesChange": 1, "lines": 5, "deletions": 2}, "numCommits": 1, "commits": {"97d73671867b262f477802d46084e8bff59063bf": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 8.000277777777777, "user": "csm", "changesInPackagesSPOON": ["org.mapdb.BTreeMap.findLarger(java.lang.Object,boolean)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "I'm getting an InternalError when trying to use the `subMap` method of `BTreeMap`:\n\n```\njava.lang.InternalError\n    at org.mapdb.BTreeMap.makeEntry(BTreeMap.java:918)\n    at org.mapdb.BTreeMap.findLarger(BTreeMap.java:1207)\n    at org.mapdb.BTreeMap$SubMap.firstEntry(BTreeMap.java:1762)\n    at org.mapdb.BTreeMap$SubMap$Iter.<init>(BTreeMap.java:1948)\n    at org.mapdb.BTreeMap$SubMap$3.<init>(BTreeMap.java:1994)\n    at org.mapdb.BTreeMap$SubMap.entryIterator(BTreeMap.java:1994)\n    at org.mapdb.BTreeMap$EntrySet.iterator(BTreeMap.java:1521)\n```\n\nAlso, `toString` on a subMap seems to emit all key/value pairs.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 1, "UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "spoonFilesChanged": 1, "MOV": 1}, "title": "InternalError with BTreeMap.subMap().entrySet()", "statsSkippedReason": "", "closed": "2013-02-07 00:46:01", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-02-07 00:43:54", "commitHash": "97d73671867b262f477802d46084e8bff59063bf", "commitParents": ["9c827618d17a0284836cb6b035fbd11d9535b540"], "commitGHEventType": "referenced", "nameRev": "97d73671867b262f477802d46084e8bff59063bf tags/mapdb-0.9.0~68", "commitGitStats": [{"insertions": 13, "lines": 13, "filePath": "src/test/java/org/mapdb/BTreeMapTest.java", "deletions": 0}, {"insertions": 3, "lines": 5, "filePath": "src/main/java/org/mapdb/BTreeMap.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.BTreeMap.findLarger(java.lang.Object,boolean)"}], "spoonFilePath": "BTreeMap.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.BTreeMapTest.submapToString()"}], "spoonFilePath": "BTreeMapTest.java"}], "commitMessage": "Fixed Issue #50, BTreeMap submap errors\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-02-07 00:43:54"}], "created": "2013-01-29 01:40:39"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/44", "title": "RandomAccessFile (compability mode) is mess", "closed": "2013-01-08 01:58:48", "commitsDetails": [], "commits": {}, "ttf": 1.0002777777777778, "created": "2013-01-07 00:20:28", "user": "jankotek", "body": ""}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/43", "title": "Windows XP troubles. ", "closed": "2013-01-26 14:42:47", "commitsDetails": [], "commits": {}, "ttf": 19.00027777777778, "created": "2013-01-07 00:20:04", "user": "jankotek", "body": "I had reports that MapDB does not work on Windows XP well. Need to investigate\n"}, {"labels": ["bug"], "filteredCommits": ["47c4f06186a05fdc9c66523857e7c54a87719ff5"], "url": "https://github.com/jankotek/mapdb/issues/36", "gitStatsSummary": {"insertions": 33, "gitFilesChange": 3, "lines": 43, "deletions": 10}, "numCommits": 1, "commits": {"47c4f06186a05fdc9c66523857e7c54a87719ff5": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 51.000277777777775, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.StorageDirect.delete(long)", "org.mapdb.StorageJournaled.delete(long)", "org.mapdb.StorageJournaled.putLargeLinkedRecord(org.mapdb.DataOutput2,long)", "org.mapdb.StorageJournaled.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StorageJournaled.unlinkPhysRecord(long,long)", "org.mapdb.Storage.unlinkPhysRecord(long,long)", "org.mapdb.StorageJournaled", "org.mapdb.StorageJournaled.reloadIndexFile()", "org.mapdb.StorageDirect.update(long,java.lang.Object,org.mapdb.Serializer)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Transactional mode does not mark deleted physical records as free. It will not reuse space after release, but grow file instead.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 9, "UPD": 0, "TOT": 19, "DEL": 0, "INS": 18, "spoonFilesChanged": 3, "MOV": 1}, "title": "Disk leak in journaled (transactional mode) ", "statsSkippedReason": "", "closed": "2013-02-07 23:58:43", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-02-07 23:57:39", "commitHash": "47c4f06186a05fdc9c66523857e7c54a87719ff5", "commitParents": ["97d73671867b262f477802d46084e8bff59063bf"], "commitGHEventType": "referenced", "nameRev": "47c4f06186a05fdc9c66523857e7c54a87719ff5 tags/mapdb-0.9.0~67", "commitGitStats": [{"insertions": 1, "lines": 2, "filePath": "src/main/java/org/mapdb/Storage.java", "deletions": 1}, {"insertions": 3, "lines": 6, "filePath": "src/main/java/org/mapdb/StorageDirect.java", "deletions": 3}, {"insertions": 29, "lines": 35, "filePath": "src/main/java/org/mapdb/StorageJournaled.java", "deletions": 6}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.delete(long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.StorageJournaled.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 6, "DEL": 0, "INS": 6, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.unlinkPhysRecord(long,long)"}, {"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.putLargeLinkedRecord(org.mapdb.DataOutput2,long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.reloadIndexFile()"}], "spoonFilePath": "StorageJournaled.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Storage.unlinkPhysRecord(long,long)"}], "spoonFilePath": "Storage.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirect.delete(long)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirect.update(long,java.lang.Object,org.mapdb.Serializer)"}], "spoonFilePath": "StorageDirect.java"}], "commitMessage": "Fixed Issue #36, disk leak in StorageJournaled\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-02-07 23:55:48"}], "created": "2012-12-18 22:45:23"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/30", "title": "Hash collision protection", "closed": "2013-01-03 17:41:28", "commitsDetails": [], "commits": {}, "ttf": 21.00027777777778, "created": "2012-12-13 02:28:49", "user": "jankotek", "body": "Most libraries (including `j.u.HashMap`) are vulnerable to [hash collision attack](http://arstechnica.com/business/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/). MapDB could be indirectly exposed to internet, so it should be immune to this attack. Solution is to add randomly generated hash salt into each store, and use salt in all hash operations.\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/25", "title": "BTreeMap is undertested", "closed": "2013-02-18 00:49:57", "commitsDetails": [], "commits": {}, "ttf": 66.00027777777778, "created": "2012-12-13 02:13:37", "user": "jankotek", "body": "BTreeMap needs much more tests.\n"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/19", "title": "BTreeMap: add online defragmentation", "closed": "2013-02-18 00:50:27", "commitsDetails": [], "commits": {}, "ttf": 66.00027777777778, "created": "2012-12-13 01:47:45", "user": "jankotek", "body": "Concurrent B-Linked-Tree used in MapDB does not support key removals efficiently. Key is just removed from node without collapsing and deleting empty nodes. So large key removals will leave empty tree nodes behind and affect performance. \n\nRight now it is not large problem, but it has to be fixed in long run.\n\nTree defragment algorithm is described [here](http://www.doc.ic.ac.uk/~td202/)\n"}, {"labels": ["bug"], "filteredCommits": ["151f856bdfd4d74e464459994ceb84e1daa61aba"], "url": "https://github.com/jankotek/mapdb/issues/18", "gitStatsSummary": {"insertions": 112, "gitFilesChange": 6, "lines": 116, "deletions": 4}, "numCommits": 1, "commits": {"151f856bdfd4d74e464459994ceb84e1daa61aba": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 58.000277777777775, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.StorageJournaled.compact()", "org.mapdb.Volume.Memory.getFile()", "org.mapdb.DebugVolume.getFile()", "org.mapdb.DB.compact()", "org.mapdb.EngineWrapper", "org.mapdb.compact()", "org.mapdb.Storage.compact()", "org.mapdb.EngineWrapper.compact()", "org.mapdb.Volume.MappedFile.getFile()", "org.mapdb.LoggerVolume.getFile()", "org.mapdb.Volume.getFile()", "org.mapdb.Volume.RandomAccessFile.getFile()"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Storage defragmentation is not currently implemented. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 12, "UPD": 0, "TOT": 12, "DEL": 0, "INS": 12, "spoonFilesChanged": 8, "MOV": 0}, "title": "Storage: add defragmentation", "statsSkippedReason": "", "closed": "2013-02-09 17:14:02", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-02-09 17:12:40", "commitHash": "151f856bdfd4d74e464459994ceb84e1daa61aba", "commitParents": ["47c4f06186a05fdc9c66523857e7c54a87719ff5"], "commitGHEventType": "referenced", "nameRev": "151f856bdfd4d74e464459994ceb84e1daa61aba tags/mapdb-0.9.0~66", "commitGitStats": [{"insertions": 69, "lines": 70, "filePath": "src/main/java/org/mapdb/Storage.java", "deletions": 1}, {"insertions": 6, "lines": 6, "filePath": "src/test/java/org/mapdb/DebugVolume.java", "deletions": 0}, {"insertions": 6, "lines": 6, "filePath": "src/test/java/org/mapdb/LoggerVolume.java", "deletions": 0}, {"insertions": 2, "lines": 2, "filePath": "src/main/java/org/mapdb/Engine.java", "deletions": 0}, {"insertions": 6, "lines": 7, "filePath": "src/main/java/org/mapdb/EngineWrapper.java", "deletions": 1}, {"insertions": 8, "lines": 8, "filePath": "src/test/java/org/mapdb/StorageDirectRAFTest.java", "deletions": 0}, {"insertions": 17, "lines": 17, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 0}, {"insertions": 6, "lines": 8, "filePath": "src/main/java/org/mapdb/DB.java", "deletions": 2}, {"insertions": 1, "lines": 2, "filePath": "src/test/java/org/mapdb/TestFile.java", "deletions": 1}, {"insertions": 19, "lines": 19, "filePath": "src/test/java/org/mapdb/StorageDirectTest.java", "deletions": 0}, {"insertions": 12, "lines": 12, "filePath": "src/main/java/org/mapdb/StorageJournaled.java", "deletions": 0}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectRAFTest"}], "spoonFilePath": "StorageDirectRAFTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DebugVolume.getFile()"}], "spoonFilePath": "DebugVolume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.LoggerVolume.getFile()"}], "spoonFilePath": "LoggerVolume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Storage.compact()"}], "spoonFilePath": "Storage.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectTest.compact()"}], "spoonFilePath": "StorageDirectTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.compact()"}], "spoonFilePath": "StorageJournaled.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DB.compact()"}], "spoonFilePath": "DB.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper.compact()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.EngineWrapper"}], "spoonFilePath": "EngineWrapper.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.compact()"}], "spoonFilePath": "Engine.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.getFile()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.RandomAccessFile.getFile()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.Memory.getFile()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Volume.MappedFile.getFile()"}], "spoonFilePath": "Volume.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.TestFile"}], "spoonFilePath": "TestFile.java"}], "commitMessage": "Add compaction, fix Issue #18\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-02-09 17:12:40"}], "created": "2012-12-13 01:43:35"}, {"labels": ["bug"], "filteredCommits": ["116cfc9f8ed8f8bcdcdac62cc297bf226a1328af", "fe919ec4202603bcf7f6c3ffdcab79a1f07715ec"], "url": "https://github.com/jankotek/mapdb/issues/17", "gitStatsSummary": {"insertions": 96, "gitFilesChange": 3, "lines": 161, "deletions": 65}, "numCommits": 2, "commits": {"116cfc9f8ed8f8bcdcdac62cc297bf226a1328af": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "fe919ec4202603bcf7f6c3ffdcab79a1f07715ec": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 169.00027777777777, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.SerializerPojo.deserializeUnknownHeader(java.io.DataInput,int,org.mapdb.FastArrayList)", "org.mapdb.DataInput2", "org.mapdb.SerializerPojo.ObjectOutputStream2", "org.mapdb.SerializerPojo.assertClassSerializable(java.lang.Class)", "org.mapdb.DataInput2.readUTF()", "org.mapdb.SerializerPojo.registerClass(java.lang.Class)", "org.mapdb.SerializerPojo.ClassInfo", "org.mapdb.SerializerPojo.ObjectOutputStream2.writeClassDescriptor(java.io.ObjectStreamClass)", "org.mapdb.SerializerPojo.serializeUnknownObject(java.io.DataOutput,java.lang.Object,org.mapdb.FastArrayList)", "org.mapdb.DataOutput2.writeUTF(java.lang.String)", "org.mapdb.DataOutput2", "org.mapdb.DataInput2.read()", "org.mapdb.SerializerPojo.1.serialize(java.io.DataOutput,java.util.concurrent.CopyOnWriteArrayList)", "org.mapdb.SerializerPojo.usesAdvancedSerialization(java.lang.Class)", "org.mapdb.SerializerPojo.ObjectInputStream2"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "MapDB Serialization should be drop-in replacement for Java Serialization. So for example all classes has to implement `Serializable` marker interface to be serializable by MapDB. \n\nHowever Java Serialization is very complex and it is nearly impossible to implement complete support for all its features. Most important right now is to support Externalizable and private writeObject readObject  methods. In some details it is [described here](http://oreilly.com/catalog/javarmi/chapter/ch10.html).\n\nWithout support for this methods, MapDB will fail to efficiently serialize many 3td party classes.\n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 15, "UPD": 18, "TOT": 67, "DEL": 6, "INS": 21, "spoonFilesChanged": 3, "MOV": 22}, "title": "Serialization: support for writeObject and readObject", "statsSkippedReason": "", "closed": "2013-05-31 22:32:45", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-05-31 23:32:16", "commitHash": "116cfc9f8ed8f8bcdcdac62cc297bf226a1328af", "commitParents": ["a12d3f856d24ffb6fd0dd6a1f7f294b7a00a8284"], "commitGHEventType": "referenced", "nameRev": "116cfc9f8ed8f8bcdcdac62cc297bf226a1328af tags/mapdb-0.9.3~4", "commitGitStats": [{"insertions": 67, "lines": 127, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 60}, {"insertions": 8, "lines": 10, "filePath": "src/main/java/org/mapdb/DataInput2.java", "deletions": 2}, {"insertions": 52, "lines": 94, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 42}, {"insertions": 4, "lines": 7, "filePath": "src/main/java/org/mapdb/DataOutput2.java", "deletions": 3}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.serialize(java.lang.Object)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testExternalizable()"}, {"UPD": 6, "TOT": 21, "DEL": 1, "INS": 0, "MOV": 14, "spoonMethodName": "org.mapdb.SerializerPojoTest.test_write_object_assertion()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.test_write_object_advanced_serializationm()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.deserialize(byte[])"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.Extr"}], "spoonFilePath": "SerializerPojoTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.ObjectInputStream2"}, {"UPD": 0, "TOT": 9, "DEL": 3, "INS": 2, "MOV": 4, "spoonMethodName": "org.mapdb.SerializerPojo.deserializeUnknownHeader(java.io.DataInput,int,org.mapdb.FastArrayList)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.usesAdvancedSerialization(java.lang.Class)"}, {"UPD": 5, "TOT": 25, "DEL": 2, "INS": 1, "MOV": 17, "spoonMethodName": "org.mapdb.SerializerPojo.assertClassSerializable(java.lang.Class)"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 1, "MOV": 1, "spoonMethodName": "org.mapdb.SerializerPojo.registerClass(java.lang.Class)"}, {"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.1.serialize(java.io.DataOutput,java.util.concurrent.CopyOnWriteArrayList)"}, {"UPD": 7, "TOT": 11, "DEL": 0, "INS": 4, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.ClassInfo"}, {"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.ObjectOutputStream2.writeClassDescriptor(java.io.ObjectStreamClass)"}, {"UPD": 1, "TOT": 5, "DEL": 1, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.serializeUnknownObject(java.io.DataOutput,java.lang.Object,org.mapdb.FastArrayList)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.ObjectOutputStream2"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DataInput2"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DataInput2.read()"}, {"UPD": 1, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DataInput2.readUTF()"}], "spoonFilePath": "DataInput2.java"}, {"spoonMethods": [{"UPD": 2, "TOT": 2, "DEL": 0, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.DataOutput2.writeUTF(java.lang.String)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.DataOutput2"}], "spoonFilePath": "DataOutput2.java"}], "commitMessage": "Fix issue #17; Serialization support for writeObject and readObject\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-05-31 23:32:16"}, {"commitUser": "jankotek", "commitDateTime": "2013-04-21 13:06:15", "commitHash": "fe919ec4202603bcf7f6c3ffdcab79a1f07715ec", "commitParents": ["c6b651ded7e972c588607f0fcfc9097d2ce106c7"], "commitGHEventType": "referenced", "nameRev": "fe919ec4202603bcf7f6c3ffdcab79a1f07715ec tags/mapdb-0.9.2~26", "commitGitStats": [{"insertions": 17, "lines": 17, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 0}, {"insertions": 59, "lines": 92, "filePath": "src/test/java/org/mapdb/SerializerPojoTest.java", "deletions": 33}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 2, "DEL": 0, "INS": 2, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojo.assertClassSerializable(java.lang.Class)"}], "spoonFilePath": "SerializerPojo.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.test_write_object_assertion()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testPersistedSimple()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.SerializerPojoTest.testPersisted()"}], "spoonFilePath": "SerializerPojoTest.java"}], "commitMessage": "Add warning if object uses advanced (and unsupported) Java Serialization. Issue #17\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-04-21 13:06:15"}], "created": "2012-12-13 01:42:24"}, {"labels": ["bug"], "url": "https://github.com/jankotek/mapdb/issues/16", "title": "Delta compression serializers for BTree Keys", "closed": "2013-01-18 01:03:00", "commitsDetails": [], "commits": {}, "ttf": 35.000277777777775, "created": "2012-12-13 01:33:47", "user": "jankotek", "body": "BTree keys are stored ordered in nodes. It is possible to save lot of space if only difference between keys is stored. \n\nJDBM3 applied compression automatically, but this required complex code and could not be modified by user. Also checks done for automatic Delta comp were slowing down BTree inserts/updates\n\nIn MapDB delta compression is done by supplying custom BTree Key Serializer. We need custom serializers for strings, byte[], BigNumber and other types. \n\nThis is 'enhancement', but should be treated as 'bug' since it has serious impact on performance tests.\n"}, {"labels": ["bug"], "filteredCommits": ["6329a16bf1c15e891291d9013156bc2623e43255"], "url": "https://github.com/jankotek/mapdb/issues/15", "gitStatsSummary": {"insertions": 260, "gitFilesChange": 3, "lines": 361, "deletions": 101}, "numCommits": 1, "commits": {"6329a16bf1c15e891291d9013156bc2623e43255": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 5.000277777777778, "user": "jankotek", "changesInPackagesSPOON": ["org.mapdb.StorageDirect.recordUpdate(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StorageJournaled.unlinkPhysRecord(long)", "org.mapdb.StorageJournaled.recordUpdate(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StorageDirect.recordPut(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.StorageJournaled.recordPut(java.lang.Object,org.mapdb.Serializer)", "org.mapdb.Storage.recordGet2(long,org.mapdb.Volume,org.mapdb.Serializer)", "org.mapdb.StorageJournaled.recordDelete(long)", "org.mapdb.Storage.unlinkPhysRecord(long)", "org.mapdb.StorageDirect.recordDelete(long)", "org.mapdb.StorageJournaled.putLargeLinkedRecord(org.mapdb.DataOutput2,long)", "org.mapdb.StorageJournaled.recordGet(long,org.mapdb.Serializer)", "org.mapdb.StorageJournaled.writeOutToTransLog(org.mapdb.DataOutput2,long,long)", "org.mapdb.StorageDirect.putLargeLinkedRecord(org.mapdb.DataOutput2,long)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "Currently MapDB store supports records with maximal serialized size 64KB. BTree usually stores  multiple key and values in single record (32 by default) and this puts practical limit somewhere around 1KB. \n\nWe need to implement linked-records to support record size up to 1GB. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 13, "UPD": 4, "TOT": 69, "DEL": 12, "INS": 20, "spoonFilesChanged": 3, "MOV": 33}, "title": "Maximal record size is 64KB", "statsSkippedReason": "", "closed": "2012-12-18 22:44:16", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2012-12-18 22:42:28", "commitHash": "6329a16bf1c15e891291d9013156bc2623e43255", "commitParents": ["e4e15337e2f73efaf8115394e8e4e104b3fb55f4"], "commitGHEventType": "referenced", "nameRev": "6329a16bf1c15e891291d9013156bc2623e43255 tags/mapdb-0.9.0~134", "commitGitStats": [{"insertions": 52, "lines": 58, "filePath": "src/main/java/org/mapdb/Storage.java", "deletions": 6}, {"insertions": 84, "lines": 136, "filePath": "src/main/java/org/mapdb/StorageDirect.java", "deletions": 52}, {"insertions": 34, "lines": 34, "filePath": "src/test/java/org/mapdb/StorageDirectTest.java", "deletions": 0}, {"insertions": 124, "lines": 167, "filePath": "src/main/java/org/mapdb/StorageJournaled.java", "deletions": 43}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.putLargeLinkedRecord(org.mapdb.DataOutput2,long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageJournaled.unlinkPhysRecord(long)"}, {"UPD": 0, "TOT": 9, "DEL": 2, "INS": 2, "MOV": 5, "spoonMethodName": "org.mapdb.StorageJournaled.recordUpdate(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 8, "DEL": 1, "INS": 1, "MOV": 6, "spoonMethodName": "org.mapdb.StorageJournaled.recordPut(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 6, "DEL": 1, "INS": 2, "MOV": 3, "spoonMethodName": "org.mapdb.StorageJournaled.recordDelete(long)"}, {"UPD": 1, "TOT": 5, "DEL": 1, "INS": 2, "MOV": 1, "spoonMethodName": "org.mapdb.StorageJournaled.writeOutToTransLog(org.mapdb.DataOutput2,long,long)"}, {"UPD": 3, "TOT": 9, "DEL": 2, "INS": 3, "MOV": 1, "spoonMethodName": "org.mapdb.StorageJournaled.recordGet(long,org.mapdb.Serializer)"}], "spoonFilePath": "StorageJournaled.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectTest.large_record()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectTest.large_record_delete()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectTest.large_record_larger()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirectTest.large_record_update()"}], "spoonFilePath": "StorageDirectTest.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 5, "DEL": 0, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.Storage.recordGet2(long,org.mapdb.Volume,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Storage.unlinkPhysRecord(long)"}], "spoonFilePath": "Storage.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 6, "DEL": 1, "INS": 1, "MOV": 4, "spoonMethodName": "org.mapdb.StorageDirect.recordPut(java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 13, "DEL": 3, "INS": 3, "MOV": 7, "spoonMethodName": "org.mapdb.StorageDirect.recordUpdate(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 4, "DEL": 1, "INS": 1, "MOV": 2, "spoonMethodName": "org.mapdb.StorageDirect.recordDelete(long)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.StorageDirect.putLargeLinkedRecord(org.mapdb.DataOutput2,long)"}], "spoonFilePath": "StorageDirect.java"}], "commitMessage": "Fix issue #15, maximal record size was 64 KB.\nFixed by introducing linked records.\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2012-12-18 22:42:28"}], "created": "2012-12-13 01:27:13"}, {"labels": ["2.0", "bug"], "filteredCommits": ["d979e6e82d3829d73775b03f1eccbd86ca0e554c", "88fdf08da278c3a21757ef9572a9f6017ee3629c"], "url": "https://github.com/jankotek/mapdb/issues/12", "gitStatsSummary": {"insertions": 508, "gitFilesChange": 5, "lines": 1025, "deletions": 517}, "numCommits": 2, "commits": {"d979e6e82d3829d73775b03f1eccbd86ca0e554c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}, "88fdf08da278c3a21757ef9572a9f6017ee3629c": {"commitUser": "jankotek", "commitGHEventType": "referenced"}}, "ttf": 1172.0002777777777, "user": "atok", "changesInPackagesSPOON": ["org.mapdb.CacheHardRef.addMemoryLowListener(java.lang.Runnable)", "org.mapdb.CacheHardRef.1.run()", "org.mapdb.Utils.isAndroid()", "org.mapdb.CacheHardRef.2.handleNotification(javax.management.Notification,java.lang.Object)", "org.mapdb.CacheHardRef.checkFreeMem()", "org.mapdb.CacheHardRef.setPercentageUsageThreshold(double)", "org.mapdb.CacheHardRef.update(long,java.lang.Object,org.mapdb.Serializer)", "org.mapdb.CacheHardRef.findTenuredGenPool()", "org.mapdb.CacheHardRef.close()", "org.mapdb.CacheHardRef", "org.mapdb.CacheHardRef.delete(long)", "org.mapdb.CacheHardRef.removeMemoryLowListener(java.lang.Runnable)"], "changesInPackagesGIT": ["src/main/java/org/mapdb"], "body": "\"works equally well on an Android phone and a supercomputer with multi-terabyte storage.\" but in reality there is no way to run MapDB on Dalvik. Multiple usages of sun-specific APIs makes MapDB incompatible with Android. \n", "filteredCommitsReason": {"duplicated": 0, "unavailable": 0, "moreThanOneParent": 0, "alsoFixesPhrase": 0, "mergeCommitUsed": 0, "multipleIssueFixes": 0}, "spoonStatsSummary": {"spoonMethodsChanged": 12, "UPD": 37.0, "TOT": 81.0, "DEL": 16.0, "INS": 6.0, "spoonFilesChanged": 2, "MOV": 22.0}, "title": "Android support mentioned but nonexistent", "statsSkippedReason": "", "closed": "2016-02-15 12:04:54", "commitsDetails": [{"commitUser": "jankotek", "commitDateTime": "2013-01-11 00:02:54", "commitHash": "d979e6e82d3829d73775b03f1eccbd86ca0e554c", "commitParents": ["c4c12adfa9056f6e5795eea965a63c883bffb68b"], "commitGHEventType": "referenced", "nameRev": "d979e6e82d3829d73775b03f1eccbd86ca0e554c tags/mapdb-0.9.0~100", "commitGitStats": [{"insertions": 65, "lines": 82, "filePath": "src/main/java/org/mapdb/SerializerPojo.java", "deletions": 17}, {"insertions": 400, "lines": 788, "filePath": "src/main/java/org/mapdb/Volume.java", "deletions": 388}], "commitSpoonAstDiffStats": [], "commitMessage": "Fix Issue #12, remove dependency on Sun undocumented API, make it run on Android.\n", "spoonStatsSkippedReason": "tooManyChanges", "authoredDateTime": "2013-01-11 00:02:54"}, {"commitUser": "jankotek", "commitDateTime": "2013-01-27 11:16:08", "commitHash": "88fdf08da278c3a21757ef9572a9f6017ee3629c", "commitParents": ["d4be426ec76ae89ce33aaa0d1bcb5445693b9fdc"], "commitGHEventType": "referenced", "nameRev": "88fdf08da278c3a21757ef9572a9f6017ee3629c tags/mapdb-0.9.0~87", "commitGitStats": [{"insertions": 3, "lines": 5, "filePath": "src/main/java/org/mapdb/CC.java", "deletions": 2}, {"insertions": 34, "lines": 142, "filePath": "src/main/java/org/mapdb/CacheHardRef.java", "deletions": 108}, {"insertions": 6, "lines": 8, "filePath": "src/main/java/org/mapdb/Utils.java", "deletions": 2}], "commitSpoonAstDiffStats": [{"spoonMethods": [{"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.Utils.isAndroid()"}], "spoonFilePath": "Utils.java"}, {"spoonMethods": [], "spoonFilePath": "CC.java"}, {"spoonMethods": [{"UPD": 0, "TOT": 3, "DEL": 0, "INS": 3, "MOV": 0, "spoonMethodName": "org.mapdb.CacheHardRef.checkFreeMem()"}, {"UPD": 9, "TOT": 19, "DEL": 4, "INS": 0, "MOV": 6, "spoonMethodName": "org.mapdb.CacheHardRef.addMemoryLowListener(java.lang.Runnable)"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.CacheHardRef.update(long,java.lang.Object,org.mapdb.Serializer)"}, {"UPD": 0, "TOT": 1, "DEL": 1, "INS": 0, "MOV": 0, "spoonMethodName": "org.mapdb.CacheHardRef.close()"}, {"UPD": 8, "TOT": 15, "DEL": 2, "INS": 0, "MOV": 5, "spoonMethodName": "org.mapdb.CacheHardRef.setPercentageUsageThreshold(double)"}, {"UPD": 6, "TOT": 10, "DEL": 1, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.CacheHardRef.findTenuredGenPool()"}, {"UPD": 7, "TOT": 10, "DEL": 0, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.CacheHardRef.2.handleNotification(javax.management.Notification,java.lang.Object)"}, {"UPD": 5, "TOT": 10, "DEL": 4, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.CacheHardRef"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 0, "MOV": 1, "spoonMethodName": "org.mapdb.CacheHardRef.1.run()"}, {"UPD": 0, "TOT": 1, "DEL": 0, "INS": 1, "MOV": 0, "spoonMethodName": "org.mapdb.CacheHardRef.delete(long)"}, {"UPD": 2, "TOT": 9, "DEL": 4, "INS": 0, "MOV": 3, "spoonMethodName": "org.mapdb.CacheHardRef.removeMemoryLowListener(java.lang.Runnable)"}], "spoonFilePath": "CacheHardRef.java"}], "commitMessage": "Remove JMX dep, so it compiles on Dalvik. Fix issue #12\n", "spoonStatsSkippedReason": "", "authoredDateTime": "2013-01-27 11:16:08"}], "created": "2012-11-29 18:29:42"}], "captureTime": "Mon Jul  6 17:19:21 2020", "projectName": "jankotek/MapDB"}