{"projectName": "reactor/reactor-core", "bugLabels": ["type/bug", "warn/regression"], "captureTime": "Sat Jul  4 15:33:15 2020", "issues": [{"title": "repeatWhenEmpty hangs on cancel when discard hook is present", "body": "## Expected Behavior\r\nIt should be safe to cancel the sequence.\r\n\r\n## Actual Behavior\r\nCancelling a sequence which is in a `repeatWhenEmpty()` loop will cause issues when a discard hook has been registered. In that case `Operators.onDiscardMultiple()` is invoked with the iterator used to keep track of the current iteration and the hook would be called for every remaining number up to `Long.MAX_VALUE`. \r\n\r\n## Steps to Reproduce\r\nThis test case will succeed when removing the `doOnDiscard()` operator.\r\n\r\n```java\r\n@Test\r\npublic void shouldCompleteEventually()\r\n{\r\n    StepVerifier.create(Mono.empty()\r\n                            .repeatWhenEmpty(Repeat.once())\r\n                            .doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release))\r\n                .thenAwait()\r\n                .thenCancel()\r\n                .verify(Duration.ofSeconds(5));\r\n}\r\n```\r\n\r\n## Possible Solution\r\nProbably we should treat the remaining iterations in a way that they can be safely discarded without bothering any application level hooks. Also, I guess `FluxStream` should not be considered \"knownToBeFinite\" if its size is `Long.MAX_VALUE`.\r\n\r\n## Your Environment\r\n* Reactor version(s) used: 3.3.6.RELEASE\r\n", "url": "https://github.com/reactor/reactor-core/issues/2196", "user": "chringwer", "labels": ["good first issue", "help wanted", "type/bug"], "created": "2020-06-17 14:05:08", "closed": "2020-06-23 15:40:15", "commits": {"5de0247ab0ed97bd32ac04f676a3b674cd484814": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}, "f6a5f5b920aec6a55b7887e252feb5aa112e4392": {"commitGHEventType": "closed", "commitUser": "ericbottard"}, "c7e8baff6dd13211cc4a5997e78794c3f601f560": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}, "50d5f2918bb8e6036674e08f68bdd41c090c280b": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "5de0247ab0ed97bd32ac04f676a3b674cd484814", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f6a5f5b920aec6a55b7887e252feb5aa112e4392", "commitGHEventType": "closed", "commitUser": "ericbottard", "commitParents": ["19d1c1c9808641b2d50922a3c9cc800fbc33d4c6"], "nameRev": "f6a5f5b920aec6a55b7887e252feb5aa112e4392 remotes/origin/2196-RepeatWhenEmptyDiscard", "commitMessage": "Fix #2196: don't hang on repeatWhenEmpty + discard handler\n", "commitDateTime": "2020-06-23 17:35:12", "authoredDateTime": "2020-06-23 15:32:38", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 18, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoRepeatWhenEmptyTest.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 18, "UPD": 4, "INS": 2, "MOV": 8, "DEL": 4}]}, {"spoonFilePath": "MonoRepeatWhenEmptyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoRepeatWhenEmptyTest.gh2196_discardHandlerHang()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "c7e8baff6dd13211cc4a5997e78794c3f601f560", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": ["776ea844d5d7e925c690b3ac1ed45171e5979813", "f6a5f5b920aec6a55b7887e252feb5aa112e4392"], "nameRev": "c7e8baff6dd13211cc4a5997e78794c3f601f560 remotes/origin/2199-RefDocContextTypo~3", "commitMessage": "Merge #2196 into 3.3.8.RELEASE\n", "commitDateTime": "2020-06-23 17:37:22", "authoredDateTime": "2020-06-23 17:37:22", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 18, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoRepeatWhenEmptyTest.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 18, "UPD": 4, "INS": 2, "MOV": 8, "DEL": 4}]}, {"spoonFilePath": "MonoRepeatWhenEmptyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoRepeatWhenEmptyTest.gh2196_discardHandlerHang()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "50d5f2918bb8e6036674e08f68bdd41c090c280b", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": ["68b281c6119b0789f8ca901d49bf15dcbd6165f2", "c7e8baff6dd13211cc4a5997e78794c3f601f560"], "nameRev": "50d5f2918bb8e6036674e08f68bdd41c090c280b remotes/origin/removeAnnotationsWarnings~7", "commitMessage": "Merge #2196 into 3.4.0-M2\n", "commitDateTime": "2020-06-23 17:39:13", "authoredDateTime": "2020-06-23 17:39:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 18, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoRepeatWhenEmptyTest.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 18, "UPD": 4, "INS": 2, "MOV": 8, "DEL": 4}]}, {"spoonFilePath": "MonoRepeatWhenEmptyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoRepeatWhenEmptyTest.gh2196_discardHandlerHang()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f6a5f5b920aec6a55b7887e252feb5aa112e4392"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 2, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 12.0, "deletions": 18.0, "lines": 30.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 18.0, "UPD": 4.0, "INS": 2.0, "MOV": 8.0, "DEL": 4.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)"]}, {"title": "ReactorDebugAgent.init fails with the NoClassDefFoundError in 3.3.6.RELEASE", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\n\r\nThe `ReactorDebugAgent.init()` has been broken in the latest release version `3.3.6.RELEASE` and it fails with the `NoClassDefFoundError`.\r\n\r\nIn `3.3.5.RELEASE` version everything works fine (just downgrade version back in a build.gradle.kts in the reproducer and `ReactorDebugAgent.init()` will work fine)\r\n\r\nThe issue was originally discovered in a project that uses __Spring-Boot__ after updating from `2.3.0.RELEASE` to `2.3.1.RELEASE` (that bumps the __reactor__ version from `3.3.5.RELEASE` to `3.3.6.RELEASE`). \r\nBut I was able to make a small reproducer attached below.\r\n\r\n<!--- /!\\ Make sure to follow the Contribution Guidelines, notably for security issues and questions:\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md\r\nhttps://pivotal.io/security\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md#question-do-you-have-a-question\r\n-->\r\n\r\n## Expected Behavior\r\n\r\n`ReactorDebugAgent.init()` completes successfully\r\n\r\n## Actual Behavior\r\n<!--- Tell us what happens instead of the expected behavior. -->\r\n`ReactorDebugAgent.init()` fails with the `NoClassDefFoundError`:\r\n<details>\r\n  <summary>Stacktrace</summary>\r\n\r\n```\r\nException in thread \"main\" java.lang.NoClassDefFoundError: net/bytebuddy/agent/ByteBuddyAgent\r\n\tat reactor.tools.agent.ReactorDebugAgent.init(ReactorDebugAgent.java:56)\r\n\tat Application.main(Application.java:5)\r\n\r\nCaused by: java.lang.ClassNotFoundException: net.bytebuddy.agent.ByteBuddyAgent\r\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602)\r\nCaused by: java.lang.ClassNotFoundException: net.bytebuddy.agent.ByteBuddyAgent\r\n\r\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\r\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)\r\n\t... 2 more\r\n```\r\n  \r\n</details>\r\n\r\n## Steps to Reproduce\r\n<!---Provide a link to a live example, or an unambiguous set of steps to\r\nreproduce this bug, eg. a unit test. Include code to reproduce, if relevant. -->\r\n\r\n1. A Gradle project of the following structure:\r\n<details>\r\n  <summary>gradle.build.kts</summary>\r\n\r\n```gradle\r\nplugins {\r\n    java\r\n    application\r\n}\r\n\r\nrepositories {\r\n    jcenter()\r\n}\r\n\r\ndependencies {\r\n    // 3.3.5.RELEASE works fine\r\n    implementation(\"io.projectreactor:reactor-tools:3.3.6.RELEASE\")\r\n}\r\n\r\napplication {\r\n    mainClassName = \"Application\"\r\n}\r\n\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n  <summary>src/main/java/Application.java</summary>\r\n\r\n```java\r\nimport reactor.tools.agent.ReactorDebugAgent;\r\n\r\npublic class Application {\r\n    public static void main(String[] args) {\r\n        ReactorDebugAgent.init();\r\n    }\r\n}\r\n\r\n```\r\n\r\n</details>\r\n\r\n2. Run `./gradlew run`\r\n\r\n\r\n## Possible Solution\r\n<!--- Not obligatory, but you can suggest a fix/reason for the bug. -->\r\n\r\nI've seen some commits in the last [release](https://github.com/reactor/reactor-core/compare/v3.3.6.RELEASE...master) that manipulate with version format, so that can be the reason for the bug.\r\n\r\nI'll try to investigate the reason in a more detailed way, but at the moment I have no idea what specifically led to the bug\r\n\r\n## Your Environment\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\n\r\n* Reactor version(s) used: 3.3.6\r\n* JVM version: openjdk version \"14\" 2020-03-17\r\nOpenJDK Runtime Environment (build 14+36-1461)\r\nOpenJDK 64-Bit Server VM (build 14+36-1461, mixed mode, sharing)\r\n* Gradle version: 6.5\r\n* OS and version: macOS 10.15.4\r\n", "url": "https://github.com/reactor/reactor-core/issues/2189", "user": "lamtev", "labels": ["status/has-workaround", "type/bug", "type/chores"], "created": "2020-06-13 17:52:40", "closed": "2020-06-19 17:09:15", "commits": {"a738652ce14ae962e9c289899327bdd2cd5dcd80": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "ba224b40f2f0d329b4663fe9bab989c97795349f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "a738652ce14ae962e9c289899327bdd2cd5dcd80", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["123475aba712dfd6c8534e45f1387c4e7fc04bdc"], "nameRev": "a738652ce14ae962e9c289899327bdd2cd5dcd80 tags/v3.4.0-M1~2^2~1", "commitMessage": "fix #2189 Ensure tools fat jar is the one published\n\nThe `reactor-tools` subproject is using the shadow plugin to create\r\na fat jar, and wants this fat jar to replace the main jar. To do so,\r\nthe normal jar that Gradle produces is replaced with a classifier,\r\n`original`, and the shadow jar is produced without classifier.\r\n\r\nThe publication is then configured to add the \"shadow\" jar to the\r\nnormal publication. However, this is incorrect: the Gradle component\r\nmodel describes that the \"apiElements\" and \"runtimeElements\" use\r\nthe output of the `jar` task as the main artifact. As a consequence,\r\nwhen publishing Gradle module metadata, the module file says that\r\nthe file to be fetched is the one produced by the `jar` task, which\r\nhas the `original` classifier.\r\n\r\nInstead, if the API and runtime of the `reactor-tools` project need\r\nto use the shadow jar, then the shadow jar needs to be set as the\r\nmain artifact.\r\n\r\nThis is what this commit does:\r\n\r\n- it replaces the default artifact that Gradle uses publication with\r\nthe \"shadow\" jar\r\n- it adds the \"original\" jar as an extra, out of context, artifact\r\nto upload alongside the shadow jar\r\n\r\nIn addition, it configures a dummy repository which can be used to\r\n\"see\" what Gradle would publish. By running the:\r\n\r\n`publishMavenJavaPublicationToMockRepository` task, Gradle will\r\ncreate a dummy repository in <rootDir>/build/repo which contains\r\nwhat it would upload to Artifactory. This way you can quickly\r\ncheck what is produced before actually releasing. In particular,\r\nyou can check the module files.\r\n\r\nNote that this problem doesn't happen with Maven consumers because\r\nMaven doesn't care about variants. Therefore, it only looks for the\r\n\"main\" jar based on its name. Gradle, on the other hand, is variant\r\naware, meaning that it will select an artifact based on the variant\r\ninformation found in the module file.\r\n\r\nThis file tells it to fetch the \"original\" file for the API, so it\r\ndoes.\r\n\r\nReviewed-in: #2194", "commitDateTime": "2020-06-19 19:07:59", "authoredDateTime": "2020-06-19 19:07:59", "commitGitStats": [{"filePath": "gradle/setup.gradle", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-tools/build.gradle", "insertions": 11, "deletions": 2, "lines": 13}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ba224b40f2f0d329b4663fe9bab989c97795349f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["cfacc2287fe8bd28dc1b481c804571e9e9b7e613", "a738652ce14ae962e9c289899327bdd2cd5dcd80"], "nameRev": "ba224b40f2f0d329b4663fe9bab989c97795349f tags/v3.4.0-M1~5", "commitMessage": "Merge #2189 into 3.4.0-M1\n", "commitDateTime": "2020-06-19 19:08:50", "authoredDateTime": "2020-06-19 19:08:50", "commitGitStats": [{"filePath": "gradle/setup.gradle", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-tools/build.gradle", "insertions": 11, "deletions": 2, "lines": 13}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Race condition in `MonoCollect` leads to NullPointerException ", "body": "The example in https://github.com/spring-projects/spring-framework/issues/25216 shows a NullPointerException in the logs:\r\n\r\n```\r\njava.lang.NullPointerException: null\r\nat reactor.core.publisher.MonoCollect$CollectSubscriber.onNext(MonoCollect.java:124) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]\r\nat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]\r\nat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]\r\nat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]\r\nat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]\r\nat reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:330) [reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]\r\n...\r\n```\r\n\r\nThis happens while collecting buffers in [DataBufferUtils#join](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java#L551) and what's `null` is the `value` field (the container collecting the items) and not the `action`. In a debugger this is where the NPE is raised:\r\n\r\n```\r\nat org.springframework.core.io.buffer.DataBufferUtils$$Lambda$340.551556520.accept(Unknown Source:-1)\r\nat reactor.core.publisher.MonoCollect$CollectSubscriber.onNext(MonoCollect.java:124)\r\nat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114)\r\nat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192)\r\nat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192)\r\nat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114)\r\nat reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:330)\r\n```\r\n\r\nAs far as I can see in `MonoCollect` around line 124 the `value` field is passed in as-is but it can be set to `null` in `Operators` around line 1728 in the `cancel` method of `MonoSubscriber`. Probably the code should look more like what is in `MonoCollectList` with a local variable and a `null` check.\r\n", "url": "https://github.com/reactor/reactor-core/issues/2186", "user": "rstoyanchev", "labels": ["type/bug"], "created": "2020-06-10 17:41:49", "closed": "2020-06-16 15:43:29", "commits": {"cf63b5e25adf6f99413e9338fc02a6834402bf07": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "123475aba712dfd6c8534e45f1387c4e7fc04bdc": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0f00568dec39f71cefa6d17b300d5d0467c2cd0f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "cf63b5e25adf6f99413e9338fc02a6834402bf07", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f6fcae15c1e4517901051bc8915a83b446c1ec55"], "nameRev": "cf63b5e25adf6f99413e9338fc02a6834402bf07 tags/v3.4.0-M1~2^2^2~1", "commitMessage": "fix #2186 Align MonoCollect and MonoCollectList\n\nThis change aligns the implementation of MonoCollect to be comparable\r\nto MonoList. Effectively they're the same, a MonoCollectList is but a\r\nMonoCollect with an ArrayList as the container.", "commitDateTime": "2020-06-16 14:27:51", "authoredDateTime": "2020-06-16 13:27:51", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java", "insertions": 61, "deletions": 34, "lines": 95}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java", "insertions": 68, "deletions": 2, "lines": 70}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCollect.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.setValue(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.cancel()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onNext(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.discard(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectList.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectTest.scanSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.normal()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelNextRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelCompleteRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "123475aba712dfd6c8534e45f1387c4e7fc04bdc", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["8de5bf3e5d9aea38a0476ebf5ce56519342715f2", "cf63b5e25adf6f99413e9338fc02a6834402bf07"], "nameRev": "123475aba712dfd6c8534e45f1387c4e7fc04bdc tags/v3.4.0-M1~2^2~2", "commitMessage": "Merge #2186 into 3.3.7.RELEASE\n", "commitDateTime": "2020-06-16 17:36:33", "authoredDateTime": "2020-06-16 17:36:33", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java", "insertions": 61, "deletions": 34, "lines": 95}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java", "insertions": 68, "deletions": 2, "lines": 70}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCollect.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.setValue(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.cancel()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onNext(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.discard(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectList.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectTest.scanSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.normal()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelNextRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelCompleteRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "0f00568dec39f71cefa6d17b300d5d0467c2cd0f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["74885739562c88cfd6d7673593525a99e0c81b96", "123475aba712dfd6c8534e45f1387c4e7fc04bdc"], "nameRev": "0f00568dec39f71cefa6d17b300d5d0467c2cd0f tags/v3.4.0-M1~8", "commitMessage": "Merge #2186 into 3.4.0-M1\n", "commitDateTime": "2020-06-16 17:42:58", "authoredDateTime": "2020-06-16 17:42:58", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java", "insertions": 61, "deletions": 34, "lines": 95}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java", "insertions": 68, "deletions": 2, "lines": 70}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCollect.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.setValue(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.cancel()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onNext(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.discard(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollect.CollectSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectList.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCollectTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectTest.scanSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.normal()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelNextRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardCancelCompleteRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["cf63b5e25adf6f99413e9338fc02a6834402bf07"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 2, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 65, "deletions": 38, "lines": 103, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 27, "UPD": 5, "INS": 10, "MOV": 8, "DEL": 4, "spoonFilesChanged": 2, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoCollect.CollectSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.MonoCollect.CollectSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber", "reactor.core.publisher.MonoCollect.CollectSubscriber.cancel()", "reactor.core.publisher.MonoCollect.CollectSubscriber.discard(java.lang.Object)", "reactor.core.publisher.MonoCollect.CollectSubscriber.onComplete()", "reactor.core.publisher.MonoCollect.CollectSubscriber", "reactor.core.publisher.MonoCollect.CollectSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.MonoCollect.CollectSubscriber.setValue(java.lang.Object)", "reactor.core.publisher.MonoCollectList.MonoCollectListSubscriber.onError(java.lang.Throwable)"]}, {"title": "`Flux#collect` does not handle `null` result", "body": "While (very?) uncommon, a `Collector` may return `null`. Currently `Flux#collect` does not explicitly consider this case, causing `onNext(null)` to be invoked.\r\n\r\n## Steps to Reproduce\r\n\r\n```java\r\n@Test\r\npublic void reproCase() {\r\n    // Passes.\r\n    StepVerifier.create(Mono.just(\"foo\").map(x -> null))\r\n        .verifyError(NullPointerException.class);\r\n\r\n    // Fails.\r\n    StepVerifier.create(Flux.empty().collect(reducing(null, (a, b) -> a)))\r\n        .verifyError(NullPointerException.class);\r\n}\r\n```\r\n\r\nThe second statement yields:\r\n```\r\njava.lang.AssertionError: expectation \"expectError(Class)\" failed (expected: onError(NullPointerException); actual: onNext(null))\r\n```\r\n\r\n## Possible Solution\r\n\r\nConsistent with `.map`, I think a `NullPointerException` should be emitted. The alternative is to emit `onComplete()`, but from an API evolvability POV it seems safer to simply disallow this for now. Another argument for going with the NPE is that this maintains the invariant that `Flux#collect` always emits exactly one element.\r\n\r\n##  Environment\r\n\r\n* Reactor version: `Dysprosium-SR7`\r\n* JVM version: `AdoptOpenJDK (build 11.0.7+10)`\r\n", "url": "https://github.com/reactor/reactor-core/issues/2181", "user": "Stephan202", "labels": ["good first issue", "type/bug"], "created": "2020-06-08 06:57:39", "closed": "2020-06-10 09:27:07", "commits": {"64affcff0739ba5355464c204fa74ee912f03574": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}, "7cf7e4df4624d7dfcc814f8c1243fb6640507355": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}, "06ca741229c6304e7bc7f696d02d355da6aac5d3": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}, "8de5bf3e5d9aea38a0476ebf5ce56519342715f2": {"commitGHEventType": "closed", "commitUser": "ericbottard"}, "d3a18ff06d6d0c973bd5845bce7a5856121878db": {"commitGHEventType": "referenced", "commitUser": "ericbottard"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "64affcff0739ba5355464c204fa74ee912f03574", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7cf7e4df4624d7dfcc814f8c1243fb6640507355", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "06ca741229c6304e7bc7f696d02d355da6aac5d3", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8de5bf3e5d9aea38a0476ebf5ce56519342715f2", "commitGHEventType": "closed", "commitUser": "ericbottard", "commitParents": ["3daa029a43f77790bea5f0ae32e6ce0dcde8ac62"], "nameRev": "8de5bf3e5d9aea38a0476ebf5ce56519342715f2 tags/v3.4.0-M1~2^2~3", "commitMessage": "Fix #2181 Handle nulls from collectors in Flux.collect()\n\nEmit an NPE early instead of signaling onNext(null).", "commitDateTime": "2020-06-10 11:20:01", "authoredDateTime": "2020-06-10 11:20:01", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoStreamCollector.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoStreamCollector.StreamCollectorSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoStreamCollectorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoStreamCollectorTest.collectHandlesNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "d3a18ff06d6d0c973bd5845bce7a5856121878db", "commitGHEventType": "referenced", "commitUser": "ericbottard", "commitParents": ["6a8fb33c2efa1f22ef7f46205f250597a8374697", "8de5bf3e5d9aea38a0476ebf5ce56519342715f2"], "nameRev": "d3a18ff06d6d0c973bd5845bce7a5856121878db tags/v3.4.0-M1~10", "commitMessage": "Merge issue #2181 into 3.4.0-M1.\n", "commitDateTime": "2020-06-10 11:22:20", "authoredDateTime": "2020-06-10 11:22:20", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoStreamCollector.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoStreamCollector.StreamCollectorSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoStreamCollectorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoStreamCollectorTest.collectHandlesNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["8de5bf3e5d9aea38a0476ebf5ce56519342715f2"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4.0, "deletions": 0.0, "lines": 4.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoStreamCollector.StreamCollectorSubscriber.onComplete()"]}, {"title": "Enabling metrics causes NPE or hanging on certain cases", "body": "## Expected Behavior\r\nEnabling metrics using `Mono#metrics` has no effect on the behavior of the `Mono`, other than enabling metrics.\r\n\r\n## Actual Behavior\r\nEnabling metrics using `Mono#metrics` may cause a `NullPointerException` or hanging on certain cases.\r\n\r\n## Steps to Reproduce\r\n\r\n```java\r\n@Test\r\n@Timeout(value = 10, unit = SECONDS)\r\nvoid this_hangs() {\r\n    StepVerifier.create(\r\n                    Mono.fromSupplier(() -> List.of(1, 2, 3))\r\n                            .metrics()\r\n                            .flatMapIterable(Function.identity()))\r\n            .expectNext(1, 2, 3)\r\n            .verifyComplete();\r\n}\r\n\r\n@Test\r\nvoid this_throws_NPE() {\r\n    StepVerifier.create(\r\n                    Mono.using(\r\n                                    () -> \"irrelevant\",\r\n                                    irrelevant -> Mono.fromSupplier(() -> List.of(1, 2, 3)),\r\n                                    irrelevant -> {})\r\n                            .metrics()\r\n                            .flatMapIterable(Function.identity()))\r\n            .expectNext(1, 2, 3)\r\n            .verifyComplete();\r\n}\r\n```\r\n\r\n## Possible Solution\r\nApplying any of the following workarounds fixes both tests:\r\n* Removing the `.metrics()` operator.\r\n* Replacing `.flatMapIterable(Function.identity()))` with `.flatMapMany(Flux::fromIterable))`.\r\n* Replacing `Mono.fromSupplier(() -> List.of(1, 2, 3))` with `Mono.just(List.of(1, 2, 3))`.\r\n\r\n## Your Environment\r\n* Reactor version: Dysprosium-SR7, 3.3.5.RELEASE.\r\n* JVM version: openjdk 11.0.6 2020-01-14.", "url": "https://github.com/reactor/reactor-core/issues/2160", "user": "EnricSala", "labels": ["type/bug"], "created": "2020-05-16 16:49:00", "closed": "2020-05-27 16:18:36", "commits": {"7c401de75e046ad4e03c32ea5fc23943f004e69b": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "6058a391f614de6213fb85970272fc5b342bd181": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 10.000277777777777, "commitsDetails": [{"commitHash": "7c401de75e046ad4e03c32ea5fc23943f004e69b", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c44dc6c31363714968065f90e3d34231e43f82d9"], "nameRev": "7c401de75e046ad4e03c32ea5fc23943f004e69b tags/v3.3.6.RELEASE~4", "commitMessage": "fix #2160 Accommodate ASYNC fusion in Mono.metrics()\n\nReviewed-in: #2168\r\nCo-authored-by: Simon Basl\u00e9 <sbasle@pivotal.io>", "commitDateTime": "2020-05-27 18:17:28", "authoredDateTime": "2020-05-27 19:17:28", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java", "insertions": 36, "deletions": 0, "lines": 36}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxMetricsTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoMetricsTest.java", "insertions": 27, "deletions": 0, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetrics.MetricsSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.MetricsSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "MonoMetricsFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetricsFuseable.MetricsFuseableSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoMetricsFuseable.MetricsFuseableSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMetricsTest.ensureFuseablePropagateOnComplete_inCaseOfAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMetricsTest.ensureOnNextInAsyncModeIsCapableToPropagateNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetricsTest.ensureFuseablePropagateOnComplete_inCaseOfAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoMetricsTest.ensureOnNextInAsyncModeIsCapableToPropagateNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "6058a391f614de6213fb85970272fc5b342bd181", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["f57e7cf183b3a4fa2d22c79bac51c40d6c2fe70c", "7c401de75e046ad4e03c32ea5fc23943f004e69b"], "nameRev": "6058a391f614de6213fb85970272fc5b342bd181 tags/v3.4.0-M1~14", "commitMessage": "Merge #2160 into 3.4.0-M1\n", "commitDateTime": "2020-05-27 18:18:09", "authoredDateTime": "2020-05-27 18:18:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java", "insertions": 36, "deletions": 0, "lines": 36}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxMetricsTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoMetricsTest.java", "insertions": 27, "deletions": 0, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetrics.MetricsSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.MetricsSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "MonoMetricsFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetricsFuseable.MetricsFuseableSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoMetricsFuseable.MetricsFuseableSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMetricsTest.ensureFuseablePropagateOnComplete_inCaseOfAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMetricsTest.ensureOnNextInAsyncModeIsCapableToPropagateNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetricsTest.ensureFuseablePropagateOnComplete_inCaseOfAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoMetricsTest.ensureOnNextInAsyncModeIsCapableToPropagateNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Hanging with log indicating OnErrorSubscription cannot be cast to class reactor.core.Fuseable$QueueSubscription", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\n\r\n<!--- /!\\ Make sure to follow the Contribution Guidelines, notably for security issues and questions:\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md\r\nhttps://pivotal.io/security\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md#question-do-you-have-a-question\r\n-->\r\nStepVerifier appears to hang on a Mono error. This issue is shown in a simple unit test in the \"Steps to Reproduce\" section was noticed when upgrading the reactor-core that comes with Spring Boot from Spring Boot 2.2.4.RELEASE to 2.2.7.RELEASE.\r\n\r\n## Expected Behavior\r\nTest provided in the \"Steps to reproduce\" should have completed normally.\r\n\r\n## Actual Behavior\r\nThe provided test should have worked but appears to fail(hangs) with the version of reactor-core packaged with spring-boot 2.2.7 (reactor-core-3.3.5.RELEASE)\r\n\r\n## Steps to Reproduce\r\n```java\r\n    @Test\r\n    void testMonoError() {\r\n        StepVerifier.create(\r\n                getSampleMono()\r\n                        .flatMapIterable(s -> s)\r\n                        .map(s -> s + \" world\")\r\n                        .collectList()\r\n                        .onErrorReturn(List.of())\r\n        )\r\n                .assertNext(list -> assertThat(list).isEmpty())\r\n                .verifyComplete();\r\n    }\r\n\r\n    private Mono<List<String>> getSampleMono() {\r\n        return Mono.error(new RuntimeException(\"An Exception\"));\r\n    }\r\n```\r\n\r\n## Possible Solution\r\n\r\n## Your Environment\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\n\r\n* Reactor version(s) used: 3.3.5.RELEASE\r\n* Other relevant libraries versions (eg. `netty`, ...):\r\n* JVM version (`javar -version`): Java 11\r\n* OS and version (eg `uname -a`): Mac OSX\r\n", "url": "https://github.com/reactor/reactor-core/issues/2152", "user": "bijukunjummen", "labels": ["type/bug"], "created": "2020-05-11 22:39:34", "closed": "2020-05-13 07:49:07", "commits": {"c8e0c4c10957dc90be61c45040d744f7c1f44645": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "3b2d4919962ea4f7ae9f0c16f8320f2bd39eb814": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "a2ed5ae070e0517c2ab3df4838f1baa69ff5fb78": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "c8e0c4c10957dc90be61c45040d744f7c1f44645", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3b2d4919962ea4f7ae9f0c16f8320f2bd39eb814", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d6e3f43f033cb3215ebacbc60f43ffd09a0f1b17"], "nameRev": "3b2d4919962ea4f7ae9f0c16f8320f2bd39eb814 tags/v3.3.6.RELEASE~16", "commitMessage": "fix #2152 reportThrowInSubscribe triggers sneaky ClassCastException\n\nThis commit changes the Subscription set by reportThrowInSubscribe to\nan instance compatible with QueueSubscription, preventing fused cases\nwhere a ClassCastException would be thrown. The later would be\nproblematic with operators that make use of the Subscription when\nreceiving the onError signal, as said Subscription would be null at\nthat point due to the ClassCastException, sometimes causing hanging.\n\nReviewed-in: #2153\n", "commitDateTime": "2020-05-13 09:48:16", "authoredDateTime": "2020-05-12 11:05:55", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 26, "deletions": 19, "lines": 45}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "insertions": 17, "deletions": 0, "lines": 17}, {"filePath": "reactor-test/src/test/java/reactor/test/DefaultStepVerifierBuilderTests.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.canAppearAfterOnSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.reportThrowInSubscribe(reactor.core.CoreSubscriber,java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.OnErrorSubscription", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.EmptySubscription", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OperatorsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorsTest.reportThrowInSubscribeWithFuseableErrorResumed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilderTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilderTests.subscribedTwiceDetectsSpecialSubscription()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a2ed5ae070e0517c2ab3df4838f1baa69ff5fb78", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a8022380f7d1eb9ef5bdcf0a9e0366d3dad534df", "483c1c244ab37b1f10573d3a94633d712acc1193"], "nameRev": "a2ed5ae070e0517c2ab3df4838f1baa69ff5fb78 tags/v3.4.0-M1~25", "commitMessage": "Merge #2152 into 3.4\n", "commitDateTime": "2020-05-13 09:48:41", "authoredDateTime": "2020-05-13 09:48:41", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 26, "deletions": 19, "lines": 45}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "insertions": 17, "deletions": 0, "lines": 17}, {"filePath": "reactor-test/src/test/java/reactor/test/DefaultStepVerifierBuilderTests.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.canAppearAfterOnSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.reportThrowInSubscribe(reactor.core.CoreSubscriber,java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.OnErrorSubscription", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.EmptySubscription", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.scanSubscriber()", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "OperatorsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorsTest.reportThrowInSubscribeWithFuseableErrorResumed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilderTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilderTests.subscribedTwiceDetectsSpecialSubscription()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Gradle module metadata not published for reactor-core 3.3.5", "body": "**Current Behavior:**\r\n\r\nreactor-core 3.3.5 was published with a Gradle module metadata declaration in its POM file (`published-with-gradle-metadata`), however, the corresponding _.module_ file is missing in the Maven Central repository.\r\n\r\n- https://search.maven.org/artifact/io.projectreactor/reactor-core/3.3.5.RELEASE/jar\r\n- https://repo1.maven.org/maven2/io/projectreactor/reactor-core/3.3.5.RELEASE/reactor-core-3.3.5.RELEASE.pom\r\n\r\n**Expected Behavior:**\r\n \r\n1. reactor-core is published with Gradle module metadata and the _.module_ file is published together with the POM and JAR file\r\n2. _or_ reactor-core is published without Gradle module metadata and does not declare it in the POM file", "url": "https://github.com/reactor/reactor-core/issues/2151", "user": "kroka", "labels": ["type/bug", "type/chores"], "created": "2020-05-08 09:35:09", "closed": "2020-05-19 09:02:07", "commits": {"1af83f77fcd2f018db35fa2b98c9e1115f864c4a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a60e6a08eca9b1938d0d763adb0b2db4e8ff223f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "b40b8db793de031bf0cb594a2c814ddf018c0693": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "cf38eefc7f0f8f389626deb2021d448bab655d9f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 10.000277777777777, "commitsDetails": [{"commitHash": "1af83f77fcd2f018db35fa2b98c9e1115f864c4a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a60e6a08eca9b1938d0d763adb0b2db4e8ff223f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d5b9cf35583977da22c45af9c44f7db13182425c"], "nameRev": "a60e6a08eca9b1938d0d763adb0b2db4e8ff223f tags/v3.2.18.RELEASE~4", "commitMessage": "fix #2151 Publish Gradle metadata, without optional dependencies\n\nReviewed-in: #2158", "commitDateTime": "2020-05-19 10:59:46", "authoredDateTime": "2020-05-19 10:59:46", "commitGitStats": [{"filePath": "build.gradle", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "buildSrc/build.gradle", "insertions": 17, "deletions": 13, "lines": 30}, {"filePath": "buildSrc/src/main/java/io/reactor/gradle/OptionalDependenciesPlugin.java", "insertions": 65, "deletions": 0, "lines": 65}, {"filePath": "buildSrc/src/test/java/io/reactor/gradle/OptionalDependenciesPluginTest.java", "insertions": 110, "deletions": 0, "lines": 110}, {"filePath": "reactor-core/build.gradle", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-test/build.gradle", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "OptionalDependenciesPlugin.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPlugin", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OptionalDependenciesPluginTest.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPluginTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b40b8db793de031bf0cb594a2c814ddf018c0693", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["74fa0e4ab4aae03f32c4f187da9fc9c5ff22b970", "a60e6a08eca9b1938d0d763adb0b2db4e8ff223f"], "nameRev": "b40b8db793de031bf0cb594a2c814ddf018c0693 tags/v3.3.6.RELEASE~12", "commitMessage": "Merge #2151 into 3.3.6\n", "commitDateTime": "2020-05-19 11:00:27", "authoredDateTime": "2020-05-19 11:00:27", "commitGitStats": [{"filePath": "build.gradle", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "buildSrc/build.gradle", "insertions": 17, "deletions": 13, "lines": 30}, {"filePath": "buildSrc/src/main/java/io/reactor/gradle/OptionalDependenciesPlugin.java", "insertions": 65, "deletions": 0, "lines": 65}, {"filePath": "buildSrc/src/test/java/io/reactor/gradle/OptionalDependenciesPluginTest.java", "insertions": 110, "deletions": 0, "lines": 110}, {"filePath": "reactor-core/build.gradle", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-test/build.gradle", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "OptionalDependenciesPlugin.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPlugin", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OptionalDependenciesPluginTest.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPluginTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "cf38eefc7f0f8f389626deb2021d448bab655d9f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a60c6820922cabe588b984824e9ac8966b20ea99", "b40b8db793de031bf0cb594a2c814ddf018c0693"], "nameRev": "cf38eefc7f0f8f389626deb2021d448bab655d9f tags/v3.4.0-M1~22", "commitMessage": "Merge #2151 into 3.4.0-M1\n", "commitDateTime": "2020-05-19 11:01:06", "authoredDateTime": "2020-05-19 11:01:06", "commitGitStats": [{"filePath": "build.gradle", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "buildSrc/build.gradle", "insertions": 17, "deletions": 13, "lines": 30}, {"filePath": "buildSrc/src/main/java/io/reactor/gradle/OptionalDependenciesPlugin.java", "insertions": 65, "deletions": 0, "lines": 65}, {"filePath": "buildSrc/src/test/java/io/reactor/gradle/OptionalDependenciesPluginTest.java", "insertions": 110, "deletions": 0, "lines": 110}, {"filePath": "reactor-core/build.gradle", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-test/build.gradle", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "OptionalDependenciesPlugin.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPlugin", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OptionalDependenciesPluginTest.java", "spoonMethods": [{"spoonMethodName": "io.reactor.gradle.OptionalDependenciesPluginTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 2, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Mutualized `subscribe` error-catching doesn't play well with StepVerifier", "body": "## Expected Behavior\r\nThe catch-all code in `Flux#subscribe(Subscriber)`, `Operators.reportThrowInSubscribe` can lead to a double `onSubscribe`. This was deeemed ok because well-formed subscribers are supposed to react to that by ignoring the second `Subscription` (after cancelling it), but `StepVerifier` is a bit different: it must somehow report the underlying failure to the test framework. Furthermore, it cannot simply ignore double subscriptions as they could come from a really problematic `Publisher`.\r\n\r\n\r\n## Actual Behavior\r\nCurrently, this means that instead of reporting the original failure, `StepVerifier` can hide it and report a double subscription instead...\r\n\r\nIn some instances, it was found to report at best a `CompositeException` with original failure + double subscription...\r\n\r\n\r\n## Steps to Reproduce\r\n```java\r\n\tprivate static final class ErrorInSubscribeFlux<T> extends Flux<T> {\r\n\r\n\t\tfinal Supplier<T> tSupplier;\r\n\r\n\t\tprivate ErrorInSubscribeFlux(Supplier<T> supplier) {\r\n\t\t\ttSupplier = supplier;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void subscribe(CoreSubscriber<? super T> actual) {\r\n\t\t\t//for now we MUST call actual.onSubscribe in case of exception\r\n\t\t\tfinal T t = tSupplier.get();\r\n\t\t\tif (t == null) throw new NullPointerException(\"supplied null value\");\r\n\r\n\t\t\t//past this point we MUST NOT  call actual.onSubscribe in case of exception\r\n\t\t\tactual.onSubscribe(new Subscription() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void request(long l) {\r\n\t\t\t\t\tactual.onNext(t);\r\n\t\t\t\t\tthrow new IllegalStateException(\"ErrorInSubscribeFlux\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void cancel() {\r\n\t\t\t\t\t//NO-OP\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void mutualizedSubscribeErrorHandlingWPreOnSubscribe() {\r\n\t\tnew ErrorInSubscribeFlux<>(() -> null)\r\n\t\t\t\t.as(StepVerifier::create)\r\n\t\t\t\t.verifyErrorMessage(\"supplied null value\");\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void mutualizedSubscribeErrorHandlingPostOnSubscribe() {\r\n\t\tnew ErrorInSubscribeFlux<>(() -> 42)\r\n\t\t\t\t.as(StepVerifier::create)\r\n\t\t\t\t.expectNext(42)\r\n\t\t\t\t.verifyErrorSatisfies(e -> assertThat(e)\r\n\t\t\t\t\t\t.isInstanceOf(IllegalStateException.class)\r\n\t\t\t\t\t\t.hasMessage(\"ErrorInSubscribeFlux\"));\r\n\t}\r\n```\r\n\r\nWhile the first test passes, the second test fails because `ErrorInSubscribeFlux` is hidden by the following exception:\r\n\r\n```\r\njava.lang.AssertionError: expectation failed (an unexpected Subscription has been received: reactor.core.publisher.Operators$EmptySubscription@16e7dcfd; actual: reactor.core.publisher.scenarios.FluxTests$ErrorInSubscribeFlux$1@3d121db3)\r\n\r\n\tat reactor.test.MessageFormatter.assertionError(MessageFormatter.java:115)\r\n\tat reactor.test.MessageFormatter.failPrefix(MessageFormatter.java:104)\r\n\tat reactor.test.MessageFormatter.fail(MessageFormatter.java:73)\r\n\tat reactor.test.DefaultStepVerifierBuilder$DefaultVerifySubscriber.setFailure(DefaultStepVerifierBuilder.java:1300)\r\n\tat reactor.test.DefaultStepVerifierBuilder$DefaultVerifySubscriber.setFailure(DefaultStepVerifierBuilder.java:1286)\r\n\tat reactor.test.DefaultStepVerifierBuilder$DefaultVerifySubscriber.onSubscribe(DefaultStepVerifierBuilder.java:1134)\r\n\tat reactor.core.publisher.Operators.reportThrowInSubscribe(Operators.java:190)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:8268)\r\n```\r\n\r\n## Possible Solution\r\n * backtrack and let each operator individually deal with exceptions, thus correctly deciding when one cannot invoke `actual.onSubscribe(Operators.emptySubscription())`\r\n * have `reportThrowInSubscribe` emit a specific instance of `EmptySubscription` that can be detected (via a **new public API**) by `StepVerifier` as the only case where a second subscription can be ignored.\r\n\r\n## Your Environment\r\n\r\n* Reactor version(s) used: 3.3.5.BUILD-SNAPSHOT (see #2072)\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/2107", "user": "simonbasle", "labels": ["for/team-attention", "status/need-decision", "type/bug", "warn/blocker"], "created": "2020-04-08 16:28:59", "closed": "2020-04-15 10:53:50", "commits": {"fb737a9280c104bba99633a1bbe4d5e36d1e631b": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "b8942096957a734b68bd7bc566f2b63298429d32": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "fb737a9280c104bba99633a1bbe4d5e36d1e631b", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b8942096957a734b68bd7bc566f2b63298429d32", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["ff755f4a286c7825169218a7a516c4d990d0e7f5"], "nameRev": "b8942096957a734b68bd7bc566f2b63298429d32 tags/v3.3.5.RELEASE~9", "commitMessage": "Fix #2107 by throwing (and checking) a specialized error (#2111)\n\n#2072 added an edge case where a second `onSubscribe` may happen.\r\n\r\nWhile it is okay from the spec's PoV, `reactor-test`'s `StepVerifier` was a bit too\r\nstrict about it.\r\n\r\nChange change relaxes the verifications in `StepVerifier` and ignores the `Subscription`\r\nif it is passed by `reportThrowInSubscribe`.", "commitDateTime": "2020-04-15 12:53:47", "authoredDateTime": "2020-04-15 12:53:47", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 26, "deletions": 1, "lines": 27}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoFirstTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDoFirstTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 19, "deletions": 0, "lines": 19}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.reportThrowInSubscribe(reactor.core.CoreSubscriber,java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.canAppearAfterOnSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.OnErrorSubscription", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDoFirstTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoFirstTest.runnableFailure_NotFuseable()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoFirstTest.runnableFailure_Fuseable()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDoFirstTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoFirstTest.runnableFailure_NotFuseable()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoFirstTest.runnableFailure_Fuseable()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.mutualizedSubscribeErrorHandlingPostOnSubscribe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Missing information in DefaultStepVerifierBuilder#onSubscribe in failure case", "body": "## Expected Behavior\r\nWhen a failure has to be set because of an unexpected subscription, we expect the failure message to contains information about the subscription nature.\r\n\r\n## Actual Behavior\r\nActually, information about the initial subscription is missing.\r\n\r\n## Possible Solution\r\nadd the missing `%s` in the message and a call to the `.get()` method of `this`.\r\n\r\n```java\r\nelse {\r\n\tsetFailure(null,\r\n\t\t\t \"an unexpected Subscription has been received: %s; actual: %s\",\r\n\t\t\tsubscription,\r\n\t\t\tthis.get());\r\n}\r\n```", "url": "https://github.com/reactor/reactor-core/issues/2106", "user": "aneveu", "labels": ["type/bug"], "created": "2020-04-08 10:57:58", "closed": "2020-04-09 09:47:56", "commits": {"bb65989767f25fe5813ef5f8843d914175a28129": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "acfa6df9bc8296670c5cfbead094e93a6951d560": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "bb65989767f25fe5813ef5f8843d914175a28129", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["321e8725f95b8e0bfd4611a3d3c9586fe94419f2"], "nameRev": "bb65989767f25fe5813ef5f8843d914175a28129 tags/v3.2.17.RELEASE~12", "commitMessage": "fix #2106 Fix DefaultStepVerifierBuilder#onSubscribe error format\n\nThe error message was missing a `%s` and using the wrong\r\nobject for the current Subscription (as the toString method\r\nof the subscriber doesn't reflect the held value)", "commitDateTime": "2020-04-09 11:45:14", "authoredDateTime": "2020-04-09 11:45:14", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "acfa6df9bc8296670c5cfbead094e93a6951d560", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["62eb77dcccfd2ca04d32825361be538196e61057", "bb65989767f25fe5813ef5f8843d914175a28129"], "nameRev": "acfa6df9bc8296670c5cfbead094e93a6951d560 tags/v3.3.5.RELEASE~14", "commitMessage": "Merge #2106 into 3.3\n", "commitDateTime": "2020-04-09 11:47:20", "authoredDateTime": "2020-04-09 11:47:20", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["bb65989767f25fe5813ef5f8843d914175a28129"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": ["reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "Mono.toFuture(): invocation of cancel after completion.", "body": "We have a code like below which does the following:\r\n\r\n1. Create a local file\r\n2. Download contents to this file\r\n3. If the subscription is canceled or there is an error we remove the possibly partially written file\r\n\r\n```java\r\nfinal String fileName = \"myLocalFile.txt\";\r\nMono<String> fileDownloadMono = Mono.using(() -> new PrintWriter(fileName, \"UTF-8\"),\r\n        new Function<PrintWriter, Mono<String>>() {\r\n            @Override\r\n            public Mono<String> apply(PrintWriter printWriter) {\r\n                // Download from network.\r\n                System.out.println(\"Downloading from network\");\r\n                String downloadedContent = \"hello\";\r\n                // write to local file\r\n                System.out.println(\"Writing to local file\");\r\n                printWriter.write(downloadedContent);\r\n                return Mono.just(fileName);\r\n            }\r\n        },\r\n        printWriter -> {\r\n            printWriter.close();\r\n        })\r\n        .doFinally(signalType -> {\r\n            if (signalType == SignalType.ON_ERROR\r\n                || signalType == SignalType.CANCEL) {\r\n                System.out.println(\"Unable to complete download/write to file, deleting unfinished file.\");\r\n                (new File(fileName)).delete();\r\n            }\r\n        });\r\n```\r\n\r\nThis works fine. The issue we're facing is when we convert this Mono to a Future like below:\r\n\r\n```java\r\nfileDownloadMono.toFuture();\r\n```\r\n\r\n`toFuture()` operator cancels the Mono as soon as the Mono completes, which result in the removal of successfully completed file.\r\n\r\nCode in `toFuture()` operator that cancel the Mono is [here](https://github.com/reactor/reactor-core/blob/c6b75f2578ee5f201ac06add2239322cc5b7bfcd/reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java#L59).", "url": "https://github.com/reactor/reactor-core/issues/2070", "user": "anuchandy", "labels": ["type/bug"], "created": "2020-03-10 19:49:27", "closed": "2020-03-11 15:37:27", "commits": {"6bdb0d6ef67726ec9a2de2a96fedcc14e4ead8ce": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d87a44d2cfe68d7c6d656f6d963e0fe92c909b36": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5b6d0ba845cfa673d5f180d68825c4f46e6c1e34": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "6bdb0d6ef67726ec9a2de2a96fedcc14e4ead8ce", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d87a44d2cfe68d7c6d656f6d963e0fe92c909b36", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["93e4c9654e6322464c996c00b2f74ffc1917375f"], "nameRev": "d87a44d2cfe68d7c6d656f6d963e0fe92c909b36 tags/v3.2.16.RELEASE~2", "commitMessage": "fix #2070 Avoid cancel in toFuture#onNext on Mono source\n\nWhen used with a Mono, the cancellation of the source is not\r\nnecessary in `onNext`, and can even be an issue.\r\n\r\nThis commit makes that behavior driven by a configurable\r\nboolean, and deactivated by default in the currently only\r\nuse of the Subscriber.", "commitDateTime": "2020-03-11 16:35:14", "authoredDateTime": "2020-03-11 16:35:14", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java", "insertions": 36, "deletions": 5, "lines": 41}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.toFuture()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoToCompletableFuture.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture.onNext(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "MonoToCompletableFutureTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.error()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.monoSourceIsntCancelled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.sourceCanBeCancelledExplicitlyByOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "5b6d0ba845cfa673d5f180d68825c4f46e6c1e34", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["981217366454d97c5c39d7ef27076f1f1569299b", "d87a44d2cfe68d7c6d656f6d963e0fe92c909b36"], "nameRev": "5b6d0ba845cfa673d5f180d68825c4f46e6c1e34 tags/v3.3.4.RELEASE~8", "commitMessage": "Merge #2070 into 3.3\n", "commitDateTime": "2020-03-11 16:36:57", "authoredDateTime": "2020-03-11 16:36:57", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java", "insertions": 36, "deletions": 5, "lines": 41}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.toFuture()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoToCompletableFuture.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture.onNext(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "MonoToCompletableFutureTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.error()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.monoSourceIsntCancelled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFutureTest.sourceCanBeCancelledExplicitlyByOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d87a44d2cfe68d7c6d656f6d963e0fe92c909b36"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 9.0, "deletions": 2.0, "lines": 11.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 1.0, "INS": 3.0, "MOV": 2.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoToCompletableFuture", "reactor.core.publisher.Mono.toFuture()", "reactor.core.publisher.MonoToCompletableFuture.onNext(java.lang.Object)"]}, {"title": "VirtualTimeScheduler does not run scheduled tasks since 3.3.3.RELEASE", "body": "## Expected Behavior\r\n`VirtualTimeScheduler` runs scheduled tasks at certain intervals.\r\n\r\n## Actual Behavior\r\nAt version `3.3.3.RELEASE`, `VirtualTimeScheduler` runs the task once and never again, even though virtual time elapsed.\r\n\r\n## Steps to Reproduce\r\nWith `io.projectreactor:reactor-test:3.2.15.RELEASE`, the following test passes. After updating to `3.3.3.RELEASE`, it hangs.\r\n\r\n```\r\n@Test\r\npublic void isolateIssue() {\r\n\tScheduler.Worker subscriptionWorker = VirtualTimeScheduler.getOrSet().createWorker();\r\n\tList<String> source = Stream.of(\"first\", \"second\", \"third\").collect(Collectors.toList());\r\n\r\n\r\n\tStepVerifier.withVirtualTime(() -> {\r\n\t\tEmitterProcessor<String> fluxEmitter = EmitterProcessor.create();\r\n\r\n\t\tsubscriptionWorker.schedulePeriodically(() -> {\r\n\t\t\tif (source.size() > 0)\r\n\t\t\t\tfluxEmitter.onNext(source.remove(0));\r\n\t\t\telse\r\n\t\t\t\tfluxEmitter.onComplete();\r\n\t\t}, 0, 10, TimeUnit.MILLISECONDS);\r\n\t\treturn fluxEmitter;\r\n\t})\r\n\t\t\t.expectNext(\"first\")\r\n\t\t\t.expectNoEvent(Duration.ofMillis(10))\r\n\t\t\t.expectNext(\"second\")\r\n\t\t\t.expectNoEvent(Duration.ofMillis(10))\r\n\t\t\t.expectNext(\"third\")\r\n\t\t\t.expectNoEvent(Duration.ofMillis(10))\r\n\t\t\t.verifyComplete();\r\n}\r\n```\r\n\r\n## Possible Solution\r\nNo solutions, but I suspect #2017 may have something to do with this.", "url": "https://github.com/reactor/reactor-core/issues/2060", "user": "elefeint", "labels": ["area/reactor-test", "status/has-workaround", "type/bug"], "created": "2020-02-27 22:53:09", "closed": "2020-03-09 14:05:40", "commits": {"e09c1308f469b30c7bef4fcdddc7ab3574a614d4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "61b5c02a9242b7d8214c1b0bf9df1d8ad1b37a75": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 10.000277777777777, "commitsDetails": [{"commitHash": "e09c1308f469b30c7bef4fcdddc7ab3574a614d4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "61b5c02a9242b7d8214c1b0bf9df1d8ad1b37a75", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["34df2b0946f88b3655101a191ff292b1e66d724a"], "nameRev": "61b5c02a9242b7d8214c1b0bf9df1d8ad1b37a75 tags/v3.3.4.RELEASE~11", "commitMessage": "fix #2060 Introduce and use VirtualTimeScheduler#getOrSet(boolean)\n\nA change in #2017 introduced a regression that prevented externally\r\ninitialized VirtualTimeSchedulers to be used in StepVerifier.\r\nThis commit allows the StepVerifier to once again discover an already\r\nset VTS instance and use it, taking the `defer` parameter into account.", "commitDateTime": "2020-03-09 15:05:38", "authoredDateTime": "2020-03-09 15:05:38", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/StepVerifier.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java", "insertions": 19, "deletions": 2, "lines": 21}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 35, "deletions": 3, "lines": 38}, {"filePath": "reactor-test/src/test/java/reactor/test/scheduler/VirtualTimeSchedulerTests.java", "insertions": 17, "deletions": 0, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "StepVerifier.java", "spoonMethods": [{"spoonMethodName": "reactor.test.withVirtualTime(java.util.function.Supplier,long)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "VirtualTimeScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.getOrSet(reactor.test.scheduler.VirtualTimeScheduler)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.getOrSet(boolean)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.set(reactor.test.scheduler.VirtualTimeScheduler)", "TOT": 5, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.externalGetOrSetTakenIntoAccount()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "VirtualTimeSchedulerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.getOrSetWithDefer()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Context.putAll can fail with a *custom* Context with parallel stream", "body": "## Expected Behavior\r\n`Context.putAll(Context)` should work with custom implementations of `Context`.\r\n\r\n## Actual Behavior\r\nLet's imagine a project using `reactor-core` rolls its own `Context` implementation. The `stream()` method could in that case return a parallel `Stream`. However, if the default `putAll` method in `Context` isn't overridden, there is an issue: it combines both contexts by iterating their `stream()` and putting entries in a new `ContextN`, which is a (non-thread-safe) `LinkedHashMap`.\r\nThis can result in arbitrary loss of data due to concurrent writes.\r\n\r\n## Steps to Reproduce\r\nRun the [ContextTest#defaultPutAllWorksWithParallelStream](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/test/java/reactor/util/context/ContextTest.java#L467) test several times until it fails.\r\n\r\n## Possible Solution\r\nThe iteration-in-insertion-order aspect of `LinkedHashMap` is important, so one can either make the `ContextN#accept(Object, Object)` `synchronized`, or ensure all the `putAll` implementations that rely on `.stream().forEach(...)` force stream sequentiality with `.stream().sequential().forEach(...)`. The later seems to be slightly more performant, perhaps because most of the time the `Stream`s will already be sequential.", "url": "https://github.com/reactor/reactor-core/issues/2050", "user": "simonbasle", "labels": ["type/bug"], "created": "2020-02-18 09:33:33", "closed": "2020-02-18 10:56:28", "commits": {"35a44a765fc258a264cd1cb8d094edf837282e29": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f9cd50c565c153e4bd5b928baf3dcace65b5a163": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "35a44a765fc258a264cd1cb8d094edf837282e29", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f9cd50c565c153e4bd5b928baf3dcace65b5a163", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c0a7bb8f4fce039dea2e40e7b9f6c06e9762aa28"], "nameRev": "f9cd50c565c153e4bd5b928baf3dcace65b5a163 tags/v3.3.3.RELEASE~4", "commitMessage": "fix #2050 Use stream().sequential() for Context default putAll\n\nIn case an external `Context` implementation returns a parallel Stream,\r\ndefault `putAll` can fail due to `ContextN` not being thread-safe.\r\n\r\nThis commit ensures that when such operations are performed over the\r\n`stream()`, it is forced to be `sequential()`.", "commitDateTime": "2020-02-18 11:56:26", "authoredDateTime": "2020-02-18 11:56:26", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/context/Context.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/util/context/ContextN.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/util/context/CoreContext.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextTest.java", "insertions": 10, "deletions": 7, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Context.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.putAll(reactor.util.context.Context)", "TOT": 6, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "ContextN.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextN.putAll(reactor.util.context.Context)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "CoreContext.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.putAll(reactor.util.context.Context)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ContextTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextTest.defaultPutAllWorksWithParallelStream()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f9cd50c565c153e4bd5b928baf3dcace65b5a163"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4.0, "deletions": 4.0, "lines": 8.0, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 12.0, "UPD": 4.0, "INS": 4.0, "MOV": 4.0, "DEL": 0.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/util/context"], "changesInPackagesSPOON": ["reactor.util.context.putAll(reactor.util.context.Context)", "reactor.util.context.ContextN.putAll(reactor.util.context.Context)"]}, {"title": "MonoCollect doesn't discard in case of onNext error + fusion", "body": "Follow-up to #1924 \r\n\r\nWhen the `collect` partially occurs then ends up failing on a subsequent `onNext` (due to the accumulating consumer failing), the partial buffer is not discarded IFF the operator is fused:\r\n\r\n```java\r\n\t@Test\r\n\tpublic void discardElementAndBufferOnAccumulatorLateFailure_fused() {\r\n\t\tFlux.just(1, 2, 3, 4)\r\n\t\t    .collect(ArrayList::new, (l, t) -> {\r\n\t\t\t    if (t == 3) {\r\n\t\t\t\t    throw new IllegalStateException(\"accumulator: boom\");\r\n\t\t\t    }\r\n\t\t\t    l.add(t);\r\n\t\t    })\r\n\t\t    .as(StepVerifier::create)\r\n\t\t    //WARNING: we need to request fusion so this expectFusion is important\r\n\t\t    .expectFusion(Fuseable.ASYNC)\r\n\t\t    .expectErrorMessage(\"accumulator: boom\")\r\n\t\t    .verifyThenAssertThat()\r\n\t\t    .hasDiscardedExactly(1, 2, 3);\r\n\t}\r\n```\r\n(note removing the `expectFusion` above, or appending a `.hide()` to the `just` will trigger discard).\r\n\r\nRoot cause is `Operators.MonoSubscriber#cancel()` which only discards the `value` (here the buffer) if `STATE <= HAS_REQUEST_NO_VALUE`, which excludes `FUSED` states.", "url": "https://github.com/reactor/reactor-core/issues/2042", "user": "simonbasle", "labels": ["area/doOnDiscard", "type/bug"], "created": "2020-02-11 18:09:13", "closed": "2020-02-17 17:05:12", "commits": {"8296456583b8168f631c076f6a0bc0ff01407103": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5e39c93aed68c133ea5048822c5b6ade43711811": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "46ed282c816e3d709f3238b35e9b0522e24128a2": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "8296456583b8168f631c076f6a0bc0ff01407103", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5e39c93aed68c133ea5048822c5b6ade43711811", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["20113d5a16aa9241848ca5f998c798f4be620cb7"], "nameRev": "5e39c93aed68c133ea5048822c5b6ade43711811 tags/v3.2.15.RELEASE~4", "commitMessage": "fix #2042 collect() discards on consumer error when fused\n\n", "commitDateTime": "2020-02-17 18:04:09", "authoredDateTime": "2020-02-17 18:04:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java", "insertions": 34, "deletions": 0, "lines": 34}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.cancel()", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "MonoCollectTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardElementAndBufferOnAccumulatorLateFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardElementAndBufferOnAccumulatorLateFailure_fused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "46ed282c816e3d709f3238b35e9b0522e24128a2", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["0ed361fbe5c5fabd2004a5f9495b622d08abe29b", "5e39c93aed68c133ea5048822c5b6ade43711811"], "nameRev": "46ed282c816e3d709f3238b35e9b0522e24128a2 tags/v3.3.3.RELEASE~7", "commitMessage": "Merge #2042 into 3.3\n", "commitDateTime": "2020-02-17 18:04:45", "authoredDateTime": "2020-02-17 18:04:45", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java", "insertions": 34, "deletions": 0, "lines": 34}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.cancel()", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "MonoCollectTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardElementAndBufferOnAccumulatorLateFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectTest.discardElementAndBufferOnAccumulatorLateFailure_fused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5e39c93aed68c133ea5048822c5b6ade43711811"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 3.0, "lines": 5.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 0.0, "INS": 1.0, "MOV": 4.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.MonoSubscriber.cancel()"]}, {"title": "MonoSubscribeOn doesn't dispose worker if cancelled before subscription", "body": "In the case where a `subscribeOn` is immediately cancelled, before there was even a chance the parent subscription was registered, the `Worker` might have been created but is not disposed.\r\n\r\n`FluxSubscribeOn` correctly unconditionally disposes the worker, so the same strategy should be applied here.\r\n", "url": "https://github.com/reactor/reactor-core/issues/2037", "user": "simonbasle", "labels": ["type/bug"], "created": "2020-02-07 15:30:45", "closed": "2020-02-07 17:30:25", "commits": {"b00dbd08201c28e9be356a6c6a1ccaded3c0bfec": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "20113d5a16aa9241848ca5f998c798f4be620cb7": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "29218c1c317545d9fee4fc011cf674d3aade3482": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "b00dbd08201c28e9be356a6c6a1ccaded3c0bfec", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "20113d5a16aa9241848ca5f998c798f4be620cb7", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["00a23332e02542ae4f753b24e765a926e5865da1"], "nameRev": "20113d5a16aa9241848ca5f998c798f4be620cb7 tags/v3.2.15.RELEASE~5", "commitMessage": "fix #2037 Unconditionally dispose worker in MonoSubscribeOn#cancel\n\n\r\n", "commitDateTime": "2020-02-07 18:29:30", "authoredDateTime": "2020-02-07 18:29:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnTest.java", "insertions": 29, "deletions": 0, "lines": 29}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoSubscribeOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.cancel()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoSubscribeOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnTest.disposeWorkerIfCancelledBeforeOnSubscribe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "29218c1c317545d9fee4fc011cf674d3aade3482", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["3781f2647088a62354c2291c75f3e5e2e79da094", "20113d5a16aa9241848ca5f998c798f4be620cb7"], "nameRev": "29218c1c317545d9fee4fc011cf674d3aade3482 tags/v3.3.3.RELEASE~10", "commitMessage": "Merge #2037 into 3.3\n", "commitDateTime": "2020-02-07 18:29:59", "authoredDateTime": "2020-02-07 18:29:59", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnTest.java", "insertions": 29, "deletions": 0, "lines": 29}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoSubscribeOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.cancel()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoSubscribeOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnTest.disposeWorkerIfCancelledBeforeOnSubscribe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["20113d5a16aa9241848ca5f998c798f4be620cb7"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 3.0, "lines": 5.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 0.0, "MOV": 2.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.cancel()"]}, {"title": "Flux.replay / Flux.cache hangs or serves wrong values due to regressions in 3.3.[0-2]", "body": "In 3.3.0, #1185 introduced a change that aims at performing the minimum necessary request on a cached/replayed source upon `connect`. Comparing to `Californium` where the source would always be requested by `Long.MAX_VALUE` upon connection, 3.3.0 would attempt to take the maximum requested amount from early subscribers, ie these that subscribed to the `ConnectableFlux` **before** `connect()` is called.\r\n\r\nThere was several bugs with that new implementation, that led to underrequesting and hanging:\r\n\r\n - [x] Pre-connect subscribers would participate in the initial request, but if they request in \"batches\" their subsequent requests wouldn't get propagated (issue #1921, fixed in #1948)\r\n - [x] With that first change, having no early subscriber before `connect()` means no request was made _at all_, instead of falling back to the `MAX_VALUE` behavior (causes #2028 and spring-projects/spring-framework#24472, fixed in #2031)", "url": "https://github.com/reactor/reactor-core/issues/2030", "user": "simonbasle", "labels": ["type/bug", "warn/regression"], "created": "2020-02-04 17:03:07", "closed": "2020-02-05 09:59:03", "commits": {"2a26f31aa5be1f16c0b946c5263b4390e3fbf457": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b70d59a47ca1f80bacb64b9f7c734690084d36ac": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2a26f31aa5be1f16c0b946c5263b4390e3fbf457", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b70d59a47ca1f80bacb64b9f7c734690084d36ac", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["309fd86f7b9ec83eb18e73e6dcf291dde2f17e90"], "nameRev": "b70d59a47ca1f80bacb64b9f7c734690084d36ac tags/v3.3.3.RELEASE~15", "commitMessage": "fix #2030 Let replay request(UNBOUNDED) when no early subscriber\n\nThis commit ensures that Flux.replay falls back to the 3.2.x behavior\r\nof requesting Long.MAX_VALUE when no early subscriber emitted requests\r\nbefore the `connect()`.\r\n\r\nAlso fixes #2028", "commitDateTime": "2020-02-05 10:58:59", "authoredDateTime": "2020-02-05 10:58:59", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 40, "deletions": 0, "lines": 40}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxReplayTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplayTest.ifSubscribeBeforeConnectThenTrackFurtherRequests()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplayTest.ifNoSubscriptionBeforeConnectThenUnbounded()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "ReactorDebugAgent makes Flux#collectList return empty Mono", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\nUsing `ReactorDebugAgent` changes the behaviour of the return value of `Flux.collectList()`. If I am not using the agent `Flux.empty().collectList()` will return `Mono.just(List.of())`, while if I am using the agent, it will return `Mono.empty()`.\r\n\r\n## Expected Behavior\r\nI would expect `Flux.empty().collectList()` to return `Mono.just(List.of())` without mattering if I am using the debug agent or not.\r\n\r\n## Actual Behavior\r\nIf I am using the debug agent, the return value of that call will be `Mono.empty()`.\r\n\r\n## Steps to Reproduce\r\n\r\nWithout the agent:\r\n\r\n```java\r\n  @Test\r\n  void noAgent() {\r\n    var empty = new EmptyFlux();\r\n    var result = empty.value()\r\n        .collectList();\r\n\r\n    StepVerifier.create(result)\r\n        .assertNext(res -> assertEquals(0, res.size()))\r\n        .verifyComplete();\r\n  }\r\n\r\n  public static class EmptyFlux {\r\n    public Flux<String> value() {\r\n      return Flux.empty();\r\n    }\r\n  }\r\n```\r\n\r\nWith the agent:\r\n\r\n```java\r\n  @Test\r\n  void agent() {\r\n    ReactorDebugAgent.init();\r\n    var empty = new EmptyFlux();\r\n    var result = empty.value()\r\n        .collectList();\r\n\r\n    StepVerifier.create(result)\r\n        .verifyComplete();\r\n  }\r\n\r\n  public static class EmptyFlux {\r\n    public Flux<String> value() {\r\n      return Flux.empty();\r\n    }\r\n  }\r\n```\r\n\r\nRun the tests separately.\r\n\r\n## Possible Solution\r\nMy knowledge of the library is not good enough to think about the cause and possible solutions :(\r\n\r\n## Your Environment\r\nI am using reactor-core, reactor-tools and reactor-test version 3.3.2 and I am executing the tests in JUnit 5.\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\n\r\n* Reactor version(s) used: 3.3.2\r\n* Other relevant libraries versions (eg. `netty`, ...): JUnit 5.5.2\r\n* JVM version (`javar -version`): OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.5+10)\r\n* OS and version (eg `uname -a`): Darwin MBP073.local 19.2.0 Darwin Kernel Version 19.2.0: Sat Nov  9 03:47:04 PST 2019; root:xnu-6153.61.1~20/RELEASE_X86_64 x86_64 i386", "url": "https://github.com/reactor/reactor-core/issues/2023", "user": "gmaiztegi", "labels": ["type/bug"], "created": "2020-01-27 11:31:00", "closed": "2020-01-27 15:15:14", "commits": {"89c8c96faafcbd5a36325ed4bfb20b741e9208d8": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "e93cd9dc1cf3f88e4dc3fc4cbbc767a8db3166e8": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "89c8c96faafcbd5a36325ed4bfb20b741e9208d8", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e93cd9dc1cf3f88e4dc3fc4cbbc767a8db3166e8", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["b05e933d0f5874d8afddabd2a7c80c3d94b7631e"], "nameRev": "e93cd9dc1cf3f88e4dc3fc4cbbc767a8db3166e8 tags/v3.2.15.RELEASE~10", "commitMessage": "Fix #2023 by handling \"empty `Callable`\" in `Flux#collectList` (#2024)\n\nIt seems that we were handling `Callable` (but not `Fuseable.ScalarCallable`) incorrectly\r\nand, instead of producing an empty list, were returning an empty `Mono` instead.\r\n\r\nThe change also simplifies handling of `Fuseable.ScalarCallable`.", "commitDateTime": "2020-01-27 16:03:12", "authoredDateTime": "2020-01-27 16:03:12", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 10, "deletions": 8, "lines": 18}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java", "insertions": 19, "deletions": 0, "lines": 19}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.collectList()", "TOT": 14, "UPD": 3, "INS": 0, "MOV": 9, "DEL": 2}]}, {"spoonFilePath": "MonoCollectListTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectListTest.emptyCallable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Limit of 256 invocations of `onErrorContinue()` ", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\n\r\n<!--- /!\\ Make sure to follow the Contribution Guidelines, notably for security issues and questions:\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md\r\nhttps://pivotal.io/security\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md#question-do-you-have-a-question\r\n-->\r\n\r\n## Expected Behavior\r\n<!--- Tell us what you think should happen. -->\r\nAccording to the javadoc `onErrorContinue()` should\r\n\r\n> recover from errors by dropping the incriminating element from the sequence and continuing with subsequent elements.\r\n\r\n## Actual Behavior\r\n<!--- Tell us what happens instead of the expected behavior. -->\r\nIn an (possibly) infinite `Flux`, after 256 invocations of `onErrorContinue()` the Flux stops processing elements.\r\n\r\n## Steps to Reproduce\r\n<!---Provide a link to a live example, or an unambiguous set of steps to\r\nreproduce this bug, eg. a unit test. Include code to reproduce, if relevant. -->\r\n\r\n```java\r\n@Test\r\npublic void repoCase() {\r\n    int numberOfRequests = 500;\r\n    Set<Integer> sink = new HashSet<>();\r\n\r\n    Flux\r\n            .fromStream(IntStream.range(0, numberOfRequests).boxed())\r\n            .map(sink::add)\r\n            .flatMap(i -> Mono.error(new Exception(\"any\")))\r\n            .onErrorContinue((throwable, o) -> {})\r\n            .subscribe();\r\n\r\n    Thread.sleep(1000);\r\n    Assertions.assertNotEquals(numberOfRequests, sink.size());\r\n    Assertions.assertEquals(256, sink.size());\r\n}\r\n```\r\n\r\n## Possible Solution\r\n<!--- Not obligatory, but you can suggest a fix/reason for the bug. -->\r\nI have no clue how to solve this. Just the fact, that it is reproducible 256, let me guess that some kind of state or metainformation like the `Context` is stored within just one bit an is just full after 256 entries.\r\n\r\n## Your Environment\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\nI used a standard spring boot application created from the initializer with spring boot version 2.2.2.RELEASE. Thus the version of reactor core is 3.3.1.RELEASE.\r\n\r\n* Reactor version(s) used:\r\n* Other relevant libraries versions (eg. `netty`, ...):\r\n* JVM version (`javar -version`): \r\njava version \"1.8.0_231\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_231-b11)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)\r\n* OS and version (eg `uname -a`):\r\nWindows 10 Enterprise, Version 1703\r\n\r\nI already asked the question in the community but didn't receive any answer, but comments on how to circumvent `onErrorContinue()`: https://stackoverflow.com/questions/59649584/limit-for-onerrorcontinue-in-flux ", "url": "https://github.com/reactor/reactor-core/issues/2011", "user": "PMacho", "labels": ["area/onErrorContinue", "type/bug"], "created": "2020-01-10 13:06:32", "closed": "2020-01-28 13:30:32", "commits": {"f7a53c16bd47a0ec9639ca61217b35d9ff6eaa98": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d02cf8eebbee223c37749cc29cfed46b3a659bc6": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "012c7213bb79680b3f8bfdf33d764b021df25f83": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 18.00027777777778, "commitsDetails": [{"commitHash": "f7a53c16bd47a0ec9639ca61217b35d9ff6eaa98", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d02cf8eebbee223c37749cc29cfed46b3a659bc6", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["e93cd9dc1cf3f88e4dc3fc4cbbc767a8db3166e8"], "nameRev": "d02cf8eebbee223c37749cc29cfed46b3a659bc6 tags/v3.2.15.RELEASE~9", "commitMessage": "fix #2011 Correctly count continued errors on flatmapped callable\n\nThis commit avoids hanging when onErrorContinue is set and there\r\nare more errors than the flatMap's concurrency.\r\nThe root cause is that when the function maps to a callable error\r\npublisher, no _producing_ is counted, so no replenishing occurs.", "commitDateTime": "2020-01-28 14:29:13", "authoredDateTime": "2020-01-28 14:29:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 14, "deletions": 0, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFlatMap.java", "spoonMethods": []}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.errorModeContinueLargerThanConcurrencySourceMappedCallableFails()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "012c7213bb79680b3f8bfdf33d764b021df25f83", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["243fe9d649a078388f2fab114723639a5d3906c3", "d02cf8eebbee223c37749cc29cfed46b3a659bc6"], "nameRev": "012c7213bb79680b3f8bfdf33d764b021df25f83 tags/v3.3.3.RELEASE~17", "commitMessage": "Merge #2011 into 3.3\n", "commitDateTime": "2020-01-28 14:30:07", "authoredDateTime": "2020-01-28 14:30:07", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 14, "deletions": 0, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFlatMap.java", "spoonMethods": []}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.errorModeContinueLargerThanConcurrencySourceMappedCallableFails()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d02cf8eebbee223c37749cc29cfed46b3a659bc6"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": []}, {"title": "BlockHound detects blocking call on cancel Timeout task", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\nBlockHound sometimes detects blocking call on cancel timeout task. \r\n\r\n<!--- /!\\ Make sure to follow the Contribution Guidelines, notably for security issues and questions:\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md\r\nhttps://pivotal.io/security\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md#question-do-you-have-a-question\r\n-->\r\n\r\n## Expected Behavior\r\n<!--- Tell us what you think should happen. -->\r\nBlockHound should not detect blocking calls in reactor-core\r\n\r\n## Actual Behavior\r\n<!--- Tell us what happens instead of the expected behavior. -->\r\nBlockHound detects blocking calls in reactor-core\r\n\r\n## Steps to Reproduce\r\n<!---Provide a link to a live example, or an unambiguous set of steps to\r\nreproduce this bug, eg. a unit test. Include code to reproduce, if relevant. -->\r\nHere is code which could reproduce issue\r\n```java\r\n@BeforeAll\r\nstatic void setUp() {\r\n    BlockHound.install();\r\n}\r\n\r\n@Test\r\nvoid cancelTimeoutBlocks() {\r\n    CopyOnWriteArrayList<Throwable> errors = new CopyOnWriteArrayList<>();\r\n    Schedulers.onHandleError((thread, throwable) -> {\r\n        errors.add(throwable);\r\n    });\r\n    Scheduler sc = Schedulers.newParallel(\"my-sc\", 10, true);\r\n    Flux<Long> test = Flux.interval(Duration.ZERO, Duration.ofMillis(5))\r\n            .flatMap(it -> {\r\n                return Mono.just(it).hide()\r\n                        .timeout(Duration.ofMillis(10_000))\r\n                        .subscribeOn(sc);\r\n            }, 20)\r\n            .subscribeOn(Schedulers.parallel())\r\n            .take(Duration.ofMillis(5_000));\r\n    test.blockLast();\r\n    Assertions.assertThat(errors).isEmpty();\r\n}\r\n```\r\nRun it and check for logs \r\n```\r\n13:36:58.222 [my-sc-12] ERROR reactor.core.scheduler.Schedulers - Scheduler worker in group main failed with an uncaught exception\r\njava.lang.Error: Blocking call! jdk.internal.misc.Unsafe#park\r\n\tat reactor.blockhound.BlockHound$Builder.lambda$new$0(BlockHound.java:196)\r\n\tat reactor.blockhound.BlockHound$Builder.lambda$install$6(BlockHound.java:318)\r\n\tat reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:46)\r\n\tat java.base/jdk.internal.misc.Unsafe.park(Unsafe.java)\r\n\tat java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:194)\r\n\tat java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:885)\r\n\tat java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:917)\r\n\tat java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1240)\r\n\tat java.base/java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:267)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.remove(ScheduledThreadPoolExecutor.java:1046)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.remove(ThreadPoolExecutor.java:1751)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.cancel(ScheduledThreadPoolExecutor.java:293)\r\n\tat reactor.core.scheduler.SchedulerTask.dispose(SchedulerTask.java:126)\r\n\tat reactor.core.publisher.MonoDelay$MonoDelayRunnable.cancel(MonoDelay.java:135)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.drainLoop(Operators.java:2051)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.drain(Operators.java:2020)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.cancel(Operators.java:1832)\r\n\tat reactor.core.publisher.Operators.terminate(Operators.java:1108)\r\n\tat reactor.core.publisher.StrictSubscriber.cancel(StrictSubscriber.java:155)\r\n\tat reactor.core.publisher.FluxTimeout$TimeoutTimeoutSubscriber.cancel(FluxTimeout.java:409)\r\n\tat reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onNext(FluxTimeout.java:159)\r\n\tat reactor.core.publisher.FluxHide$HideSubscriber.onNext(FluxHide.java:74)\r\n\tat reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2186)\r\n\tat reactor.core.publisher.FluxHide$HideSubscriber.request(FluxHide.java:58)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1994)\r\n\tat reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onSubscribe(FluxTimeout.java:148)\r\n\tat reactor.core.publisher.FluxHide$HideSubscriber.onSubscribe(FluxHide.java:69)\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\tat reactor.core.publisher.Mono.subscribe(Mono.java:4105)\r\n\tat reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:124)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)\r\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\n## Possible Solution\r\n<!--- Not obligatory, but you can suggest a fix/reason for the bug. -->\r\nProbably extend allowed blocking methods or document it\r\n\r\n## Your Environment\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\n\r\n* Reactor version(s) used: \r\nreactor-core:3.3.1.RELEASE,\r\nblockhound:1.0.1.RELEASE\r\n* Other relevant libraries versions (eg. `netty`, ...):\r\n* JVM version (`javar -version`): \r\nopenjdk version \"11\" 2018-09-25\r\nOpenJDK Runtime Environment 18.9 (build 11+28)\r\nOpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)\r\n* OS and version (eg `uname -a`):\r\nWin10", "url": "https://github.com/reactor/reactor-core/issues/2004", "user": "robotmrv", "labels": ["area/devexp", "type/bug"], "created": "2020-01-06 11:52:32", "closed": "2020-02-14 10:52:34", "commits": {"c181dfa00f3cc5c5ef3ba5ca0a5faf96991482c9": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "0ed361fbe5c5fabd2004a5f9495b622d08abe29b": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 38.000277777777775, "commitsDetails": [{"commitHash": "c181dfa00f3cc5c5ef3ba5ca0a5faf96991482c9", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0ed361fbe5c5fabd2004a5f9495b622d08abe29b", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["ae86602c5d37658b8e0bea8323ea3ef66a9211ec"], "nameRev": "0ed361fbe5c5fabd2004a5f9495b622d08abe29b tags/v3.3.3.RELEASE~8", "commitMessage": "Fix #2004 by whitelisting `SchedulerTask#dispose` (#2046)\n\nWhen the submitted task is disposed, there can be a concurrent race\r\nin `DelayedWorkQueue#remove` when it acquires `ReentrantLock#lock`.\r\n\r\nThis race cannot be avoided, hence the whitelisting.", "commitDateTime": "2020-02-14 11:52:30", "authoredDateTime": "2020-02-14 11:52:30", "commitGitStats": [{"filePath": "reactor-core/src/blockHoundTest/java/reactor/core/scheduler/ReactorBlockHoundIntegrationTest.java", "insertions": 24, "deletions": 1, "lines": 25}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ReactorBlockHoundIntegration.java", "insertions": 7, "deletions": 1, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ReactorBlockHoundIntegrationTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ReactorBlockHoundIntegrationTest", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ReactorBlockHoundIntegrationTest.shouldNotReportScheduledFutureTask()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ReactorBlockHoundIntegration.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ReactorBlockHoundIntegration.applyTo(reactor.blockhound.BlockHound$Builder)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Ensure docsZip defines a -docs classifier", "body": "since switching to `maven-publish`, maven naming conventions are enforced. this was missed as no warning is emitted by Gradle in case the archive's name doesn't follow said conventions (the plugin transparently renames \ud83d\ude22).\r\n\r\nthis impacts the zip of reference documentation, which ends up following the format `reactor-core-VERSION.zip` instead of (formerly) `reactor-core-docs-VERSION.zip`. Since there is no apparent way of keeping the name, the next best thing is to use a classifier and turn the filename into a deployable `reactor-core-VERSION-docs.zip`. Such a zip would still only be distributed to Artifactory.\r\n\r\n`3.2.13.RELEASE` and `3.3.1.RELEASE` where impacted, but the zip was renamed directly on artifactory. see also https://github.com/reactor/projectreactor.io/issues/48", "url": "https://github.com/reactor/reactor-core/issues/1975", "user": "simonbasle", "labels": ["type/bug", "type/chores", "warn/regression"], "created": "2019-11-26 14:11:53", "closed": "2019-11-27 10:55:17", "commits": {"84e9ba45b3fcd16a0d05250fd0ed9866822a7f47": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5ee0940904ae3fdf345e8726fca64d6834c9a824": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "84e9ba45b3fcd16a0d05250fd0ed9866822a7f47", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["2ba476070751fd60804fce111eda78266ee4c0e4"], "nameRev": "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e tags/v3.2.14.RELEASE~8", "commitMessage": "fix #1975 Publish docsZip with -docs classifier\n", "commitDateTime": "2019-11-27 11:48:07", "authoredDateTime": "2019-11-26 15:58:51", "commitGitStats": [{"filePath": "gradle/doc.gradle", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5ee0940904ae3fdf345e8726fca64d6834c9a824", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["0acc568e62825a356d3d9d67beea1448494fc1c7", "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e"], "nameRev": "5ee0940904ae3fdf345e8726fca64d6834c9a824 tags/v3.3.2.RELEASE~24", "commitMessage": "Merge #1975 into 3.3\n\n - propdeps was already reapplied in build.gradle on master, but\n propdeps-maven was not suppressed in setup.gradle\n - asciidoc.gradle changes to the target directory structure conflicts\n", "commitDateTime": "2019-11-27 11:53:16", "authoredDateTime": "2019-11-27 11:53:16", "commitGitStats": [{"filePath": "gradle/asciidoc.gradle", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "gradle/setup.gradle", "insertions": 0, "deletions": 1, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 1.0, "lines": 3.0, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["gradle"]}, {"title": "BoundedElasticScheduler does not invoke any tasks after interruption.", "body": "I've stumbled upon a problem with BoundedElasticScheduler when there's high traffic creating many queued task on it. Invoking dispose() on scheduled tasks seems to break scheduler, to the point where it is not invoking any new tasks.\r\n\r\n## Expected Behavior\r\nScheduler should correctly invoke tasks, after disposing all of its other tasks.\r\n\r\n## Actual Behavior\r\nScheduler doesn't do anything after disposing all of its tasks, and scheduling a new one.\r\n\r\n## Steps to Reproduce\r\nIn the following example, behavior is as follows:\r\n\r\n* ~520 tasks are scheduled\r\n* ~300 scheduled tasks are processed correctly\r\n* When dispose() is called all of scheduled tasks are cancelled\r\n* On most scheduled tasks InterruptedException occurs, except ~15 last ones (505-520)\r\n* Scheduled task after dispose() call is never invoked.\r\n\r\n```java\r\nLogger logger = LoggerFactory.getLogger(\"Test\");\r\n\r\n    @Test\r\n    public void test() throws InterruptedException {\r\n        Scheduler scheduler =\r\n                Schedulers.newBoundedElastic(30, Schedulers.DEFAULT_BOUNDED_ELASTIC_QUEUESIZE, \"test-scheduler\");\r\n        Disposable subscription = Flux.range(0, 100000000)\r\n                .flatMap(i -> {\r\n                    logger.info(\"Scheduling {}\", i);\r\n                    return Mono.fromSupplier(() -> invokeLongOperation(i))\r\n                            .subscribeOn(scheduler)\r\n                            .publishOn(Schedulers.parallel())\r\n                            .doOnError(throwable -> logger.error(\"Error occurred in thread {} \", i, throwable))\r\n                            .doOnCancel(() -> logger.info(\"Thread {} cancelled\", i));\r\n                })\r\n                .subscribe(i -> logger.info(\"Thread {} finished\", i),\r\n                           throwable -> logger.error(\"Error \", throwable));\r\n        Thread.sleep(10000);\r\n        logger.info(\"Invoking dispose\");\r\n        subscription.dispose();\r\n        Thread.sleep(1000);\r\n        Mono.fromSupplier(() -> invokeLongOperation(999999999))\r\n                .subscribeOn(scheduler)\r\n                .publishOn(Schedulers.parallel())\r\n                .subscribe((i) -> logger.info(\"Consumed value {} \", i),\r\n                           throwable -> logger.error(\"Exception\"));\r\n        logger.info(\"Sleeping\");\r\n        Thread.sleep(100000);\r\n    }\r\n\r\n    private int invokeLongOperation(Integer i) {\r\n        logger.info(\"Invoking long operation {}\", i);\r\n        try {\r\n            Thread.sleep(1000);\r\n        } catch (InterruptedException e) {\r\n            logger.error(\"Thread {} interrupted\", i);\r\n        }\r\n        return i;\r\n    }\r\n```\r\n\r\n##Environment\r\n\r\n* Reactor version used: 3.3.0\r\n* JVM version: 1.8.0\r\n", "url": "https://github.com/reactor/reactor-core/issues/1973", "user": "jacekmg", "labels": ["type/bug"], "created": "2019-11-25 14:26:05", "closed": "2020-02-14 09:11:22", "commits": {"1fb434f73abb6cd8a10170775a745a0b24c13475": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ae86602c5d37658b8e0bea8323ea3ef66a9211ec": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 80.00027777777778, "commitsDetails": [{"commitHash": "1fb434f73abb6cd8a10170775a745a0b24c13475", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ae86602c5d37658b8e0bea8323ea3ef66a9211ec", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["29218c1c317545d9fee4fc011cf674d3aade3482"], "nameRev": "ae86602c5d37658b8e0bea8323ea3ef66a9211ec tags/v3.3.3.RELEASE~9", "commitMessage": "fix #1973 Resolve a race that prevent decrement of REMAINING_TASK\n\nWhen the active worker becomes inactive and picks a deferred worker\r\nto serve, but at the same time that deferred worker is cancelled or\r\ndisposed, the later can be gone from the parent's pool (due to the\r\nformer polling).\r\n\r\nThe issue is that the decrementing of REMAINING_TASK was guarded\r\nby a successful removal of the deferred worker from the parent,\r\nwhich in the race is already removed and thus returns false.\r\n\r\nThe decrement must be done unconditionally at this step to fix\r\nthe issue.", "commitDateTime": "2020-02-14 10:11:21", "authoredDateTime": "2020-02-14 10:11:21", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/BoundedElasticScheduler.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/BoundedElasticSchedulerTest.java", "insertions": 42, "deletions": 0, "lines": 42}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BoundedElasticScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.BoundedElasticScheduler.DeferredDirect.dispose()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "BoundedElasticSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.BoundedElasticSchedulerTest.raceActiveWorkerDisposeAndDeferredDirectDispose()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ae86602c5d37658b8e0bea8323ea3ef66a9211ec"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 1.0, "lines": 3.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 0.0, "MOV": 2.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.BoundedElasticScheduler.DeferredDirect.dispose()"]}, {"title": "Flux onError's exhibit inconsistent behavior", "body": "This issue was working correctly in `3.2.11` and began to fail in `3.2.12`\r\n\r\nWhile upgrading our services, we ran into an issue where our onErrorResume which had previously been working, no longer did.\r\n\r\nIn examining the behavior, it seems that when a flux has only a single element, the onErrorResume is wrapped in a `ReactiveException` with the `.getCause()` being the original exception. When the publisher is a Mono or when a Flux has multiple elements, this behavior goes away.\r\n\r\nA junit test to demonstrate the inconsistent behavior (using NoSuchMethodException for no reason in particular except demonstration):\r\n\r\n```java\r\n  @Test\r\n  public void temptest() {\r\n    boolean monoTest = (boolean) Mono.just(\"\")\r\n      .flatMap(x -> Mono.error(new NoSuchMethodException()))\r\n      .onErrorResume(x -> x instanceof NoSuchMethodException ? Mono.just(true) : Mono.just(false))\r\n      .block();\r\n    boolean fluxMultiTest = (boolean) Flux.just(\"\", \"\")\r\n      .flatMap(x -> Mono.error(new NoSuchMethodException()))\r\n      .onErrorResume(x -> x instanceof NoSuchMethodException ? Mono.just(true) : Mono.just(false))\r\n      .next()\r\n      .block();\r\n    boolean fluxTest = (boolean) Flux.just(\"\")\r\n      .flatMap(x -> Mono.error(new NoSuchMethodException()))\r\n      .onErrorResume(x -> x instanceof NoSuchMethodException ? Mono.just(true) : Mono.just(false))\r\n      .next()\r\n      .block();\r\n\r\n    assertTrue(\"Mono test failed\", monoTest);\r\n    assertTrue(\"Flux Multi test failed\", fluxMultiTest);\r\n    assertTrue(\"Flux test failed\", fluxTest);  // The only assertion that fails\r\n  }\r\n```\r\n\r\nWhile we are lucky that we caught this issue in test, this now forces us to understand at every step whether the Flux is emitting a single element or more, and in areas of unpredictable behavior, we are forced to check both the actual exception and the ReactiveException, which does not seem to be the documented behavior.\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/1945", "user": "RankWeis", "labels": ["type/bug"], "created": "2019-11-06 19:47:57", "closed": "2019-11-07 16:44:03", "commits": {"1115399da07626e8889ee050732a7dd107e6ad92": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b220eb8b08f374c61f22a0d00890a75744bda979": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "cb74c0c377599723f4a51549f042040a555aa9d4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "1115399da07626e8889ee050732a7dd107e6ad92", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b220eb8b08f374c61f22a0d00890a75744bda979", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["dc6038507e1cddf6705ba45d9bbb1d46444d1d61"], "nameRev": "b220eb8b08f374c61f22a0d00890a75744bda979 tags/v3.2.13.RELEASE~8", "commitMessage": "fix #1945 Avoid unnecessary wrapping of exceptions in scalar flatMap\n\nDue to the usage of Operators.onNextPollError for the purpose of error\r\nmode with scalar sources, which returns a RuntimeException, the original\r\nerrors can be wrapped in a ReactiveException (provided they're not a\r\nRuntimeException already).\r\n\r\nThis is problematic, since this occurs even if no error mode strategy\r\nis in place.\r\n\r\nThis change introduces a new Operators.onNextError variant that doesn't\r\nwrap the exception nor cancels a Subscription. It merely returns the\r\noriginal error to be passed to onError.", "commitDateTime": "2019-11-07 17:41:33", "authoredDateTime": "2019-11-07 17:41:33", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java", "insertions": 14, "deletions": 14, "lines": 28}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 46, "deletions": 8, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapTest.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.drain()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMap.java", "spoonMethods": []}, {"spoonFilePath": "FluxHandleFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxHandleFuseable.HandleFuseableSubscriber.poll()", "TOT": 12, "UPD": 4, "INS": 4, "MOV": 0, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxHandleFuseable.HandleFuseableConditionalSubscriber.poll()", "TOT": 9, "UPD": 3, "INS": 3, "MOV": 0, "DEL": 3}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.onNextError(java.lang.Object,java.lang.Throwable,reactor.util.context.Context)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.noWrappingOfCheckedExceptions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.noWrappingOfCheckedExceptions_hide()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoFlatMapTest.noWrappingOfCheckedExceptions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoFlatMapTest.noWrappingOfCheckedExceptions_hide()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "cb74c0c377599723f4a51549f042040a555aa9d4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["c17e276ade11f54fe11e444fbd2e733244749452", "b220eb8b08f374c61f22a0d00890a75744bda979"], "nameRev": "cb74c0c377599723f4a51549f042040a555aa9d4 tags/v3.3.1.RELEASE~15", "commitMessage": "Merge #1945 into 3.3\n", "commitDateTime": "2019-11-07 17:43:44", "authoredDateTime": "2019-11-07 17:43:44", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java", "insertions": 14, "deletions": 14, "lines": 28}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 46, "deletions": 8, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapTest.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.drain()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMap.java", "spoonMethods": []}, {"spoonFilePath": "FluxHandleFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxHandleFuseable.HandleFuseableSubscriber.poll()", "TOT": 12, "UPD": 4, "INS": 4, "MOV": 0, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxHandleFuseable.HandleFuseableConditionalSubscriber.poll()", "TOT": 9, "UPD": 3, "INS": 3, "MOV": 0, "DEL": 3}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.onNextError(java.lang.Object,java.lang.Throwable,reactor.util.context.Context)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.noWrappingOfCheckedExceptions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.noWrappingOfCheckedExceptions_hide()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoFlatMapTest.noWrappingOfCheckedExceptions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoFlatMapTest.noWrappingOfCheckedExceptions_hide()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b220eb8b08f374c61f22a0d00890a75744bda979"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 69.0, "deletions": 31.0, "lines": 100.0, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 25.0, "UPD": 10.0, "INS": 8.0, "MOV": 0.0, "DEL": 7.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.onNextError(java.lang.Object,java.lang.Throwable,reactor.util.context.Context)", "reactor.core.publisher.FluxHandleFuseable.HandleFuseableConditionalSubscriber.poll()", "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.drain()", "reactor.core.publisher.FluxHandleFuseable.HandleFuseableSubscriber.poll()"]}, {"title": " Race condition in .bufferUntil causing \"Could not emit buffer due to lack of requests\"", "body": "<!--- Provide a general summary of the issue in the Title above -->\r\n\r\n<!--- /!\\ Make sure to follow the Contribution Guidelines, notably for security issues and questions:\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md\r\nhttps://pivotal.io/security\r\nhttps://github.com/reactor/.github/blob/master/CONTRIBUTING.md#question-do-you-have-a-question\r\n-->\r\n\r\n## Expected Behavior\r\n<!--- Tell us what you think should happen. -->\r\n`.bufferUntil` should not be able to cause \"Could not emit buffer due to lack of requests\" since it is deterministic, and not based on the rate of the subscriber like in `.bufferTimeout`.\r\n\r\n## Actual Behavior\r\n<!--- Tell us what happens instead of the expected behavior. -->\r\n`.bufferUntil` threw \"Could not emit buffer due to lack of requests\"\r\n\r\n## Steps to Reproduce\r\n<!---Provide a link to a live example, or an unambiguous set of steps to\r\nreproduce this bug, eg. a unit test. Include code to reproduce, if relevant. -->\r\n\r\n```java\r\npackage test;\r\n\r\nimport java.time.Duration;\r\n\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Hooks;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        Hooks.onOperatorDebug();\r\n        Flux.range(0, 1000)\r\n                .bufferUntil(v -> true)\r\n                .flatMap(v -> Mono.delay(Duration.ofMillis(10)))\r\n                .blockLast();\r\n    }\r\n}\r\n```\r\n\r\n## Possible Solution\r\n<!--- Not obligatory, but you can suggest a fix/reason for the bug. -->\r\n\r\n## Your Environment\r\n<!--- Include as many relevant details about the environment you experienced the bug in. -->\r\n<!--- Especially, always include the version(s) of Reactor library/libraries you used! -->\r\n\r\n* Reactor version(s) used: 3.3.0.RELEASE\r\n* Other relevant libraries versions (eg. `netty`, ...): none\r\n* JVM version (`javar -version`): JDK 11\r\n* OS and version (eg `uname -a`): Windows 10\r\n", "url": "https://github.com/reactor/reactor-core/issues/1937", "user": "benwiles1", "labels": ["type/bug"], "created": "2019-11-01 22:16:59", "closed": "2020-02-17 19:19:36", "commits": {"cf776bfd150cd8ebb6c294d4a7762ce9835a1bf8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5ee7910e14b2a5aa80562320593eff67ba15ecfb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "621f88d964496cf08e92db850e5abbad3780100b": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "820f654261b4507f44bf21ce0bacfa64b4cf0a68": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 107.00027777777778, "commitsDetails": [{"commitHash": "cf776bfd150cd8ebb6c294d4a7762ce9835a1bf8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "621f88d964496cf08e92db850e5abbad3780100b", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["5e39c93aed68c133ea5048822c5b6ade43711811"], "nameRev": "621f88d964496cf08e92db850e5abbad3780100b tags/v3.2.15.RELEASE~3", "commitMessage": "fix #1937 Account for requests made to upstream in FluxBufferPredicate\n\nThis commit adds additional request accounting to FluxBufferPredicate,\r\nallowing it to keep track of when there is remaining upstream request\r\nand when there is not. In turn, this allows the \"just add to buffer\"\r\ncase to perform an additional `request(1)` ONLY if necessary (to further\r\nfill the current buffer).\r\n\r\nReviewed-in: #2029\r\n", "commitDateTime": "2020-02-17 20:12:39", "authoredDateTime": "2020-02-17 20:12:39", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "insertions": 43, "deletions": 33, "lines": 76}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "insertions": 260, "deletions": 8, "lines": 268}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 3, "deletions": 3, "lines": 6}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "820f654261b4507f44bf21ce0bacfa64b4cf0a68", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["46ed282c816e3d709f3238b35e9b0522e24128a2", "621f88d964496cf08e92db850e5abbad3780100b"], "nameRev": "820f654261b4507f44bf21ce0bacfa64b4cf0a68 tags/v3.3.3.RELEASE~6", "commitMessage": "Merge #1937 into 3.3\n", "commitDateTime": "2020-02-17 20:19:02", "authoredDateTime": "2020-02-17 20:19:02", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "insertions": 43, "deletions": 33, "lines": 76}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java", "insertions": 257, "deletions": 8, "lines": 265}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 3, "deletions": 3, "lines": 6}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "reactor-core 3.3 OSGI bundle issue reactor.blockhound is not optional", "body": "## Expected Behavior\r\nWhen using reactor-core bundle in OSGI environment, reactor.blockhound bundle would not be required as it is an optional dependency from reactor-core.\r\n\r\n## Actual Behavior\r\n`reactor.blockhound,reactor.blockhound.integration` are packages required at runtime. As reactor.blockhound is not exporting those packages, it is currently impossible to run reactor-core >= 3.3 in OSGI env.\r\n\r\n## Possible Solution\r\nThe section `bundleImportPackages` in the build.gradle file could specify `'reactor.blockhound.*;resolution:=optional'` juste as `io.micrometer`\r\n\r\n## Your Environment\r\n\r\n* Reactor-core version(s) used: v3.3.0.RELEASE\r\n* JVM version (`javar -version`):\r\nopenjdk version \"1.8.0_222\"\r\nOpenJDK Runtime Environment (build 1.8.0_222-8u222-b10-1~deb9u1-b10)\r\nOpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode)\r\n* OS and version (eg `uname -a`):\r\n`Linux 90b5161a77a8 4.18.0-0.bpo.1-amd64 #1 SMP Debian 4.18.6-1~bpo9+1 (2018-09-13) x86_64 GNU/Linux`\r\n", "url": "https://github.com/reactor/reactor-core/issues/1932", "user": "simondaudin", "labels": ["type/bug", "warn/regression"], "created": "2019-10-31 08:22:46", "closed": "2019-11-01 10:50:41", "commits": {"fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["74b9bec73857177f700a902eecb42167295c588e"], "nameRev": "fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e tags/v3.3.1.RELEASE~21", "commitMessage": "fix #1932 Add reactor.blockhound to OSGI optional bundles (#1933)\n\nSince we only provide an SPI's implementation and not depend on\r\nBlockHound directly, we should mark it as an \"optional\" OSGI import.", "commitDateTime": "2019-11-01 11:50:39", "authoredDateTime": "2019-11-01 11:50:39", "commitGitStats": [{"filePath": "build.gradle", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "onLastAssembly() could be invoked more than once per subscribe()/block()", "body": "I've noticed that `onLastAssembly()` could be invoked more than once per subscription which contradicts with its name. \r\nIf `Hooks.onLastOperator` is used to initialize context (propagation form ThreadLocal) it could lead to re-initialization/replacement of the original context with wrong one.\r\n\r\nI'm not sure if it is correct behavior. \r\nIf it is correct one what is the reason/use case for such behavior? \r\n\r\n## Expected Behavior\r\n`onLastAssembly()`  should be invoked once per subscription\r\n\r\n## Actual Behavior\r\nin addition to initial subscription `onLastAssembly()` is invoked from  \r\nreactor.core.publisher.FluxRetry.RetrySubscriber#resubscribe  \r\nreactor.core.publisher.FluxOnErrorResume.ResumeSubscriber#onError  \r\nreactor.core.publisher.MonoTimeout#subscribe\r\n...\r\n\r\n## Steps to Reproduce\r\n```java\r\n@Test\r\npublic void onLastAssemblyShouldBeInvokedOncePerSubscription() {\r\n    ArrayList<Exception> traces = new ArrayList<>();\r\n    Hooks.onLastOperator(\"my-hook\", (publisher) -> {\r\n        traces.add(new RuntimeException(\"fromHook\"));\r\n        return publisher;\r\n    });\r\n    Mono.error(new RuntimeException(\"boom\"))\r\n            .retry(1)\r\n            .onErrorResume(throwable -> Mono.empty())\r\n            .block();\r\n    traces.forEach(e -> e.printStackTrace());\r\n    Assertions.assertThat(traces).size().isEqualTo(1);\r\n}\r\n```\r\n\r\n## Possible Solution\r\nif Publisher is Mono or Flux use \r\n`public abstract void subscribe(CoreSubscriber<? super T> actual);`\r\n\r\n## Your Environment\r\n* Reactor version(s) used:\r\nreactor-core-3.2.12.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1883", "user": "robotmrv", "labels": ["type/bug"], "created": "2019-09-06 15:18:18", "closed": "2019-09-16 10:31:39", "commits": {"d7aaae8f021487742b2219c7d76cff80f714a34b": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "9167a484c539f3bb00cbf5ee5c7d2b7a1dd252ad": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "918c92c4cf69f67e742ddc664f18040ba60e8350": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 9.000277777777777, "commitsDetails": [{"commitHash": "d7aaae8f021487742b2219c7d76cff80f714a34b", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "9167a484c539f3bb00cbf5ee5c7d2b7a1dd252ad", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "918c92c4cf69f67e742ddc664f18040ba60e8350", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f60feec40e9f5281c5fe8549d1853235f732584e"], "nameRev": "918c92c4cf69f67e742ddc664f18040ba60e8350 tags/v3.3.0.RELEASE~9", "commitMessage": "fix #1883 Avoid extra lastAssembly by using CorePublisher where possible\n\n", "commitDateTime": "2019-09-16 12:31:37", "authoredDateTime": "2019-09-16 12:31:37", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxExpand.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRepeat.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRepeatPredicate.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRetry.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRetryPredicate.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRepeatTest.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRetryTest.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/TailCallSubscribeTest.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingIterable", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxExpand.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxExpand.ExpandDepthSubscription", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRepeat.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRepeat.RepeatSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRepeatPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRepeatPredicate.RepeatPredicateSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRepeatWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRepeatWhen.RepeatWhenMainSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRetry.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRetry.RetrySubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRetryPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRetryPredicate.RetryPredicateSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRetryWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRetryWhen.subscribe(reactor.core.CoreSubscriber,java.util.function.Function,org.reactivestreams.Publisher)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRetryWhen.RetryWhenMainSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxSubscribeOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.create()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SignalLogger.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLogger", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRepeatTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRepeatTest.onLastAssemblyOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRetryTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRetryTest.onLastAssemblyOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TailCallSubscribeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.TailCallSubscribeTest.repeat()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.TailCallSubscribeTest.retry()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["918c92c4cf69f67e742ddc664f18040ba60e8350"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 37.0, "deletions": 33.0, "lines": 70.0, "gitFilesChange": 11}, "spoonStatsSummary": {"TOT": 24.0, "UPD": 24.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 11, "spoonMethodsChanged": 13}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber", "reactor.core.publisher.FluxRetryWhen.subscribe(reactor.core.CoreSubscriber,java.util.function.Function,org.reactivestreams.Publisher)", "reactor.core.publisher.MonoProcessor.create()", "reactor.core.publisher.MonoProcessor", "reactor.core.publisher.FluxRepeat.RepeatSubscriber", "reactor.core.publisher.FluxExpand.ExpandDepthSubscription", "reactor.core.publisher.SignalLogger", "reactor.core.publisher.FluxRepeatWhen.RepeatWhenMainSubscriber", "reactor.core.publisher.FluxRepeatPredicate.RepeatPredicateSubscriber", "reactor.core.publisher.FluxRetryPredicate.RetryPredicateSubscriber", "reactor.core.publisher.FluxRetry.RetrySubscriber", "reactor.core.publisher.BlockingIterable", "reactor.core.publisher.FluxRetryWhen.RetryWhenMainSubscriber"]}, {"title": "FluxReplay source is never canceled with Hooks.onEachOperator()", "body": "FluxReplay `source` is not canceled if all subscribers are disconnected and `Hooks.onEachOperator()` is applied \r\n\r\n## Expected Behavior\r\n`source` should be cancelled after first signal \r\n\r\n## Actual Behavior\r\n`source` never shows cancellation and continues emit data signals\r\n\r\n## Steps to Reproduce\r\n```java\r\nHooks.onEachOperator(Operators.lift((scannable, coreSubscriber) -> coreSubscriber));\r\nFlux.interval(Duration.ZERO, Duration.ofMillis(300))\r\n        .log(\"source\")\r\n        .replay(Duration.ofMillis(500))\r\n        .refCount()\r\n        .log(\"connected\")\r\n        .take(1)\r\n        .subscribe();\r\nThread.sleep(1000);\r\n```\r\n\r\n## Possible Solution\r\nIt seems that there is a typo in reactor.core.publisher.ConnectableLiftFuseable#connect\r\n```java \r\n@Override\r\npublic void connect(Consumer<? super Disposable> cancelSupport) {\r\n\tthis.source.connect();//<--- does not pass cancelSupport\r\n}\r\n```\r\nif I change it to `this.source.connect(cancelSupport);` \r\nor remove `Hooks.onEachOperator` \r\nall work as expected \r\n\r\n## Your Environment\r\n* Reactor version(s) used: 3.2.10.RELEASE\r\n* JVM version (`javar -version`): \r\nopenjdk version \"1.8.0_191-1-ojdkbuild\"\r\nOpenJDK Runtime Environment (build 1.8.0_191-1-ojdkbuild-b12)\r\nOpenJDK 64-Bit Server VM (build 25.191-b12, mixed mode)\r\n* OS and version: Windows 10\r\n", "url": "https://github.com/reactor/reactor-core/issues/1860", "user": "robotmrv", "labels": ["good first issue", "type/bug"], "created": "2019-08-21 16:31:06", "closed": "2020-02-06 09:00:04", "commits": {"786cf4e4f19b0b4319c0d161157ee7d310ef904a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5525225f083929fb2355a4741e59a3df3d77c5d2": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "7bda61c95559ccb066a10ee7b9e4fcce506dad33": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "c9c0ae0c6a865137f249825157c2865fe679943b": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "d27ccbf74684daab3cae960a1b1709418e7423f7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 168.00027777777777, "commitsDetails": [{"commitHash": "786cf4e4f19b0b4319c0d161157ee7d310ef904a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5525225f083929fb2355a4741e59a3df3d77c5d2", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a06dec084bacfddf2766f8e76e439146a0d66ba5"], "nameRev": "5525225f083929fb2355a4741e59a3df3d77c5d2 tags/v3.2.12.RELEASE~4", "commitMessage": "fix #1860 Pass on cancelSupport when lifting ConnectableFlux\n\n", "commitDateTime": "2019-08-27 16:00:22", "authoredDateTime": "2019-08-27 16:00:22", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLift.connect(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFluxWithCancelSupport()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "7bda61c95559ccb066a10ee7b9e4fcce506dad33", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["b491aab80a49e31c709d296fb01040eeb29f44be", "5525225f083929fb2355a4741e59a3df3d77c5d2"], "nameRev": "7bda61c95559ccb066a10ee7b9e4fcce506dad33 tags/v3.3.0.RC1~16", "commitMessage": "Merge #1860 into 3.3\n", "commitDateTime": "2019-08-27 16:01:14", "authoredDateTime": "2019-08-27 16:01:14", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLift.connect(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFluxWithCancelSupport()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "c9c0ae0c6a865137f249825157c2865fe679943b", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d02cf8eebbee223c37749cc29cfed46b3a659bc6"], "nameRev": "c9c0ae0c6a865137f249825157c2865fe679943b tags/v3.2.15.RELEASE~8", "commitMessage": "fix #1860 Pass on cancelSupport when lifting ConnectableLiftFuseable\n\nThis was overlooked in the previous fix of #1860, see 786cf4e", "commitDateTime": "2020-02-06 09:51:20", "authoredDateTime": "2020-02-06 10:51:20", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 22, "deletions": 1, "lines": 23}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLiftFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLiftFuseable.connect(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableLiftFuseableWithCancelSupport()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "d27ccbf74684daab3cae960a1b1709418e7423f7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["3aa07de36af1b878ca7d556520b51ae7b75cfc85", "c9c0ae0c6a865137f249825157c2865fe679943b"], "nameRev": "d27ccbf74684daab3cae960a1b1709418e7423f7 tags/v3.3.3.RELEASE~13", "commitMessage": "Merge #2034 in 3.3 (see #1860)\n", "commitDateTime": "2020-02-06 09:59:24", "authoredDateTime": "2020-02-06 09:59:24", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 22, "deletions": 1, "lines": 23}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLiftFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLiftFuseable.connect(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableLiftFuseableWithCancelSupport()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5525225f083929fb2355a4741e59a3df3d77c5d2", "c9c0ae0c6a865137f249825157c2865fe679943b"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 2.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.ConnectableLift.connect(java.util.function.Consumer)", "reactor.core.publisher.ConnectableLiftFuseable.connect(java.util.function.Consumer)"]}, {"title": "A few Mono operators can lead to bad signal combination of onNext+onError", "body": "## Expected Behavior\r\n`Mono` authorized sequences of events are `onNext`+`onComplete`, `onComplete` or `onError` (also, technically, infinite Monos with `onNext` or no signal at all).\r\n\r\n`onNext` should never be followed by `onError`.\r\n\r\n## Actual Behavior\r\n`Mono.just(\"foo\").doOnTerminate(() -> { throw new IllegalStateException(); })` results in the undesirable signals sequence.\r\n\r\n`Mono.using` with a `completeHandler` that throws similarly produces bad signals.\r\n\r\n## Possible Solution\r\n-  for `Mono#doOnComplete`, rework into an alias to `doOnSuccessOrError` that ignores both inputs, make it prominent in the javadoc (ie. `onNext` is discarded rather than propagated if the callback fails, and thus the callback is executed _before_ `actual.onNext` rather than between onNext and onComplete)\r\n - for `Mono#using`, like `usingWhen` it would delay the emission of `onNext` to until the `onComplete` handler has finished.\r\n\r\nRelates to #1832 ", "url": "https://github.com/reactor/reactor-core/issues/1853", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-08-19 17:04:43", "closed": "2019-08-27 17:51:50", "commits": {"2a99b3f5cf8e221834bea051fc45cf4b7af72cd9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "4d059fded4bce54ff1b184c1a357d1714522a1b4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "98f0f0e0226789b43be103bfeafbac174a265468": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f9f686a24d25bc6d5ec9a288e4618dbbddae06ab": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7d4522a8b23d6e07474bcf0cb98581a8c449e0f9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6436811a6540f4ad7e9ae3de698f25ca887b5951": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "fa86abe41ea7a9d41aef00e4e6bd0d47d4dee23a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "8d29500abb5a4ed061c62fd1d506c3fdc35ad2ac": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2d55d7d600442d26207d1023efe4ef8fd17d2396": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "a93c96cfb128e0702a0b23121be7b1ba26bf4990": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "2a99b3f5cf8e221834bea051fc45cf4b7af72cd9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "4d059fded4bce54ff1b184c1a357d1714522a1b4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "98f0f0e0226789b43be103bfeafbac174a265468", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f9f686a24d25bc6d5ec9a288e4618dbbddae06ab", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7d4522a8b23d6e07474bcf0cb98581a8c449e0f9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6436811a6540f4ad7e9ae3de698f25ca887b5951", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fa86abe41ea7a9d41aef00e4e6bd0d47d4dee23a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8d29500abb5a4ed061c62fd1d506c3fdc35ad2ac", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2d55d7d600442d26207d1023efe4ef8fd17d2396", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["df34ad922247cede827bb18a61f8a2d3d72ffcfa"], "nameRev": "2d55d7d600442d26207d1023efe4ef8fd17d2396 tags/v3.3.0.RC1~14", "commitMessage": "fix #1853 Prevent Mono#using to trigger onNext+onError if cleanup fails\n\nThis commit slightly changes the behavior of Mono#using so that, in\neager mode, the cleanup is applied inside `onNext`. Thus it is applied\nbefore the value is passed to downstream (which at this point is no\nlonger in the protected scope of the `sourceSupplier`).\n\nThis is done to prevent the case where the value would be passed down\nyet the cleanup throws, resulting in an invalid sequence of onNext then\nonError signals.\n", "commitDateTime": "2019-08-27 19:51:48", "authoredDateTime": "2019-08-20 18:42:38", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 11, "deletions": 5, "lines": 16}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java", "insertions": 250, "deletions": 12, "lines": 262}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java", "insertions": 148, "deletions": 2, "lines": 150}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "a93c96cfb128e0702a0b23121be7b1ba26bf4990", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["2d55d7d600442d26207d1023efe4ef8fd17d2396"], "nameRev": "a93c96cfb128e0702a0b23121be7b1ba26bf4990 tags/v3.3.0.RC1~13", "commitMessage": "fix #1752 Make doOnTerminate for Mono same as doOnSuccess\n\nThis means that the handler is invoked during processing of the `onNext`\nsignal.\n\nThis commit also slightly rework MonoPeekTerminal to make the onSuccess\nand onError handlers canonical, instead of the (successOrError) one.\n\nFinally, it makes `doOnError` directly use MonoPeekTerminal instead of\nMonoPeek, and modifies the marble diagrams (adding a convention for the\nnull value / empty set).\n\nRelates-to: #1853\n", "commitDateTime": "2019-08-27 19:51:48", "authoredDateTime": "2019-08-22 11:30:29", "commitGitStats": [{"filePath": "docs/svg/conventions.svg", "insertions": 2002, "deletions": 8927, "lines": 10929}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 34, "deletions": 31, "lines": 65}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeek.java", "insertions": 2, "deletions": 10, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekFuseable.java", "insertions": 2, "deletions": 10, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java", "insertions": 15, "deletions": 49, "lines": 64}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/doOnSuccess.svg", "insertions": 348, "deletions": 11, "lines": 359}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/doOnTerminateForMono.svg", "insertions": 25, "deletions": 25, "lines": 50}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoPeekAfterTest.java", "insertions": 12, "deletions": 27, "lines": 39}, {"filePath": "reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.doAfterSuccessOrError(java.util.function.BiConsumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSuccess(java.util.function.Consumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.util.function.Consumer)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.lang.Class,java.util.function.Consumer)", "TOT": 5, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "TOT": 5, "UPD": 4, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSuccessOrError(java.util.function.BiConsumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminate(java.lang.Runnable)", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorMap(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorMap(java.util.function.Predicate,java.util.function.Function)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorResume(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.lang.Class,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.util.function.Predicate,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.subscriberContext(reactor.util.context.Context)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.timestamp(reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.transformDeferred(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.zipWhen(java.util.function.Function,java.util.function.BiFunction)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSignal(reactor.core.publisher.Mono,java.util.function.Consumer,java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable,java.util.function.LongConsumer,java.lang.Runnable)", "TOT": 5, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.ofType(java.lang.Class)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnCancel(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnNext(java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnRequest(java.util.function.LongConsumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSubscribe(java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminalSignal(reactor.core.publisher.Mono,java.util.function.Consumer,java.util.function.Consumer,java.util.function.BiConsumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoPeek.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeek", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.MonoPeek.onErrorCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeek.onCompleteCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable.onErrorCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable.onCompleteCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoPeekTerminal.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal", "TOT": 8, "UPD": 6, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.tryOnNext(java.lang.Object)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onComplete()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.clear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.isEmpty()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoDematerializeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDematerializeTest.sourceWithSignalButNeverCompletes()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 3}]}, {"spoonFilePath": "MonoPeekAfterTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksNoFusion()", "TOT": 7, "UPD": 3, "INS": 1, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksFusionSync()", "TOT": 8, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksFusionAsync()", "TOT": 8, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 3}]}, {"spoonFilePath": "DefaultTestPublisherTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.publisher.DefaultTestPublisherTests.misbehavingMonoCanAvoidCompleteAfterOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2d55d7d600442d26207d1023efe4ef8fd17d2396"], "filteredCommitsReason": {"duplicated": 8, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 261.0, "deletions": 17.0, "lines": 278.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": []}, {"title": "doAfterTerminate not applied when poll() fails, in case of micro-fusion", "body": "## Expected Behavior\r\nA fused chain that includes a `doAfterTerminate` sees said `doAfterTerminate` invoked in case of error.\r\n\r\n## Actual Behavior\r\nWhen fusion is triggered, an error inside the `poll()` method doesn't execute the `doAfterTerminate` callback.\r\n\r\n## Steps to Reproduce\r\n\r\n```java\r\n@Test\r\n\tpublic void syncPollAfterTerminateCalledWhenError() {\r\n\t\tAtomicBoolean onAfterTerminate = new AtomicBoolean();\r\n\t\tFlux<Integer> f = Flux.just(1, 0, 3)\r\n\t\t                      .map(i -> 100 / i)\r\n\t\t                      .doAfterTerminate(() -> onAfterTerminate.set(true));\r\n\t\tStepVerifier.create(f)\r\n\t\t            .expectFusion()\r\n\t\t            .expectNext(100)\r\n\t\t            .verifyError(ArithmeticException.class);\r\n\r\n\t\tassertThat(onAfterTerminate.get()).withFailMessage(\"onAfterTerminate not called back\").isTrue();\r\n\t}```", "url": "https://github.com/reactor/reactor-core/issues/1835", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-08-08 16:26:11", "closed": "2019-08-13 08:35:50", "commits": {"a000d746caabe0767d88fa28f705f82a685df4f1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "567d9cb60a5795cb0b9cc2975fd1cf754d0e72ae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d172933aa825c7ff2934ddec415119abffac3f53": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "13fc80f665c185c68caa23e64e23e6eec51a297e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b259e6135b6e1a9184b1360ef4610dced2aef6dc": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "51f12a5623c2413068beda4988de3c7423820035": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ca77fd8adc652bdda2f6621ce6ae9965c1952cb4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "04702c35233b90e1fba575c20d9c13bec00e3d9d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "a0969f5a48c87c41241b08fea5c4566becc019ef": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "a000d746caabe0767d88fa28f705f82a685df4f1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "567d9cb60a5795cb0b9cc2975fd1cf754d0e72ae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d172933aa825c7ff2934ddec415119abffac3f53", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "13fc80f665c185c68caa23e64e23e6eec51a297e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b259e6135b6e1a9184b1360ef4610dced2aef6dc", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "51f12a5623c2413068beda4988de3c7423820035", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["229b1ecec7e2e7fe16014d3be7a37c28dc9e9c35"], "nameRev": "51f12a5623c2413068beda4988de3c7423820035 remotes/origin/1556-macroFuseMapFilter", "commitMessage": "temporarily disable afterTerminate assertion, see #1835\n", "commitDateTime": "2019-08-09 17:06:06", "authoredDateTime": "2019-08-09 12:53:24", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 4, "deletions": 2, "lines": 6}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.macroFusionWithFuseable_error()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ca77fd8adc652bdda2f6621ce6ae9965c1952cb4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "04702c35233b90e1fba575c20d9c13bec00e3d9d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a7bce5593e654d59a446e48b144ffe4fb2237038"], "nameRev": "04702c35233b90e1fba575c20d9c13bec00e3d9d tags/v3.2.12.RELEASE~7", "commitMessage": "fix #1835 Flux#doAfterTerminate now executed when onError in fused mode (#1836)\n\nThis commit lets the doAfterTerminate handler be executed from within\r\nthe poll method (in fused path) when there is an `onError` event\r\ntriggered in said poll.", "commitDateTime": "2019-08-13 10:27:41", "authoredDateTime": "2019-08-13 10:27:41", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 77, "deletions": 21, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPeekFuseableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateCalled()", "TOT": 5, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateCalled()", "TOT": 5, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollCompleteCalled()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalCompleteCalled()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateCalledWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateCalledWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateFailureWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateFailureWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a0969f5a48c87c41241b08fea5c4566becc019ef", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["756c71a0c42e39fd7b55f15d1377245139eb0ae5", "04702c35233b90e1fba575c20d9c13bec00e3d9d"], "nameRev": "a0969f5a48c87c41241b08fea5c4566becc019ef tags/v3.3.0.RC1~27", "commitMessage": "Merge #1835 into 3.3\n", "commitDateTime": "2019-08-13 10:35:10", "authoredDateTime": "2019-08-13 10:35:10", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 20, "deletions": 0, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 77, "deletions": 21, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPeekFuseableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateCalled()", "TOT": 5, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateCalled()", "TOT": 5, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollCompleteCalled()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalCompleteCalled()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateCalledWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateCalledWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateFailureWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateFailureWhenError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["51f12a5623c2413068beda4988de3c7423820035"], "filteredCommitsReason": {"duplicated": 6, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Context constructors should enforce null checks", "body": "### Expected behavior\r\nAny concrete package-private implementation of `Context` should reject a `null` key or value at construction, the same way they are rejected when trying to `put` them in the Context.\r\n\r\n### Actual behavior\r\nConstructors do not enforce null checks the way `put` does.\r\n\r\n### Reactor Core version\r\n3.2.10.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1797", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-07-10 08:30:40", "closed": "2019-07-10 14:25:04", "commits": {"f0e31eda557f3343ba09ecca71191dde56d96fe5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "72f83d20b79a3f028d3833b1f40819e2f8df6b58": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "35bacecd5602d99d8205e57c6a2f23ae4f752ccd": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "f0e31eda557f3343ba09ecca71191dde56d96fe5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "72f83d20b79a3f028d3833b1f40819e2f8df6b58", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["7d9faa604b2a39a404e58396837f63bd2f5a9a92"], "nameRev": "72f83d20b79a3f028d3833b1f40819e2f8df6b58 tags/v3.3.0.M3~11^2~3", "commitMessage": "fix #1797 Explicitly reject null keys/values in Context constructors\n\nThis commit better enforces non-null nature of the various Context\r\nimplementations by throwing a NullPointerException whenever a null key\r\nor null value is passed to one of the implementations' constructors.\r\n\r\nThis aligns with the `put` behavior, which already throws NPE.\r\n\r\nSince ContextN extends HashMap, which allows null, the constructors\r\ndon't delegate to super.put/putAll anymore, but rather use an inner\r\nversion that checks for nulls.\r\n\r\nThe javadoc has been updated to better convey the non-null nature of\r\nthe factory methods.\r\n", "commitDateTime": "2019-07-10 16:24:06", "authoredDateTime": "2019-07-10 16:24:06", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/context/Context.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context1.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context2.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context3.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context4.java", "insertions": 8, "deletions": 8, "lines": 16}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context5.java", "insertions": 10, "deletions": 10, "lines": 20}, {"filePath": "reactor-core/src/main/java/reactor/util/context/ContextN.java", "insertions": 28, "deletions": 14, "lines": 42}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextNTest.java", "insertions": 71, "deletions": 2, "lines": 73}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextTest.java", "insertions": 81, "deletions": 0, "lines": 81}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Context.java", "spoonMethods": []}, {"spoonFilePath": "Context1.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context1", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "Context2.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context2", "TOT": 8, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 4}]}, {"spoonFilePath": "Context3.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context3", "TOT": 12, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 6}]}, {"spoonFilePath": "Context4.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4", "TOT": 16, "UPD": 0, "INS": 8, "MOV": 0, "DEL": 8}]}, {"spoonFilePath": "Context5.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context5", "TOT": 20, "UPD": 0, "INS": 10, "MOV": 0, "DEL": 10}]}, {"spoonFilePath": "ContextN.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextN", "TOT": 10, "UPD": 10, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN.getOrDefault(java.lang.Object,java.lang.Object)", "TOT": 7, "UPD": 1, "INS": 3, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.util.context.ContextN.get(java.lang.Object)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.util.context.ContextN.innerPut(java.lang.Object,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN.innerPutAll(java.util.Map)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextNTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextNTest.constructFromPairsRejectsNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithAdditionalNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithAdditionalNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithLeftNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithLeftNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithRightNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithRightNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextTest.of1NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of2NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of3NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of4NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of5NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "35bacecd5602d99d8205e57c6a2f23ae4f752ccd", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["2bade288e282d25e713bbc1db43c1652a6ae9937", "72f83d20b79a3f028d3833b1f40819e2f8df6b58"], "nameRev": "35bacecd5602d99d8205e57c6a2f23ae4f752ccd tags/v3.3.0.M3~28", "commitMessage": "Merge #1797 into 3.3\n", "commitDateTime": "2019-07-10 16:24:39", "authoredDateTime": "2019-07-10 16:24:39", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/context/Context.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context1.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context2.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context3.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context4.java", "insertions": 8, "deletions": 8, "lines": 16}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context5.java", "insertions": 10, "deletions": 10, "lines": 20}, {"filePath": "reactor-core/src/main/java/reactor/util/context/ContextN.java", "insertions": 28, "deletions": 14, "lines": 42}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextNTest.java", "insertions": 71, "deletions": 2, "lines": 73}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextTest.java", "insertions": 81, "deletions": 0, "lines": 81}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Context.java", "spoonMethods": []}, {"spoonFilePath": "Context1.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context1", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "Context2.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context2", "TOT": 8, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 4}]}, {"spoonFilePath": "Context3.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context3", "TOT": 12, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 6}]}, {"spoonFilePath": "Context4.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4", "TOT": 16, "UPD": 0, "INS": 8, "MOV": 0, "DEL": 8}]}, {"spoonFilePath": "Context5.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context5", "TOT": 20, "UPD": 0, "INS": 10, "MOV": 0, "DEL": 10}]}, {"spoonFilePath": "ContextN.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextN", "TOT": 10, "UPD": 10, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN.getOrDefault(java.lang.Object,java.lang.Object)", "TOT": 7, "UPD": 1, "INS": 3, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.util.context.ContextN.get(java.lang.Object)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.util.context.ContextN.innerPut(java.lang.Object,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN.innerPutAll(java.util.Map)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextNTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextNTest.constructFromPairsRejectsNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithAdditionalNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapWithAdditionalNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithLeftNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithLeftNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithRightNullKey()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextNTest.constructFromMapsWithRightNullValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextTest.of1NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of2NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of3NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of4NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of5NullChecks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["72f83d20b79a3f028d3833b1f40819e2f8df6b58"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 65.0, "deletions": 45.0, "lines": 110.0, "gitFilesChange": 7}, "spoonStatsSummary": {"TOT": 84.0, "UPD": 11.0, "INS": 38.0, "MOV": 3.0, "DEL": 32.0, "spoonFilesChanged": 6, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/util/context"], "changesInPackagesSPOON": ["reactor.util.context.Context5", "reactor.util.context.ContextN.innerPutAll(java.util.Map)", "reactor.util.context.Context1", "reactor.util.context.ContextN", "reactor.util.context.Context4", "reactor.util.context.Context2", "reactor.util.context.ContextN.innerPut(java.lang.Object,java.lang.Object)", "reactor.util.context.ContextN.get(java.lang.Object)", "reactor.util.context.Context3", "reactor.util.context.ContextN.getOrDefault(java.lang.Object,java.lang.Object)"]}, {"title": "Context.of() not checking for duplicate keys", "body": "### Expected behavior\r\nCreating an instance of `Context`  using `Context.of()` method should check for duplicate keys.\r\n\r\n### Actual behavior\r\n`Context.of()` currently allows duplicate keys and when an update to the key is made, only the 1st entry matching the key is updated. When the context is read, the last argument matching the key in `Context.of()` is returned as the value for the key.\r\n\r\nFor e.g. \r\n```\r\nContext context = Context.of(key, \"value1\", key, \"value2\"); \r\ncontext.put(key, \"value3\");\r\n```\r\nThis will result in `key` returning `value2` instead of `value3` which was the last updated value.\r\n\r\n### Steps to reproduce\r\n```\r\nimport java.util.List;\r\nimport java.util.Map.Entry;\r\nimport java.util.stream.Collectors;\r\nimport reactor.core.publisher.Mono;\r\nimport reactor.util.context.Context;\r\n\r\npublic class TestReactorContext {\r\n    public static void main(String[] args) {\r\n        TestReactorContext test = new TestReactorContext();\r\n        String key = \"name\";\r\n\r\n        // Same key with multiple values. Last updated value is \"Baz\"\r\n        Context context = Context.of(key, \"John\", key, \"Doe\");\r\n        context = context.put(key, \"Foo\");\r\n        context = context.put(key, \"Bar\");\r\n        context = context.put(key, \"Baz\");\r\n\r\n        String result = test\r\n            .greet(\"Hello, \")\r\n            .subscriberContext(context)\r\n            .block();\r\n\r\n        // Expected: \"Hello, my name is Baz.\"\r\n        // Actual: \"Hello, my name is Doe.\"\r\n        System.out.println(result);\r\n    }\r\n\r\n    Mono<String> greet(String prefix) {\r\n        // convert subscriberContext coming into this method into a string\r\n        return Mono.subscriberContext()\r\n            .map(this::getMessage)\r\n            .flatMap(message -> prettyPrint(prefix, message));\r\n    }\r\n\r\n    private Mono<String> prettyPrint(String prefix, String context) {\r\n        String msg = prefix + context;\r\n        return Mono.just(msg);\r\n    }\r\n\r\n    private String getMessage(Context context) {\r\n        List<Entry<Object, Object>> entries = context.stream().collect(Collectors.toList());\r\n        System.out.println(\"Reactor context size = \" + entries.size()); // size is 1\r\n        StringBuilder contextBuilder = new StringBuilder();\r\n        entries.stream().forEach(\r\n            entry -> contextBuilder.append(\"my \").append(entry.getKey()).append(\" is \").append(entry.getValue()).append(\".\"));\r\n        return contextBuilder.toString();\r\n    }\r\n}\r\n\r\n```\r\n### Reactor Core version\r\n3.2.3.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\nJDK 8", "url": "https://github.com/reactor/reactor-core/issues/1793", "user": "srnagar", "labels": ["type/bug", "type/enhancement"], "created": "2019-07-09 04:39:04", "closed": "2019-07-10 18:04:17", "commits": {"d319edfe43ee968c86ce7c3e41142401804a2e23": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "8b6bb16b971280f4417311620763129b55a81044": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "49c23b2427ced7e30a12ed1f795aedf39078a76c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "4f4d23989f0bba0b6e6b18674f111b80edef2fb9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "e42f607d7aca39935a6a3a7834d25705d0794331": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "d319edfe43ee968c86ce7c3e41142401804a2e23", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8b6bb16b971280f4417311620763129b55a81044", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "49c23b2427ced7e30a12ed1f795aedf39078a76c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "4f4d23989f0bba0b6e6b18674f111b80edef2fb9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["72f83d20b79a3f028d3833b1f40819e2f8df6b58"], "nameRev": "4f4d23989f0bba0b6e6b18674f111b80edef2fb9 tags/v3.3.0.M3~11^2~2", "commitMessage": "fix #1793 Reject Context.of calls with duplicate keys\n\nThis commit also add a Context.of(Map) variant that will choose\r\nthe most efficient implementation depending on the Map size.\r\n\r\nReviewed-In: #1794", "commitDateTime": "2019-07-10 20:03:25", "authoredDateTime": "2019-07-10 20:03:25", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/context/Context.java", "insertions": 40, "deletions": 0, "lines": 40}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context2.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context3.java", "insertions": 8, "deletions": 2, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context4.java", "insertions": 30, "deletions": 1, "lines": 31}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context5.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/util/context/ContextN.java", "insertions": 21, "deletions": 17, "lines": 38}, {"filePath": "reactor-core/src/test/java/reactor/util/context/Context4Test.java", "insertions": 134, "deletions": 2, "lines": 136}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextTest.java", "insertions": 173, "deletions": 36, "lines": 209}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Context.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.of(java.util.Map)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Context2.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context2", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "Context3.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context3", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "Context4.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.util.context.Context4.checkKeys(java.lang.Object[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Context5.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context5", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextN.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextN.innerPut(java.lang.Object,java.lang.Object)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN", "TOT": 18, "UPD": 10, "INS": 2, "MOV": 4, "DEL": 2}, {"spoonMethodName": "reactor.util.context.ContextN.innerPutAll(java.util.Map)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "Context4Test.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysZeroOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextTest.of1NullChecks()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of2NullChecks()", "TOT": 9, "UPD": 9, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of3NullChecks()", "TOT": 25, "UPD": 25, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of4NullChecks()", "TOT": 49, "UPD": 49, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of5NullChecks()", "TOT": 81, "UPD": 81, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofTwoRejectsDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofThreeRejectsDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofFourRejectsSimpleDuplicate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofFiveRejectsSimpleDuplicate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapSix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "e42f607d7aca39935a6a3a7834d25705d0794331", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["35bacecd5602d99d8205e57c6a2f23ae4f752ccd", "4f4d23989f0bba0b6e6b18674f111b80edef2fb9"], "nameRev": "e42f607d7aca39935a6a3a7834d25705d0794331 tags/v3.3.0.M3~27", "commitMessage": "Merge #1793 into 3.3\n", "commitDateTime": "2019-07-10 20:03:53", "authoredDateTime": "2019-07-10 20:03:53", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/context/Context.java", "insertions": 40, "deletions": 0, "lines": 40}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context2.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context3.java", "insertions": 8, "deletions": 2, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context4.java", "insertions": 30, "deletions": 1, "lines": 31}, {"filePath": "reactor-core/src/main/java/reactor/util/context/Context5.java", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/util/context/ContextN.java", "insertions": 21, "deletions": 17, "lines": 38}, {"filePath": "reactor-core/src/test/java/reactor/util/context/Context4Test.java", "insertions": 134, "deletions": 2, "lines": 136}, {"filePath": "reactor-core/src/test/java/reactor/util/context/ContextTest.java", "insertions": 173, "deletions": 36, "lines": 209}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Context.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.of(java.util.Map)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Context2.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context2", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "Context3.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context3", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "Context4.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.util.context.Context4.checkKeys(java.lang.Object[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Context5.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context5", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextN.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextN.innerPut(java.lang.Object,java.lang.Object)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextN", "TOT": 18, "UPD": 10, "INS": 2, "MOV": 4, "DEL": 2}, {"spoonMethodName": "reactor.util.context.ContextN.innerPutAll(java.util.Map)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "Context4Test.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysZeroOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkDuplicateKeysFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.Context4Test.checkNullKeysFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ContextTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.context.ContextTest.of1NullChecks()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of2NullChecks()", "TOT": 9, "UPD": 9, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of3NullChecks()", "TOT": 25, "UPD": 25, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of4NullChecks()", "TOT": 49, "UPD": 49, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.of5NullChecks()", "TOT": 81, "UPD": 81, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofTwoRejectsDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofThreeRejectsDuplicates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofFourRejectsSimpleDuplicate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofFiveRejectsSimpleDuplicate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapOne()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapTwo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapFour()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapFive()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.context.ContextTest.ofMapSix()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Mono.cache(ttlFunctions...) has misleading doc and ttl error handling bug", "body": "The operator documents that exceptions thrown from the TTL-generating `Function` are considered transient and would cause a state reset, causing the next subscriber to re-try. This unfortunately doesn't work for the onError case, as the original error is dropped (`Operators.onErrorDropped`). This in turn causes the exception to be thrown if there is no user-provided hook in place, short-circuiting the state reset logic as well as the propagation of the error downstream.\r\n\r\nFurthermore, this focus on TTL functions throwing is a bit misleading: the more interesting case is how to ensure an error **in the source** can be propagated to the first subscriber only then retried for further subscribers.\r\n\r\nNote that this can already be achieved by using `Duration.ZERO` as a return value, which should be properly documented.\r\n\r\nWithout the state reset bug, returning `null` or throwing would also work, but as a twisted way of achieving that...", "url": "https://github.com/reactor/reactor-core/issues/1783", "user": "simonbasle", "labels": ["type/bug", "type/documentation"], "created": "2019-07-03 09:06:50", "closed": "2019-07-03 14:36:24", "commits": {"7a6032fb5c43dc176f5d3feb89a62bdff9032e14": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d38fb862cb1b48d7a8caf20d83f03d66bb180aca": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "da6011a7f0ddf390e79f0f6f47c8133327de7086": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "7a6032fb5c43dc176f5d3feb89a62bdff9032e14", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d38fb862cb1b48d7a8caf20d83f03d66bb180aca", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["fe479a92c08d0d39f5157ed84d6e58d4df60b9be"], "nameRev": "d38fb862cb1b48d7a8caf20d83f03d66bb180aca tags/v3.3.0.M3~11^2~5", "commitMessage": "fix #1783 Do not drop errors in MonoCacheTime, better doc (#1784)\n\nThis commit avoids onErrorDropped in the path where TTL function throws\r\nand the original signal was an error. Since the default behavior of\r\ndropping is to throw, this would break the operator: no state reset\r\nnor exception propagation to downstream would occur.\r\n\r\nAdditionally, the case of TTL 0 is now explicitly handled and avoids\r\ngoing through the Scheduler, immediately resetting the state.\r\n\r\nThis is now better documented, and the TTL 0 approach gets more focus\r\nin the javadoc (as throwing TTL function is more of an edge case).", "commitDateTime": "2019-07-03 16:35:30", "authoredDateTime": "2019-07-03 16:35:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 8, "lines": 20}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 7, "deletions": 5, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 141, "deletions": 4, "lines": 145}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": []}, {"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.signalCached(reactor.core.publisher.Signal)", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 3}]}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.nextTtlGeneratorTransientFailure()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.emptyTtlGeneratorTransientFailure()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.errorTtlGeneratorTransientFailure()", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.errorTtlGeneratorFailure()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.transientErrorWithZeroTtlIsNotCached()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "da6011a7f0ddf390e79f0f6f47c8133327de7086", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["58abafc611607d6cad00b545169a8442197fc9c8", "d38fb862cb1b48d7a8caf20d83f03d66bb180aca"], "nameRev": "da6011a7f0ddf390e79f0f6f47c8133327de7086 tags/v3.3.0.M3~32", "commitMessage": "Merge #1783 into 3.3\n", "commitDateTime": "2019-07-03 16:36:02", "authoredDateTime": "2019-07-03 16:36:02", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 8, "lines": 20}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 7, "deletions": 5, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 141, "deletions": 4, "lines": 145}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": []}, {"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.signalCached(reactor.core.publisher.Signal)", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 3}]}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.nextTtlGeneratorTransientFailure()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.emptyTtlGeneratorTransientFailure()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.errorTtlGeneratorTransientFailure()", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.errorTtlGeneratorFailure()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.transientErrorWithZeroTtlIsNotCached()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Flux loses elements sometimes", "body": "### Expected behavior\r\nIf Flux publishes n elements, I expect to consume n elements after flatMap and publishOn operations.\r\n\r\n### Actual behavior\r\nSometimes I lose elements. I don't understand what it depends on.\r\n\r\n### Steps to reproduce\r\nSimple test:\r\n\r\n```\r\n        List info;\r\n        Scheduler scheduler = Schedulers.elastic();\r\n        long count = 0;\r\n        do {\r\n            info = Flux.range(0, 37)\r\n                    .flatMap(t -> Mono.just(\"\")\r\n                            .publishOn(scheduler)\r\n                            .flatMap(Mono::just)\r\n                    )\r\n                    .collectList()\r\n                    .block();\r\n        } while (info.size() == 37 && ++count < 1000);\r\n        assertEquals(info.size(), 37);\r\n```\r\nAt some iteration info.size() can return less than 37.\r\n\r\nBut for example this code always works fine:\r\n\r\n```\r\n        List info;\r\n        Scheduler scheduler = Schedulers.elastic();\r\n        long count = 0;\r\n        do {\r\n            info = Flux.range(0, 37)\r\n                    .flatMap(t -> Mono.just(\"\")\r\n                            .publishOn(scheduler)\r\n                            .flatMap(Mono::just)\r\n                            .doOnSuccess(v -> {})\r\n                    )\r\n                    .collectList()\r\n                    .block();\r\n        } while (info.size() == 37 && ++count < 1000);\r\n        assertEquals(info.size(), 37);\r\n```\r\n\r\n### Reactor Core version\r\n3.2.9.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\nopenjdk version \"11.0.2\" 2019-01-15\r\nOpenJDK Runtime Environment 18.9 (build 11.0.2+9)\r\nOpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)", "url": "https://github.com/reactor/reactor-core/issues/1771", "user": "kamax70", "labels": ["type/bug"], "created": "2019-06-25 07:37:43", "closed": "2019-06-25 11:40:15", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Mono onComplete order is confusing", "body": "### Expected behavior\r\nFollowing code:\r\n```java\r\nMono.just(\"outer\")\r\n    .then(Mono.just(\"inner\").doOnTerminate(() -> System.out.println(\"Completed inner mono.\")))\r\n    .doOnTerminate(() -> System.out.println(\"Completed outer mono.\"))\r\n    .subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Subscriber onComplete called.\"));\r\n```\r\n**Expected output:**\r\n_inner\r\nCompleted inner mono.\r\nCompleted outer mono.\r\nSubscriber onComplete called._\r\n\r\n### Actual behavior\r\n**Actual output:**\r\n_inner\r\nSubscriber onComplete called.\r\nComplete outer mono.\r\nComplete inner mono._\r\n\r\n### Reactor Core version\r\n3.2.8\r\n\r\n### Additional details\r\nSwitching the inner `Mono` to an empty one produces the expected output\r\n```java\r\nMono.just(\"outer\")\r\n    .then(Mono.empty().doOnTerminate(() -> System.out.println(\"Completed inner mono.\")))\r\n    .doOnTerminate(() -> System.out.println(\"Completed outer mono.\"))\r\n    .subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Subscriber onComplete called.\"));\r\n```\r\n**Output:** \r\n_Completed inner mono.\r\nCompleted outer mono.\r\nSubscriber onComplete called._\r\n\r\nSwitching to `thenMany(Flux)` instead of `then(Mono)` also creates the expected output.\r\n\r\nLooking at a more basic example:\r\n```java\r\nMono.just(\"outer\")\r\n    .doOnTerminate(() -> System.out.println(\"Complete outer mono.\"))\r\n    .subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"Subscriber onComplete called.\"));\r\n```\r\n**also produces slightly unexpected output:**\r\n_outer\r\nSubscriber onComplete called.\r\nComplete outer mono._\r\n\r\nSwitching to `Flux` here produces the expected output.\r\nFor the first example the issue is somewhere inside `MonoIgnoreThen` I believe.", "url": "https://github.com/reactor/reactor-core/issues/1752", "user": "martin-tarjanyi", "labels": ["status/need-design", "type/bug"], "created": "2019-06-15 22:45:57", "closed": "2019-08-27 17:51:51", "commits": {"6436811a6540f4ad7e9ae3de698f25ca887b5951": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "8d29500abb5a4ed061c62fd1d506c3fdc35ad2ac": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a93c96cfb128e0702a0b23121be7b1ba26bf4990": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 72.00027777777778, "commitsDetails": [{"commitHash": "6436811a6540f4ad7e9ae3de698f25ca887b5951", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8d29500abb5a4ed061c62fd1d506c3fdc35ad2ac", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a93c96cfb128e0702a0b23121be7b1ba26bf4990", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["2d55d7d600442d26207d1023efe4ef8fd17d2396"], "nameRev": "a93c96cfb128e0702a0b23121be7b1ba26bf4990 tags/v3.3.0.RC1~13", "commitMessage": "fix #1752 Make doOnTerminate for Mono same as doOnSuccess\n\nThis means that the handler is invoked during processing of the `onNext`\nsignal.\n\nThis commit also slightly rework MonoPeekTerminal to make the onSuccess\nand onError handlers canonical, instead of the (successOrError) one.\n\nFinally, it makes `doOnError` directly use MonoPeekTerminal instead of\nMonoPeek, and modifies the marble diagrams (adding a convention for the\nnull value / empty set).\n\nRelates-to: #1853\n", "commitDateTime": "2019-08-27 19:51:48", "authoredDateTime": "2019-08-22 11:30:29", "commitGitStats": [{"filePath": "docs/svg/conventions.svg", "insertions": 2002, "deletions": 8927, "lines": 10929}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 34, "deletions": 31, "lines": 65}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeek.java", "insertions": 2, "deletions": 10, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekFuseable.java", "insertions": 2, "deletions": 10, "lines": 12}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java", "insertions": 15, "deletions": 49, "lines": 64}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/doOnSuccess.svg", "insertions": 348, "deletions": 11, "lines": 359}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/doOnTerminateForMono.svg", "insertions": 25, "deletions": 25, "lines": 50}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoPeekAfterTest.java", "insertions": 12, "deletions": 27, "lines": 39}, {"filePath": "reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.doAfterSuccessOrError(java.util.function.BiConsumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSuccess(java.util.function.Consumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.util.function.Consumer)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.lang.Class,java.util.function.Consumer)", "TOT": 5, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "TOT": 5, "UPD": 4, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSuccessOrError(java.util.function.BiConsumer)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminate(java.lang.Runnable)", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorMap(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorMap(java.util.function.Predicate,java.util.function.Function)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorResume(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.lang.Class,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.onErrorReturn(java.util.function.Predicate,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.subscriberContext(reactor.util.context.Context)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.timestamp(reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.transformDeferred(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.zipWhen(java.util.function.Function,java.util.function.BiFunction)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSignal(reactor.core.publisher.Mono,java.util.function.Consumer,java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable,java.util.function.LongConsumer,java.lang.Runnable)", "TOT": 5, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.ofType(java.lang.Class)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnCancel(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnNext(java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnRequest(java.util.function.LongConsumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnSubscribe(java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminalSignal(reactor.core.publisher.Mono,java.util.function.Consumer,java.util.function.Consumer,java.util.function.BiConsumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoPeek.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeek", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.MonoPeek.onErrorCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeek.onCompleteCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable.onErrorCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekFuseable.onCompleteCall()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoPeekTerminal.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal", "TOT": 8, "UPD": 6, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.tryOnNext(java.lang.Object)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onComplete()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.clear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.isEmpty()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoDematerializeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDematerializeTest.sourceWithSignalButNeverCompletes()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 3}]}, {"spoonFilePath": "MonoPeekAfterTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksNoFusion()", "TOT": 7, "UPD": 3, "INS": 1, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksFusionSync()", "TOT": 8, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekAfterTest.testCallbacksFusionAsync()", "TOT": 8, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 3}]}, {"spoonFilePath": "DefaultTestPublisherTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.publisher.DefaultTestPublisherTests.misbehavingMonoCanAvoidCompleteAfterOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "`MonoCreate` with `DelayUntil` trigger exception causes blocking subscriber to hang", "body": "### Expected behavior\r\nWhen `DelayUntil` trigger chained to a `MonoCreate` original publisher throws an exception, it should propagate to subscribers as a publisher error.\r\n\r\n### Actual behavior\r\nWhen `DelayUntil` trigger chained to a `MonoCreate` original publisher throws an exception, it causes blocking subscribers (`.block()`, `StepVerifier`) to hang.\r\n\r\n### Steps to reproduce\r\nThis test, with trigger generator function returning a proper publisher error, passes:\r\n```\r\n  @Test\r\n  public void delayUntilPropagatesTriggerError() {\r\n\r\n    StepVerifier.create(Mono.<String>create(sink -> {\r\n      sink.success(\"abc\");\r\n    }).delayUntil(c ->\r\n      Mono.error(new RuntimeException(\"simulate problem in trigger\"))\r\n    )).verifyError();\r\n  }\r\n```\r\n\r\nBut if the trigger publisher generator function throws an exception, the test hangs:\r\n```\r\n  @Test\r\n  public void delayUntilHangsOnTriggerException() {\r\n\r\n    StepVerifier.create(Mono.<String>create(sink -> {\r\n      sink.success(\"abc\");\r\n    }).delayUntil(c -> {\r\n      throw new RuntimeException(\"simulate problem in trigger\");\r\n    })).verifyError();\r\n  }\r\n\r\n```\r\n\r\nThis is the result of a combination of `MonoCreate` and `DelayUntil` behaviors.\r\n\r\n`DelayUntil` [does not check](https://github.com/reactor/reactor-core/blob/49271e2fca27f5daa68390066f28ccdb42c037c5/reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java#L169) for publisher function failure. Perhaps it could wrap the generator invocation in try/catch, and propagate a `Mono.error()` in case of failure.\r\nOn its side, `MonoCreate` [does try to handle `onNext()` throwing an exception](https://github.com/reactor/reactor-core/blob/3d2d1c40338926a27f4c58bbe331eac907a7e800/reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java#L156), but only calls `onComplete()` upon successful completion of `onNext()`. In case of failure, only `disposeResource()` is called, leaving the publisher in incomplete state.\r\n\r\nEither blocking or using `StepVerifier` will cause the code to hang, waiting for the `MonoCreate` publisher to complete.\r\n\r\n### Reactor Core version\r\nreactor-core:3.2.8.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\nJava 8 (openjdk 1.8.0_181)", "url": "https://github.com/reactor/reactor-core/issues/1741", "user": "elefeint", "labels": ["type/bug"], "created": "2019-06-10 15:32:02", "closed": "2019-07-23 09:40:23", "commits": {"12e9d27da209f3c74920cb6f06a5bbbfb66eef43": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5192d5d6d85c70f89a7f66b0d51b4e845a051424": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 42.000277777777775, "commitsDetails": [{"commitHash": "12e9d27da209f3c74920cb6f06a5bbbfb66eef43", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f61e34e0b93353d2c840f6ea245fbe5c881b6ce8"], "nameRev": "12e9d27da209f3c74920cb6f06a5bbbfb66eef43 tags/v3.3.0.M3~11^2", "commitMessage": "fix #1741 MonoCreate hanging if delayUntil throws exception\n\nThis commit fixes MonoCreate handling of downstream subscribers that\r\nthrow in onNext/onComplete, as an additional security.\r\n\r\nOne such subscriber, MonoDelayUntil, is also fixed: delay-generating\r\nfunctions that throw will now be correctly caught and translated into\r\nonError signal.", "commitDateTime": "2019-07-23 11:39:04", "authoredDateTime": "2019-07-23 11:39:04", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java", "insertions": 11, "deletions": 1, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDelayUntil.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntil.DelayUntilCoordinator.subscribeNextTrigger(java.lang.Object,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.delayUntilTriggerProviderThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDelayUntilTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.testAPIchainingCombines()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.testAPIchainingCumulatesDelaysAfterValueGenerated()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.triggerThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "5192d5d6d85c70f89a7f66b0d51b4e845a051424", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a1bb8439f7fd920beff44413f5e49ff113ee4da0", "12e9d27da209f3c74920cb6f06a5bbbfb66eef43"], "nameRev": "5192d5d6d85c70f89a7f66b0d51b4e845a051424 tags/v3.3.0.M3~11", "commitMessage": "Merge #1741 into 3.3\n", "commitDateTime": "2019-07-23 11:39:47", "authoredDateTime": "2019-07-23 11:39:47", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java", "insertions": 11, "deletions": 1, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDelayUntil.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntil.DelayUntilCoordinator.subscribeNextTrigger(java.lang.Object,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.delayUntilTriggerProviderThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDelayUntilTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.testAPIchainingCombines()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.testAPIchainingCumulatesDelaysAfterValueGenerated()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDelayUntilTest.triggerThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["12e9d27da209f3c74920cb6f06a5bbbfb66eef43"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14, "deletions": 1, "lines": 15, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoDelayUntil.DelayUntilCoordinator.subscribeNextTrigger(java.lang.Object,int)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)"]}, {"title": "reactor.scheduler.id metric tag for Schedulers.fromExecutorService is not useful", "body": "When using a `Scheduler` created via `Schedulers.fromExecutorService`, with metrics enabled via `Schedulers.enableMetrics()`, the metrics for the scheduler are tagged with `reactor.scheduler.id=fromExecutorService(null)`, which is not very useful.\r\n\r\nThe first problem is the `null` string, which is caused by:\r\n1. [`this` escaping the constructor](http://www.javapractices.com/topic/TopicAction.do?Id=252) of `DelegateServiceScheduler` [here](https://github.com/reactor/reactor-core/blob/d4fd8c61d75e9ab44a98524ae8d9a52cfc4868b8/reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java#L50).\r\n2. The `decorateExecutorService` call results in the `SchedulerMetricDecorator` accessing the not-fully-constructed `DelegateServiceScheduler` when it [scans for the Attr.NAME](https://github.com/reactor/reactor-core/blob/d4fd8c61d75e9ab44a98524ae8d9a52cfc4868b8/reactor-core/src/main/java/reactor/core/scheduler/SchedulerMetricDecorator.java#L49-L51)\r\n3. The scan calls back into the not-fully-constructed `DelegateServiceScheduler` [scanUnsafe](https://github.com/reactor/reactor-core/blob/d4fd8c61d75e9ab44a98524ae8d9a52cfc4868b8/reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java#L101)\r\n4. At that point, the executor is null, because `this.executor` hasn't been assigned yet from step 1\r\n\r\nThe second problem is that even if the first problem was solved, using the [`executor.toString()`](https://github.com/reactor/reactor-core/blob/d4fd8c61d75e9ab44a98524ae8d9a52cfc4868b8/reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java#L101) as the scheduler name, and therefore in the `reactor.scheduler.id` tag, is questionable.  The standard executor service implementations provided by the JDK have toString() values that change based on the state of the executor service.  For example, [`java.util.concurrent.ThreadPoolExecutor` includes the number of active tasks, etc in the `toString()` value](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#l1916).  Using such an unpredictable value in a tag is bad.\r\n\r\nIt seems that there should be a first class way of providing a scheduler name/id.  You could somewhat do this by wrapping an ExecutorService in something that provides a better .toString() , but that seems like a hack.\r\n\r\n### Expected behavior\r\n\r\n`reactor.scheduler.id` metric tag value for `Schedulers.fromExecutorService` has a useful value.\r\n\r\n### Actual behavior\r\n\r\n`reactor.scheduler.id=fromExecutorService(null)`\r\n\r\nSee main description.\r\n\r\n### Steps to reproduce\r\n\r\n1. Call `Schedulers.enableMetrics()`\r\n2. Construct a scheduler via `Schedulers.fromExecutorService`\r\n3. Observe tag values of metrics for the scheduler\r\n\r\n### Reactor Core version\r\n\r\n3.2.9.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n11.0.2", "url": "https://github.com/reactor/reactor-core/issues/1739", "user": "philsttr", "labels": ["type/bug", "type/enhancement"], "created": "2019-06-06 21:36:56", "closed": "2019-07-03 08:00:47", "commits": {"01507480df4d964c16d85f5f07b957881a16e57a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "fe479a92c08d0d39f5157ed84d6e58d4df60b9be": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "58abafc611607d6cad00b545169a8442197fc9c8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 26.00027777777778, "commitsDetails": [{"commitHash": "01507480df4d964c16d85f5f07b957881a16e57a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fe479a92c08d0d39f5157ed84d6e58d4df60b9be", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["dd8856cf3c94c518a18eb8d02f810853e0d78322"], "nameRev": "fe479a92c08d0d39f5157ed84d6e58d4df60b9be tags/v3.3.0.M3~11^2~6", "commitMessage": "fix #1739 Enforce a name for Schedulers.fromExecutorService\n\nThis avoids relying on the underlying ExecutorService's toString, at\r\nleast for the purpose of calling `scan(Attr.NAME)`.\r\n\r\nPreviously, relying on the backing ExecutorService#toString method\r\nwas not ideal as this generally depends on the state of the executor,\r\nwhich is not ideal for most usages of `NAME` and especially not for\r\nmetrics (where NAME is used a a differentiating tag for the meters).\r\n\r\nThere is an additional issue of NAME being used for metrics decorator,\r\nwhich is invoked during construction. Other schedulers use fields that\r\nare initiliazed early in the constructor, but fromExecutorService used\r\nthe executor toString, which obviously cannot possibly be initialized.\r\nAdding the name field and initializing it early helps again here.", "commitDateTime": "2019-07-03 09:58:41", "authoredDateTime": "2019-07-03 09:58:41", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java", "insertions": 11, "deletions": 2, "lines": 13}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 18, "deletions": 2, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/AbstractSchedulerTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/DelegateServiceSchedulerTest.java", "insertions": 75, "deletions": 71, "lines": 146}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SchedulersMetricsTest.java", "insertions": 60, "deletions": 15, "lines": 75}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DelegateServiceScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler.scanUnsafe(reactor.core.scheduler.Attr)", "TOT": 12, "UPD": 5, "INS": 1, "MOV": 6, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService,java.lang.String)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest.autoCleanup(reactor.core.Disposable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest.cleanupCompositeDisposable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DelegateServiceSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanName()", "TOT": 23, "UPD": 6, "INS": 0, "MOV": 14, "DEL": 3}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.smokeTestDelay()", "TOT": 9, "UPD": 0, "INS": 1, "MOV": 7, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.smokeTestInterval()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanExecutorAttributes()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanNameAnonymous()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.notScheduledRejects()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scheduledDoesntReject()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanNameExplicit()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.autoCleanup(reactor.core.Disposable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.fromExecutorServiceSchedulerId()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.tearDown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHasDistinctNameTags()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHasDistinctSchedulerIdTags()", "TOT": 10, "UPD": 0, "INS": 5, "MOV": 5, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHandleNamingClash()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.decorateTwiceWithSameSchedulerInstance()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.disablingMetricsRemovesSchedulerMeters()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "58abafc611607d6cad00b545169a8442197fc9c8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["723892d168f2f6a0706b1dd1b46932ddbee147a3", "fe479a92c08d0d39f5157ed84d6e58d4df60b9be"], "nameRev": "58abafc611607d6cad00b545169a8442197fc9c8 tags/v3.3.0.M3~33", "commitMessage": "Merge #1739 into 3.3\n", "commitDateTime": "2019-07-03 10:00:22", "authoredDateTime": "2019-07-03 10:00:22", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java", "insertions": 11, "deletions": 2, "lines": 13}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 18, "deletions": 2, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/AbstractSchedulerTest.java", "insertions": 24, "deletions": 0, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/DelegateServiceSchedulerTest.java", "insertions": 75, "deletions": 71, "lines": 146}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SchedulersMetricsTest.java", "insertions": 60, "deletions": 15, "lines": 75}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DelegateServiceScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler.scanUnsafe(reactor.core.scheduler.Attr)", "TOT": 12, "UPD": 5, "INS": 1, "MOV": 6, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService,java.lang.String)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest.autoCleanup(reactor.core.Disposable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.AbstractSchedulerTest.cleanupCompositeDisposable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DelegateServiceSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanName()", "TOT": 23, "UPD": 6, "INS": 0, "MOV": 14, "DEL": 3}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.smokeTestDelay()", "TOT": 9, "UPD": 0, "INS": 1, "MOV": 7, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.smokeTestInterval()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanExecutorAttributes()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanNameAnonymous()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.notScheduledRejects()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scheduledDoesntReject()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceSchedulerTest.scanNameExplicit()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.autoCleanup(reactor.core.Disposable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.fromExecutorServiceSchedulerId()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.tearDown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHasDistinctNameTags()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHasDistinctSchedulerIdTags()", "TOT": 10, "UPD": 0, "INS": 5, "MOV": 5, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.metricsActivatedHandleNamingClash()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.decorateTwiceWithSameSchedulerInstance()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersMetricsTest.disablingMetricsRemovesSchedulerMeters()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["fe479a92c08d0d39f5157ed84d6e58d4df60b9be"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 29.0, "deletions": 4.0, "lines": 33.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 22.0, "UPD": 6.0, "INS": 8.0, "MOV": 8.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService,java.lang.String)", "reactor.core.scheduler.DelegateServiceScheduler", "reactor.core.scheduler.DelegateServiceScheduler.scanUnsafe(reactor.core.scheduler.Attr)", "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService)"]}, {"title": "FluxRefCount doesn't accomodate double cancellation", "body": "### Expected behavior\r\n No exception\r\n### Actual behavior\r\nstream throws java.util.concurrent.CancellationException. Without .onBackpressureBuffer() it works as expected. Also .refCount(1, Duration.ofMillis(1)) fix issue.\r\n### Steps to reproduce\r\n```\r\npublic static void main(String[] args) throws InterruptedException {\r\n        Flux<Integer> stream = Flux.range(0, 100)\r\n                .delayElements(Duration.ofMillis(2))\r\n                .publish()\r\n                .refCount()\r\n                .onBackpressureBuffer();\r\n\r\n        stream\r\n                .log(\"subscriber 1\")\r\n                .subscribe();\r\n\r\n        Thread.sleep(50);\r\n\r\n        stream\r\n                .take(1)\r\n                .log(\"subscriber 2\")\r\n                .subscribe();\r\n\r\n        Thread.currentThread().join();\r\n    }\r\n```\r\n### Reactor Core version\r\n 3.2.9-RELEASE\r\n### JVM version (e.g. `java -version`)\r\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)", "url": "https://github.com/reactor/reactor-core/issues/1738", "user": "rasentry", "labels": ["type/bug"], "created": "2019-06-06 09:58:01", "closed": "2019-07-09 07:49:58", "commits": {"585b001ed5b25d0caaf1662d89a20469882dec74": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7d9faa604b2a39a404e58396837f63bd2f5a9a92": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "b6651b86cd412adaefecb694a602642479ab8fdd": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 32.000277777777775, "commitsDetails": [{"commitHash": "585b001ed5b25d0caaf1662d89a20469882dec74", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7d9faa604b2a39a404e58396837f63bd2f5a9a92", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d38fb862cb1b48d7a8caf20d83f03d66bb180aca"], "nameRev": "7d9faa604b2a39a404e58396837f63bd2f5a9a92 tags/v3.3.0.M3~11^2~4", "commitMessage": "fix #1738 FluxRefCount inner doesn't guard against multiple cancels\n\nThis commit prevents overeager removal of inners when a given Subscriber\r\nsends the cancel signal several times (which is not encouraged, but\r\npermitted by the spec).\r\n\r\nThe double cancel would previously cause the second subscriber to be\r\nconsidered remove, triggering the disconnection from the source.\r\n\r\nExamples include putting an onBackpressureBuffer immediately after a\r\n`publish().refCount()`.", "commitDateTime": "2019-07-09 09:48:24", "authoredDateTime": "2019-07-09 09:48:24", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 24, "deletions": 6, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 47, "deletions": 0, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.avoidUnexpectedDoubleCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.avoidUnexpectedDoubleCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInnerCancelled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInner()", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b6651b86cd412adaefecb694a602642479ab8fdd", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["75e9d32ec7f73d4f50a4a62de560f9409b597772", "7d9faa604b2a39a404e58396837f63bd2f5a9a92"], "nameRev": "b6651b86cd412adaefecb694a602642479ab8fdd tags/v3.3.0.M3~30", "commitMessage": "Merge #1738 into 3.3\n", "commitDateTime": "2019-07-09 09:48:52", "authoredDateTime": "2019-07-09 09:48:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 24, "deletions": 6, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 47, "deletions": 0, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.avoidUnexpectedDoubleCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.avoidUnexpectedDoubleCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInnerCancelled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInner()", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7d9faa604b2a39a404e58396837f63bd2f5a9a92"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 24.0, "deletions": 6.0, "lines": 30.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 0.0, "INS": 8.0, "MOV": 5.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "reactor.core.publisher.FluxRefCount.RefCountInner.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxRefCount", "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "reactor.core.publisher.FluxRefCount.RefCountInner"]}, {"title": "ElasticScheduler leaks thread when task is disposed immediately", "body": "### Expected behavior\r\n\r\nThe following code should always return the executor to the cache.\r\n\r\n```java\r\nSchedulers.elastic()\r\n    .schedule(() -> System.out.println(\"yeah\"))\r\n    .dispose();\r\n```\r\n\r\n### Actual behavior\r\n\r\nSometimes the executor is not returned to the cache. It causes threads to leak.\r\n\r\n### Steps to reproduce\r\n\r\n```java\r\npublic class ElasticSchedulerLeakTest {\r\n    public static void main(String[] args) throws Exception {\r\n        while (true) {\r\n            Schedulers.elastic()\r\n                    .schedule(() -> System.out.println(\"yeah\"))\r\n                    .dispose();\r\n\r\n            Thread.sleep(100);\r\n\r\n            int cacheSize = ((Scannable) Schedulers.elastic()).scan(Scannable.Attr.BUFFERED);\r\n            // should print 1 if executor is returned to cache, but sometimes 0 is printed\r\n            System.out.println(cacheSize);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Reactor Core version\r\n\r\n3.2.8.RELEASE\r\n\r\nIt seems to happen on other versions too.\r\n\r\n----\r\n\r\nWhen `schedule` is called, a `CachedService` is acquired first:\r\n\r\nhttps://github.com/reactor/reactor-core/blob/a0b332b99b25f98461536f01cc18e6b30319301a/reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java#L159\r\n\r\n`CachedService` is disposed after the task is run:\r\n\r\nhttps://github.com/reactor/reactor-core/blob/a0b332b99b25f98461536f01cc18e6b30319301a/reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java#L300\r\n\r\nHowever, if the task is not run (because of immediate disposal), `CachedService` is not disposed.", "url": "https://github.com/reactor/reactor-core/issues/1722", "user": "dittos", "labels": ["type/bug"], "created": "2019-05-24 13:53:36", "closed": "2019-07-02 08:59:43", "commits": {"723892d168f2f6a0706b1dd1b46932ddbee147a3": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 38.000277777777775, "commitsDetails": [{"commitHash": "723892d168f2f6a0706b1dd1b46932ddbee147a3", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["8d5748f90fa5bc25fe626e8fece076ea222757e4"], "nameRev": "723892d168f2f6a0706b1dd1b46932ddbee147a3 tags/v3.3.0.M3~34", "commitMessage": "fix #1722 Make sure ElasticScheduler.CachedService gets disposed\n\nWhen schedule is called, a CachedService is acquired first.\r\nIt is disposed after the task is run. However, if the task is not run\r\n(because of immediate disposal), CachedService is not disposed.\r\nThis commit fixes that.\r\n\r\nReviewed in: #1724\r\n", "commitDateTime": "2019-07-02 10:59:42", "authoredDateTime": "2019-07-02 17:59:42", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 4, "deletions": 26, "lines": 30}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/SchedulerTask.java", "insertions": 34, "deletions": 1, "lines": 35}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java", "insertions": 74, "deletions": 9, "lines": 83}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DelegateServiceScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.DelegateServiceScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ElasticScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ElasticScheduler.schedule(java.lang.Runnable)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ElasticScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ElasticScheduler.DirectScheduleTask", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "ParallelScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ParallelScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ParallelScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulerTask.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulerTask", "TOT": 5, "UPD": 0, "INS": 5, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulerTask.call()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulerTask.dispose()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.directSchedule(java.util.concurrent.ScheduledExecutorService,java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.directSchedule(java.util.concurrent.ScheduledExecutorService,java.lang.Runnable,reactor.core.Disposable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SingleScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SingleScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ElasticSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ElasticSchedulerTest.eviction()", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 5, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ElasticSchedulerTest.doesntRecycleWhileRunningAfterDisposed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ElasticSchedulerTest.recycleOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Items are intermittently lost when flat mapping includes a Mono that uses the elastic scheduler", "body": "### Expected behavior\r\n\r\nWhen flat mapping, all Monos are considered irrespective of the scheduler they use\r\n\r\n### Actual behavior\r\n\r\nThe use of the elastic scheduler causes a Mono to be intermittently missed\r\n\r\n### Steps to reproduce\r\n\r\nRun the following code:\r\n\r\n```java\r\nfor (int i = 0; i < 10000; i++) {\r\n\tMap<String, Mono<Integer>> input = new HashMap<String, Mono<Integer>>();\r\n\tinput.put(\"one\", Mono.just(1));\r\n\tinput.put(\"two\", Mono.create(\r\n\t\t\t(sink) -> Schedulers.elastic().schedule(() -> sink.success(2))));\r\n\tinput.put(\"three\", Mono.just(3));\r\n\tint sum = Flux.fromIterable(input.entrySet())\r\n\t\t\t.flatMap((entry) -> Mono.zip(Mono.just(entry.getKey()),\r\n\t\t\t\t\tentry.getValue()))\r\n\t\t\t.collectMap(Tuple2::getT1, Tuple2::getT2).map((items) -> {\r\n\t\t\t\tAtomicInteger result = new AtomicInteger();\r\n\t\t\t\titems.values().forEach(result::addAndGet);\r\n\t\t\t\treturn result.get();\r\n\t\t\t}).block();\r\n\tassertThat(sum).as(\"Iteration %s\", i).isEqualTo(6);\r\n}\r\n```\r\n\r\nAfter approximately 100 iterations, the assertion will fail with the sum being 4 rather than 6. The problem does not occur if `log()` is called on the result of the call to `Mono.zip`.\r\n\r\nI realise the logic above is a bit odd as it ignores the keys. It's a simplification of [something in Spring Boot](https://github.com/spring-projects/spring-boot/blob/a5537bd2e1179e52e009cc88882087d9a762d5e3/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/CompositeReactiveHealthIndicator.java#L83-L87) that uses the keys. The above is just intended to be as close to the Boot code as possible while also being as minimal as possible.\r\n\r\n### Reactor Core version\r\n\r\n3.3.0.M1\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n1.8.0_181", "url": "https://github.com/reactor/reactor-core/issues/1719", "user": "wilkinsona", "labels": ["type/bug"], "created": "2019-05-23 15:16:14", "closed": "2019-05-23 21:07:00", "commits": {"0708241f80ae6bc4db9552eba132833030c164d0": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "26a1511f679c63568d47cbed96451d62d7ff9492": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "f47a803087378b30018b969b9c75296b4e549246": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0708241f80ae6bc4db9552eba132833030c164d0", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "26a1511f679c63568d47cbed96451d62d7ff9492", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f47a803087378b30018b969b9c75296b4e549246", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["ad26ce26cb395e8a3f69386649f2a3be5bf12d0a"], "nameRev": "f47a803087378b30018b969b9c75296b4e549246 tags/v3.2.10.RELEASE~10", "commitMessage": "fix #1719 Fix a memory barrier regression introduced in MonoSubscriber\n\nSigned-off-by: Stephane Maldini <smaldini@pivotal.io>\n", "commitDateTime": "2019-05-23 14:08:05", "authoredDateTime": "2019-05-23 10:32:08", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 10, "deletions": 5, "lines": 15}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java", "insertions": 23, "deletions": 0, "lines": 23}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.complete(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "MonoSubscriberTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscriberTest.issue1719()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f47a803087378b30018b969b9c75296b4e549246"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 10.0, "deletions": 5.0, "lines": 15.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 0.0, "INS": 1.0, "MOV": 4.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.MonoSubscriber.complete(java.lang.Object)"]}, {"title": "publish().autoConnect(0) behaving different with 3.3.0.M1", "body": "### Expected behavior\r\nThe test to succeed (as it does with reactor-core 3.2.6)\r\n\r\n### Actual behavior\r\nTest fails\r\n```\r\nException in thread \"main\" java.lang.AssertionError: expectation \"expectNext(99)\" failed (expected value: 99; actual value: 1)\r\n```\r\n\r\n### Steps to reproduce\r\n```\r\n        TestPublisher<Integer> publisher = TestPublisher.create();\r\n        Flux<Integer> flux = publisher.flux().publish().autoConnect(0);\r\n        publisher.next(1);\r\n        publisher.next(2);\r\n        publisher.next(3);\r\n\r\n        StepVerifier.create(flux)\r\n                    .expectSubscription()\r\n                    .then(() -> publisher.next(99))\r\n                    .expectNext(99)\r\n                    .then(publisher::complete)\r\n                    .verifyComplete();\r\n```\r\n### Reactor Core version\r\n3.3.0.M1\r\n\r\n### JVM version (e.g. `java -version`)\r\n```\r\njava version \"1.8.0_191\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_191-b12)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\r\n```\r\n", "url": "https://github.com/reactor/reactor-core/issues/1712", "user": "joshiste", "labels": ["type/bug"], "created": "2019-05-17 10:59:36", "closed": "2019-05-22 10:03:29", "commits": {"5068e9d2b3b11ac45627f9d2215ed5833931f533": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ac28cdd8ff9046153adabc2fd2a24306516b4884": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "9341b8e6c66cc03bea3e31f5b587a407c259889f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "5068e9d2b3b11ac45627f9d2215ed5833931f533", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ac28cdd8ff9046153adabc2fd2a24306516b4884", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["2ce7b75ff95a21aa5151ffd9cf93d3a7995d9eee"], "nameRev": "ac28cdd8ff9046153adabc2fd2a24306516b4884 tags/v3.2.10.RELEASE~12", "commitMessage": "fix #1712 Flux.publish().autoConnect(0) should drop early items\n\nThis is linked to #1528, the previous fix having introduced a regression\nwhere early connection without subscribers is not handled correctly and\naccumulates received items instead of \"dropping\" them.\n\nThis is because, unlike EmitterProcessor, FluxPublish should distinguish\ninitial connection with empty subscribers array vs empty subscribers\narray that is due to removing the last inner (ie. cancelling).\n\nThis commit also ensures that disconnectAction, which is synonymous to\ncancellation, sets the subscribers array to CANCELLED, not INIT.\n", "commitDateTime": "2019-05-22 11:47:56", "authoredDateTime": "2019-05-21 17:44:59", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 15, "deletions": 8, "lines": 23}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 39, "deletions": 2, "lines": 41}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.remove(reactor.core.publisher.FluxPublish$PubSubInner)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfConnectImmediately()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfAutoconnectZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "9341b8e6c66cc03bea3e31f5b587a407c259889f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["8895e9409067699af11770e794b18bc9f8d74541", "ac28cdd8ff9046153adabc2fd2a24306516b4884"], "nameRev": "9341b8e6c66cc03bea3e31f5b587a407c259889f tags/v3.3.0.M2~22", "commitMessage": "Merge #1712 into 3.3\n", "commitDateTime": "2019-05-22 12:02:52", "authoredDateTime": "2019-05-22 12:02:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 18, "deletions": 10, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 55, "deletions": 2, "lines": 57}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.remove(reactor.core.publisher.FluxPublish$PubSubInner)", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.removeUnknownInnerIgnored()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfConnectImmediately()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfAutoconnectZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.removeUnknownInnerIgnored()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "OOME is occurred due to Throwable#addSuppressed at BlockingSingleSubscriber", "body": "### Steps to reproduce\r\n\r\nUnfortunately, netty's Read(Write)TimeoutError is singleton.\r\nThis code can cause OOME.\r\n\r\nhttps://github.com/reactor/reactor-core/blob/c86db5aa0cc648520c8f95349232b314cb6e953e/reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java#L132-L133\r\n\r\nIn fact, in my environment, when a network trouble occurs, the heap accumulates and OOME has occurred.\r\n\r\nI also created issue in netty-side.\r\nhttps://github.com/netty/netty/issues/9151\r\n\r\n### Reactor Core version\r\n\r\n3.2.8.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```\r\nopenjdk version \"1.8.0_171\"\r\nOpenJDK Runtime Environment (build 1.8.0_171-b10)\r\nOpenJDK 64-Bit Server VM (build 25.171-b10, mixed mode)\r\n```\r\n", "url": "https://github.com/reactor/reactor-core/issues/1710", "user": "be-hase", "labels": ["type/bug"], "created": "2019-05-16 06:55:08", "closed": "2019-05-21 15:56:18", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Flux.generate should wrap and throw exception in poll using propagate, not bubble", "body": "Error is not thrown due to a missuse of Exceptions.bubble :\r\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java#L339", "url": "https://github.com/reactor/reactor-core/issues/1685", "user": "smaldini", "labels": ["type/bug"], "created": "2019-05-03 08:13:47", "closed": "2019-05-06 07:38:27", "commits": {"29590ff447f26aa38b47c30feeaa6ada1b2e60ed": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "51fe3e5bbc69daafaf054b6c82b0516c3a63e879": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e3ef0a050da16b820b569cb03d71d9e051b5f04e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f9c56a10e59d595e789c7f5d86e1302782c1c128": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "bbbf84647f6785cf690861c92027c45cddc9210d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "b37a6dd2d61036480c20c2f562eaeef048690623": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "cc71b036f4aae1e24472ae6bc271b5cd6451081b": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "29590ff447f26aa38b47c30feeaa6ada1b2e60ed", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "51fe3e5bbc69daafaf054b6c82b0516c3a63e879", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e3ef0a050da16b820b569cb03d71d9e051b5f04e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f9c56a10e59d595e789c7f5d86e1302782c1c128", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["7a487e1d29aa4300be8da1b3475847864cb033ea"], "nameRev": "f9c56a10e59d595e789c7f5d86e1302782c1c128 tags/v3.2.9.RELEASE~2", "commitMessage": "fix #1685 Flux.generate propagates exception in all poll cases\n\nThe case where an iteration of the generator both emits a value and an\nerror wasn't covered by tests. It failed to throw the aforementioned\nerror despite wrapping with `Exceptions.propagate`, which resulted\nin a missed `onError` signal in such cases.\n", "commitDateTime": "2019-05-03 22:08:38", "authoredDateTime": "2019-05-03 10:39:56", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java", "insertions": 32, "deletions": 0, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxGenerate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxGenerate.GenerateSubscription.poll()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "FluxGenerateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxGenerateTest.fusedGeneratedNextAndErrorPropagateException()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxGenerateTest.fusedGenerateErrorThrowsPropagateException()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "bbbf84647f6785cf690861c92027c45cddc9210d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["96f8309026d093dd967f26582a4206d569521848"], "nameRev": "bbbf84647f6785cf690861c92027c45cddc9210d tags/v3.3.0.M1~18", "commitMessage": "fix #1685 Flux.generate propagates exception in all poll cases\n\nThe case where an iteration of the generator both emits a value and an\nerror wasn't covered by tests. It failed to throw the aforementioned\nerror despite wrapping with `Exceptions.propagate`, which resulted\nin a missed `onError` signal in such cases.\n", "commitDateTime": "2019-05-06 09:38:13", "authoredDateTime": "2019-05-03 10:39:56", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java", "insertions": 32, "deletions": 0, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxGenerate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxGenerate.GenerateSubscription.poll()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "FluxGenerateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxGenerateTest.fusedGeneratedNextAndErrorPropagateException()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxGenerateTest.fusedGenerateErrorThrowsPropagateException()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b37a6dd2d61036480c20c2f562eaeef048690623", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["bbbf84647f6785cf690861c92027c45cddc9210d", "f9c56a10e59d595e789c7f5d86e1302782c1c128"], "nameRev": "b37a6dd2d61036480c20c2f562eaeef048690623 tags/v3.3.0.M1~17", "commitMessage": "Merge branch '3.2.x' to align on #1685\n\nThe commit was not part of a proper forward merge.\n", "commitDateTime": "2019-05-06 09:39:18", "authoredDateTime": "2019-05-06 09:39:18", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "cc71b036f4aae1e24472ae6bc271b5cd6451081b", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f9c56a10e59d595e789c7f5d86e1302782c1c128"], "filteredCommitsReason": {"duplicated": 5, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 1.0, "INS": 1.0, "MOV": 2.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxGenerate.GenerateSubscription.poll()"]}, {"title": "onBackpressureBuffer(maxSize) uses rounded up maxSize", "body": "### Expected behavior\r\n`onBackpressureBuffer(3, System.err::println)` should emit 1, buffer 3 next unrequested elements, print out the 5th element and cancel the source.\r\n\r\n`onBackpressureBuffer(9, System.err::println)` should emit 1, buffer next 9 unrequested elements, print out the 11th and cancel the source.\r\n\r\n### Actual behavior\r\nFirst version buffers up to 8 elements, prints out `10`. Second version buffers up to 16 elements, prints out `18`.\r\n\r\n### Steps to reproduce\r\n```java\r\n\t@Test\r\n\tpublic void gh1666_bufferThree() {\r\n\t\tAtomicInteger overflow = new AtomicInteger();\r\n\t\tStepVerifier.create(Flux.range(1, 100)\r\n\t\t                        .hide()\r\n\t\t                        .onBackpressureBuffer(3, overflow::set)\r\n\t\t\t\t, 0)\r\n\t\t            .expectSubscription()\r\n\t\t            .thenRequest(1)\r\n\t\t            .expectNext(1)\r\n\t\t            .thenAwait()\r\n\t\t            .thenCancel()\r\n\t\t            .verify();\r\n\r\n\t\tassertThat(overflow).as(\"overflow value\").hasValue(5);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void gh1666_bufferNine() {\r\n\t\tAtomicInteger overflow = new AtomicInteger();\r\n\t\tStepVerifier.create(Flux.range(1, 100)\r\n\t\t                        .hide()\r\n\t\t                        .onBackpressureBuffer(9, overflow::set)\r\n\t\t\t\t, 0)\r\n\t\t            .expectSubscription()\r\n\t\t            .thenRequest(1)\r\n\t\t            .expectNext(1)\r\n\t\t            .thenAwait()\r\n\t\t            .thenCancel()\r\n\t\t            .verify();\r\n\r\n\t\tassertThat(overflow).as(\"overflow value\").hasValue(11);\r\n\t}\r\n```\r\n\r\n### Reactor Core version\r\n3.2.8.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1666", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-04-19 14:59:09", "closed": "2019-04-19 17:59:46", "commits": {"89897c1e7da913f4adba7ff4d966ae99b0304ec0": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "9d49b7e26eca885850aac1e72fd3969ed12a447d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "3475db216501ca0b20252fefff978c9849871fd5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "89897c1e7da913f4adba7ff4d966ae99b0304ec0", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "9d49b7e26eca885850aac1e72fd3969ed12a447d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["63c36c9e1642bca5a9c3b0a1daff9310b2f24590"], "nameRev": "9d49b7e26eca885850aac1e72fd3969ed12a447d tags/v3.2.9.RELEASE~11", "commitMessage": "fix #1666 Use queue.size() for onBackpressureBuffer maxSize evaluation\n\nThe queue.offer() can be unreliable, mainly due to Spsc*Queue rounding the\r\nrequested capacity up to the nearest power of two, as well as \r\nQueues.get(capacity) rounding up capacity to a minimum of 8...\r\n\r\nThis commit keeps track of the exact buffer size and compares it to the \r\nqueue size() when in bounded mode.\r\n\r\nThis also allows to answer to `scan(CAPACITY)`.\r\n\r\nThe documentation has been improved to reflect this, as well as the marble\r\ndiagram of both variants with a bufferSize and no strategy (the strategy\r\none being a different implementation that is not impacted).\r\n\r\nTests have been added, and some tests that didn't cover \r\nFluxOnBackpressureBuffer have been moved to the more correct \r\nFluxOnBackpressureStrategyTest case.", "commitDateTime": "2019-04-19 19:58:53", "authoredDateTime": "2019-04-19 19:58:53", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 19, "deletions": 13, "lines": 32}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "insertions": 13, "deletions": 4, "lines": 17}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSize.svg", "insertions": 53, "deletions": 60, "lines": 113}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeConsumer.svg", "insertions": 139, "deletions": 0, "lines": 139}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeStrategyDropOldest.svg", "insertions": 102, "deletions": 0, "lines": 102}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferStrategyTest.java", "insertions": 82, "deletions": 0, "lines": 82}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTest.java", "insertions": 154, "deletions": 32, "lines": 186}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": []}, {"spoonFilePath": "FluxOnBackpressureBuffer.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferStrategyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowDropOldest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowDropLatest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferWithBadSourceEmitsAfterComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow()", "TOT": 26, "UPD": 10, "INS": 0, "MOV": 14, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow2()", "TOT": 36, "UPD": 13, "INS": 0, "MOV": 21, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow3()", "TOT": 41, "UPD": 16, "INS": 0, "MOV": 22, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMax()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.stepByStepRequesting()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.gh1666_bufferThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.gh1666_bufferNine()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityUnbounded()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityBoundedQueueWithExactCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityBoundedQueueWithExtraCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackUnder8()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackSourceEmitsAfterComplete()", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "3475db216501ca0b20252fefff978c9849871fd5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["0ec7f91d31cf508d1d5d9658a9e9ceac563d1020", "9d49b7e26eca885850aac1e72fd3969ed12a447d"], "nameRev": "3475db216501ca0b20252fefff978c9849871fd5 tags/v3.3.0.M1~30", "commitMessage": "Merge #1666 into 3.3\n", "commitDateTime": "2019-04-19 19:59:30", "authoredDateTime": "2019-04-19 19:59:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 19, "deletions": 13, "lines": 32}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java", "insertions": 13, "deletions": 4, "lines": 17}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSize.svg", "insertions": 53, "deletions": 60, "lines": 113}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeConsumer.svg", "insertions": 139, "deletions": 0, "lines": 139}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeStrategyDropOldest.svg", "insertions": 102, "deletions": 0, "lines": 102}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferStrategyTest.java", "insertions": 82, "deletions": 0, "lines": 82}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTest.java", "insertions": 154, "deletions": 32, "lines": 186}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": []}, {"spoonFilePath": "FluxOnBackpressureBuffer.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferStrategyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowDropOldest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferMaxCallbackOverflowDropLatest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferStrategyTest.onBackpressureBufferWithBadSourceEmitsAfterComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow()", "TOT": 26, "UPD": 10, "INS": 0, "MOV": 14, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow2()", "TOT": 36, "UPD": 13, "INS": 0, "MOV": 21, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackOverflow3()", "TOT": 41, "UPD": 16, "INS": 0, "MOV": 22, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMax()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.stepByStepRequesting()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.gh1666_bufferThree()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.gh1666_bufferNine()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityUnbounded()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityBoundedQueueWithExactCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.scanCapacityBoundedQueueWithExtraCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackUnder8()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTest.onBackpressureBufferMaxCallbackSourceEmitsAfterComplete()", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["9d49b7e26eca885850aac1e72fd3969ed12a447d"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 326.0, "deletions": 77.0, "lines": 403.0, "gitFilesChange": 5}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 0.0, "INS": 4.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSize.svg", "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeStrategyDropOldest.svg", "reactor-core/src/main/java/reactor/core/publisher/doc-files/marbles/onBackpressureBufferWithMaxSizeConsumer.svg", "reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber", "reactor.core.publisher.FluxOnBackpressureBuffer.BackpressureBufferSubscriber.onNext(java.lang.Object)"]}, {"title": "The context is not passed to ParallelFlux#doOnEach's signal", "body": "### Expected behavior\r\nSubscriber's context is passed to ParallelFlux#doOnEach's signal\r\n\r\n### Actual behavior\r\nThe context is missing\r\n\r\n### Steps to reproduce\r\n```java\r\nFlux.just(1, 2, 3)\r\n    .parallel()\r\n    .doOnEach(s -> {\r\n        if (s.hasValue()) {\r\n\t\t    String valueFromContext = s.getContext()\r\n\t\t                   .getOrDefault(\"test\", null);\r\n\t\t    results.add(s.get() + \" \" + valueFromContext);\r\n\t    }\r\n    })\r\n    .reduce(Integer::sum)\r\n    .subscriberContext(Context.of(\"test\", \"Hello!\"))\r\n    .block();\r\n```\r\n\r\n### Reactor Core version\r\nany\r\n\r\n### JVM version (e.g. `java -version`)\r\nnon-JVM specific", "url": "https://github.com/reactor/reactor-core/issues/1656", "user": "bsideup", "labels": ["type/bug"], "created": "2019-04-10 09:34:02", "closed": "2019-04-11 08:46:23", "commits": {"0cfd1179f92f22fe81e16468c0afce8b8b356424": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "0e121b9d8404dc6d8284069138a2cb73571c124a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "63c36c9e1642bca5a9c3b0a1daff9310b2f24590": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0cfd1179f92f22fe81e16468c0afce8b8b356424", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0e121b9d8404dc6d8284069138a2cb73571c124a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "63c36c9e1642bca5a9c3b0a1daff9310b2f24590", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["a20541cdca7f69331a8a4d3ec78db1b476e0ed5b"], "nameRev": "63c36c9e1642bca5a9c3b0a1daff9310b2f24590 tags/v3.2.9.RELEASE~12", "commitMessage": "fix #1656 ParallelFlux#doOnEach should receive the context (#1657)\n\n`ParallelFlux#doOnEach` was passing signals to the consumers,\r\nbut `context` property of these signals was not set due to\r\nthe use of `ParallelPeek`.\r\n\r\nThis change introduces context-passing `ParallelDoOnEach`.", "commitDateTime": "2019-04-11 10:40:43", "authoredDateTime": "2019-04-11 10:40:43", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelDoOnEach.java", "insertions": 157, "deletions": 0, "lines": 157}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java", "insertions": 28, "deletions": 0, "lines": 28}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ParallelDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelDoOnEach", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ParallelFlux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFlux.doOnEach(java.util.function.Consumer)", "TOT": 12, "UPD": 1, "INS": 3, "MOV": 6, "DEL": 2}]}, {"spoonFilePath": "ParallelFluxTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.doOnEachContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "distinctUntilChanged retains a reference to the last key on cancel/termination", "body": "### Expected behavior\r\nWith the base variant where the key is the actual object, once a subscriber is cancelled the objects should all be garbage collected.\r\n\r\nSame on termination.\r\n\r\nDiscarding is more tricky, as even if the actual data can be stored as `lastKey`, said piece of data has been passed downstream and is the responsibility of downstream. We'll leave it as is for now. Generally keys for distinct/distinctUntilChanged shouldn't be of types that require discard cleanup.\r\n\r\n### Actual behavior\r\nA reference to the last object is kept as `lastKey`, since `cancel()` doesn't null out said reference.\r\n\r\n### Steps to reproduce\r\n```\r\n\t@Test\r\n\tpublic void distinctUntilChangedDefaultCancelDoesntRetainObjects_subscriber() {\r\n\t\tRetainedDetector retainedDetector = new RetainedDetector();\r\n\t\tAtomicReference<DistinctDefaultCancel> fooRef = new AtomicReference<>(retainedDetector.tracked(new DistinctDefaultCancel(0)));\r\n\r\n\t\tDistinctUntilChangedSubscriber<DistinctDefaultCancel, DistinctDefaultCancel> sub = new DistinctUntilChangedSubscriber<>(\r\n\t\t\t\tnew BaseSubscriber<DistinctDefaultCancel>() {}, Function.identity(), Objects::equals);\r\n\t\tsub.onSubscribe(Operators.emptySubscription());\r\n\t\tsub.onNext(fooRef.getAndSet(null));\r\n\r\n\t\tassertThat(retainedDetector.finalizedCount()).isZero();\r\n\t\tassertThat(retainedDetector.trackedTotal()).isOne();\r\n\r\n\t\tsub.cancel();\r\n\t\tSystem.gc();\r\n\r\n\t\tawait()\r\n\t\t\t\t.atMost(2, TimeUnit.SECONDS)\r\n\t\t\t\t.untilAsserted(() -> assertThat(retainedDetector.finalizedCount()).isOne());\r\n\t}\r\n```\r\n\r\n### Reactor Core version\r\n3.2.8.RELEASE\r\n", "url": "https://github.com/reactor/reactor-core/issues/1647", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-04-04 09:54:47", "closed": "2019-04-05 13:16:52", "commits": {"aa7c383ac56b3019883f7fc918e62bc257ffa648": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "3603a2db418ac6a17a41416429e6705fb5299b00": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "fb740d14f55dfd9b589227dd6488e6067c70ae30": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "aa7c383ac56b3019883f7fc918e62bc257ffa648", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3603a2db418ac6a17a41416429e6705fb5299b00", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["46ea79b121d2809853c5865f06c435dc5181138d"], "nameRev": "3603a2db418ac6a17a41416429e6705fb5299b00 tags/v3.2.9.RELEASE~18", "commitMessage": "fix #1647 Null out lastKey to avoid retaining in distinctUntilChanged\n\nThis includes cancel, complete and error.", "commitDateTime": "2019-04-05 10:22:48", "authoredDateTime": "2019-04-05 10:22:48", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java", "insertions": 176, "deletions": 8, "lines": 184}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java", "insertions": 140, "deletions": 2, "lines": 142}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDistinctUntilChanged.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.cancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.cancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDistinctTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctPredicateThrowsConditional()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctPredicateThrowsConditionalOnNext()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.scanSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.scanConditionalSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCompleteOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCompleteOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedErrorOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedErrorOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCancelOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCancelOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDistinctUntilChangedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.scanSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.scanConditionalSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCompleteOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCompleteOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedErrorOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedErrorOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCancelOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCancelOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "fb740d14f55dfd9b589227dd6488e6067c70ae30", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["3d98ac7b7de096a7a224b64a294448156e6d40aa", "22691ef7f5743a8e38cc58350aee24cdd9292774"], "nameRev": "fb740d14f55dfd9b589227dd6488e6067c70ae30 tags/v3.3.0.M1~38", "commitMessage": "Merge #1643 #1645 #1647 into 3.3\n", "commitDateTime": "2019-04-05 15:16:08", "authoredDateTime": "2019-04-05 15:16:08", "commitGitStats": [{"filePath": "reactor-core/build.gradle", "insertions": 19, "deletions": 4, "lines": 23}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java", "insertions": 176, "deletions": 8, "lines": 184}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java", "insertions": 140, "deletions": 2, "lines": 142}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java", "insertions": 20, "deletions": 14, "lines": 34}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 6, "deletions": 3, "lines": 9}, {"filePath": "reactor-test/build.gradle", "insertions": 20, "deletions": 5, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDistinctUntilChanged.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.cancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.cancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDistinctTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctPredicateThrowsConditional()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctPredicateThrowsConditionalOnNext()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.scanSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.scanConditionalSubscriber()", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCompleteOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCompleteOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedErrorOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedErrorOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCancelOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.doesntRetainObjectsWithForcedCancelOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDistinctUntilChangedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.scanSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.scanConditionalSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCompleteOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCompleteOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedErrorOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedErrorOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCancelOnSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.doesntRetainObjectsWithForcedCancelOnSubscriber_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxSwitchOnFirstTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSwitchOnFirstTest.shouldCancelSourceOnUnrelatedPublisherCompleteConditional()", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSwitchOnFirstTest.shouldCancelSourceOnUnrelatedPublisherErrorConditional()", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSwitchOnFirstTest.shouldCancelSourceOnUnrelatedPublisherCancelConditional()", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testWorkerSchedulePeriodicallyCancelsSchedulerTask()", "TOT": 4, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testDirectScheduleZeroPeriodicallyCancelsSchedulerTask()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3603a2db418ac6a17a41416429e6705fb5299b00"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 8.0, "deletions": 0.0, "lines": 8.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 8.0, "UPD": 0.0, "INS": 8.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 8}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onComplete()", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onComplete()", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedSubscriber.cancel()", "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.cancel()"]}, {"title": "Mono and FluxSink OnCancel are not invoked on eager cancel", "body": "", "url": "https://github.com/reactor/reactor-core/issues/1622", "user": "smaldini", "labels": ["type/bug"], "created": "2019-03-26 06:28:38", "closed": "2019-03-26 12:24:10", "commits": {"de9668acb42c64ba139b347860fd7a0f8b3acbb5": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "4cb8ac3011d86e2e87fcb9d9ac8b240528dd0c33": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "ea80523e9860c7f9c13b2ddcd6b12ab34e36ec8c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "3d2d1c40338926a27f4c58bbe331eac907a7e800": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "611658f7931a72011bc3b1a4478a2098ed2482c6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "de9668acb42c64ba139b347860fd7a0f8b3acbb5", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["28957e4dd10ae84dc146e5382ff16548f0389f0e"], "nameRev": "de9668acb42c64ba139b347860fd7a0f8b3acbb5 tags/v3.2.7.RELEASE~2", "commitMessage": "Fix #1622 Invoke XxxSink#onCancel on eager cancellation\n\n\r\n", "commitDateTime": "2019-03-25 23:29:55", "authoredDateTime": "2019-03-26 08:29:55", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 32, "deletions": 17, "lines": 49}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 4, "deletions": 6, "lines": 10}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java", "insertions": 41, "deletions": 3, "lines": 44}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 26, "deletions": 0, "lines": 26}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.complete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.IgnoreSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.NoOverflowBaseAsyncSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.complete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.disposeResource(boolean)", "TOT": 10, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.isCancelled()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.onDispose(reactor.core.Disposable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.isDisposed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.onCancel(reactor.core.Disposable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onCancel(reactor.core.Disposable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onDispose(reactor.core.Disposable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreateTest.normalBuffered()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.monoFirstCancelThenOnCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.monoFirstCancelThenOnDispose()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.scanBaseSinkTerminated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.scanBaseSink()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.monoFirstCancelThenOnCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.monoFirstCancelThenOnDispose()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4cb8ac3011d86e2e87fcb9d9ac8b240528dd0c33", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["7d112973cf11d376f1e0f2e119c222151a51428c", "de9668acb42c64ba139b347860fd7a0f8b3acbb5"], "nameRev": "4cb8ac3011d86e2e87fcb9d9ac8b240528dd0c33 tags/v3.3.0.M1~46", "commitMessage": "Merge branch '3.2.x' Fix #1622 Invoke XxxSink#onCancel on eager cancellation\n", "commitDateTime": "2019-03-25 23:31:17", "authoredDateTime": "2019-03-25 23:30:37", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 32, "deletions": 17, "lines": 49}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 4, "deletions": 6, "lines": 10}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java", "insertions": 41, "deletions": 3, "lines": 44}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 26, "deletions": 0, "lines": 26}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.complete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.IgnoreSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.NoOverflowBaseAsyncSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.next(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.complete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.disposeResource(boolean)", "TOT": 10, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.isCancelled()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.onDispose(reactor.core.Disposable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.isDisposed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.onCancel(reactor.core.Disposable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onCancel(reactor.core.Disposable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onDispose(reactor.core.Disposable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreateTest.normalBuffered()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.monoFirstCancelThenOnCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.monoFirstCancelThenOnDispose()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.scanBaseSinkTerminated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreateTest.scanBaseSink()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.monoFirstCancelThenOnCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.monoFirstCancelThenOnDispose()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ea80523e9860c7f9c13b2ddcd6b12ab34e36ec8c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3d2d1c40338926a27f4c58bbe331eac907a7e800", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["3383ac1aa9a00c6fbc7eebc72f876b02368a5d25"], "nameRev": "3d2d1c40338926a27f4c58bbe331eac907a7e800 tags/v3.2.8.RELEASE~1", "commitMessage": "fix #1622 regression: MonoCreate now distinguishes CANCEL vs TERMINATED\n\n", "commitDateTime": "2019-03-26 13:19:36", "authoredDateTime": "2019-03-26 13:19:36", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 41, "deletions": 13, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.disposeResource(boolean)", "TOT": 10, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onCancel(reactor.core.Disposable)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onDispose(reactor.core.Disposable)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.isDisposed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.scanDefaultMonoSink()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "611658f7931a72011bc3b1a4478a2098ed2482c6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["c6e95f8cdc7c74e1f63b310c5afd72241de1dc9f", "3d2d1c40338926a27f4c58bbe331eac907a7e800"], "nameRev": "611658f7931a72011bc3b1a4478a2098ed2482c6 tags/v3.3.0.M1~44", "commitMessage": "Merge #1622 second fix into 3.3\n", "commitDateTime": "2019-03-26 13:23:20", "authoredDateTime": "2019-03-26 13:23:20", "commitGitStats": [{"filePath": "README.md", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 41, "deletions": 13, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.disposeResource(boolean)", "TOT": 10, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onCancel(reactor.core.Disposable)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onDispose(reactor.core.Disposable)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoCreate", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.isDisposed()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.scanDefaultMonoSink()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["de9668acb42c64ba139b347860fd7a0f8b3acbb5", "3d2d1c40338926a27f4c58bbe331eac907a7e800"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 2, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 77.0, "deletions": 36.0, "lines": 113.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 79.0, "UPD": 9.0, "INS": 31.0, "MOV": 22.0, "DEL": 17.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 24}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoCreate.DefaultMonoSink.onCancel(reactor.core.Disposable)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.onDispose(reactor.core.Disposable)", "reactor.core.publisher.FluxCreate.BaseSink", "reactor.core.publisher.FluxCreate.IgnoreSink.next(java.lang.Object)", "reactor.core.publisher.FluxCreate.BaseSink.onCancel(reactor.core.Disposable)", "reactor.core.publisher.FluxCreate.SerializedSink.complete()", "reactor.core.publisher.FluxCreate.SerializedSink.next(java.lang.Object)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.isDisposed()", "reactor.core.publisher.FluxCreate.BaseSink.complete()", "reactor.core.publisher.MonoCreate.DefaultMonoSink.disposeResource(boolean)", "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "reactor.core.publisher.MonoCreate", "reactor.core.publisher.MonoCreate.DefaultMonoSink", "reactor.core.publisher.MonoCreate.DefaultMonoSink.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxCreate.BaseSink.isDisposed()", "reactor.core.publisher.MonoCreate.DefaultMonoSink.success()", "reactor.core.publisher.FluxCreate.BaseSink.disposeResource(boolean)", "reactor.core.publisher.FluxCreate.BaseSink.isCancelled()", "reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "reactor.core.publisher.FluxCreate.BaseSink.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxCreate.NoOverflowBaseAsyncSink.next(java.lang.Object)", "reactor.core.publisher.FluxCreate.BaseSink.onDispose(reactor.core.Disposable)"]}, {"title": "onRequest from MonoSink is not triggered", "body": "### Expected behavior\r\nMono exposed via Controller must call MonoSink#onRequest as soon as incoming request hits controller.\r\n\r\n### Actual behavior\r\nAn expected call does not happen, but only for Mono, not for Flux\r\n\r\n### Steps to reproduce\r\nThe test is available here: https://github.com/alexey-anufriev/reactor-monosink-onrequest-bug\r\n\r\n### Reactor Core version\r\n3.2.6.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\"11.0.2\" 2019-01-15 LTS", "url": "https://github.com/reactor/reactor-core/issues/1560", "user": "alexey-anufriev", "labels": ["type/bug"], "created": "2019-03-14 23:09:05", "closed": "2019-03-26 06:05:30", "commits": {"663f6b76a919d446a37e54702e5d3776fec0e217": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "3a89fc66a0f92ade377bc1d64db49c773ad3121d": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "28957e4dd10ae84dc146e5382ff16548f0389f0e": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "74d7dfcfa6ef0fe5ba3ab1b62b1f3698a9a38b7f": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 11.000277777777777, "commitsDetails": [{"commitHash": "663f6b76a919d446a37e54702e5d3776fec0e217", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3a89fc66a0f92ade377bc1d64db49c773ad3121d", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "28957e4dd10ae84dc146e5382ff16548f0389f0e", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["832d870a2ee7b36286750f69719a45245b18f55e"], "nameRev": "28957e4dd10ae84dc146e5382ff16548f0389f0e tags/v3.2.7.RELEASE~3", "commitMessage": "fix #1560 Call MonoSink.onRequest with eager demand\n", "commitDateTime": "2019-03-25 23:07:55", "authoredDateTime": "2019-03-25 23:03:10", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 19, "deletions": 3, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.onRequest(java.util.function.LongConsumer)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSink.java", "spoonMethods": []}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.onRequest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.onRequestDeferred()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "74d7dfcfa6ef0fe5ba3ab1b62b1f3698a9a38b7f", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["28957e4dd10ae84dc146e5382ff16548f0389f0e"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7.0, "deletions": 3.0, "lines": 10.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 2.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoCreate.DefaultMonoSink.onRequest(java.util.function.LongConsumer)"]}, {"title": "Mono#doOnEach doesn't call handler with complete signal during onNext", "body": "### Expected behavior\r\n```java\r\nCopyOnWriteArrayList<String> events = new CopyOnWriteArrayList<>();\r\nMono.just(\"foo\")\r\n    .doOnEach(sig -> events.add(sig.toString()))\r\n    .doOnSuccess(v -> events.add(\"success \" + v))\r\n    .block();\r\nSystem.out.println(events);\r\n```\r\nis expected to print:\r\n```\r\ndoOnEach_onNext(foo)\r\nonComplete()\r\nsuccess foo\r\n```\r\n\r\n### Actual behavior\r\nPrints out of order complete event:\r\n```\r\ndoOnEach_onNext(foo)\r\nsuccess foo\r\nonComplete()\r\n```\r\n\r\n### Analysis\r\n`MonoPeekTerminal` (which backs `doOnSuccess`) calls the onTerminate and onSuccess handlers directly in its `onNext` method *before* forwarding the signal downstream.\r\n\r\n`doOnEach` has no Mono-dedicated implementation, and thus doesn't do that.\r\n\r\nAs a result, when the two are chained, the `MonoTerminalPeekSubscriber` invokes its \"onComplete\" handler(s) before the `DoOnEachSubscriber` does.", "url": "https://github.com/reactor/reactor-core/issues/1547", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-02-27 10:21:50", "closed": "2019-03-04 12:01:07", "commits": {"c8d4a91f4aff235da17c9be8b1478bb31eb47f4f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d181d2ef129ca45590b28532ba90be21187c1385": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "70699712abbfd70e16dbbea62cbea59c43b056a7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e9ec79265e8ccd8ae758ff20b837259e83891b13": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "c8d4a91f4aff235da17c9be8b1478bb31eb47f4f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d181d2ef129ca45590b28532ba90be21187c1385", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0bfa6ee8be869f1fc3ca37262db186442137d9b9"], "nameRev": "d181d2ef129ca45590b28532ba90be21187c1385 tags/v3.1.16.RELEASE~5", "commitMessage": "fix #1547 Eagerly invoke Mono#doOnEach handler(complete) during onNext\n\nThis commit aligns Mono's doOnEach with eg. doOnSuccess\r\n(MonoPeekTerminal) regarding the eager invocation of the handler with\r\nan onComplete Signal whenever onNext is received.\r\n\r\nAs a result, putting doOnEach before doOnSuccess in a chain won't give\r\nout of order invocations anymore.", "commitDateTime": "2019-03-04 11:13:45", "authoredDateTime": "2019-03-04 11:13:45", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java", "insertions": 47, "deletions": 24, "lines": 71}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java", "insertions": 144, "deletions": 0, "lines": 144}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber", "TOT": 8, "UPD": 2, "INS": 6, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onError(java.lang.Throwable)", "TOT": 9, "UPD": 1, "INS": 4, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onComplete()", "TOT": 16, "UPD": 2, "INS": 6, "MOV": 4, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEach.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.scanSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNextFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorDuringCompleteSignalInMonoOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorDuringCompleteSignalInMonoOnNextFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.monoOnNextDoesntTriggerCompleteTwice()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.monoOnNextDoesntTriggerCompleteTwiceFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.testDoOnEachSignal()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "70699712abbfd70e16dbbea62cbea59c43b056a7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["d181d2ef129ca45590b28532ba90be21187c1385"], "nameRev": "70699712abbfd70e16dbbea62cbea59c43b056a7 tags/v3.1.16.RELEASE~4", "commitMessage": "fix #1547 regression: call doOnEach handler with error if complete fails\n", "commitDateTime": "2019-03-04 12:46:25", "authoredDateTime": "2019-03-04 12:46:25", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java", "insertions": 10, "deletions": 3, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java", "insertions": 42, "deletions": 1, "lines": 43}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onComplete()", "TOT": 7, "UPD": 2, "INS": 2, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.completeCallbackError()", "TOT": 16, "UPD": 8, "INS": 4, "MOV": 3, "DEL": 1}]}, {"spoonFilePath": "MonoDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorInCompleteHandlingTriggersErrorHandling()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorInCompleteHandlingTriggersErrorHandlingFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "e9ec79265e8ccd8ae758ff20b837259e83891b13", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a0c2a36ef5f83b6f1a33034ea41f5af4bbcbe974", "70699712abbfd70e16dbbea62cbea59c43b056a7"], "nameRev": "e9ec79265e8ccd8ae758ff20b837259e83891b13 tags/v3.2.7.RELEASE~9", "commitMessage": "Merge #1547 into 3.2.x\n\n(includes fixup of regression from 70699712)\n", "commitDateTime": "2019-03-04 12:58:31", "authoredDateTime": "2019-03-04 12:58:31", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java", "insertions": 62, "deletions": 36, "lines": 98}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEachFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEachFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java", "insertions": 14, "deletions": 7, "lines": 21}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java", "insertions": 240, "deletions": 1, "lines": 241}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber", "TOT": 8, "UPD": 2, "INS": 6, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.createSubscriber(reactor.core.CoreSubscriber,java.util.function.Consumer,boolean)", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachFuseableConditionalSubscriber", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onError(java.lang.Throwable)", "TOT": 9, "UPD": 1, "INS": 4, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onComplete()", "TOT": 11, "UPD": 2, "INS": 4, "MOV": 2, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachFuseableSubscriber.poll()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onNext(java.lang.Object)", "TOT": 5, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.createSubscriber(reactor.core.CoreSubscriber,java.util.function.Consumer,boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachFuseableSubscriber", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachConditionalSubscriber", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDoOnEachFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachFuseable.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEach.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDoOnEachFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEachFuseable.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.completeCallbackError(reactor.core.publisher.Flux)", "TOT": 16, "UPD": 8, "INS": 4, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.conditionalTryOnNext()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.conditionalFuseableTryOnNext()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.scanSubscriber()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNextFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNextConditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.triggersCompleteSignalInMonoOnNextConditionalFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorDuringCompleteSignalInMonoOnNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorDuringCompleteSignalInMonoOnNextFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.monoOnNextDoesntTriggerCompleteTwice()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.monoOnNextDoesntTriggerCompleteTwiceFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorInCompleteHandlingTriggersErrorHandling()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDoOnEachTest.errorInCompleteHandlingTriggersErrorHandlingFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.testDoOnEachSignal()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d181d2ef129ca45590b28532ba90be21187c1385", "70699712abbfd70e16dbbea62cbea59c43b056a7"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 52.0, "deletions": 29.0, "lines": 81.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 50.0, "UPD": 8.0, "INS": 23.0, "MOV": 9.0, "DEL": 10.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 7}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onComplete()", "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxDoOnEach.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber", "reactor.core.publisher.MonoDoOnEach.subscribe(reactor.core.CoreSubscriber)"]}, {"title": "Avoid self-suppression in Flux#onErrorContinue", "body": "More specifically, the built in `OnNextFailureStrategy` implementations should avoid adding  a suppressed exception to itself.", "url": "https://github.com/reactor/reactor-core/issues/1535", "user": "simonbasle", "labels": ["type/bug"], "created": "2019-02-21 09:18:43", "closed": "2019-02-21 14:49:45", "commits": {"c627e9f81a70850e711deb80ff40aa1e0d3eb771": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "47a716707cf7775d7b0b2bfafb3743c00abaaaef": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "c627e9f81a70850e711deb80ff40aa1e0d3eb771", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "47a716707cf7775d7b0b2bfafb3743c00abaaaef", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["aec13da69deb156f29c59d93981c15a019b8d545"], "nameRev": "47a716707cf7775d7b0b2bfafb3743c00abaaaef tags/v3.2.7.RELEASE~12", "commitMessage": "fix #1535 Avoid self-suppression in onErrorContinue underlying handlers\n\nThis commit modifies the OnNextFailureStrategy implementations that\nwould add a suppressed exception to use the Exceptions util, which\nguards against self-suppression.\n", "commitDateTime": "2019-02-21 15:49:40", "authoredDateTime": "2019-02-21 10:48:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/OnNextFailureStrategy.java", "insertions": 2, "deletions": 4, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OnNextFailureStrategyTest.java", "insertions": 59, "deletions": 0, "lines": 59}], "commitSpoonAstDiffStats": [{"spoonFilePath": "OnNextFailureStrategy.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ResumeStrategy.process(java.lang.Throwable,java.lang.Object,reactor.util.context.Context)", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.ResumeDropStrategy.process(java.lang.Throwable,java.lang.Object,reactor.util.context.Context)", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "OnNextFailureStrategyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OnNextFailureStrategyTest.resumeDropDoesntSelfSuppressIfHookRethrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.OnNextFailureStrategyTest.resumeIfDoesntSelfSuppress()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["47a716707cf7775d7b0b2bfafb3743c00abaaaef"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 4.0, "lines": 6.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 10.0, "UPD": 0.0, "INS": 2.0, "MOV": 4.0, "DEL": 4.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.ResumeStrategy.process(java.lang.Throwable,java.lang.Object,reactor.util.context.Context)", "reactor.core.publisher.ResumeDropStrategy.process(java.lang.Throwable,java.lang.Object,reactor.util.context.Context)"]}, {"title": "Flux.bufferTimeout : Does this method produce duplicate data to subscriber ?", "body": "I did a test. and subscriber received  duplicate data. Is this normal behavior?\r\n```\r\n@Test\r\n    public void test1() throws InterruptedException {\r\n        HashSet<Long> hashSet = new HashSet<>();\r\n        Flux.interval(Duration.ofMillis(2)).bufferTimeout(2, Duration.ofMillis(2)).subscribe(\r\n                values -> {\r\n                    System.out.println(values);\r\n                    values.forEach(aLong -> {\r\n                        Assert.assertTrue(\"error:\"+aLong,hashSet.add(aLong));\r\n                    });\r\n                }\r\n        );\r\n        Thread.sleep(10000);\r\n\r\n    }\r\n```\r\noutput\r\n```\r\n[1951, 1952]\r\n[1953, 1954]\r\n[1955, 1956]\r\n[1955, 1956]\r\n16:47:46.064 [parallel-1] ERROR reactor.core.scheduler.Schedulers - Scheduler worker in group main failed with an uncaught exception\r\nreactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.AssertionError: error:1955\r\nCaused by: java.lang.AssertionError: error:1955\r\n```\r\nThere has two same array\r\n", "url": "https://github.com/reactor/reactor-core/issues/1532", "user": "yuncheolkim", "labels": ["type/bug"], "created": "2019-02-19 09:19:37", "closed": "2019-02-21 11:59:58", "commits": {"33f2b4ee296ed86968d9dd42be5635e86134b27f": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "236eee4c45a0194762e8e71970ac42c05c950c01": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "0bfa6ee8be869f1fc3ca37262db186442137d9b9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "aec13da69deb156f29c59d93981c15a019b8d545": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "33f2b4ee296ed86968d9dd42be5635e86134b27f", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "236eee4c45a0194762e8e71970ac42c05c950c01", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0bfa6ee8be869f1fc3ca37262db186442137d9b9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["e9c04b5608eaf7bb421ddc40f3db9a5ece49cd96"], "nameRev": "0bfa6ee8be869f1fc3ca37262db186442137d9b9 tags/v3.1.16.RELEASE~6", "commitMessage": "Fix a race in FluxBufferTimeout on flush. (#1534)\n\nOn flush, values must be accessed inside a `synchronized` block to\r\navoid a race condition when `nextCallback` modifies the collection.\r\n\r\nThis makes it consistent with the rest of access to the variable.\r\nOther operators do the same.\r\n\r\nFixes #1532.\r\n", "commitDateTime": "2019-02-21 11:16:28", "authoredDateTime": "2019-02-21 11:16:28", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java", "insertions": 37, "deletions": 0, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.flushCallback(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.tearDown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.flushShouldNotRaceWithNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "aec13da69deb156f29c59d93981c15a019b8d545", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["115f3f6f069e51ce11edc6205c4d578015fea977", "0bfa6ee8be869f1fc3ca37262db186442137d9b9"], "nameRev": "aec13da69deb156f29c59d93981c15a019b8d545 tags/v3.2.7.RELEASE~13", "commitMessage": "Merge #1532 / #1534 into 3.2\n", "commitDateTime": "2019-02-21 12:56:05", "authoredDateTime": "2019-02-21 12:56:05", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java", "insertions": 37, "deletions": 3, "lines": 40}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.flushCallback(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.tearDown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.flushShouldNotRaceWithNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "StepVerifier.expectRecordedMatches(...) causes verify to block forever if you consume the capacity of the underlying flux", "body": "### Expected behavior\r\n\r\nThe following `StepVerifier` should work independently of how many elements one consumes in the `.thenConsumeWhile(...)` step (as long as there's an element in the provided flux that causes the condition passed to `.thenConsumeWhile(...)` to return false).\r\n\r\n    int CAPACITY = ...;\r\n    int end = ...;\r\n    List<Integer> expected = IntStream.range(0, end).boxed().collect(Collectors.toList());\r\n\r\n    ReplayProcessor<Integer> flux = ReplayProcessor.create(CAPACITY);\r\n\r\n    for (int i = 0; i < CAPACITY; i++) flux.onNext(i);\r\n\r\n    StepVerifier.create(flux)\r\n            .recordWith(ArrayList::new)\r\n            .thenConsumeWhile(i -> i < (end - 1))\r\n            .expectRecordedMatches(expected::equals)\r\n            .thenCancel()\r\n            .verify();\r\n\r\n### Actual behavior\r\n\r\nEverything works fine if the `thenConsumeWhile` condition causes you to consume fewer elements than are available in the underlying flux, however if you consume _exactly_ the number of elements that are available then the `expectRecordedMatches` step executes but the `verify` step blocks forever.\r\n\r\n### Steps to reproduce\r\n\r\nDefine `CAPACITY` above as a constant, e.g. 100, and create a function that takes `end` as an argument and contains the above `StepVerifier` sequence, then create two unit tests - one that calls the function like so:\r\n\r\n    myStepVerifierFunction(CAPACITY - 1); // Record CAPACITY - 1 elements.\r\n\r\nAnd another one that calls it with:\r\n\r\n    myStepVerifierFunction(CAPACITY); // Record exactly CAPACITY elements.\r\n\r\nI've created a GitHub repo that does this - see [`RecordTest`](https://github.com/george-hawkins/publish-cancel-test/blob/master/src/test/java/com/example/RecordTest.java). \r\n\r\nIn my code, I've added a `System.err.println` call into the `expectRecordedMatches` step, so you can see there's no problem with this aspect of things - in both tests the `expectRecordedMatches` step executes and returns true. But in the test where we record exactly `CAPACITY` elements the `verify` blocks forever, and in the one where we record less than `CAPACITY` elements there's no issue.\r\n\r\nI've also added an additional test where I consume `CAPACITY` elements from the flux _but_ miss out the `expectRecordedMatches` step. In this case, the `verify` does _not_ block, so it seems it's a side effect of this `expectRecordedMatches` step that causes the issue.\r\n\r\n### Reactor Core version\r\n\r\n3.2.5.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```\r\nopenjdk version \"11\" 2018-09-25\r\nOpenJDK Runtime Environment 18.9 (build 11+28)\r\nOpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)\r\n```", "url": "https://github.com/reactor/reactor-core/issues/1529", "user": "george-hawkins", "labels": ["type/bug"], "created": "2019-02-15 13:00:02", "closed": "2019-03-27 14:43:37", "commits": {"429bf7e7f3ea9153c7567fee1adf06a85036e28f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 40.000277777777775, "commitsDetails": [{"commitHash": "429bf7e7f3ea9153c7567fee1adf06a85036e28f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["e8c8a1cde3dbb96dab84135a16b62fe74fd25c49"], "nameRev": "429bf7e7f3ea9153c7567fee1adf06a85036e28f tags/v3.3.0.M1~42", "commitMessage": "fix #1529 Prevent StepVerifier collect hang when consuming all signals\n\nFix has also been tested against test [RecordTest](https://github.com/george-hawkins/publish-cancel-test/blob/master/src/test/java/com/example/RecordTest.java) provided by the issue author.\r\n\r\nEverything worked fine if publisher ended with `onComplete` signal.\r\nWithout `onComplete` ,  `completeLatch` was never decremented and as a result \r\nverify step blocked forever.\r\n\r\n\r\n", "commitDateTime": "2019-03-27 15:43:35", "authoredDateTime": "2019-03-27 15:43:35", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 45, "deletions": 1, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onCollect(reactor.core.publisher.Signal)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.parallelVerifyWithVtsMutuallyExclusive()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.testExpectRecordedMatches()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.testExpectRecordedMatchesTwice()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.testExpectRecordedMatchesWithoutComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["429bf7e7f3ea9153c7567fee1adf06a85036e28f"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": ["reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onCollect(reactor.core.publisher.Signal)"]}, {"title": "StepVerifier fails to cancel ConnectableFlux with autoConnect and blocks forever", "body": "### Expected behavior\r\n\r\nThe following `StepVerifier` sequence should work independently of whether the provided flux is a basic flux or a connectable flux with auto-connect enabled.\r\n\r\n    StepVerifier.create(flux)\r\n            .thenConsumeWhile(i -> i < 10)\r\n            .thenCancel()\r\n            .verify();\r\n\r\n### Actual behavior\r\n\r\nThe above `StepVerifier` sequence completes without problem for a basic flux like this:\r\n\r\n    Flux.fromStream(Stream.iterate(0, i -> i + 1))\r\n\r\nHowever it does not work for a connectable flux created from the one above by calling `.publish().autoConnect()`, the `.verify()` just blocks forever.\r\n\r\n### Steps to reproduce\r\n\r\nCreate a function that takes a flux as an argument and contains the above `StepVerifier` sequence, then create two unit tests - one that calls the function with:\r\n\r\n    Flux.fromStream(Stream.iterate(0, i -> i + 1))\r\n\r\nAnd another one that calls it with:\r\n\r\n    Flux.fromStream(Stream.iterate(0, i -> i + 1)).publish().autoConnect();\r\n\r\nI've created a GitHub repo that does this - see [`PublishCancelTest`](https://github.com/george-hawkins/publish-cancel-test/blob/master/src/test/java/com/example/PublishCancelTest.java).\r\n\r\nIn my code, I've added a `System.err.println` call into the `thenConsumeWhile` step, so you can see there's no problem with this aspect of things - in all tests the expected elements are seen and consumed.\r\n\r\nI've also added two additional tests where, instead of creating the basic flux from a stream, it's instead created using `ReplayProcessor`. In this situation, the `StepVerifier` sequence works fine for both the basic scenario and the one where `.publish().autoConnect()` is used to derive a connectable flux.\r\n\r\nSo in addition to the issue outlined above, the question is also why should it make a difference if the underlying flux is derived from a stream, as shown above, or created using `ReplayProcessor`?\r\n\r\n### Reactor Core version\r\n\r\n3.2.5.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```\r\nopenjdk version \"11\" 2018-09-25\r\nOpenJDK Runtime Environment 18.9 (build 11+28)\r\nOpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)\r\n```", "url": "https://github.com/reactor/reactor-core/issues/1528", "user": "george-hawkins", "labels": ["type/bug"], "created": "2019-02-15 10:55:34", "closed": "2019-04-01 07:24:37", "commits": {"1991ab6464cd54bec41ae54a246e9ed631a0efca": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0241811b1174769c3e1e706e190e447b7a967a7c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "ca2549be24a1ff20e252e4e3a8a845a57cefb6e8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5068e9d2b3b11ac45627f9d2215ed5833931f533": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ac28cdd8ff9046153adabc2fd2a24306516b4884": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 44.000277777777775, "commitsDetails": [{"commitHash": "1991ab6464cd54bec41ae54a246e9ed631a0efca", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0241811b1174769c3e1e706e190e447b7a967a7c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["573e9d962f2fb32421d6b4b8e2dcfb323e349bc1"], "nameRev": "0241811b1174769c3e1e706e190e447b7a967a7c tags/v3.2.9.RELEASE~20", "commitMessage": "fix #1528 Potential infinite loop when cancelling SYNC-fused FluxPublish\n\nThis commit fixes a missing exit condition in Flux.publish drain loop\r\nwhen the subscribers have been cancelled with a fusion sourceMode of\r\nSYNC.\r\n\r\nAdditionally, a `checkTerminated` call in the drain loop is made to\r\ncorrectly check the `empty` state instead of assuming it is empty.", "commitDateTime": "2019-04-01 09:22:55", "authoredDateTime": "2019-04-01 09:22:55", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 29, "deletions": 0, "lines": 29}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 32, "deletions": 6, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ca2549be24a1ff20e252e4e3a8a845a57cefb6e8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["98bda90b359393d4dab43c4d0bc407aac816965b", "0241811b1174769c3e1e706e190e447b7a967a7c"], "nameRev": "ca2549be24a1ff20e252e4e3a8a845a57cefb6e8 tags/v3.3.0.M1~40", "commitMessage": "Merge #1528 into 3.3\n", "commitDateTime": "2019-04-01 09:24:17", "authoredDateTime": "2019-04-01 09:24:17", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 29, "deletions": 0, "lines": 29}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 32, "deletions": 6, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "5068e9d2b3b11ac45627f9d2215ed5833931f533", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ac28cdd8ff9046153adabc2fd2a24306516b4884", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["2ce7b75ff95a21aa5151ffd9cf93d3a7995d9eee"], "nameRev": "ac28cdd8ff9046153adabc2fd2a24306516b4884 tags/v3.2.10.RELEASE~12", "commitMessage": "fix #1712 Flux.publish().autoConnect(0) should drop early items\n\nThis is linked to #1528, the previous fix having introduced a regression\nwhere early connection without subscribers is not handled correctly and\naccumulates received items instead of \"dropping\" them.\n\nThis is because, unlike EmitterProcessor, FluxPublish should distinguish\ninitial connection with empty subscribers array vs empty subscribers\narray that is due to removing the last inner (ie. cancelling).\n\nThis commit also ensures that disconnectAction, which is synonymous to\ncancellation, sets the subscribers array to CANCELLED, not INIT.\n", "commitDateTime": "2019-05-22 11:47:56", "authoredDateTime": "2019-05-21 17:44:59", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 15, "deletions": 8, "lines": 23}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 39, "deletions": 2, "lines": 41}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.remove(reactor.core.publisher.FluxPublish$PubSubInner)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfConnectImmediately()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.dataDroppedIfAutoconnectZero()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionFromInfiniteStreamAndTake()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0241811b1174769c3e1e706e190e447b7a967a7c"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5.0, "deletions": 4.0, "lines": 9.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 7.0, "UPD": 0.0, "INS": 3.0, "MOV": 2.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublish.PublishSubscriber.drain()"]}, {"title": "Ensure atomic cleanup in Flux/Mono.usingWhen(\u2026)", "body": "### Expected behavior\r\nCleanup functions should be called only once.\r\n\r\n### Actual behavior\r\nCleanup close can be called multiple times if a subscription terminates and then gets cancelled.\r\n\r\n### Steps to reproduce\r\n\r\n```java\r\nPublisher<Void> cleanup = \u2026,\r\nFlux flux = Flux.usingWhen(\u2026, cleanup, cleanup, cleanup);\r\n\r\nflux.subscribe(new CoreSubscriber<Object>() {\r\n\tSubscription subscription;\r\n\r\n\t@Override\r\n\tpublic void onSubscribe(Subscription s) {\r\n\t\ts.request(1);\r\n\t\tsubscription = s;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onNext(Object o) {}\r\n\r\n\t@Override\r\n\tpublic void onError(Throwable t) {}\r\n\r\n\t@Override\r\n\tpublic void onComplete() {\r\n\t\tsubscription.cancel();\r\n\t}\r\n});\r\n```\r\n\r\n### Reactor Core version\r\n\r\nReactor 3.2.5\r\n", "url": "https://github.com/reactor/reactor-core/issues/1486", "user": "mp911de", "labels": ["type/bug"], "created": "2019-01-11 09:23:58", "closed": "2019-01-14 18:21:13", "commits": {"c3ce472e8a071b63276fa595219b3f7180eb1bd4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "42db2f7a36daf7e70502824b481abc96fb9f353e": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5ae36a0a336666ee07f9c726a900a5eabcdd3bc0": {"commitGHEventType": "referenced", "commitUser": "bsideup"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "c3ce472e8a071b63276fa595219b3f7180eb1bd4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "42db2f7a36daf7e70502824b481abc96fb9f353e", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a2929c99b883c4004d467ed8f61be69bff70c52d"], "nameRev": "42db2f7a36daf7e70502824b481abc96fb9f353e tags/v3.2.6.RELEASE~26", "commitMessage": "fix #1486 Prevent usingWhen terminal & cancel callbacks to both apply (#1487)\n\nThis commit prevents asyncComplete/asyncError terminal callbacks to\r\napply in addition to asyncCancel, in case one signal is still received\r\nafter the other (eg. a cancellation is performed asynchronously,\r\nresulting in the signal arriving AFTER the onError/onComplete signals).", "commitDateTime": "2019-01-14 19:21:09", "authoredDateTime": "2019-01-14 19:21:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxUsingWhen.java", "insertions": 44, "deletions": 34, "lines": 78}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java", "insertions": 178, "deletions": 1, "lines": 179}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxUsingWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxUsingWhen.UsingWhenSubscriber", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhen.UsingWhenSubscriber.cancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhen.UsingWhenSubscriber.onError(java.lang.Throwable)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhen.UsingWhenSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 0}]}, {"spoonFilePath": "FluxUsingWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxUsingWhenTest.noCancelCallbackAfterComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhenTest.noCancelCallbackAfterError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhenTest.noCompleteCallbackAfterCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsingWhenTest.noErrorCallbackAfterCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "5ae36a0a336666ee07f9c726a900a5eabcdd3bc0", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "windowWhile not propagating cancel signal", "body": "### Expected behavior\r\n\r\n`windowWhile` should propagate cancel signal when subscriptions to the inner window and outer Flux is cancelled.\r\n\r\n### Actual behavior\r\n\r\nCancel signal is not propagated when subscriptions to the inner window and outer Flux is cancelled when the current active window is a deffered window. This is a behaviour change made in 3.2.0 (https://github.com/reactor/reactor-core/issues/1033), this works as expected in 3.1.12.\r\n\r\n### Steps to reproduce\r\n\r\n```java\r\n        final EmitterProcessor<String> processor = EmitterProcessor.create();\r\n        final FluxSink<String> sink = processor.sink();\r\n\r\n        sink.next(\"0\").next(\"#\");\r\n\r\n        final Disposable disposable = processor\r\n                .windowWhile(next -> !\"#\".equals(next))\r\n                .as(Flux::concat)\r\n                .subscribe();\r\n\r\n        disposable.dispose();\r\n\r\n        assert sink.isCancelled();\r\n```\r\n\r\n### Reactor Core version\r\n3.2.3\r\n\r\n### JVM version (e.g. `java -version`)\r\n```\r\nopenjdk version \"11.0.1\" 2018-10-16\r\nOpenJDK Runtime Environment 18.9 (build 11.0.1+13)\r\nOpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode)\r\n```", "url": "https://github.com/reactor/reactor-core/issues/1452", "user": "devstdout", "labels": ["type/bug"], "created": "2018-11-30 12:41:48", "closed": "2019-02-04 09:32:28", "commits": {"50e1cfabfde8931bdad697da78031480aacce857": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ee37379a6efcc91f3735441becc88a5e83203780": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 65.00027777777778, "commitsDetails": [{"commitHash": "50e1cfabfde8931bdad697da78031480aacce857", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ee37379a6efcc91f3735441becc88a5e83203780", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0567900603a143e2df7ff579a0efc98cfc0e17d3"], "nameRev": "ee37379a6efcc91f3735441becc88a5e83203780 tags/v3.2.6.RELEASE~21", "commitMessage": "fix #1452 Ensure proper cancellation of windowWhile/windowUntil\n\nThis commit fixes cancellation of FluxWindowPredicate when the inners\r\n(windows) and outer sequence are cancelled at different stages:\r\n\r\n - when a window is \"in-flight\" as the outer sequence is cancelled,\r\n  the source cancellation is deferred. When window completes, then the\r\n  source is cancelled. This commit also takes the case of\r\n  manually cancelling an infinite window (after the outer) into account.\r\n - in some cases when encountering a splitter element, a new Window is\r\n  prepared but not emitted to the user. When the main sequence is\r\n  cancelled, this pending window would previously not be cancelled,\r\n  which prevented source cancellation. This is now fixed.\r\n\r\nThe first part of the fix is implemented by adding a third state to the\r\nCANCELLED flag, for when the outer has been cancelled but not the inner.", "commitDateTime": "2019-02-04 10:32:25", "authoredDateTime": "2019-02-04 10:32:25", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java", "insertions": 19, "deletions": 0, "lines": 19}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 103, "deletions": 0, "lines": 103}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxWindowPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.cancel()", "TOT": 5, "UPD": 0, "INS": 5, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWindowPredicateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.signalErrorMessage(java.lang.String)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhilePropagatingCancelToSource_disposeOuterFirst()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileNotPropagatingCancelToSource_disposeInnerFirst()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileNotPropagatingCancelToSource_withConcat()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ee37379a6efcc91f3735441becc88a5e83203780"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 19.0, "deletions": 0.0, "lines": 19.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 0.0, "INS": 5.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.cancel()"]}, {"title": "Reactor metrics incompatible with Prometheus export", "body": "### Expected behavior\r\nMetrics generated by reactor support exporting using Prometheus aka `io.micrometer:micrometer-registry-prometheus`.\r\n\r\n### Actual behavior\r\n`PrometheusMeterRegistry` throws an exception for metric with name `reactor.flow.duration` (maybe others as well?):\r\n\r\n```\r\njava.lang.IllegalArgumentException: Prometheus requires that all meters with the same name have the same set of tag keys. There is already an existing meter containing tag keys [exception, flow, owner, service, status, type]. The meter you are attempting to register has keys [flow, owner, service, status, type].\r\n```\r\n\r\n### Steps to reproduce\r\n\r\n\r\n### Reactor Core version\r\n`3.2.2.RELEASE`\r\n\r\n### JVM version (e.g. `java -version`)\r\n`jdk1.8.0_181`\r\n\r\n### Workaround\r\nUse `MeterFilter.map` to remap `Meter.Id` with name `reactor.flow.duration` and missing tag `exception` and add empty tag `exception` (`exception=''`).\r\n\r\n### Possible solution\r\nAs per [this comment](https://github.com/micrometer-metrics/micrometer/issues/266#issuecomment-349227368) an empty tag `exception` could be added to non-error cases of the metric.", "url": "https://github.com/reactor/reactor-core/issues/1425", "user": "jrehwaldt", "labels": ["type/bug"], "created": "2018-11-07 10:39:04", "closed": "2018-11-09 10:16:16", "commits": {"70c9888fede3652bf0ce4e254cdba71249ba971b": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "5a5252c83c2ee0b73df361262ef4c95ce64b5279": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "70c9888fede3652bf0ce4e254cdba71249ba971b", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5a5252c83c2ee0b73df361262ef4c95ce64b5279", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f03d2d92ed558a7de2d181b05b374a6cd4d0f353"], "nameRev": "5a5252c83c2ee0b73df361262ef4c95ce64b5279 tags/v3.2.3.RELEASE~14", "commitMessage": "fix #1425 Ensure METER_FLOW_DURATION always have exception tag\n\nThis is needed by exporters like Prometheus which require an uniform\r\ntag key space per meter.\r\n\r\nThis commit also moved tag management to one place by use of a Function\r\nwhich removes the need to keep a reference to the `registry`.", "commitDateTime": "2018-11-09 11:16:13", "authoredDateTime": "2018-11-09 11:16:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java", "insertions": 14, "deletions": 12, "lines": 26}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java", "insertions": 13, "deletions": 11, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxMetricsTest.java", "insertions": 31, "deletions": 1, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoMetricsTest.java", "insertions": 30, "deletions": 0, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber", "TOT": 22, "UPD": 9, "INS": 5, "MOV": 4, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsFuseableSubscriber.poll()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber", "TOT": 23, "UPD": 9, "INS": 5, "MOV": 5, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber.onError(java.lang.Throwable)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsFuseableSubscriber.poll()", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "FluxMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMetricsTest.flowDurationTagsConsistency()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoMetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetricsTest.flowDurationTagsConsistency()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5a5252c83c2ee0b73df361262ef4c95ce64b5279"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 27.0, "deletions": 23.0, "lines": 50.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 69.0, "UPD": 24.0, "INS": 14.0, "MOV": 19.0, "DEL": 12.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 8}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsFuseableSubscriber.poll()", "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsFuseableSubscriber.poll()", "reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsSubscriber", "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber", "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxMetrics.MicrometerFluxMetricsSubscriber.onError(java.lang.Throwable)"]}, {"title": "Context is not propagated in Junit5 nested class", "body": "### Expected behavior\r\nBoth tests pass\r\n\r\n### Actual behavior\r\nOnly test in main class pass\r\n\r\n### Steps to reproduce\r\nRun the test:\r\n```\r\n@ExtendWith(SpringExtension.class)\r\n@TestExecutionListeners(MockitoTestExecutionListener.class)\r\nclass ContextTest {\r\n\r\n    @Nested\r\n    class Nest {\r\n\r\n        @Test\r\n        void testContext() {\r\n          StepVerifier.create(Mono.just(1).map(i -> i + 10),\r\n          StepVerifierOptions.create().withInitialContext(Context.of(\"foo\", \"bar\")))\r\n              .expectAccessibleContext()\r\n              .contains(\"foo\", \"bar\")\r\n              .then()\r\n              .expectNext(11)\r\n              .verifyComplete();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void testContext() {\r\n      StepVerifier.create(Mono.just(1).map(i -> i + 10),\r\n      StepVerifierOptions.create().withInitialContext(Context.of(\"foo\", \"bar\")))\r\n          .expectAccessibleContext()\r\n          .contains(\"foo\", \"bar\")\r\n          .then()\r\n          .expectNext(11)\r\n          .verifyComplete();\r\n    }\r\n}\r\n```\r\n\r\n### Reactor Core version\r\n`3.2.0.RELEASE`\r\n\r\n### JVM version (e.g. `java -version`)\r\n`9.0.4`", "url": "https://github.com/reactor/reactor-core/issues/1417", "user": "eximius313", "labels": ["status/need-investigation", "type/bug"], "created": "2018-10-31 16:11:20", "closed": "2018-11-14 09:17:55", "commits": {"aae2336853d10733fe3400614adc42b291609c46": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "4a769d432e3d0da8d3dcb30dce8919e5bb66b8ab": {"commitGHEventType": "referenced", "commitUser": "bsideup"}, "f9f7ab679d41b517ab77fbf9104b96ddd24f618f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "4008820c6a124d5bd05905557f13ae7e74bea7b1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 13.000277777777777, "commitsDetails": [{"commitHash": "aae2336853d10733fe3400614adc42b291609c46", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "4a769d432e3d0da8d3dcb30dce8919e5bb66b8ab", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f9f7ab679d41b517ab77fbf9104b96ddd24f618f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["54445c8c2df8a6029a5262c78a79448b949efb13"], "nameRev": "f9f7ab679d41b517ab77fbf9104b96ddd24f618f tags/v3.1.12.RELEASE~2", "commitMessage": "fix #1417 Make `expectAccessibleContext` work with `initialContext` from `StepVerifier`\n\nImprove the context detection algorithm in `StepVerifier.then`:\r\n- Start scanning parents from lowest subscription instead of actual\r\n- Handle `ScalaSubscription` or similar sources", "commitDateTime": "2018-11-14 08:48:37", "authoredDateTime": "2018-11-14 08:48:37", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/ContextTests.java", "insertions": 41, "deletions": 0, "lines": 41}, {"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 19, "deletions": 3, "lines": 22}, {"filePath": "reactor-test/src/test/java/reactor/test/DefaultContextExpectationsTest.java", "insertions": 20, "deletions": 2, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ContextTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ContextTests.expectAccessibleContextWithInitialContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextAccessibleWithEmptySubscriptionAndOperator1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextAccessibleWithEmptySubscriptionAndOperator2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextNotAccessibleWithEmptySubscriptionOnly()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultContextExpectations.then()", "TOT": 5, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "DefaultContextExpectationsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultContextExpectationsTest.notContextAccessible()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4008820c6a124d5bd05905557f13ae7e74bea7b1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["cd5999aa5c97ebcae5b2389da859d37843792414", "f9f7ab679d41b517ab77fbf9104b96ddd24f618f"], "nameRev": "4008820c6a124d5bd05905557f13ae7e74bea7b1 tags/v3.2.3.RELEASE~9", "commitMessage": "Adapt #1417 into 3.2\n", "commitDateTime": "2018-11-14 10:17:48", "authoredDateTime": "2018-11-14 10:17:48", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/ContextTests.java", "insertions": 41, "deletions": 0, "lines": 41}, {"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 19, "deletions": 3, "lines": 22}, {"filePath": "reactor-test/src/test/java/reactor/test/DefaultContextExpectationsTest.java", "insertions": 20, "deletions": 2, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ContextTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ContextTests.expectAccessibleContextWithInitialContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextAccessibleWithEmptySubscriptionAndOperator1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextAccessibleWithEmptySubscriptionAndOperator2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.contextNotAccessibleWithEmptySubscriptionOnly()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultContextExpectations.then()", "TOT": 5, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "DefaultContextExpectationsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultContextExpectationsTest.notContextAccessible()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f9f7ab679d41b517ab77fbf9104b96ddd24f618f"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 19.0, "deletions": 3.0, "lines": 22.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 2.0, "INS": 1.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": ["reactor.test.DefaultStepVerifierBuilder.DefaultContextExpectations.then()"]}, {"title": "NullPointerException in format method of console/jdk loggers", "body": "### Expected behavior\r\nLogging a message using a format with 2 placeholders should work.\r\n\r\n### Actual behavior\r\nLogging a message using a format with 2 placeholders and at least one null value (or an equivalent, as long as the vararg is interpreted as a null-containing array) produces an NPE.\r\n\r\n### Steps to reproduce\r\n```\r\nLoggers.useConsoleLoggers();\r\nLogger l = Loggers.getLogger(\"test\");\r\nl.info(\"test {} is {}\", null, null);\r\n```\r\n\r\n### Reactor Core version\r\n3.1.10.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1403", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-10-22 15:19:36", "closed": "2018-10-22 17:45:14", "commits": {"7cdb75f6931336f0791cd7a851449c2575348c5f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f975e77a55c14eb321177527b9fad294ab6a5485": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "4e6a58a5e9fca3b7e5afbe9cbd4f001ac059c2e5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "7cdb75f6931336f0791cd7a851449c2575348c5f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f975e77a55c14eb321177527b9fad294ab6a5485", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["2b3ffac6255bee7300fea9989b9b34d3b1348a67"], "nameRev": "f975e77a55c14eb321177527b9fad294ab6a5485 tags/v3.1.11.RELEASE~2", "commitMessage": "fix #1403 NullPointerException in some logger format\n\nThis commit fixes an NPE triggered by null parameters in format method\r\nof the JDK and Console Logger variants.", "commitDateTime": "2018-10-22 19:44:07", "authoredDateTime": "2018-10-22 19:44:07", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/Loggers.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/util/ConsoleLoggerTest.java", "insertions": 64, "deletions": 0, "lines": 64}, {"filePath": "reactor-core/src/test/java/reactor/util/JdkLoggerTest.java", "insertions": 84, "deletions": 0, "lines": 84}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Loggers.java", "spoonMethods": [{"spoonMethodName": "reactor.util.Loggers.JdkLogger", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.JdkLogger.format(java.lang.String,java.lang.Object[])", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.ConsoleLogger.format(java.lang.String,java.lang.Object[])", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.ConsoleLogger", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ConsoleLoggerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.ConsoleLoggerTest.traceNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.debugNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.infoNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.warnNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.errorNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.formatNull()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "JdkLoggerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.JdkLoggerTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4e6a58a5e9fca3b7e5afbe9cbd4f001ac059c2e5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["900693df19a13e50ed395c50b12640a089af4a3c", "f975e77a55c14eb321177527b9fad294ab6a5485"], "nameRev": "4e6a58a5e9fca3b7e5afbe9cbd4f001ac059c2e5 tags/v3.2.2.RELEASE~8", "commitMessage": "Merge #1403 into 3.2\n", "commitDateTime": "2018-10-22 19:44:53", "authoredDateTime": "2018-10-22 19:44:53", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/util/Loggers.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "reactor-core/src/test/java/reactor/util/ConsoleLoggerTest.java", "insertions": 64, "deletions": 0, "lines": 64}, {"filePath": "reactor-core/src/test/java/reactor/util/JdkLoggerTest.java", "insertions": 84, "deletions": 0, "lines": 84}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Loggers.java", "spoonMethods": [{"spoonMethodName": "reactor.util.Loggers.JdkLogger", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.JdkLogger.format(java.lang.String,java.lang.Object[])", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.ConsoleLogger.format(java.lang.String,java.lang.Object[])", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.Loggers.ConsoleLogger", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ConsoleLoggerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.ConsoleLoggerTest.traceNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.debugNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.infoNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.warnNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.errorNulls()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.ConsoleLoggerTest.formatNull()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "JdkLoggerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.JdkLoggerTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f975e77a55c14eb321177527b9fad294ab6a5485"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 6.0, "lines": 12.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 5.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/util"], "changesInPackagesSPOON": ["reactor.util.Loggers.JdkLogger.format(java.lang.String,java.lang.Object[])", "reactor.util.Loggers.ConsoleLogger.format(java.lang.String,java.lang.Object[])", "reactor.util.Loggers.JdkLogger", "reactor.util.Loggers.ConsoleLogger"]}, {"title": "Race condition in reduce with seed cancellation can lead to NPE", "body": "### Expected behavior\r\nA reducing `Flux` with a seed value can safely be cancelled.\r\n\r\n### Actual behavior\r\nThe `BiFunction` can be fed a `null` value in case there is a concurrent `cancel()` along the first `onNext(T)`. This is due to `cancel` nulling out the internal accumulated `value` and `onNext` not checking for nulls.\r\n\r\n### Steps to reproduce\r\n```java\r\n\t@Test\r\n\tpublic void onNextAndCancelRace() {\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfinal AssertSubscriber<Object> testSubscriber = AssertSubscriber.create();\r\n\r\n\t\tMonoReduceSeed.ReduceSeedSubscriber<Integer, List<Integer>> sub =\r\n\t\t\t\tnew MonoReduceSeed.ReduceSeedSubscriber<>(testSubscriber,\r\n\t\t\t\t\t\t(l, next) -> {\r\n\t\t\t\t\t\t\tl.add(next);\r\n\t\t\t\t\t\t\treturn l;\r\n\t\t\t\t\t\t}, list);\r\n\r\n\t\tsub.onSubscribe(Operators.emptySubscription());\r\n\t\tsub.cancel();\r\n\t\tsub.onNext(1);\r\n\t\ttestSubscriber.assertNoError(); //=> fails, NullPointerException in lambda above\r\n\t}\r\n```\r\n\r\n### Reactor Core version\r\n3.1.10.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1393", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-10-19 17:02:09", "closed": "2018-10-19 18:08:09", "commits": {"82c2e5c15bf713369dbaf2b4d48aa13429790c69": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a822592d872b11b0499d8631e3b9e36a8fa4073c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "aa0936a468578f2a90ef01f8823ea29a717eb755": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2b3ffac6255bee7300fea9989b9b34d3b1348a67": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "900693df19a13e50ed395c50b12640a089af4a3c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "82c2e5c15bf713369dbaf2b4d48aa13429790c69", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a822592d872b11b0499d8631e3b9e36a8fa4073c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["bea125092f6450f4c05e4bd53dbe6efbb8d0281d"], "nameRev": "a822592d872b11b0499d8631e3b9e36a8fa4073c tags/v3.1.11.RELEASE~4", "commitMessage": "fix #1393 null can be passed to reduce lambda if cancelled, causing NPE\n\nThis commit fixes a race condition that would result in a null\r\nbeing passed to the BiFunction of the seeded variant, which could\r\ntrigger a NullPointerException depending on said function.\r\n\r\nThis was due to `cancel()` nulling out the accumulated value / seed,\r\nwhich was not guarded against in `onNext`.", "commitDateTime": "2018-10-19 20:06:50", "authoredDateTime": "2018-10-19 20:06:50", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java", "insertions": 14, "deletions": 12, "lines": 26}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceSeedTest.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 25, "deletions": 0, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoReduceSeed.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceSeed.ReduceSeedSubscriber.onNext(java.lang.Object)", "TOT": 13, "UPD": 2, "INS": 4, "MOV": 4, "DEL": 3}]}, {"spoonFilePath": "MonoReduceSeedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceSeedTest.onNextAndCancelRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoReduceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceTest.onNextAndCancelRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "aa0936a468578f2a90ef01f8823ea29a717eb755", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["b7ee63f3163aad9c53e4121427ab6ac4512f992c", "a822592d872b11b0499d8631e3b9e36a8fa4073c"], "nameRev": "aa0936a468578f2a90ef01f8823ea29a717eb755 tags/v3.2.2.RELEASE~10", "commitMessage": "Merge #1393 into 3.2\n", "commitDateTime": "2018-10-19 20:07:48", "authoredDateTime": "2018-10-19 20:07:48", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java", "insertions": 14, "deletions": 12, "lines": 26}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceSeedTest.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 25, "deletions": 0, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoReduceSeed.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceSeed.ReduceSeedSubscriber.onNext(java.lang.Object)", "TOT": 13, "UPD": 2, "INS": 4, "MOV": 4, "DEL": 3}]}, {"spoonFilePath": "MonoReduceSeedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceSeedTest.onNextAndCancelRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoReduceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceTest.onNextAndCancelRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "2b3ffac6255bee7300fea9989b9b34d3b1348a67", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a822592d872b11b0499d8631e3b9e36a8fa4073c"], "nameRev": "2b3ffac6255bee7300fea9989b9b34d3b1348a67 tags/v3.1.11.RELEASE~3", "commitMessage": "fixup of MonoReduceTest following #1393 fix\n\nThe wrong subscriber class was tested\n", "commitDateTime": "2018-10-22 11:15:36", "authoredDateTime": "2018-10-22 11:15:36", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 4, "deletions": 9, "lines": 13}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoReduceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceTest.onNextAndCancelRace()", "TOT": 9, "UPD": 3, "INS": 1, "MOV": 2, "DEL": 3}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "900693df19a13e50ed395c50b12640a089af4a3c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["aa0936a468578f2a90ef01f8823ea29a717eb755", "2b3ffac6255bee7300fea9989b9b34d3b1348a67"], "nameRev": "900693df19a13e50ed395c50b12640a089af4a3c tags/v3.2.2.RELEASE~9", "commitMessage": "Merge fixup of MonoReduceTest following #1393 fix\n", "commitDateTime": "2018-10-22 11:16:03", "authoredDateTime": "2018-10-22 11:16:03", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 4, "deletions": 9, "lines": 13}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoReduceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceTest.onNextAndCancelRace()", "TOT": 9, "UPD": 3, "INS": 1, "MOV": 2, "DEL": 3}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a822592d872b11b0499d8631e3b9e36a8fa4073c", "2b3ffac6255bee7300fea9989b9b34d3b1348a67"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 2, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14.0, "deletions": 12.0, "lines": 26.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 2.0, "INS": 4.0, "MOV": 4.0, "DEL": 3.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoReduceSeed.ReduceSeedSubscriber.onNext(java.lang.Object)"]}, {"title": "share/refcount/refcountgrace can ignore repeat/retry re-subscriptions", "body": "### Expected behavior\r\n\r\nIn `Flux.interval(d).map(fn).share().retry(n)` the upstream of `share()` should be resubscribed on retry, when an error is signaled within `map()`.\r\n\r\n### Actual behavior\r\n\r\nThe `map()` and `interval()` Fluxes are never resubscribed on retry. It seems that the `share()` Flux still holds reference to the subscription\r\nterminated by the error and never resubscribes upstream.\r\n\r\n### Steps to reproduce\r\n\r\nRun the following test:\r\n\r\n```\r\n@Test\r\npublic void testIntervalMapShareRetry() throws InterruptedException {\r\n    final Flux<Long> flux = Flux.interval(Duration.ofMillis(250)).transform(report(\"interval\"))\r\n            .map(round -> {\r\n                if (round == 3) {\r\n                    throw new RuntimeException();\r\n                }\r\n                return round;\r\n            }).transform(report(\"map\"))\r\n            .share().transform(report(\"share\"))\r\n            .retry(3).transform(report(\"retry\"));\r\n\r\n    final Disposable disposable = flux.subscribe(System.out::println);\r\n\r\n    Thread.sleep(5_000);\r\n    System.out.println(\"Timeout; disposing all\");\r\n    disposable.dispose();\r\n}\r\n\r\nprivate static <T> Function<Flux<T>, Publisher<T>> report(final String name) {\r\n    return flux -> flux\r\n            .doOnSubscribe(s -> System.out.println(\"onSubscribe \" + name + \" \" + s))\r\n            .doOnEach(s -> System.out.println(s.getType() + \" \" + name))\r\n            .doOnCancel(() -> System.out.println(\"onCancel \" + name));\r\n}\r\n```\r\n\r\nThe last round causing error outputs:\r\n\r\n```\r\nonNext interval\r\nonCancel interval\r\nonError map\r\nonError share\r\nonSubscribe share reactor.core.publisher.FluxRefCount$RefCountInner@72321294\r\nTimeout; disposing all\r\nonCancel retry\r\nonCancel share\r\n```\r\n\r\nAnother subscription after error resubscribes to upstream of `share()`, emitting events to both subscriptions until next error is signaled.\r\n\r\n```\r\n    //final Disposable disposable = flux.subscribe(System.out::println);\r\n    final Disposable.Composite disposable = Disposables.composite();\r\n    disposable.add(flux.subscribe(System.out::println));\r\n    Thread.sleep(3_000);\r\n    disposable.add(flux.subscribe(System.out::println));\r\n```\r\n\r\nThis issue does _not_ appear if the root Flux is something executed in same thread, e.g.\r\n\r\n```\r\nFlux.fromStream(() -> LongStream.range(0, 10).boxed()).transform(report(\"stream\"))\r\n```\r\n\r\nor if a scheduler to new thread is added after `share()`\r\n\r\n```\r\n            // ...\r\n            .share().transform(report(\"share\"))\r\n            .subscribeOn(Schedulers.newSingle(\"newSingle scheduler\")).transform(report(\"scheduler\"))\r\n            .retry(3).transform(report(\"retry\"));\r\n```\r\n\r\n\r\n### Reactor Core version\r\n\r\n3.2.1.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```\r\njava version \"1.8.0_181\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_181-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\r\n```\r\n", "url": "https://github.com/reactor/reactor-core/issues/1385", "user": "petringo", "labels": ["type/bug"], "created": "2018-10-15 05:25:23", "closed": "2018-10-15 17:07:05", "commits": {"26847fa0454aa991e2df9f65542ae317afa8f49e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "bea125092f6450f4c05e4bd53dbe6efbb8d0281d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "a0d5de16b24abc7f1f42feaec846658305fee72c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "26847fa0454aa991e2df9f65542ae317afa8f49e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "bea125092f6450f4c05e4bd53dbe6efbb8d0281d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0d260bcd7a26aa99b6fe86082b10e7f5add39b8f"], "nameRev": "bea125092f6450f4c05e4bd53dbe6efbb8d0281d tags/v3.1.11.RELEASE~5", "commitMessage": "fix #1385 Fix refCount(Grace)/Share missing repeat/retry re-subscribes (#1386)\n\nThis commit fixes a bug where `FluxRefCount`/`FluxRefCountGrace` (which\r\nis also accessible through the `FLux#share` API) would miss\r\nre-subscriptions from `repeat` or `retry`. This was due to the state of\r\nconnection being reset only AFTER the terminal signal was propagated to\r\nthe downstream re-subscribing operator, resulting in the re-subscription\r\nbeing dismissed by the refcount operator.", "commitDateTime": "2018-10-15 19:01:27", "authoredDateTime": "2018-10-15 19:01:27", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 54, "deletions": 0, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 54, "deletions": 1, "lines": 55}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGrace.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountInner.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 6, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 6, "UPD": 2, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.sizeOneCanRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.sizeOneCanRepeat()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.sizeOneCanRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.sizeOneCanRepeat()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a0d5de16b24abc7f1f42feaec846658305fee72c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["08ea029e3a518048c00b7a4c335a22902ccf0c70", "bea125092f6450f4c05e4bd53dbe6efbb8d0281d"], "nameRev": "a0d5de16b24abc7f1f42feaec846658305fee72c tags/v3.2.2.RELEASE~12", "commitMessage": "Adapt #1385 into 3.2\n\nThe repeat(n) semantics having changed, the repeat test has been altered\naccordingly.\n", "commitDateTime": "2018-10-15 19:06:11", "authoredDateTime": "2018-10-15 19:06:11", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 54, "deletions": 0, "lines": 54}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 54, "deletions": 1, "lines": 55}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGrace.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountInner.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 6, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 6, "UPD": 2, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.sizeOneCanRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.sizeOneCanRepeat()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.sizeOneCanRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.sizeOneCanRepeat()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Mono.metrics() throws NoClassDefFoundError if micrometer not on classpath", "body": "### Expected behavior\r\n\r\nIf I call `Mono.metrics()` (or `Flux.metrics()`), and micrometer is not on the classpath, then this should be a no-op. This is what the javadoc for those methods say should happen.\r\n\r\n### Actual behavior\r\n\r\n`java.lang.NoClassDefFoundError: io/micrometer/core/instrument/MeterRegistry` is thrown.\r\n\r\n### Steps to reproduce\r\n\r\nRun this test without micrometer on the classpath:\r\n\r\n    @Test\r\n    public void test() {\r\n        Mono.just(\"foo\").metrics();\r\n    }\r\n\r\nThis would appear to be the fault of the `FluxMetrics` class, which has a `isMicrometerAvailable` method which is being correctly checked by `Mono.metrics()`, but the `FluxMetrics` class itself cannot be loaded if micrometer is not on the classpath, mostly likely because it uses micrometer types in its method signature.\r\n\r\nThe reactor-core test suite isn't catching this, because it always has micrometer on its classpath.\r\n\r\n### Reactor Core version\r\n\r\n3.2.0.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n> openjdk version \"1.8.0_181\"\r\n> OpenJDK Runtime Environment (Zulu 8.31.0.1-macosx) (build 1.8.0_181-b02)\r\n> OpenJDK 64-Bit Server VM (Zulu 8.31.0.1-macosx) (build 25.181-b02, mixed mode)", "url": "https://github.com/reactor/reactor-core/issues/1383", "user": "kennymacleod", "labels": ["type/bug"], "created": "2018-10-11 22:52:41", "closed": "2018-10-19 17:19:20", "commits": {"a4009c45e9ecf265eacb22f6ed2fc1e5d3dda1e6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "fef0f45aadb0286153e64078250e4fc0b4a2cba4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b7ee63f3163aad9c53e4121427ab6ac4512f992c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "a4009c45e9ecf265eacb22f6ed2fc1e5d3dda1e6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fef0f45aadb0286153e64078250e4fc0b4a2cba4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b7ee63f3163aad9c53e4121427ab6ac4512f992c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a0d5de16b24abc7f1f42feaec846658305fee72c"], "nameRev": "b7ee63f3163aad9c53e4121427ab6ac4512f992c tags/v3.2.2.RELEASE~11", "commitMessage": "fix #1383 metrics() without Micrometer triggers NoClassDefFoundError\n\nReorganizes the micrometer detection into a dedicated class `Metrics`, which avoids loading the entire `FluxMetrics` class, including Micrometer-dependent code.", "commitDateTime": "2018-10-19 19:19:17", "authoredDateTime": "2018-10-19 19:19:17", "commitGitStats": [{"filePath": "build.gradle", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java", "insertions": 9, "deletions": 30, "lines": 39}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxMetricsFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java", "insertions": 8, "deletions": 9, "lines": 17}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/util/Metrics.java", "insertions": 52, "deletions": 0, "lines": 52}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/util/MetricsNoMicrometerTest.java", "insertions": 74, "deletions": 0, "lines": 74}, {"filePath": "reactor-core/src/test/java/reactor/util/MetricsTest.java", "insertions": 49, "deletions": 0, "lines": 49}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.metrics()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMetrics", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxMetrics.isMicrometerAvailable()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxMetrics.subscribe(reactor.core.CoreSubscriber)", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 3}]}, {"spoonFilePath": "FluxMetricsFuseable.java", "spoonMethods": []}, {"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.metrics()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoMetrics.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoMetrics", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoMetrics.subscribe(reactor.core.CoreSubscriber)", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 3}]}, {"spoonFilePath": "MonoMetricsFuseable.java", "spoonMethods": []}, {"spoonFilePath": "Metrics.java", "spoonMethods": [{"spoonMethodName": "reactor.util.Metrics", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSourceTest.java", "spoonMethods": []}, {"spoonFilePath": "MetricsNoMicrometerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.MetricsNoMicrometerTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MetricsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.MetricsTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b7ee63f3163aad9c53e4121427ab6ac4512f992c"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 101.0, "deletions": 43.0, "lines": 144.0, "gitFilesChange": 8}, "spoonStatsSummary": {"TOT": 24.0, "UPD": 4.0, "INS": 3.0, "MOV": 6.0, "DEL": 11.0, "spoonFilesChanged": 5, "spoonMethodsChanged": 8}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", "", "reactor-core/src/main/java/reactor/util"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoMetrics.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.Flux.metrics()", "reactor.core.publisher.FluxMetrics.subscribe(reactor.core.CoreSubscriber)", "reactor.util.Metrics", "reactor.core.publisher.FluxMetrics.isMicrometerAvailable()", "reactor.core.publisher.Mono.metrics()", "reactor.core.publisher.FluxMetrics", "reactor.core.publisher.MonoMetrics"]}, {"title": "EmitterProcessor not Emitting Items from Publisher it is subscribed to", "body": "### Expected behavior\r\nEmitterProcessor emits items from publisher to which it is subscribed\r\n\r\n### Actual behavior\r\nEmitterProcessor doesn't emit anything except completion\r\n\r\n### Steps to reproduce\r\n    import java.util.concurrent.atomic.AtomicReference;\r\n    \r\n    import org.junit.Test;\r\n    import org.reactivestreams.Subscriber;\r\n    import org.reactivestreams.Subscription;\r\n    \r\n    import reactor.core.CoreSubscriber;\r\n    import reactor.core.publisher.BaseSubscriber;\r\n    import reactor.core.publisher.EmitterProcessor;\r\n    import reactor.core.publisher.Flux;\r\n    import reactor.core.publisher.FluxOperator;\r\n    import reactor.core.publisher.Mono;\r\n    \r\n    import static org.junit.Assert.assertEquals;\r\n    \r\n    public class EmitterProcessorEmissionBug {\r\n    \r\n        @Test\r\n        public void expose() {\r\n            AtomicReference<String> result = new AtomicReference<>();\r\n    \r\n            Mono.just(\"DATA\")\r\n                .subscribeWith(EmitterProcessor.create())\r\n                .transform(LowerCasingOperator::new)\r\n                .subscribe(result::set);\r\n    \r\n            assertEquals(\"data\", result.get());\r\n        }\r\n    \r\n        private static final class LowerCasingOperator extends FluxOperator<String, String> {\r\n    \r\n            protected LowerCasingOperator(Flux<? extends String> source) {\r\n                super(source);\r\n            }\r\n    \r\n            @Override\r\n            public void subscribe(CoreSubscriber<? super String> actual) {\r\n                source.subscribe(new LowerCasingSubscriber(actual));\r\n            }\r\n        }\r\n    \r\n        private static final class LowerCasingSubscriber extends BaseSubscriber<String> {\r\n    \r\n            private final Subscriber<? super String> subscriber;\r\n    \r\n            private LowerCasingSubscriber(Subscriber<? super String> subscriber) {\r\n                this.subscriber = subscriber;\r\n            }\r\n    \r\n            @Override\r\n            protected void hookOnSubscribe(Subscription subscription) {\r\n                subscriber.onSubscribe(subscription);\r\n            }\r\n    \r\n            @Override\r\n            protected void hookOnNext(String value) {\r\n                subscriber.onNext(value.toLowerCase());\r\n            }\r\n        }\r\n    }\r\n\r\n### Reactor Core version\r\n3.1.9.RELEASE, 3.2.0.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n1.8.0_102\r\n\r\nNote: The above test works with Reactor Core version 3.1.8.RELEASE. It also works with 3.1.9.RELEASE if `EmitterProcessor.create()` is replaced with `UnicastProcessor.create()`", "url": "https://github.com/reactor/reactor-core/issues/1364", "user": "Sage-Pierce", "labels": ["status/has-workaround", "type/bug"], "created": "2018-09-25 14:38:32", "closed": "2018-10-03 09:00:03", "commits": {"20e1ceadf06fbccea9623a1a6ee4ff749dc33ca5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "20e1ceadf06fbccea9623a1a6ee4ff749dc33ca5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "spoonStatsSummary": {}, "statsSkippedReason": ""}, {"title": "RejectedExcecutionException not being thrown from 3.2.0-M1 to 3.2.0-M2", "body": "While upgrading from 3.2.0-M1 to 3.2.0-M2 we got a performance degradation in some scenarios with high concurrency. This is caused because in those cases, we want to handle retries in case we get a `RejectedExcecutionException`: \r\n```\r\njust(event)\r\n           .transform(getTransformer())\r\n           .retryWhen(onlyIf(ctx -> RejectedExecutionException.class.isAssignableFrom(unwrap(ctx.exception()).getClass()))\r\n              .backoff(ctx -> new BackoffDelay(ofMillis(2), ZERO, ZERO))\r\n              .withBackoffScheduler(getScheduler()));\r\n// we basically check if RejectedExcecucionException is the cause of the exception thrown\r\n```\r\nAfter profiling, we found out that the retry logic is not being executed. This might be caused by a change in behaviour that was throwing a RejectedExecutionException, but now doesn't. \r\nWe checked with 3.2.0-M3, 3.2.0.M4 and 3.2.0-RC1 and we are getting similar results. ", "url": "https://github.com/reactor/reactor-core/issues/1362", "user": "mbuchwald", "labels": ["for/user-attention", "status/need-investigation", "type/bug"], "created": "2018-09-24 15:41:31", "closed": "2018-10-05 13:53:44", "commits": {}, "ttf": 10.000277777777777, "commitsDetails": []}, {"title": "Some examples from the reference can't be compiled", "body": "### Expected behavior\r\nExamples from the reference are compiled and working.\r\n\r\n### Actual behavior\r\nExamples can't be compiled\r\n\r\n### Steps to reproduce\r\nhttp://projectreactor.io/docs/core/snapshot/reference/#__code_publishon_code\r\nExamples in this paragraph:\r\n\r\n```\r\nScheduler s = Schedulers.newParallel(4); // no such method in 3.2.0\r\n\r\nfinal Flux<Integer> flux = Flux\r\n    .range(1, 2)\r\n    .map(i -> 10 + i)  \r\n    .publishOn(s)  \r\n    .map(i -> \"value \" + i);  // map to string but Flux<Integer>\r\n\r\nnew Thread(() -> flux.subscribe(System.out::println));\r\n```\r\n\r\nThe same story with http://projectreactor.io/docs/core/snapshot/reference/#__code_subscribeon_code\r\n\r\n### Reactor Core version\r\n3.2.0 RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1361", "user": "romangr", "labels": ["type/bug"], "created": "2018-09-22 12:16:59", "closed": "2018-10-01 23:06:18", "commits": {"ea83172ac6169b497821462473806610288c3cf6": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 9.000277777777777, "commitsDetails": [{"commitHash": "ea83172ac6169b497821462473806610288c3cf6", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["2f7f80d6a3ac8e57e05dfe436e42751ce7fb384e"], "nameRev": "ea83172ac6169b497821462473806610288c3cf6 tags/v3.2.1.RELEASE~16", "commitMessage": "fix #1361 Snippet from the docs can't be compiled (#1369)\n\n", "commitDateTime": "2018-10-01 16:06:15", "authoredDateTime": "2018-10-02 02:06:15", "commitGitStats": [{"filePath": "src/docs/asciidoc/coreFeatures.adoc", "insertions": 4, "deletions": 4, "lines": 8}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Using combineLatest with a single non-fuseable source results in ClassCastException", "body": "### Expected behavior\r\nThe below test passes.\r\n\r\n### Actual behavior\r\nThe test fails with the following exception\r\n```\r\n\r\njava.lang.ClassCastException: reactor.core.publisher.FluxMap$MapSubscriber cannot be cast to reactor.core.Fuseable$QueueSubscription\r\n\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:89)\r\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86)\r\n\tat reactor.core.publisher.FluxHide$HideSubscriber.onSubscribe(FluxHide.java:69)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:53)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:59)\r\n\tat reactor.core.publisher.FluxHide.subscribe(FluxHide.java:39)\r\n\tat reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62)\r\n\tat reactor.core.publisher.FluxCombineLatest.subscribe(FluxCombineLatest.java:164)\r\n\tat reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)\r\n\tat reactor.core.publisher.MonoCollectList.subscribe(MonoCollectList.java:59)\r\n\tat reactor.core.publisher.Mono.block(Mono.java:1174)\r\n\tat FluxCombineLatestFuseableBugTest.failsWithClassCastException(FluxCombineLatestFuseableBugTest.java:20)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\r\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n```\r\n\r\n### Steps to reproduce\r\n```\r\n  @Test\r\n  public void failsWithClassCastException() {\r\n    List<String> result = Flux.combineLatest(\r\n        Arrays.asList(Flux.just(1, 2, 3).hide()),\r\n        (arr) -> arr[0].toString())\r\n        //.hide() // adding this makes the test pass\r\n        .map(x -> x + \"!\")\r\n        .collectList()\r\n        .block();\r\n    assertEquals(result, Arrays.asList(\"1!\", \"2!\", \"3!\"));\r\n  }\r\n```\r\n\r\n### Reactor Core version\r\nLatest master (commit e337f0e52878386052e3c672f0b7d3e0581e069d) and 3.1.6.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n1.8.0_181-b13\r\n", "url": "https://github.com/reactor/reactor-core/issues/1356", "user": "mlex", "labels": ["status/has-workaround", "type/bug"], "created": "2018-09-14 15:16:29", "closed": "2018-10-10 07:53:19", "commits": {"2c70362c252f2e9994b7fc740f38d2151e9968ae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e0c4b9f277df521b7e4744e372fed5bcd69a4385": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "b26cadc6ea16d758107b0250f39ca4af16c3cbc2": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 25.00027777777778, "commitsDetails": [{"commitHash": "2c70362c252f2e9994b7fc740f38d2151e9968ae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e0c4b9f277df521b7e4744e372fed5bcd69a4385", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["045321642b82871b477fc7743b1f6b258febe942"], "nameRev": "e0c4b9f277df521b7e4744e372fed5bcd69a4385 tags/v3.1.10.RELEASE~4", "commitMessage": "fix #1356 combineLatest ClassCastException with single source\n\nThe `ClassCastException` only happens when there is a single source\r\nwhich is NOT `Fuseable` and the operator downstream of `combineLatest`\r\nIS `Fuseable`.\r\n\r\nThis fix only optimizes the single-source case into a `map` when both\r\nsource and downstream share the same `Fuseable` characteristics,\r\ndegenerating into the coordinator implementation when they are not\r\n(thus preventing the class cast down the road).", "commitDateTime": "2018-10-10 09:49:44", "authoredDateTime": "2018-10-10 09:49:44", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java", "insertions": 37, "deletions": 0, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCombineLatest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCombineLatest.subscribe(reactor.core.CoreSubscriber)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxCombineLatestTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceNormalWithFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceNormalWithoutFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceFusedWithFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b26cadc6ea16d758107b0250f39ca4af16c3cbc2", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["8369b0fb350847f2b48c3a54341fc6ca124a340b", "e0c4b9f277df521b7e4744e372fed5bcd69a4385"], "nameRev": "b26cadc6ea16d758107b0250f39ca4af16c3cbc2 tags/v3.2.1.RELEASE~7", "commitMessage": "Merge #1356 into 3.2\n", "commitDateTime": "2018-10-10 09:52:30", "authoredDateTime": "2018-10-10 09:52:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java", "insertions": 37, "deletions": 0, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCombineLatest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCombineLatest.subscribe(reactor.core.CoreSubscriber)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxCombineLatestTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceNormalWithFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceNormalWithoutFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCombineLatestTest.singleSourceFusedWithFuseableDownstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e0c4b9f277df521b7e4744e372fed5bcd69a4385"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3.0, "deletions": 2.0, "lines": 5.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 2.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxCombineLatest.subscribe(reactor.core.CoreSubscriber)"]}, {"title": "`doOnSuccess` suppresses `ErrorCallbackNotImplemented`", "body": "### Expected behavior\r\nWith a `Mono.error` with `doOnSuccess` and a simplistic `subscribe(v -> {})`, the `ErrorCallbackNotImplemented` exception should be thrown.\r\n\r\n`doOn*` _do_ sometimes suppress this wrapping exception, but only when they themselves define an error handler.\r\n\r\n### Actual behavior\r\nThe wrapping `ErrorCallbackNotImplemented` exception is swallowed.\r\n\r\n### Steps to reproduce\r\n```java\r\n\t@Test\r\n\tpublic void testErrorWithDoOnSuccess() {\r\n\t\tassertThatExceptionOfType(RuntimeException.class)\r\n\t\t\t\t.isThrownBy(() ->\r\n\t\t\t\t\t\tMono.error(new NullPointerException(\"boom\"))\r\n\t\t\t\t\t\t    .doOnSuccess(aValue -> {})\r\n\t\t\t\t\t\t    .subscribe())\r\n\t\t\t\t.withCauseInstanceOf(NullPointerException.class)\r\n\t\t\t\t.matches(Exceptions::isErrorCallbackNotImplemented, \"ErrorCallbackNotImplemented\");\r\n\t}\r\n```\r\n\r\n### Reactor Core version\r\n3.1.8, 3.2.0\r\n\r\n### Source\r\nStackOverflow: https://stackoverflow.com/questions/52152692/why-does-mono-doonsuccess-suppress-errors/52162479#52162479\r\n\r\n### Workaround\r\nFollow best practices and define an error handler in the `subscribe`.\r\n", "url": "https://github.com/reactor/reactor-core/issues/1337", "user": "simonbasle", "labels": ["status/has-workaround", "type/bug"], "created": "2018-09-04 09:01:48", "closed": "2018-09-05 21:50:33", "commits": {"13bd57deb043bdc58ad39afc1369aeb5c7d50c4b": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "f66f725e5740eacb9b940b068c6ee7d991e228fb": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "214da086359beb70c9ae38283255e5c58f2036b2": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "a52529d7be440ac0a5bea4687534a946c4c10902": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "13bd57deb043bdc58ad39afc1369aeb5c7d50c4b", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f66f725e5740eacb9b940b068c6ee7d991e228fb", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "214da086359beb70c9ae38283255e5c58f2036b2", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["a41d828938e1c47080caddd9cfa76f3337c1aa55"], "nameRev": "214da086359beb70c9ae38283255e5c58f2036b2 tags/v3.1.9.RELEASE~2", "commitMessage": "fix #1337 Do not swallow error without terminateHook (#1341)\n\n", "commitDateTime": "2018-09-05 14:52:16", "authoredDateTime": "2018-09-05 14:52:16", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java", "insertions": 7, "deletions": 4, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoPeekTest.java", "insertions": 14, "deletions": 1, "lines": 15}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoPeekTerminal.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "TOT": 7, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoPeekTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTest.testErrorWithDoOnSuccess()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a52529d7be440ac0a5bea4687534a946c4c10902", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["62de59a4443bb1bd534807f6f84935a03768bf3d", "214da086359beb70c9ae38283255e5c58f2036b2"], "nameRev": "a52529d7be440ac0a5bea4687534a946c4c10902 tags/v3.2.0.RC1~2", "commitMessage": "Merge #1337 into 3.2\n", "commitDateTime": "2018-09-05 14:58:55", "authoredDateTime": "2018-09-05 14:58:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java", "insertions": 7, "deletions": 4, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoPeekTest.java", "insertions": 14, "deletions": 1, "lines": 15}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoPeekTerminal.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "TOT": 7, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoPeekTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTest.testErrorWithDoOnSuccess()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Ability to build with Java 9", "body": "### Expected behavior\r\n\r\nIt would be good to be able to build the project with Java 9. \r\n\r\n### Actual behavior\r\n\r\nCurrently there are [failing tests](https://travis-ci.org/reactor/reactor-core/jobs/418775729#L816).\r\n\r\n### Extra notes\r\n\r\nIt is a prerequisite to the official Java 9(+) support in reactor-core (which - having Java 11 LTS knocking at the door - become an important thing). I haven't found any related issue, but I believe you have it in your plans (there is more work to do to achieve that).\r\n\r\n### Reactor Core version\r\n\r\ncurrent master\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\nOpenJDK Runtime Environment (build 9.0.4+11)", "url": "https://github.com/reactor/reactor-core/issues/1326", "user": "szpak", "labels": ["area/java9", "type/bug"], "created": "2018-08-21 22:53:34", "closed": "2018-08-23 10:22:29", "commits": {"f7c7e11955eb287c0f419f4ae8b4b425142de44f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "f7c7e11955eb287c0f419f4ae8b4b425142de44f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["36b8ccfc3f1c58c067f8f59c34c9f2cf60ec0431"], "nameRev": "f7c7e11955eb287c0f419f4ae8b4b425142de44f tags/v3.2.0.RC1~9", "commitMessage": "fix #1326 Fix ClassCastException in OneQueue/ZeroQueue + Java9 build\n\nThis commit fixes a ClassCastException in the `toArray(T[])` methods of\r\n`OneQueue` and `ZeroQueue`. Under Java 9, the compiler would make the\r\nerror in `OneQueue` explicit.\r\n\r\nIt also reactivate mandatory builds of the project under JDK9 in Travis\r\nand amends a test that fails in Java 9 due to additional stacktrace\r\nlines.\r\n\r\nReviewed in #1327", "commitDateTime": "2018-08-23 12:22:26", "authoredDateTime": "2018-08-23 12:22:26", "commitGitStats": [{"filePath": ".travis.yml", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/util/concurrent/Queues.java", "insertions": 14, "deletions": 11, "lines": 25}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/util/concurrent/QueuesOneQueueTest.java", "insertions": 105, "deletions": 0, "lines": 105}, {"filePath": "reactor-core/src/test/java/reactor/util/concurrent/QueuesTest.java", "insertions": 8, "deletions": 1, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Queues.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.Queues.OneQueue.toArray(java.lang.Object[])", "TOT": 13, "UPD": 0, "INS": 5, "MOV": 4, "DEL": 4}, {"spoonMethodName": "reactor.util.concurrent.Queues.ZeroQueue.toArray(java.lang.Object[])", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxOnAssemblyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "QueuesOneQueueTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.QueuesOneQueueTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "QueuesTest.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.QueuesTest.toArrayOnZeroQueueShouldNotFailAlsoOnJava9()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Why Flux.toIterable cannot happen in non-blocking thread", "body": "https://github.com/reactor/reactor-core/blob/383453706fe441a74b82462ea65d6190ea0bfffd/reactor-core/src/main/java/reactor/core/publisher/Flux.java#L8410\r\n\r\nSorry, I did not find a better channel to ask this. So filing as an issue here.\r\n\r\n## Problem description\r\nFlux.toIterable() itself is lazy. BlockingIterable.iterator() is the place where a new subscription is created and even that doesn't seem to require true blocking behavior since iterator.next()/hasNext() is where it actually blocks on stream elements.\r\n\r\nIn contrast. Mono.toFuture() news up a Future with a new subscription. It can happen in non-blocking thread.\r\n\r\n## Version\r\nlatest trunk\r\n\r\n## Proposed fix\r\nMove the check to place where blocking behavior is really needed", "url": "https://github.com/reactor/reactor-core/issues/1313", "user": "zzhao0", "labels": ["type/bug"], "created": "2018-08-14 18:26:18", "closed": "2018-08-21 16:07:55", "commits": {"01ab4b1828527eea33300847cd29e3436ea213a0": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2df74f9485af6c1e5bb5ac2adad75fad460e9dc7": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5fa95df3f433cf388db65839557cda9dc548b629": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "01ab4b1828527eea33300847cd29e3436ea213a0", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2df74f9485af6c1e5bb5ac2adad75fad460e9dc7", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f2a38874feed4770d5825ddd3e2404eb05362691"], "nameRev": "2df74f9485af6c1e5bb5ac2adad75fad460e9dc7 tags/v3.1.9.RELEASE~4", "commitMessage": "fix #1313 Defer the NonBlocking rejection in toStream/toIterable...\n\nThis commit defers the NonBlocking rejection in toStream/toIterable to\r\nwhen the iterator/stream is actually used. That is to say, to when the\r\niterator is instantiated and its `hasNext` or `next` methods are called.", "commitDateTime": "2018-08-21 18:05:36", "authoredDateTime": "2018-08-21 18:05:36", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 18, "deletions": 6, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/BlockingTests.java", "insertions": 96, "deletions": 24, "lines": 120}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingIterable.SubscriberIterator.hasNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.toIterable(int,java.util.function.Supplier)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Flux.toStream(int)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "BlockingTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingTests.fluxToIterableForbidden()", "TOT": 24, "UPD": 13, "INS": 0, "MOV": 11, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingTests.fluxToStreamForbidden()", "TOT": 26, "UPD": 14, "INS": 0, "MOV": 12, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "5fa95df3f433cf388db65839557cda9dc548b629", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["fd77d6328309a231c430fde9426168fee49960ea", "2df74f9485af6c1e5bb5ac2adad75fad460e9dc7"], "nameRev": "5fa95df3f433cf388db65839557cda9dc548b629 tags/v3.2.0.RC1~11", "commitMessage": "Merge #1313 into 3.2\n", "commitDateTime": "2018-08-21 18:07:28", "authoredDateTime": "2018-08-21 18:07:28", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 18, "deletions": 6, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/BlockingTests.java", "insertions": 96, "deletions": 24, "lines": 120}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingIterable.SubscriberIterator.hasNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.toIterable(int,java.util.function.Supplier)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Flux.toStream(int)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "BlockingTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingTests.fluxToIterableForbidden()", "TOT": 24, "UPD": 13, "INS": 0, "MOV": 11, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingTests.fluxToStreamForbidden()", "TOT": 26, "UPD": 14, "INS": 0, "MOV": 12, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2df74f9485af6c1e5bb5ac2adad75fad460e9dc7"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 23.0, "deletions": 7.0, "lines": 30.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 2.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.toIterable(int,java.util.function.Supplier)", "reactor.core.publisher.BlockingIterable.SubscriberIterator.hasNext()", "reactor.core.publisher.Flux.toStream(int)"]}, {"title": "Sync fix for concatMap/publish fusion", "body": "As reported on rxjava we should adapt the fix for reactor fusion path too https://github.com/ReactiveX/RxJava/issues/6144", "url": "https://github.com/reactor/reactor-core/issues/1302", "user": "smaldini", "labels": ["type/bug"], "created": "2018-08-08 16:53:49", "closed": "2018-08-09 19:56:23", "commits": {"313190b455f5a3d74eb08921f9d50471de60e9bc": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "d4b98d8e2faabc8d4b5de43bb935bcbbed39d6d9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "174f5dffedfaa42284f7cfd669812d53fe4a4cff": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "313190b455f5a3d74eb08921f9d50471de60e9bc", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d4b98d8e2faabc8d4b5de43bb935bcbbed39d6d9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["946144aa89692c772399b83e09867aecdd6882a5"], "nameRev": "d4b98d8e2faabc8d4b5de43bb935bcbbed39d6d9 tags/v3.2.0.M4~5^2", "commitMessage": "fix #1302 Request fusion with THREAD_BARRIER in concatMap* and publish\n\n", "commitDateTime": "2018-08-09 21:53:30", "authoredDateTime": "2018-08-09 12:53:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "insertions": 34, "deletions": 0, "lines": 34}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 17, "deletions": 0, "lines": 17}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 7, "deletions": 5, "lines": 12}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapImmediate.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxConcatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.boundaryFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.boundaryFusionDelayError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.boundaryFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWindowPredicateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileOneByOneStartingDelimiterReplenishes()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowUntilUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "174f5dffedfaa42284f7cfd669812d53fe4a4cff", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["6b90dead775fe086d34d7fceb309e31227db2cb6", "d4b98d8e2faabc8d4b5de43bb935bcbbed39d6d9"], "nameRev": "174f5dffedfaa42284f7cfd669812d53fe4a4cff tags/v3.2.0.M4~5", "commitMessage": "Adapt #1302 into 3.2\n", "commitDateTime": "2018-08-09 21:55:18", "authoredDateTime": "2018-08-09 21:55:18", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "insertions": 32, "deletions": 0, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 17, "deletions": 0, "lines": 17}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 7, "deletions": 5, "lines": 12}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapImmediate.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxConcatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.boundaryFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.boundaryFusionDelayError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.boundaryFused()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWindowPredicateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileOneByOneStartingDelimiterReplenishes()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowUntilUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d4b98d8e2faabc8d4b5de43bb935bcbbed39d6d9"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4.0, "deletions": 4.0, "lines": 8.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 0.0, "INS": 3.0, "MOV": 0.0, "DEL": 3.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublish.PublishSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxConcatMap.ConcatMapImmediate.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "ArrayIndexOutOfBoundsException when using ParallelFlux", "body": "We recently updated from 3.1.7 to 3.1.8 and code that was previously working now fails with an exception:\r\n\r\n```\r\njava.lang.ArrayIndexOutOfBoundsException: -1\r\n\tat reactor.core.publisher.ParallelLiftFuseable.subscribe(ParallelLiftFuseable.java:74) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.ParallelMergeReduce.subscribe(ParallelMergeReduce.java:63) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.MonoLiftFuseable.subscribe(MonoLiftFuseable.java:56) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.MonoLiftFuseable.subscribe(MonoLiftFuseable.java:56) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.MonoLiftFuseable.subscribe(MonoLiftFuseable.java:56) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.Mono.subscribe(Mono.java:3080) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.Mono.subscribeWith(Mono.java:3188) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.publisher.Mono.subscribe(Mono.java:2965) ~[reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat me.MyClass$MyRunnable.run() ~[classes/:?]\r\n\tat reactor.core.scheduler.PeriodicSchedulerTask.call(PeriodicSchedulerTask.java:49) [reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat reactor.core.scheduler.PeriodicSchedulerTask.run(PeriodicSchedulerTask.java:63) [reactor-core-3.1.8.RELEASE.jar:3.1.8.RELEASE]\r\n\tat org.springframework.cloud.sleuth.instrument.async.TraceRunnable.run(TraceRunnable.java:62) [spring-cloud-sleuth-core-2.0.0.RELEASE.jar:2.0.0.RELEASE]\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_144]\r\n\tat java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [?:1.8.0_144]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_144]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [?:1.8.0_144]\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_144]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_144]\r\n\tat java.lang.Thread.run(Thread.java:748) [?:1.8.0_144]\r\n```\r\n\r\nLooking at the code for ParallelLiftFuseable.java:74, I see:\r\n\r\n```java\r\n\t\tint i = 0;\r\n\t\twhile (i < subscribers.length) {\r\n\t\t\tCoreSubscriber<? super O> actual = s[i - 1];\r\n```\r\n\r\nSeems like `i` will always be `0` in the first iteration, thus `s[i - 1]` will always be `s[-1]` and throw an exception every time.\r\n\r\n### Steps to reproduce\r\n\r\nWhere this is failing is a somewhat complex parallel/reduce operation.  I'm trying to come up with a simple example to demonstrate, but not having any luck.  However, looking at the above code, it's hard to see how this class could ever work.\r\n\r\n### Reactor Core version\r\n\r\nStarted failing in 3.1.8.  Previous version (3.1.7) works fine.\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\nJRE is 10.0.2, but compile target 1.8.", "url": "https://github.com/reactor/reactor-core/issues/1293", "user": "blake-bauman", "labels": ["type/bug"], "created": "2018-08-03 02:28:05", "closed": "2018-08-07 08:02:10", "commits": {"6cc40283f57896fac24c55cebc698bf80e04d505": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "946144aa89692c772399b83e09867aecdd6882a5": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "055214fb39af279d98a322cf61f6fa4be0b3c290": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "6cc40283f57896fac24c55cebc698bf80e04d505", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "946144aa89692c772399b83e09867aecdd6882a5", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["ee45db06e42087f0e6d0d70c0f1bcf48cd0c2b55"], "nameRev": "946144aa89692c772399b83e09867aecdd6882a5 tags/v3.2.0.M4~5^2~1", "commitMessage": "fix #1293 Index bound error on ParallelLiftFuseable\n", "commitDateTime": "2018-08-07 09:57:03", "authoredDateTime": "2018-08-03 10:35:26", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 38, "deletions": 13, "lines": 51}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ParallelLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelLift.subscribe(reactor.core.CoreSubscriber[])", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "ParallelLiftFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelLiftFuseable.subscribe(reactor.core.CoreSubscriber[])", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftParallelFluxFuseable()", "TOT": 8, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftMono()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftParallelFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftMonoFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftFluxFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFluxFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "055214fb39af279d98a322cf61f6fa4be0b3c290", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["5393403b6a2fdd115849ccb61c98dea124bdd73f", "946144aa89692c772399b83e09867aecdd6882a5"], "nameRev": "055214fb39af279d98a322cf61f6fa4be0b3c290 tags/v3.2.0.M4~7", "commitMessage": "Adapt #1293 into 3.2\n", "commitDateTime": "2018-08-07 10:01:41", "authoredDateTime": "2018-08-07 10:01:41", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 38, "deletions": 13, "lines": 51}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ParallelLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelLift.subscribe(reactor.core.CoreSubscriber[])", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "ParallelLiftFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelLiftFuseable.subscribe(reactor.core.CoreSubscriber[])", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftParallelFluxFuseable()", "TOT": 8, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftMono()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftParallelFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftMonoFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftFluxFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.LiftFunctionTest.liftConnectableFluxFuseable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["946144aa89692c772399b83e09867aecdd6882a5"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 4.0, "lines": 10.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 8.0, "UPD": 0.0, "INS": 4.0, "MOV": 2.0, "DEL": 2.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.ParallelLiftFuseable.subscribe(reactor.core.CoreSubscriber[])", "reactor.core.publisher.ParallelLift.subscribe(reactor.core.CoreSubscriber[])"]}, {"title": "Sync fusion with FluxPublish", "body": "Reported by @artembilan\r\n\r\n ### Expected behavior\r\n\r\nTrigger onComplete signal\r\n\r\n### Actual behavior\r\n\r\nFused upstream doesn't trigger onComplete signal\r\n\r\n### Steps to reproduce\r\n\r\nhttps://jira.spring.io/browse/INT-4510\r\n\r\n### Reactor Core version\r\n\r\n3.1.8 and 3.2.0.M3", "url": "https://github.com/reactor/reactor-core/issues/1290", "user": "smaldini", "labels": ["type/bug"], "created": "2018-07-26 22:51:00", "closed": "2018-08-01 04:12:09", "commits": {"59331091b921122149e9ec0adbbc193419684634": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "9d46549c57125fdcfd88881b071d6228a6280838": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a318b977d62d196fd5f6524bc4e3bbc1858bf1e9": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "ee45db06e42087f0e6d0d70c0f1bcf48cd0c2b55": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "8579316184e959a1325e025fbb6cfd9bea9d0663": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "59331091b921122149e9ec0adbbc193419684634", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "9d46549c57125fdcfd88881b071d6228a6280838", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a318b977d62d196fd5f6524bc4e3bbc1858bf1e9", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["35519abf5dd6fb7052d9806443dc48cd81994eee"], "nameRev": "a318b977d62d196fd5f6524bc4e3bbc1858bf1e9 tags/v3.2.0.M4~10", "commitMessage": "fix #1290 - FluxPublish should trigger an extra poll on sync fusion (#1291)\n\nFluxPublish should trigger an extra poll on sync fusion\r\nEmitterProcessor should trigger an extra poll on sync fusion", "commitDateTime": "2018-07-31 21:12:07", "authoredDateTime": "2018-07-31 21:12:07", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 14, "deletions": 3, "lines": 17}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 12, "deletions": 1, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 40, "deletions": 6, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithSyncFusionSingle()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithSyncFusionMultiple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalHidden()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalHiddenBackpressured()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normal()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalBackpressured()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionSingle()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionMultiple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ee45db06e42087f0e6d0d70c0f1bcf48cd0c2b55", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03"], "nameRev": "ee45db06e42087f0e6d0d70c0f1bcf48cd0c2b55 tags/v3.2.0.M4~5^2~2", "commitMessage": "fix #1290 - FluxPublish should trigger an extra poll on sync fusion (#1291)\n\nFluxPublish should trigger an extra poll on sync fusion\r\nEmitterProcessor should trigger an extra poll on sync fusion", "commitDateTime": "2018-08-01 10:01:36", "authoredDateTime": "2018-07-31 21:12:07", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 14, "deletions": 3, "lines": 17}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 12, "deletions": 1, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 40, "deletions": 6, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithSyncFusionSingle()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithSyncFusionMultiple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.subscribeWithAsyncFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalHidden()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalHiddenBackpressured()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normal()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.normalBackpressured()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionSingle()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishTest.syncFusionMultiple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "8579316184e959a1325e025fbb6cfd9bea9d0663", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["a318b977d62d196fd5f6524bc4e3bbc1858bf1e9", "ee45db06e42087f0e6d0d70c0f1bcf48cd0c2b55"], "nameRev": "8579316184e959a1325e025fbb6cfd9bea9d0663 tags/v3.2.0.M4~9", "commitMessage": "Merge backport of #1290 into 3.2\n", "commitDateTime": "2018-08-01 10:02:16", "authoredDateTime": "2018-08-01 10:02:16", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "log() after window leads to UnsupportedOperationException", "body": "The following example with `log()` after `window(3)` leads to a `java.lang.UnsupportedOperationException`:\r\n\r\n```kotlin\r\nFlux.just(1, 2, 3, 4, 5, 6, 7, 8)\r\n        .window(3)\r\n        .log(\"demo\")\r\n        .subscribe()\r\n```\r\n\r\nIt works if I move the `log()` method call before `window(3)`:\r\n\r\n```kotlin\r\nFlux.just(1, 2, 3, 4, 5, 6, 7, 8)\r\n        .log(\"demo\")\r\n        .window(3)\r\n        .subscribe()\r\n```\r\n\r\nIt looks a bit like a Log4j problem, but the Log4j config is actually very basic:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Configuration status=\"WARN\">\r\n    <Appenders>\r\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\r\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\r\n        </Console>\r\n    </Appenders>\r\n    <Loggers>\r\n        <Root level=\"info\">\r\n            <AppenderRef ref=\"Console\"/>\r\n        </Root>\r\n    </Loggers>\r\n</Configuration>\r\n```\r\n\r\n### Expected behavior\r\n\r\nUsual logging.\r\n\r\n### Actual behavior\r\n\r\nThe code throws an `UnsupportedOperationException` with this stacktrace:\r\n\r\n```\r\n3:00:05.918 [main] INFO  demo - onSubscribe(FluxWindow.WindowExactSubscriber)\r\n13:00:05.928 [main] INFO  demo - request(unbounded)\r\n2018-06-28 13:00:05,934 main ERROR An exception occurred processing Appender Console java.lang.UnsupportedOperationException: Operators should not use this method!\r\n\tat reactor.core.Fuseable$QueueSubscription.iterator(Fuseable.java:140)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendCollection(ParameterFormatter.java:593)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:501)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:457)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.formatMessage2(ParameterFormatter.java:190)\r\n\tat org.apache.logging.log4j.message.ParameterizedMessage.formatTo(ParameterizedMessage.java:228)\r\n\tat org.apache.logging.log4j.core.pattern.MessagePatternConverter.format(MessagePatternConverter.java:123)\r\n\tat org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:334)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:233)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:218)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:58)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:177)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:170)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:161)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:448)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:433)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:417)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:403)\r\n\tat org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:63)\r\n\tat org.apache.logging.log4j.core.Logger.logMessage(Logger.java:146)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2163)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2118)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2101)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2006)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1875)\r\n\tat org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:194)\r\n\tat reactor.util.Loggers$Slf4JLogger.info(Loggers.java:238)\r\n\tat reactor.core.publisher.SignalLogger.log(SignalLogger.java:180)\r\n\tat reactor.core.publisher.SignalLogger.lambda$onNextCall$2(SignalLogger.java:237)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:177)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onNext(FluxWindow.java:164)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.fastPath(FluxArray.java:171)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.request(FluxArray.java:96)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.request(FluxWindow.java:216)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130)\r\n\tat reactor.core.publisher.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:89)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onSubscribe(FluxWindow.java:144)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:54)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:60)\r\n\tat reactor.core.publisher.FluxWindow.subscribe(FluxWindow.java:89)\r\n\tat reactor.core.publisher.FluxLog.subscribe(FluxLog.java:50)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6877)\r\n\tat reactor.core.publisher.Flux.subscribeWith(Flux.java:7044)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6870)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6834)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6752)\r\n\tat com.example.domain.operators.TimeBasedWindowOperatorTest.test(TimeBasedWindowOperatorTest.kt:51)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:513)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170)\r\n\tat org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)\r\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)\r\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n\r\n2018-06-28 13:00:05,943 main ERROR An exception occurred processing Appender Console java.lang.UnsupportedOperationException: Operators should not use this method!\r\n\tat reactor.core.Fuseable$QueueSubscription.iterator(Fuseable.java:140)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendCollection(ParameterFormatter.java:593)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:501)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:457)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.formatMessage2(ParameterFormatter.java:190)\r\n\tat org.apache.logging.log4j.message.ParameterizedMessage.formatTo(ParameterizedMessage.java:228)\r\n\tat org.apache.logging.log4j.core.pattern.MessagePatternConverter.format(MessagePatternConverter.java:123)\r\n\tat org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:334)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:233)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:218)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:58)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:177)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:170)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:161)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:448)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:433)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:417)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:403)\r\n\tat org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:63)\r\n\tat org.apache.logging.log4j.core.Logger.logMessage(Logger.java:146)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2163)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2118)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2101)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2006)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1875)\r\n\tat org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:194)\r\n\tat reactor.util.Loggers$Slf4JLogger.info(Loggers.java:238)\r\n\tat reactor.core.publisher.SignalLogger.log(SignalLogger.java:180)\r\n\tat reactor.core.publisher.SignalLogger.lambda$onNextCall$2(SignalLogger.java:237)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:177)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onNext(FluxWindow.java:164)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.fastPath(FluxArray.java:171)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.request(FluxArray.java:96)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.request(FluxWindow.java:216)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130)\r\n\tat reactor.core.publisher.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:89)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onSubscribe(FluxWindow.java:144)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:54)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:60)\r\n\tat reactor.core.publisher.FluxWindow.subscribe(FluxWindow.java:89)\r\n\tat reactor.core.publisher.FluxLog.subscribe(FluxLog.java:50)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6877)\r\n\tat reactor.core.publisher.Flux.subscribeWith(Flux.java:7044)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6870)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6834)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6752)\r\n\tat com.example.domain.operators.TimeBasedWindowOperatorTest.test(TimeBasedWindowOperatorTest.kt:51)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:513)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170)\r\n\tat org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)\r\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)\r\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n\r\n2018-06-28 13:00:05,950 main ERROR An exception occurred processing Appender Console java.lang.UnsupportedOperationException: Operators should not use this method!\r\n\tat reactor.core.Fuseable$QueueSubscription.iterator(Fuseable.java:140)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendCollection(ParameterFormatter.java:593)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:501)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:457)\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.formatMessage2(ParameterFormatter.java:190)\r\n\tat org.apache.logging.log4j.message.ParameterizedMessage.formatTo(ParameterizedMessage.java:228)\r\n\tat org.apache.logging.log4j.core.pattern.MessagePatternConverter.format(MessagePatternConverter.java:123)\r\n\tat org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:334)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:233)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:218)\r\n\tat org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:58)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:177)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:170)\r\n\tat org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:161)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120)\r\n\tat org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:448)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:433)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:417)\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:403)\r\n\tat org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:63)\r\n\tat org.apache.logging.log4j.core.Logger.logMessage(Logger.java:146)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2163)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2118)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2101)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2006)\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1875)\r\n\tat org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:194)\r\n\tat reactor.util.Loggers$Slf4JLogger.info(Loggers.java:238)\r\n\tat reactor.core.publisher.SignalLogger.log(SignalLogger.java:180)\r\n\tat reactor.core.publisher.SignalLogger.lambda$onNextCall$2(SignalLogger.java:237)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:177)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onNext(FluxWindow.java:164)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.fastPath(FluxArray.java:171)\r\n\tat reactor.core.publisher.FluxArray$ArraySubscription.request(FluxArray.java:96)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.request(FluxWindow.java:216)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130)\r\n\tat reactor.core.publisher.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:89)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163)\r\n\tat reactor.core.publisher.FluxWindow$WindowExactSubscriber.onSubscribe(FluxWindow.java:144)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:54)\r\n\tat reactor.core.publisher.FluxArray.subscribe(FluxArray.java:60)\r\n\tat reactor.core.publisher.FluxWindow.subscribe(FluxWindow.java:89)\r\n\tat reactor.core.publisher.FluxLog.subscribe(FluxLog.java:50)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6877)\r\n\tat reactor.core.publisher.Flux.subscribeWith(Flux.java:7044)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6870)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6834)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6752)\r\n\tat com.example.domain.operators.TimeBasedWindowOperatorTest.test(TimeBasedWindowOperatorTest.kt:51)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:513)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170)\r\n\tat org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\r\n\tat java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\r\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116)\r\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)\r\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\r\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\r\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\r\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\r\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121)\r\n\tat org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)\r\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)\r\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nRun this method:\r\n\r\n```kotlin\r\nimport reactor.core.publisher.Flux\r\n\r\nfun main(args: Array<String>) {\r\n    Flux.just(1, 2, 3, 4, 5, 6, 7, 8)\r\n            .window(3)\r\n            .log(\"demo\")\r\n            .subscribe()\r\n}\r\n```\r\n\r\n### Reactor Core version\r\n\r\n3.1.8.RELEASE\r\n\r\n### JVM version\r\n\r\n1.8.0_172", "url": "https://github.com/reactor/reactor-core/issues/1270", "user": "helmbold", "labels": ["status/has-workaround", "type/bug", "type/enhancement"], "created": "2018-06-28 11:17:12", "closed": "2018-07-02 09:06:43", "commits": {"a20b840e103f62ee246e0e151e139dc91eaa22fa": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b6698270a740c6dd725def6de4a66ae3951513a2": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "b56d75a9e7211c307d641e805e850cbe10c1f016": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "a20b840e103f62ee246e0e151e139dc91eaa22fa", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b6698270a740c6dd725def6de4a66ae3951513a2", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["abd5ffe34230128eddf0b0309339ff6caa120031"], "nameRev": "b6698270a740c6dd725def6de4a66ae3951513a2 tags/v3.2.0.M3~10^2", "commitMessage": "fix #1270 Explicitly log() QueueSubcription as toString during onNext\n\nThis is done by catching `UnsupportedOperationException` in\r\n`SignalLogger`. The exception is additionally logged in DEBUG mode.\r\n\r\n`SignalLogger` has been reworked a bit (`log(...)` was called with a\r\n3rd unused parameter), and the `QueueSubcription` UOE message has been\r\nreworded.", "commitDateTime": "2018-07-02 11:05:14", "authoredDateTime": "2018-07-02 11:05:14", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Fuseable.java", "insertions": 19, "deletions": 14, "lines": 33}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java", "insertions": 53, "deletions": 27, "lines": 80}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java", "insertions": 31, "deletions": 7, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Fuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.peek()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.add(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.offer(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.remove()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.element()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.contains(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.iterator()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.toArray()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.toArray(java.lang.Object[])", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.remove(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.containsAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.addAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.removeAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.retainAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SignalLogger.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLogger.log(java.lang.Object[])", "TOT": 7, "UPD": 7, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onNextCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onSubscribeCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCurrentContextCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCompleteCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onRequestCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCancelCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.safeLog(reactor.core.publisher.SignalType,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.log(reactor.core.publisher.SignalType,java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.subscriptionAsString(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "SignalLoggerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.testLogCollectionSubscription()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.monoLogWithGivenLogger()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.fluxLogWithGivenLogger()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.testLogQueueSubscriptionValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b56d75a9e7211c307d641e805e850cbe10c1f016", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["344628850de592c86b39f89ffe4d6cb8729471cf", "b6698270a740c6dd725def6de4a66ae3951513a2"], "nameRev": "b56d75a9e7211c307d641e805e850cbe10c1f016 tags/v3.2.0.M3~10", "commitMessage": "Merge #1270 fix into 3.2\n", "commitDateTime": "2018-07-02 11:06:11", "authoredDateTime": "2018-07-02 11:06:11", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Fuseable.java", "insertions": 19, "deletions": 14, "lines": 33}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java", "insertions": 53, "deletions": 27, "lines": 80}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java", "insertions": 31, "deletions": 7, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Fuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.peek()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.add(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.offer(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.remove()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.element()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.contains(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.iterator()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.toArray()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.toArray(java.lang.Object[])", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.remove(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.containsAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.addAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.removeAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.retainAll(java.util.Collection)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SignalLogger.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLogger.log(java.lang.Object[])", "TOT": 7, "UPD": 7, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onNextCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onSubscribeCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCurrentContextCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCompleteCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onRequestCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCancelCall()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.safeLog(reactor.core.publisher.SignalType,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.log(reactor.core.publisher.SignalType,java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 6, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.subscriptionAsString(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "SignalLoggerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.testLogCollectionSubscription()", "TOT": 6, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.monoLogWithGivenLogger()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.fluxLogWithGivenLogger()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.testLogQueueSubscriptionValue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b6698270a740c6dd725def6de4a66ae3951513a2"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 72.0, "deletions": 41.0, "lines": 113.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 70.0, "UPD": 8.0, "INS": 22.0, "MOV": 20.0, "DEL": 20.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 26}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core", "reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.contains(java.lang.Object)", "reactor.core.removeAll(java.util.Collection)", "reactor.core.toArray()", "reactor.core.publisher.SignalLogger.log(reactor.core.publisher.SignalType,java.lang.Object)", "reactor.core.containsAll(java.util.Collection)", "reactor.core.add(java.lang.Object)", "reactor.core.publisher.SignalLogger.onCancelCall()", "reactor.core.publisher.SignalLogger.onNextCall()", "reactor.core.publisher.SignalLogger.log(java.lang.Object[])", "reactor.core.publisher.SignalLogger.subscriptionAsString(org.reactivestreams.Subscription)", "reactor.core.element()", "reactor.core.addAll(java.util.Collection)", "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "reactor.core.retainAll(java.util.Collection)", "reactor.core.iterator()", "reactor.core", "reactor.core.remove(java.lang.Object)", "reactor.core.publisher.SignalLogger.onSubscribeCall()", "reactor.core.publisher.SignalLogger.onCompleteCall()", "reactor.core.publisher.SignalLogger.onRequestCall()", "reactor.core.toArray(java.lang.Object[])", "reactor.core.peek()", "reactor.core.publisher.SignalLogger.safeLog(reactor.core.publisher.SignalType,java.lang.Object)", "reactor.core.publisher.SignalLogger.onCurrentContextCall()", "reactor.core.offer(java.lang.Object)", "reactor.core.remove()"]}, {"title": "Dropped signal in ConnectableFlux with multiple subscriptions", "body": "Hi,\r\n\r\nI think that the following code introduces a bug. After onNextDropped is invoked, no more signals are received by the subscriptions.\r\n\r\n### Expected behavior\r\nConsole output:\r\n```\r\nSignal count: 100000\r\nSignal count: 100000\r\n```\r\n\r\n### Actual behavior\r\nConsole output:\r\n```\r\n[DEBUG] (Thread-0) onNextDropped: Test\r\nSignal count: 1458\r\nSignal count: 4\r\n```\r\n\r\n### Steps to reproduce\r\n```\r\nfinal Flux testFlux = Flux.create(fluxSink -> fluxSink.next(\"Test\")).replay(1).refCount();\r\n\r\nfinal Runnable subscriber = () -> {\r\n    final AtomicInteger signalCount = new AtomicInteger();\r\n\r\n    for (int i = 0; i < 100000; i++) {\r\n        testFlux.next().subscribe(signal -> signalCount.incrementAndGet(), System.err::println);\r\n    }\r\n\r\n    System.out.println(\"Signal count: \" + signalCount);\r\n};\r\n\r\nnew Thread(subscriber).start();\r\nnew Thread(subscriber).start();\r\n```\r\n\r\n### Reactor Core version\r\n3.1.8.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n1.8.0_171", "url": "https://github.com/reactor/reactor-core/issues/1260", "user": "stef2georg", "labels": ["type/bug"], "created": "2018-06-25 15:51:45", "closed": "2018-07-24 07:37:44", "commits": {"c8134a2b9629289532f85bf05789191c5eb0f73f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "db3b4c84711bc5f3a09f016952129eb31d5c6f3c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 28.00027777777778, "commitsDetails": [{"commitHash": "c8134a2b9629289532f85bf05789191c5eb0f73f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["e239d65ae1ce2f2d0e83e3977b1c6cb2f9e929dd"], "nameRev": "27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03 tags/v3.2.0.M3~5^2", "commitMessage": "fix #1260 Race condition on refCount quick subscribe-and-cancel\n\nAlso aligns internals of refCount and refCount with grace period.", "commitDateTime": "2018-07-24 09:33:52", "authoredDateTime": "2018-07-24 09:33:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 72, "deletions": 63, "lines": 135}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java", "insertions": 44, "deletions": 36, "lines": 80}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 58, "deletions": 0, "lines": 58}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 30, "deletions": 9, "lines": 39}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)", "TOT": 18, "UPD": 9, "INS": 0, "MOV": 8, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.accept(reactor.core.Disposable)", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.subscribe(reactor.core.CoreSubscriber)", "TOT": 27, "UPD": 5, "INS": 4, "MOV": 13, "DEL": 5}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.innerCancelled()", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 5, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor", "TOT": 11, "UPD": 2, "INS": 1, "MOV": 7, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.upstreamFinished()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.cancel(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.terminated(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGrace.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.subscribe(reactor.core.CoreSubscriber)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.cancel(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "TOT": 16, "UPD": 0, "INS": 7, "MOV": 6, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.timeout(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanMain()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInner()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "db3b4c84711bc5f3a09f016952129eb31d5c6f3c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["e4a9aee41e9f06f17bb3158ffe46684ad9625185", "27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03"], "nameRev": "db3b4c84711bc5f3a09f016952129eb31d5c6f3c tags/v3.2.0.M3~5", "commitMessage": "Merge #1260 into 3.2\n", "commitDateTime": "2018-07-24 09:35:19", "authoredDateTime": "2018-07-24 09:35:19", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 72, "deletions": 63, "lines": 135}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java", "insertions": 44, "deletions": 36, "lines": 80}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 58, "deletions": 0, "lines": 58}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 30, "deletions": 9, "lines": 39}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)", "TOT": 18, "UPD": 9, "INS": 0, "MOV": 8, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.accept(reactor.core.Disposable)", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.subscribe(reactor.core.CoreSubscriber)", "TOT": 27, "UPD": 5, "INS": 4, "MOV": 13, "DEL": 5}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.innerCancelled()", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 5, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor", "TOT": 11, "UPD": 2, "INS": 1, "MOV": 7, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.upstreamFinished()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.cancel(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.terminated(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGrace.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.subscribe(reactor.core.CoreSubscriber)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.cancel(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "TOT": 16, "UPD": 0, "INS": 7, "MOV": 6, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.timeout(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 2, "DEL": 2}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.raceSubscribeAndCancelNoTimeout()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanMain()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.scanInner()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.raceSubscribeAndCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["27dd6e359d1bd43e3a3bbf6b04de7f5bd78ace03"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 116.0, "deletions": 99.0, "lines": 215.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 116.0, "UPD": 25.0, "INS": 21.0, "MOV": 51.0, "DEL": 19.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 16}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxRefCount.RefCountInner.onError(java.lang.Throwable)", "reactor.core.publisher.FluxRefCount.RefCountInner.onComplete()", "reactor.core.publisher.FluxRefCount.RefCountInner.cancel()", "reactor.core.publisher.FluxRefCount.terminated(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "reactor.core.publisher.FluxRefCount.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.innerCancelled()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.upstreamFinished()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.accept(reactor.core.Disposable)", "reactor.core.publisher.FluxRefCountGrace.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxRefCount", "reactor.core.publisher.FluxRefCount.cancel(reactor.core.publisher.FluxRefCount$RefCountMonitor)", "reactor.core.publisher.FluxRefCountGrace.cancel(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "reactor.core.publisher.FluxRefCount.RefCountInner", "reactor.core.publisher.FluxRefCountGrace.timeout(reactor.core.publisher.FluxRefCountGrace$RefConnection)", "reactor.core.publisher.FluxRefCount.RefCountMonitor"]}, {"title": "FluxBufferTimeout cancels itself, FluxBufferWhen subscribe order and cancel guard issues", "body": "Several issues were encountered with a few buffer operators while working on #999 that would make sense addressing in 3.1.x:\r\n\r\n - `FluxBufferTimeout.BufferTimeoutSubscriber#onNext` should cancel the parent `Subscription` in case of TTL task rejection, not itself. Otherwise, the `onError` that is called is effectively NO-OP as the `cancel()` will have altered the state already.\r\n - `FluxBufferWhen` subscribes to the source first and the buffer opening `Publisher` second, leading to possible misses when the open is supposed to be immediate\r\n - `FluxBufferWhen.BufferWhenMainSubscriber#cancel` guard appears wrong: it clears the buffer `queue` WHEN THERE IS WORK IN PROGRESS IN `drain()` (`WINDOWS.getAndIncrement(this) != 0`, where it should probably do it when THERE ISN'T (`WINDOWS.getAndIncrement(this) == 0`)", "url": "https://github.com/reactor/reactor-core/issues/1247", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-06-19 09:57:44", "closed": "2018-06-19 11:17:30", "commits": {"f6f02185b1433095a062bcb6949211b11807184f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5856516cbc2e045efc58febf30e23f728347c763": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "2729e5e551223a49f2463e1c3c297573a1cdc30a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "f6f02185b1433095a062bcb6949211b11807184f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5856516cbc2e045efc58febf30e23f728347c763", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["eda4e80c101f4c7bb3bda4ddda5a0a2e70774345"], "nameRev": "5856516cbc2e045efc58febf30e23f728347c763 tags/v3.2.0.M3~10^2~5", "commitMessage": "fix #1247 Multiple bufferTimeout and bufferWhen issues\n\nThis commit fixe a few issues in bufferTimeout and bufferWhen:\n - a TTL-task rejection in bufferTimeout onNext would not propagate an\n error because it cancels the subscriber rather than the actual\n - bufferWhen should subscribes to source first and buffer-opening\n second\n - bufferWhen race between cancel and drain is wrongly handled, as\n cancel checks the wrong state for the WINDOWS guard\n", "commitDateTime": "2018-06-19 13:14:46", "authoredDateTime": "2018-06-19 12:57:55", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java", "insertions": 50, "deletions": 9, "lines": 59}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxBufferWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.BufferWhenMainSubscriber.cancel()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.rejectedOnNextLeadsToOnError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBufferWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMain()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMainCancelled()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMainCompleted()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanWhenCloseSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanWhenOpenSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.immediateOpen()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.cancelWinsOverDrain()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "2729e5e551223a49f2463e1c3c297573a1cdc30a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["bd21f68a3a0afd8111693b73a461ee2a5ed14641", "5856516cbc2e045efc58febf30e23f728347c763"], "nameRev": "2729e5e551223a49f2463e1c3c297573a1cdc30a tags/v3.2.0.M3~19", "commitMessage": "Merge #1247 fix into 3.2\n", "commitDateTime": "2018-06-19 13:16:11", "authoredDateTime": "2018-06-19 13:16:11", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java", "insertions": 50, "deletions": 9, "lines": 59}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxBufferWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.BufferWhenMainSubscriber.cancel()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.rejectedOnNextLeadsToOnError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBufferWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMain()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMainCancelled()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanStartEndMainCompleted()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanWhenCloseSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.scanWhenOpenSubscriber()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.immediateOpen()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.cancelWinsOverDrain()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5856516cbc2e045efc58febf30e23f728347c763"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3.0, "deletions": 3.0, "lines": 6.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 1.0, "INS": 1.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxBufferWhen.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxBufferWhen.BufferWhenMainSubscriber.cancel()"]}, {"title": "FluxEmpty does not throw NoSuchElementException", "body": "### Expected behavior\r\nThe JavaDoc of Flux#last states:\r\n> [...] or emit NoSuchElementException error if the source was empty\r\n\r\n### Steps to reproduce\r\n    Flux.empty().last().block()\r\n\r\n    Flux.fromIterable(List.of()).block()\r\n\r\n### Actual behavior\r\nThe first line does not throw an Exception and returns `null`. The second example throws a NoSuchElementException.\r\n\r\n### Reactor Core version\r\n3.1.6\r\n\r\n### JVM version (e.g. `java -version`)\r\n9.0.4", "url": "https://github.com/reactor/reactor-core/issues/1226", "user": "Danny02", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-05-30 06:26:28", "closed": "2018-06-06 15:55:00", "commits": {"af0d609f486c27f9941aa6f42de9d2afe49996ce": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "fbe62f41d3bbfd5873d04a436a6194f7b3f02f7b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2b0928689fcc2d360e89969b53c75ebebb869a04": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "787603a29431542986d594b989c76be0b24f336c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "af0d609f486c27f9941aa6f42de9d2afe49996ce", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fbe62f41d3bbfd5873d04a436a6194f7b3f02f7b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2b0928689fcc2d360e89969b53c75ebebb869a04", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["8fdb1e1a65f0a8f9a1fbe1dc943e9856b1d9e84c"], "nameRev": "2b0928689fcc2d360e89969b53c75ebebb869a04 tags/v3.2.0.M2~11", "commitMessage": "fix #1226 Correct NoSuchElementException on callable empty last()\n\nThe operator Flux#last() used to skip the exception on empty source that\r\nwas also a Callable, due to an overeager optimization.", "commitDateTime": "2018-06-06 17:54:57", "authoredDateTime": "2018-06-06 17:54:57", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java", "insertions": 14, "deletions": 2, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.last()", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "MonoTakeLastOneTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoTakeLastOneTest.empty()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOneTest.emptyCallableThrowsNoSuchElement()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "787603a29431542986d594b989c76be0b24f336c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["9020acfb92fc2e1351cf919c5c70777f63049fbd"], "nameRev": "787603a29431542986d594b989c76be0b24f336c tags/v3.1.8.RELEASE~4", "commitMessage": "port #1226 Correct NoSuchElementException on callable empty last()\n\nThe operator Flux#last() used to skip the exception on empty source that\nwas also a Callable, due to an overeager optimization.\n\nThis is a backport of commit 2b09286, as tracked in #1198\n", "commitDateTime": "2018-06-07 09:47:53", "authoredDateTime": "2018-06-06 17:54:57", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java", "insertions": 14, "deletions": 2, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.last()", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 4, "DEL": 1}]}, {"spoonFilePath": "MonoTakeLastOneTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoTakeLastOneTest.empty()", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOneTest.emptyCallableThrowsNoSuchElement()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2b0928689fcc2d360e89969b53c75ebebb869a04"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 2.0, "lines": 8.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 7.0, "UPD": 0.0, "INS": 2.0, "MOV": 4.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.last()"]}, {"title": "DelayUntil request Integer.MAX_VALUE onSubscribe", "body": "", "url": "https://github.com/reactor/reactor-core/issues/1214", "user": "smaldini", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-05-17 18:03:15", "closed": "2018-05-30 04:58:30", "commits": {"77a5cb1e74b1b0f15648e36355257123684ea634": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "0e174992db943bde70c7fcd62d09b9f040239cd5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 12.000277777777777, "commitsDetails": [{"commitHash": "77a5cb1e74b1b0f15648e36355257123684ea634", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["2f74309848326a2906ddc4cb91ff21dd9777ab55"], "nameRev": "77a5cb1e74b1b0f15648e36355257123684ea634 tags/v3.2.0.M2~13", "commitMessage": "Fix #1214 DelayUntil request Integer.MAX_VALUE onSubscribe\n", "commitDateTime": "2018-05-29 21:58:26", "authoredDateTime": "2018-05-29 21:08:49", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoDelayUntil.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntil.DelayUntilTrigger.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "0e174992db943bde70c7fcd62d09b9f040239cd5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["3daea4e6fe16e028394ebcee73041c52e7102f6d"], "nameRev": "0e174992db943bde70c7fcd62d09b9f040239cd5 tags/v3.1.8.RELEASE~6", "commitMessage": "port #1214 DelayUntil request Integer.MAX_VALUE onSubscribe\n\nThis is a backport of commit 77a5cb1, as tracked in #1198\n", "commitDateTime": "2018-06-06 10:43:27", "authoredDateTime": "2018-05-29 21:08:49", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoDelayUntil.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayUntil.DelayUntilTrigger.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["77a5cb1e74b1b0f15648e36355257123684ea634"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoDelayUntil.DelayUntilTrigger.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "`Operators.lift` should transparently return instances compatible with `ConnectableFlux` and `GroupedFlux`", "body": "### Expected behavior\r\nApplying an `Operators.lift()` function on a `ConnectableFlux` or `GroupedFlux` should return an instance compatible with these interfaces.\r\n\r\n### Actual behavior\r\nA `Flux` instance is returned due to no support in `LiftFunction`. This can lead to `ClassCastException`.\r\n\r\n### Steps to reproduce\r\n\r\n### Fix design\r\nLike `MonoLift` and `ParallelLift`, implement a delegating `ConnectableLift` and `GroupedLift` and return these.", "url": "https://github.com/reactor/reactor-core/issues/1204", "user": "simonbasle", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-05-14 13:02:33", "closed": "2018-05-15 18:33:03", "commits": {"b313af477ad611c430ddb9814d8719e69637208f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f0b14c2e31d1565fa9c2c202589dd4ec9f18cab4": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "be4a0e9ca2aa904ce987c9c82545d3c946bcb8b7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "c9406f34e246bff6c475d7ea709bf736ec5a2fae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "b313af477ad611c430ddb9814d8719e69637208f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f0b14c2e31d1565fa9c2c202589dd4ec9f18cab4", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["06ae870afa5059f17eea27f6dff538cfa7c2e313"], "nameRev": "f0b14c2e31d1565fa9c2c202589dd4ec9f18cab4 tags/v3.2.0.M2~23", "commitMessage": "fix #1204 Lift properly maintain GroupedFlux/ConnectableFlux interface\n\nThis commit prevents potential ClassCastExceptions when lifting either a\r\nGroupedFlux or a ConnectableFlux, by instantiating dedicated operators\r\nsimilarly to what is done for ParallelFlux for example.", "commitDateTime": "2018-05-15 20:33:00", "authoredDateTime": "2018-05-15 20:33:00", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java", "insertions": 71, "deletions": 0, "lines": 71}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/GroupedLift.java", "insertions": 74, "deletions": 0, "lines": 74}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 98, "deletions": 0, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLift", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "GroupedLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.GroupedLift", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.LiftFunction.apply(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "be4a0e9ca2aa904ce987c9c82545d3c946bcb8b7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "c9406f34e246bff6c475d7ea709bf736ec5a2fae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["9c4981b297d6f7b00f329015f8cda0c6365a3eb4"], "nameRev": "c9406f34e246bff6c475d7ea709bf736ec5a2fae tags/v3.1.8.RELEASE~9", "commitMessage": "port #1204 Lift properly maintain GroupedFlux/ConnectableFlux interface\n\nThis commit prevents potential ClassCastExceptions when lifting either a\nGroupedFlux or a ConnectableFlux, by instantiating dedicated operators\nsimilarly to what is done for ParallelFlux for example.\n\nThis is a backport of commit f0b14c2, as tracked in #1198\n", "commitDateTime": "2018-05-18 21:54:36", "authoredDateTime": "2018-05-15 20:33:00", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java", "insertions": 71, "deletions": 0, "lines": 71}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/GroupedLift.java", "insertions": 74, "deletions": 0, "lines": 74}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java", "insertions": 98, "deletions": 0, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ConnectableLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ConnectableLift", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "GroupedLift.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.GroupedLift", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.LiftFunction.apply(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LiftFunctionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LiftFunctionTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f0b14c2e31d1565fa9c2c202589dd4ec9f18cab4"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 151.0, "deletions": 0.0, "lines": 151.0, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 4.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.LiftFunction.apply(org.reactivestreams.Publisher)", "reactor.core.publisher.GroupedLift", "reactor.core.publisher.ConnectableLift"]}, {"title": "Wrong subscriber request handling in Flux.onBackpressureBuffer variant with duration/timeout", "body": "### Steps to reproduce\r\n\r\n`Flux.<String>create(fluxSink -> fluxSink`\r\n`                                 .next(\"1\")`\r\n                                  `.next(\"not requested\")`\r\n                                 ` .next(\"not requested\"),`\r\n                    `FluxSink.OverflowStrategy.BUFFER)`\r\n`  .onBackpressureBuffer(Duration.ofSeconds(1), 3, s -> System.out.println(\"dropped \" + s))`  \r\n`    .subscribe(new BaseSubscriber<String>()  {  `  \r\n`        @Override`  \r\n  `     protected void hookOnSubscribe(Subscription subscription) {`  \r\n `       subscription.request(1L);`  \r\n `     }`  \r\n`      @Override`  \r\n`      protected void hookOnNext(String value) {`  \r\n `       System.out.println(value);`  \r\n`      }`  \r\n`    });`  \r\n\r\n### Expected behavior\r\n1\r\n\r\n### Actual behavior\r\n1\r\nnot requested\r\nnot requested\r\n\r\n### Reactor Core version\r\n3.1.7.RELEASE\r\n\r\n### Personal findings\r\nreactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber::drain\r\ndoes not update requested flag\r\n`\r\nif (e != 0L && r != Long.MAX_VALUE) {\r\n\tOperators.produced(REQUESTED, this, e);\r\n}\r\n`", "url": "https://github.com/reactor/reactor-core/issues/1194", "user": "misterxiceguy", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-05-05 20:03:28", "closed": "2018-05-07 11:11:06", "commits": {"01df9877c38ba124ddc250ba23f5bab5d7252fca": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "ae9c90d509bfe36d8e128523dcf64ca3df99b42d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "4be43d3e30d4137ce5ed19ecce44850ce33e86d9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "01df9877c38ba124ddc250ba23f5bab5d7252fca", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ae9c90d509bfe36d8e128523dcf64ca3df99b42d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a5e76ccc7b83925ce4b04069c87088dc5208abb5"], "nameRev": "ae9c90d509bfe36d8e128523dcf64ca3df99b42d tags/v3.2.0.M2~27", "commitMessage": "fix #1194 Request is not accounted for in FluxOnBackpressureBufferTimout\n\n", "commitDateTime": "2018-05-07 07:11:04", "authoredDateTime": "2018-05-07 04:11:04", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java", "insertions": 13, "deletions": 1, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxOnBackpressureBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber.drain()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTimeoutTest.gh1194()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4be43d3e30d4137ce5ed19ecce44850ce33e86d9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["220b7de5c7ef246e348815a1ab002a096a99e652"], "nameRev": "4be43d3e30d4137ce5ed19ecce44850ce33e86d9 tags/v3.1.8.RELEASE~12", "commitMessage": "port #1194 Request is not tracked in FluxOnBackpressureBufferTimout\n\nThis is a backport of #1194 (commit 01df987), as tracked in #1198\n", "commitDateTime": "2018-05-07 13:31:46", "authoredDateTime": "2018-05-07 04:11:04", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java", "insertions": 13, "deletions": 1, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxOnBackpressureBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber.drain()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxOnBackpressureBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTimeoutTest.gh1194()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ae9c90d509bfe36d8e128523dcf64ca3df99b42d"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5.0, "deletions": 1.0, "lines": 6.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber.drain()"]}, {"title": "MonoCacheTime subscribe can get out of order", "body": "The current subscribe() implementation of MonoCacheTime can add subscribers before onSubscribe is call, leading to a potential premature onNext or onComplete signal being emitted.", "url": "https://github.com/reactor/reactor-core/issues/1190", "user": "smaldini", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-05-02 20:42:51", "closed": "2018-05-02 21:23:42", "commits": {"5e041ee9036f16b861123d7d099e15e90070b28f": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "d960fa39faf1849d804ebda54e2374c0075f9621": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "7de4661a3fd2a0cfc429ade970ad3865dbc86bb4": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "5e041ee9036f16b861123d7d099e15e90070b28f", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d960fa39faf1849d804ebda54e2374c0075f9621", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["51dff9f255e6d7ca2fefaf23cb2fb2b9d9ddfdbf"], "nameRev": "d960fa39faf1849d804ebda54e2374c0075f9621 tags/v3.2.0.M2~30", "commitMessage": "fix #1190 - onSubscribe before add in MonoCacheTime.subscribe\n", "commitDateTime": "2018-05-02 14:23:39", "authoredDateTime": "2018-05-02 13:47:33", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 32, "deletions": 22, "lines": 54}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.subscribe(reactor.core.CoreSubscriber)", "TOT": 36, "UPD": 13, "INS": 4, "MOV": 15, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber.cancel()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "7de4661a3fd2a0cfc429ade970ad3865dbc86bb4", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["86de85ab2b05f2f3ef6da9ccd0ad791b87efd587"], "nameRev": "7de4661a3fd2a0cfc429ade970ad3865dbc86bb4 tags/v3.1.7.RELEASE~2", "commitMessage": "port #1190 - onSubscribe before add in MonoCacheTime.subscribe\n", "commitDateTime": "2018-05-02 13:44:48", "authoredDateTime": "2018-05-02 13:44:48", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 32, "deletions": 22, "lines": 54}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.subscribe(reactor.core.CoreSubscriber)", "TOT": 40, "UPD": 10, "INS": 8, "MOV": 14, "DEL": 8}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber.cancel()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d960fa39faf1849d804ebda54e2374c0075f9621", "7de4661a3fd2a0cfc429ade970ad3865dbc86bb4"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 64.0, "deletions": 44.0, "lines": 108.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 92.0, "UPD": 23.0, "INS": 16.0, "MOV": 33.0, "DEL": 20.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber.cancel()", "reactor.core.publisher.MonoCacheTime.CacheMonoSubscriber", "reactor.core.publisher.MonoCacheTime.subscribe(reactor.core.CoreSubscriber)"]}, {"title": "Regression in MonoProcessor ", "body": "The latest MonoProcessor changes for #1114 cause a [test failure](https://build.spring.io/browse/SPR-PUB-6079) in the Spring Framework build. \r\n\r\nFrom what I can tell, [when we turn](https://github.com/spring-projects/spring-framework/blob/af0cb5374271ddeaab09541eb155cba4a8204d61/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpConnection.java#L63) the `Mono<Void>` from a write into a `ListenableFuture` there are two subscribe calls, which then cause the same Netty ByteBuf to be written and decremented twice leading to `IllegalReferenceCountException`. The first (expected) subscribe happens [here](https://github.com/spring-projects/spring-framework/blob/af0cb5374271ddeaab09541eb155cba4a8204d61/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractMonoToListenableFutureAdapter.java#L66) and the second (unexpected) subscribe [here](https://github.com/spring-projects/spring-framework/blob/af0cb5374271ddeaab09541eb155cba4a8204d61/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractMonoToListenableFutureAdapter.java#L73).", "url": "https://github.com/reactor/reactor-core/issues/1184", "user": "rstoyanchev", "labels": ["type/bug"], "created": "2018-05-02 11:21:07", "closed": "2018-05-02 16:45:14", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FluxPublish doesn't defer dispose correctly", "body": "Currently, `FluxPublish.PublishSubscriber#dispose()\" defers the disposing action due to the CancellationException sent back on existing subscribers (and WIP gate).\r\nUnfortunately this might leave the current \"connection\" mixed with racing subscribers, e.g. using retry(). It results in an unwanted CancellationException sent to the new subscriber post PublishSubscriber#dispose. ", "url": "https://github.com/reactor/reactor-core/issues/1173", "user": "smaldini", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-04-25 19:55:31", "closed": "2018-04-26 08:38:11", "commits": {"ba565a178c5342fe33acaacd6d5ee55c66340e4c": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "44426330dc9412db89b924bbb2b231bda2282463": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "8ece13d11995badfe21b3f1b1eb246fc0b0e0923": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "53a4b107b834bed338192324afb1c1af1247289c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "ba565a178c5342fe33acaacd6d5ee55c66340e4c", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "44426330dc9412db89b924bbb2b231bda2282463", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8ece13d11995badfe21b3f1b1eb246fc0b0e0923", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["4e551223913a4fde5fbcc67433ccf34e9d7e9c7b"], "nameRev": "8ece13d11995badfe21b3f1b1eb246fc0b0e0923 tags/v3.2.0.M2~41", "commitMessage": "fix #1173 Tweak FluxPublish dispose to clear the existing connection\n\nThis commit tweaks the dispose of `FluxPublish` so that it clears the\r\nexisting connection and avoids sending a `CancellationException` to\r\n`Subscribers` that would come in in the meantime (as part of a new\r\nconnection).", "commitDateTime": "2018-04-26 10:38:08", "authoredDateTime": "2018-04-26 01:38:08", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 14, "deletions": 10, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 26, "deletions": 1, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishInner.removeAndDrainParent()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 4, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.asyncRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "53a4b107b834bed338192324afb1c1af1247289c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["61fac7026154e64f2a051ae7c815cabee056cbb5"], "nameRev": "53a4b107b834bed338192324afb1c1af1247289c tags/v3.1.7.RELEASE~10", "commitMessage": "fix #1173 Tweak FluxPublish dispose to clear the existing connection\n\nThis commit tweaks the dispose of `FluxPublish` so that it clears the\nexisting connection and avoids sending a `CancellationException` to\n`Subscribers` that would come in in the meantime (as part of a new\nconnection).\n\nThis is a backport of #1173 (commit 8ece13d), as tracked in #1175\n", "commitDateTime": "2018-04-26 10:47:40", "authoredDateTime": "2018-04-26 01:38:08", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 14, "deletions": 10, "lines": 24}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 26, "deletions": 1, "lines": 27}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishInner.removeAndDrainParent()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 4, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.asyncRetry()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["8ece13d11995badfe21b3f1b1eb246fc0b0e0923"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 14.0, "deletions": 10.0, "lines": 24.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 11.0, "UPD": 0.0, "INS": 5.0, "MOV": 6.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction(reactor.core.publisher.FluxPublish$PubSubInner[])", "reactor.core.publisher.FluxPublish.PublishSubscriber.dispose()", "reactor.core.publisher.FluxPublish.PublishSubscriber.disconnectAction()", "reactor.core.publisher.FluxPublish.PublishInner.removeAndDrainParent()", "reactor.core.publisher.FluxPublish.PublishSubscriber.checkTerminated(boolean,boolean)"]}, {"title": "WorkQueueProcessor leaves threads running after forceShutdown()", "body": "### Expected behavior\r\n\r\n`forceShutdown()` completely shutdowns its inner executor, leaving no threads from it running\r\n\r\n### Actual behavior\r\n\r\nOne of the `WorkQueueProcessor`'s inner executor threads keeps running after `forceShutdown()`, even after being interrupted.\r\n\r\n### Steps to reproduce\r\n\r\nThis test (copied from `TopicProcessorTest` into `WorkQueuProcessorTest`) reproduces the behavior:\r\n\r\n```\r\n\t@Test\r\n\tpublic void testForceShutdownAfterShutdown() throws InterruptedException {\r\n\t\tWorkQueueProcessor<String> processor = WorkQueueProcessor.<String>builder()\r\n\t\t\t\t.name(\"processor\").bufferSize(4).build();\r\n\t\tPublisher<String> publisher = Flux.fromArray(new String[] { \"1\", \"2\", \"3\", \"4\", \"5\" });\r\n\t\tpublisher.subscribe(processor);\r\n\t\t\r\n\t\tAssertSubscriber<String> subscriber = AssertSubscriber.create(0);\r\n\t\tprocessor.subscribe(subscriber);\r\n\t\t\r\n\t\tsubscriber.request(1);\r\n\t\t\r\n\t\tThread.sleep(250);\r\n\t\t\r\n\t\tprocessor.shutdown();\r\n\t\t\r\n\t\tassertFalse(processor.awaitAndShutdown(Duration.ofMillis(400)));\r\n\t\t\r\n\t\tprocessor.forceShutdown();\r\n\t\t\r\n\t\t// This assertion fails\r\n\t\tassertTrue(processor.awaitAndShutdown(Duration.ofMillis(400)));\r\n\t}\r\n```\r\nA thread dump taken before the failing assertion, shows just one of the threads still running:\r\n```\r\n\"processor-1\" #16 daemon prio=5 os_prio=0 tid=0x00007f56e0680000 nid=0x390b runnable [0x00007f5721c66000]\r\n   java.lang.Thread.State: RUNNABLE\r\n        at sun.misc.Unsafe.park(Native Method)\r\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:312)\r\n        at reactor.core.publisher.WorkQueueProcessor$WorkQueueInner.run(WorkQueueProcessor.java:505)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1129)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\r\n        at java.lang.Thread.run(Thread.java:748)\r\n\r\n   Locked ownable synchronizers:\r\n        - <0x000000076d598d18> (a java.util.concurrent.ThreadPoolExecutor$Worker)\r\n```\r\n\r\n### Reactor Core version\r\n`3.2.0.M1`\r\n\r\n### JVM version (e.g. `java -version`)\r\njava version \"1.8.0_161\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_161-b12)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)\r\n", "url": "https://github.com/reactor/reactor-core/issues/1142", "user": "elrodro83", "labels": ["type/bug"], "created": "2018-03-24 17:39:55", "closed": "2018-05-01 15:21:55", "commits": {"c431c8b58655f5a9b937c59f4ab50bcc35bc2a85": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6e1e63a43c11266ca9dec358c489632407586117": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7bde523722906dce38b683d8c083930a107f2ded": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "07b3e12555b6ff6f2c8df2693a1e1e14be936ee4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 37.000277777777775, "commitsDetails": [{"commitHash": "c431c8b58655f5a9b937c59f4ab50bcc35bc2a85", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6e1e63a43c11266ca9dec358c489632407586117", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7bde523722906dce38b683d8c083930a107f2ded", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["66051ffd53632db92b00b0c8ccd0cc27e90432d0"], "nameRev": "7bde523722906dce38b683d8c083930a107f2ded tags/v3.2.0.M2~37", "commitMessage": "fix #1142 Dangling thread when calling WorkQueueProcessor.forceShutdown\n\n", "commitDateTime": "2018-05-01 11:21:52", "authoredDateTime": "2018-05-01 11:21:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 23, "deletions": 9, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/TopicProcessorVerification.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/WorkQueueProcessorVerification.java", "insertions": 5, "deletions": 3, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "WorkQueueProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.run()", "TOT": 10, "UPD": 0, "INS": 5, "MOV": 2, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.isRunning()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.replay(boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.testForceShutdownAfterShutdown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TopicProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.TopicProcessorVerification.createIdentityProcessor(int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.WorkQueueProcessorVerification.createIdentityProcessor(int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.tck.WorkQueueProcessorVerification.required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "07b3e12555b6ff6f2c8df2693a1e1e14be936ee4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["4b4f20a55d2f39218e374b0632518da74c600a0f"], "nameRev": "07b3e12555b6ff6f2c8df2693a1e1e14be936ee4 tags/v3.1.7.RELEASE~7", "commitMessage": "port #1142 Dangling thread when calling WorkQueueProcessor.forceShutdown\n\nThis is a backport of #1142 (commit 7bde5237), as tracked in #1175\n", "commitDateTime": "2018-05-01 11:29:24", "authoredDateTime": "2018-05-01 11:21:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 23, "deletions": 9, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/TopicProcessorVerification.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/WorkQueueProcessorVerification.java", "insertions": 5, "deletions": 3, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "WorkQueueProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.run()", "TOT": 10, "UPD": 0, "INS": 5, "MOV": 2, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.isRunning()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.replay(boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.testForceShutdownAfterShutdown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TopicProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.TopicProcessorVerification.createIdentityProcessor(int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.WorkQueueProcessorVerification.createIdentityProcessor(int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.tck.WorkQueueProcessorVerification.required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7bde523722906dce38b683d8c083930a107f2ded"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 23.0, "deletions": 9.0, "lines": 32.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 17.0, "UPD": 2.0, "INS": 8.0, "MOV": 3.0, "DEL": 4.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.tck.WorkQueueProcessorVerification.required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo()", "reactor.core.publisher.tck.TopicProcessorVerification.createIdentityProcessor(int)", "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.isRunning()", "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.run()", "reactor.core.publisher.tck.WorkQueueProcessorVerification.createIdentityProcessor(int)", "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.replay(boolean)"]}, {"title": "Mono.cache() loses Context", "body": "With the following code:\r\n```\r\nfinal String value = Mono.subscriberContext( )\r\n\t.cache( )\r\n\t.subscriberContext( Context.of( \"a\", \"GOOD\" ) )\r\n\t.map( x -> x.getOrDefault( \"a\", \"BAD\" ) )\r\n\t.block( );\r\nSystem.out.println( value );\r\n```\r\n### Expected behavior\r\nAn output of `GOOD`.\r\n\r\n### Actual behavior\r\nAn output of `BAD`.\r\n\r\n### Reactor Core version\r\n3.1.5.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\njava version \"1.8.0_131\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\r\n", "url": "https://github.com/reactor/reactor-core/issues/1114", "user": "Vulcannis", "labels": ["status/backported-3.1", "type/bug"], "created": "2018-03-07 22:06:12", "closed": "2018-05-02 16:44:13", "commits": {"7b947904e889dda67447d42f386ad982fcb94633": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a9c5a8dd228a3dec5d4758c816c4ed1b47cb2246": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f17795d3ab60f41785f71fc42c8d0dd8dda7724a": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6e5af65830e757d827daf3d27c907ecc387411c7": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "bd7586bee49e750b2925a975127db37fdca46f33": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "c6f89949f4c488e4853a49f45e4d93949d90e6f0": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "d2d352d68c2d588ecd5dd6dc6a6d1d887a52fef2": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "318b770b27ff2658bf8c8acbf4cab193186d8b36": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "3a498352b434791de3a32684683ad3e1d08415b6": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "df3d03746dc0bb53b3c3caf50637ddf9631591fb": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "3c680df90bebaeb1df77d18b89ec2eca53bc4815": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "dd858f0325bceb73969cbd63eafd6ed224636b6b": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "fa97347fa92b596149b3dafbc3d1b43af5937e82": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "ad7039dc43c84a42f50d55f6b1cbbc6636e82149": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "f8a018ed98e8a98a223111bb79e553d5d34af25d": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6ab518681f42b4e3b683d4d1200b048a5c450784": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "1a47421c026078595b73786090b991db9baf58dd": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6016be41554389583a9b5d54bbe9ab2204e8cddc": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "64318b5f36e30c5cb9ddc0742d15778ce773d5f7": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "aa5ca5014f765636bb836945e8fede60c926a403": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "38b86698668ecbd2bcb5c59506820814cf83ffd9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "c6b75f2578ee5f201ac06add2239322cc5b7bfcd": {"commitGHEventType": "referenced", "commitUser": "bsideup"}}, "ttf": 55.000277777777775, "commitsDetails": [{"commitHash": "7b947904e889dda67447d42f386ad982fcb94633", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a9c5a8dd228a3dec5d4758c816c4ed1b47cb2246", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f17795d3ab60f41785f71fc42c8d0dd8dda7724a", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6e5af65830e757d827daf3d27c907ecc387411c7", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "bd7586bee49e750b2925a975127db37fdca46f33", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "c6f89949f4c488e4853a49f45e4d93949d90e6f0", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d2d352d68c2d588ecd5dd6dc6a6d1d887a52fef2", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "318b770b27ff2658bf8c8acbf4cab193186d8b36", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3a498352b434791de3a32684683ad3e1d08415b6", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "df3d03746dc0bb53b3c3caf50637ddf9631591fb", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3c680df90bebaeb1df77d18b89ec2eca53bc4815", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "dd858f0325bceb73969cbd63eafd6ed224636b6b", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fa97347fa92b596149b3dafbc3d1b43af5937e82", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ad7039dc43c84a42f50d55f6b1cbbc6636e82149", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f8a018ed98e8a98a223111bb79e553d5d34af25d", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6ab518681f42b4e3b683d4d1200b048a5c450784", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["37ce9e5a69ba184a20af75443948a0691071bf1a"], "nameRev": "6ab518681f42b4e3b683d4d1200b048a5c450784 tags/v3.1.7.RELEASE~5", "commitMessage": "port MonoProcessor simplification in preparation for #1114\n", "commitDateTime": "2018-05-02 10:22:29", "authoredDateTime": "2018-05-02 10:22:29", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCompletionStage.java", "insertions": 5, "deletions": 3, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 274, "deletions": 264, "lines": 538}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "1a47421c026078595b73786090b991db9baf58dd", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6016be41554389583a9b5d54bbe9ab2204e8cddc", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["7bde523722906dce38b683d8c083930a107f2ded"], "nameRev": "6016be41554389583a9b5d54bbe9ab2204e8cddc tags/v3.2.0.M2~36", "commitMessage": "Simplify MonoProcessor internals in preparation for #1114 and further 3.2 changes\n\nFix double MonoProcessor subscribe in toProcessor\n", "commitDateTime": "2018-05-02 12:19:07", "authoredDateTime": "2018-05-01 07:22:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCompletionStage.java", "insertions": 5, "deletions": 3, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 274, "deletions": 264, "lines": 538}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "64318b5f36e30c5cb9ddc0742d15778ce773d5f7", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["6016be41554389583a9b5d54bbe9ab2204e8cddc"], "nameRev": "64318b5f36e30c5cb9ddc0742d15778ce773d5f7 tags/v3.2.0.M2~35", "commitMessage": "fix #1114 Resolve to 1st context found for multi-subscribers\n\nNote that due to the multi-subscriber nature of those processors or\noperators, context availability is volatile as subscribers may\ncome and go concurrently.\nA small tweak has been applied to fluxReplay to make sure the subscribers\n list is being updated before source subscribe\n", "commitDateTime": "2018-05-02 12:27:15", "authoredDateTime": "2018-05-01 11:53:36", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 19, "deletions": 13, "lines": 32}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 5, "deletions": 10, "lines": 15}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCacheTest.java", "insertions": 72, "deletions": 1, "lines": 73}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 33, "deletions": 2, "lines": 35}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "insertions": 29, "deletions": 0, "lines": 29}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.subscribe(reactor.core.CoreSubscriber)", "TOT": 20, "UPD": 1, "INS": 6, "MOV": 8, "DEL": 5}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.actual()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.signalCached(reactor.core.publisher.Signal)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor.currentContext()", "TOT": 8, "UPD": 2, "INS": 1, "MOV": 2, "DEL": 3}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.multiSubscribersContext(reactor.core.publisher.InnerProducer[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ReplayProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ReplayProcessor.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxCacheTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCacheTest.cacheContextHistory()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCacheTest.cacheContextTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxReplayTest.java", "spoonMethods": []}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.contextFromFirstSubscriberCached()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.monoCacheContextHistory()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "aa5ca5014f765636bb836945e8fede60c926a403", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["6ab518681f42b4e3b683d4d1200b048a5c450784"], "nameRev": "aa5ca5014f765636bb836945e8fede60c926a403 tags/v3.1.7.RELEASE~4", "commitMessage": "port #1114 Resolve the 1st context found for multi-subscribers ops\n", "commitDateTime": "2018-05-02 12:31:28", "authoredDateTime": "2018-05-02 10:05:58", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 19, "deletions": 13, "lines": 32}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 5, "deletions": 10, "lines": 15}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxCacheTest.java", "insertions": 72, "deletions": 1, "lines": 73}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 33, "deletions": 2, "lines": 35}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "insertions": 34, "deletions": 3, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.subscribe(reactor.core.CoreSubscriber)", "TOT": 20, "UPD": 1, "INS": 6, "MOV": 8, "DEL": 5}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.actual()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCacheTime.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor.currentContext()", "TOT": 8, "UPD": 2, "INS": 1, "MOV": 2, "DEL": 3}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.multiSubscribersContext(reactor.core.publisher.InnerProducer[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ReplayProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ReplayProcessor.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxCacheTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCacheTest.cacheContextHistory()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCacheTest.cacheContextTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxReplayTest.java", "spoonMethods": []}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.contextFromFirstSubscriberCached()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.promiseOnAfter()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.promiseDelays()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.monoCacheContextHistory()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "38b86698668ecbd2bcb5c59506820814cf83ffd9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["80d78bccd01db9c1f4bab5729fab5aa10ba310a0"], "nameRev": "38b86698668ecbd2bcb5c59506820814cf83ffd9 tags/v3.2.13.RELEASE~4", "commitMessage": "fix #1968 Make FluxPublish propagate 1st subscriber context\n\nFluxPublish operator should propagate the first subscriber context,\r\nlike FluxReplay does.\r\n\r\nRelates-to: #1114", "commitDateTime": "2019-11-25 09:47:08", "authoredDateTime": "2019-11-25 10:47:08", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 8, "deletions": 2, "lines": 10}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 29, "deletions": 1, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.subscriberContextPropagation()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "c6b75f2578ee5f201ac06add2239322cc5b7bfcd", "commitGHEventType": "referenced", "commitUser": "bsideup", "commitParents": ["437a16e7ce06ecf81024a7e6f53787ae4352db56"], "nameRev": "c6b75f2578ee5f201ac06add2239322cc5b7bfcd tags/v3.3.2.RELEASE~18", "commitMessage": "Explicit `currentContext()` (#1988)\n\nAs seen in issues like https://github.com/reactor/reactor-core/issues/1114,\r\ndue to the default `currentContext()` in `CoreSubscriber`,\r\nwe sometimes forget to delegate the context to the actual one.\r\n\r\nTo prevent it, this change adds an ArchUnit rule to check that we always\r\nexplicitly implement `currentContext()`.\r\n\r\nAfter running the check, a few potentially buggy places were discovered & fixed:\r\n- `FluxBufferWhen`\r\n- `FluxTimeout`", "commitDateTime": "2019-12-10 18:16:20", "authoredDateTime": "2019-12-10 18:16:20", "commitGitStats": [{"filePath": "reactor-core/build.gradle", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingOptionalMonoSubscriber.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxTimeout.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/StrictSubscriber.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/CoreSubscriberArchTest.java", "insertions": 63, "deletions": 0, "lines": 63}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingIterable.SubscriberIterator.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterable.SubscriberIterator.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BlockingOptionalMonoSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingOptionalMonoSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "BlockingSingleSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingSingleSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBufferWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.BufferWhenOpenSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhen.BufferWhenCloseSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxProcessor.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTimeout.TimeoutOtherSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoToCompletableFuture.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoToCompletableFuture.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.DrainSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.1.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StrictSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.StrictSubscriber.currentContext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CoreSubscriberArchTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.CoreSubscriberArchTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6ab518681f42b4e3b683d4d1200b048a5c450784", "6016be41554389583a9b5d54bbe9ab2204e8cddc", "64318b5f36e30c5cb9ddc0742d15778ce773d5f7", "aa5ca5014f765636bb836945e8fede60c926a403", "c6b75f2578ee5f201ac06add2239322cc5b7bfcd"], "filteredCommitsReason": {"duplicated": 16, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 5, "gitStatsSummary": {"insertions": 715.0, "deletions": 593.0, "lines": 1308.0, "gitFilesChange": 16}, "spoonStatsSummary": {"TOT": 87.0, "UPD": 6.0, "INS": 45.0, "MOV": 20.0, "DEL": 16.0, "spoonFilesChanged": 13, "spoonMethodsChanged": 24}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", "reactor-core"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.multiSubscribersContext(reactor.core.publisher.InnerProducer[])", "reactor.core.publisher.FluxReplay.ReplaySubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxReplay.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.ReplayProcessor.onNext(java.lang.Object)", "reactor.core.publisher.MonoProcessor.currentContext()", "reactor.core.publisher.ReplayProcessor.currentContext()", "reactor.core.publisher.FluxReplay.actual()", "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.currentContext()", "reactor.core.publisher.FluxReplay.ReplaySubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxReplay.ReplaySubscriber.currentContext()", "reactor.core.publisher.FluxProcessor.currentContext()", "reactor.core.publisher.BlockingIterable.SubscriberIterator.currentContext()", "reactor.core.publisher.FluxBufferWhen.BufferWhenOpenSubscriber.currentContext()", "reactor.core.publisher.FluxTimeout.TimeoutOtherSubscriber.currentContext()", "reactor.core.publisher.BlockingSingleSubscriber.currentContext()", "reactor.core.publisher.MonoToCompletableFuture.currentContext()", "reactor.core.publisher.StrictSubscriber.currentContext()", "reactor.core.publisher.BlockingIterable.SubscriberIterator.onNext(java.lang.Object)", "reactor.core.publisher.Operators.1.currentContext()", "reactor.core.publisher.Operators.DrainSubscriber.currentContext()", "reactor.core.publisher.MonoToCompletableFuture.onNext(java.lang.Object)", "reactor.core.publisher.FluxBufferWhen.BufferWhenCloseSubscriber.currentContext()", "reactor.core.publisher.BlockingOptionalMonoSubscriber.currentContext()", "reactor.core.publisher.MonoCacheTime.CoordinatorSubscriber.signalCached(reactor.core.publisher.Signal)"]}, {"title": "Should flatMap and merge need to send cancelation signal if they were canceled?", "body": "In my case, `createAsyncMono` returns a `Mono` which creates a socket (and listen to messages) that must be closed inside `onCancel` __only if__ `flatMap` (or `merge`) didn't pass it on. For now, the returned `Mono` will be completed and will never be canceled. I can't use `onDispose` because `onDispose` will be called even if the `flatMap` passed the socket on...\r\n\r\n```java\r\npublic static Mono<Integer> createAsyncMono(int i) {\r\n    return Mono.<Integer>create(sink -> {\r\n        sink.onCancel(() ->\r\n                System.out.println(\"cancel signal sent to Mono.create(\" + i + \")\"));\r\n        System.out.println(\"start calculation inside Mono.create(\" + i + \")\");\r\n        sink.success(i);\r\n    }).subscribeOn(Schedulers.elastic());\r\n}\r\n\r\npublic static void doWork() {\r\n    Flux.just(1, 2)\r\n            .flatMap(App::createAsyncMono)\r\n            .limitRequest(1)\r\n            .subscribe(System.out::println,\r\n                    Throwable::printStackTrace,\r\n                    () -> System.out.println(\"finish-work\"));\r\n}\r\n```\r\n\r\n### Expected behavior\r\n```java\r\nstart calculation inside Mono.create(1)\r\nstart calculation inside Mono.create(2)\r\n1\r\nfinish-work\r\ncancel signal sent to Mono.create(2)\r\n```\r\nor\r\n```java\r\nstart calculation inside Mono.create(1)\r\nstart calculation inside Mono.create(2)\r\n2\r\nfinish-work\r\ncancel signal sent to Mono.create(1)\r\n```\r\n### Actual behavior\r\n```java\r\nstart calculation inside Mono.create(1)\r\n1\r\nfinish-work\r\nstart calculation inside Mono.create(2)\r\n```\r\n### Reactor Core version\r\n`Bismuth-SR7`\r\n### JVM version (e.g. `java -version`)\r\n`1.8`", "url": "https://github.com/reactor/reactor-core/issues/1113", "user": "stavalfi", "labels": ["type/bug"], "created": "2018-03-07 21:51:49", "closed": "2018-03-27 17:35:58", "commits": {}, "ttf": 19.00027777777778, "commitsDetails": []}, {"title": "CancellationException occurs while subscribing to connectable hot source", "body": "I think the following scenario introduces a bug.\r\n\r\n### Expected behavior\r\n\r\n> test\r\n> test\r\n\r\n### Actual behavior\r\n\r\n> test\r\n> Exception in thread \"main\" reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.CancellationException: Disconnected\r\n> Caused by: java.util.concurrent.CancellationException: Disconnected\r\n>     at reactor.core.publisher.FluxReplay$ReplaySubscriber.dispose(FluxReplay.java:1202)\r\n>     at reactor.core.publisher.OperatorDisposables.dispose(OperatorDisposables.java:132)\r\n>     at reactor.core.publisher.FluxRefCount$RefCountMonitor.innerCancelled(FluxRefCount.java:132)\r\n>     at reactor.core.publisher.FluxRefCount$RefCountInner.cancel(FluxRefCount.java:200)\r\n>     at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:75)\r\n>     at reactor.core.publisher.FluxRefCount$RefCountInner.onNext(FluxRefCount.java:177)\r\n>     at reactor.core.publisher.FluxReplay$SizeBoundReplayBuffer.replayNormal(FluxReplay.java:808)\r\n>     at reactor.core.publisher.FluxReplay$SizeBoundReplayBuffer.replay(FluxReplay.java:892)\r\n>     at reactor.core.publisher.FluxReplay.subscribe(FluxReplay.java:1085)\r\n>     at reactor.core.publisher.FluxRefCount$RefCountMonitor.subscribe(FluxRefCount.java:116)\r\n>     at reactor.core.publisher.FluxRefCount.subscribe(FluxRefCount.java:77)\r\n>     at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40)\r\n>     at reactor.core.publisher.Mono.subscribe(Mono.java:3077)\r\n>     at reactor.core.publisher.Mono.subscribeWith(Mono.java:3185)\r\n>     at reactor.core.publisher.Mono.subscribe(Mono.java:3071)\r\n>     at reactor.core.publisher.Mono.subscribe(Mono.java:3038)\r\n>     at reactor.core.publisher.Mono.subscribe(Mono.java:2985)\r\n>     at test.Test.main(Test.java:10)\r\n\r\n### Steps to reproduce\r\n```\r\nFlux<String> flux = Flux.<String>create(sink -> sink.next(\"test\"))\r\n    .replay(1)\r\n    .refCount();\r\n\r\nflux.subscribe(System.out::println);\r\nflux.next().subscribe(System.out::println); // The exception is thrown here!\r\n```\r\n### Reactor Core version\r\n[3.1.4](https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.4.RELEASE)\r\n### JVM version (e.g. `java -version`)\r\njava version \"1.8.0_121\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\r\n\r\nI also posted a question to [Stackoverflow](https://stackoverflow.com/questions/48888858/cancellationexception-occurs-while-subscribing-to-connectable-hot-source).", "url": "https://github.com/reactor/reactor-core/issues/1088", "user": "stef2georg", "labels": ["type/bug"], "created": "2018-02-21 09:19:44", "closed": "2018-02-26 18:52:36", "commits": {"9f62948d726e07f64db9890552096aec2773d40d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b9df8b3abbc500472eb07c9df359b34ebb03ef3b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "74b94a4eadabf67140d394a4fb9fb3cff267b26a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "3d0a317fcb0541e1cc30866dfc8f26c12062bc2a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "9f62948d726e07f64db9890552096aec2773d40d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b9df8b3abbc500472eb07c9df359b34ebb03ef3b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "74b94a4eadabf67140d394a4fb9fb3cff267b26a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["1c27a1519553de093a0fca0d39350fed46aa9a6c"], "nameRev": "74b94a4eadabf67140d394a4fb9fb3cff267b26a tags/v3.2.0.M2~69", "commitMessage": "fix #1088 FluxRefCount DisconnectException on cancellation race\n\nThis commit reorders the \"subscribers\" state update and the parallel\r\nsource subscription so that an inner source immediately terminating or\r\nimmediately cancelling will still see the correct state.\r\n\r\nThis prevents a `Disconnected` exception when eg. a replaying source is\r\nsubscribed twice (once as a Flux and once as a Mono, using next(), which\r\ncancels on first `onNext`).", "commitDateTime": "2018-02-26 13:52:34", "authoredDateTime": "2018-02-26 13:52:34", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 4, "deletions": 2, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 35, "deletions": 0, "lines": 35}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.cancelDoesntTriggerDisconnectErrorOnFirstSubscribeNoComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.cancelDoesntTriggerDisconnectErrorOnFirstSubscribeDoComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "3d0a317fcb0541e1cc30866dfc8f26c12062bc2a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["55d8b488d9ca5a1ab2c6ccfeba60c66ffd30a7d5"], "nameRev": "3d0a317fcb0541e1cc30866dfc8f26c12062bc2a tags/v3.1.5.RELEASE~4", "commitMessage": "port #1088 FluxRefCount DisconnectException on cancellation race\n\nThis commit reorders the \"subscribers\" state update and the parallel\nsource subscription so that an inner source immediately terminating or\nimmediately cancelling will still see the correct state.\n\nThis prevents a `Disconnected` exception when eg. a replaying source is\nsubscribed twice (once as a Flux and once as a Mono, using next(), which\ncancels on first `onNext`).\n\nThis is a backport of #1096 (commit 74b94a4), as tracked in #1083\n", "commitDateTime": "2018-02-26 19:53:31", "authoredDateTime": "2018-02-26 13:52:34", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 4, "deletions": 2, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 35, "deletions": 0, "lines": 35}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.cancelDoesntTriggerDisconnectErrorOnFirstSubscribeNoComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.cancelDoesntTriggerDisconnectErrorOnFirstSubscribeDoComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["74b94a4eadabf67140d394a4fb9fb3cff267b26a"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4.0, "deletions": 2.0, "lines": 6.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 2.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(reactor.core.CoreSubscriber)"]}, {"title": "ExecutorScheduler is terminated after receiving RejectedExecutionException", "body": "### Expected behavior\r\nWith default rejected execution policy I expect the Scheduler to reject tasks to the caller and continue consuming tasks, after time passes and queue is not full again it should accept new tasks.\r\n\r\n### Actual behavior\r\nException terminates the [ExecutorScheduler ](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java#L66), then parts of the system that shares the Scheduler are unavailable. Also please note [the comment](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java#L60) - I can't understand what does it mean, I guess there's something missing in that statement.  \r\n\r\n### Steps to reproduce\r\n1. Run your app with Mono/Flux that have subscribeOn(yourExecutorScheduler).\r\n2. Generate heavy traffic, so you'll have more tasks than you can handle - fill the bounded queue.\r\n3. Once RejectedExecution happens the Scheduler is terminated and it's useless. \r\n\r\n\r\n### Reactor Core version\r\n3.1.3 \r\n### JVM version (e.g. `java -version`)\r\nOracle 1.8.144", "url": "https://github.com/reactor/reactor-core/issues/1080", "user": "cybuch", "labels": ["type/bug"], "created": "2018-02-16 12:14:38", "closed": "2018-02-20 09:26:15", "commits": {"93d6a482b64bb5f505c487aa77e7f6855d8c707c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b0fca2fe893ff6a89619cfa8fb789c74f26ea83c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "ae33c6c780d7921342a73a1287f2acdad9257dc6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "93d6a482b64bb5f505c487aa77e7f6855d8c707c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b0fca2fe893ff6a89619cfa8fb789c74f26ea83c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["db1126a7fdaa6ed86718c750ab23dd6ccf41482d"], "nameRev": "b0fca2fe893ff6a89619cfa8fb789c74f26ea83c tags/v3.2.0.M2~77", "commitMessage": "fix #1080 Only terminate ExecutorScheduler if underlying is shut down\n\nThis commit prevents the termination of an `ExecutorScheduler` upon any\r\nexception caught during submit. Such an exception could be transient,\r\ncoming from the task itself or even an Executor backed by a temporarily\r\nfull queue.\r\n\r\nThere is still a case where the scheduler can be terminated by a failure\r\nin submit: since `ExecutorScheduler` _can_ be created with a\r\n`ExecutorService`, the scheduler will detect that and check if the\r\n`isShutdown()` status is true, and _only_ in this case would the\r\nScheduler be terminated.", "commitDateTime": "2018-02-20 10:26:13", "authoredDateTime": "2018-02-20 10:26:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java", "insertions": 130, "deletions": 5, "lines": 135}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ExecutorScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorScheduler.schedule(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ExecutorSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingExecutorIsTerminated()", "TOT": 19, "UPD": 3, "INS": 0, "MOV": 15, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.scanBuffered()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingPlainExecutorIsNotTerminated()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingExecutorServiceIsNotTerminated()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingAndShutDownExecutorServiceIsTerminated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ae33c6c780d7921342a73a1287f2acdad9257dc6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["9da9e50e0e052f1bcbbf87e18ab39019e823ab48"], "nameRev": "ae33c6c780d7921342a73a1287f2acdad9257dc6 tags/v3.1.5.RELEASE~10", "commitMessage": "port #1080 Only terminate ExecutorScheduler if underlying is shut down\n\nThis commit prevents the termination of an `ExecutorScheduler` upon any\nexception caught during submit. Such an exception could be transient,\ncoming from the task itself or even an Executor backed by a temporarily\nfull queue.\n\nThere is still a case where the scheduler can be terminated by a failure\nin submit: since `ExecutorScheduler` _can_ be created with a\n`ExecutorService`, the scheduler will detect that and check if the\n`isShutdown()` status is true, and _only_ in this case would the\nScheduler be terminated.\n\nThis is a backport of #1082 (commit b0fca2f), as tracked in #1083\n", "commitDateTime": "2018-02-20 10:28:13", "authoredDateTime": "2018-02-20 10:28:13", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java", "insertions": 130, "deletions": 5, "lines": 135}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ExecutorScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorScheduler.schedule(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ExecutorSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingExecutorIsTerminated()", "TOT": 19, "UPD": 3, "INS": 0, "MOV": 15, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.scanBuffered()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingPlainExecutorIsNotTerminated()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingExecutorServiceIsNotTerminated()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorSchedulerTest.failingAndShutDownExecutorServiceIsTerminated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["b0fca2fe893ff6a89619cfa8fb789c74f26ea83c"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4.0, "deletions": 1.0, "lines": 5.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 1.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.ExecutorScheduler.schedule(java.lang.Runnable)"]}, {"title": "Exception in the thread who subscribed the flux or mono", "body": "The following scenario will prove theoretically that even if I check if the stream canceled before sending error signal, then flux will throw an exception to the subscribed thread: consider the following scenario inside Flux.create which the main thread subscribed to it (flux.create(..)....parallel()...take(1)...):\r\n1. main thread check if the stream is canceled before sending an error signal. the answer is no.\r\n2. main thread is on hold by the operating system.\r\n3. parallelThread1 pass the `take(1)` and terminate the stream.\r\n4. parallelThread1 is on hold by the operating system.\r\n4. main thread is alive now and sending an error signal. the error will be thrown in the main thread.\r\n\r\n**In general, what are my options to avoid exceptions in the thread who subscribed the flux?**", "url": "https://github.com/reactor/reactor-core/issues/1078", "user": "stavalfi", "labels": ["type/bug"], "created": "2018-02-15 20:07:49", "closed": "2018-02-20 14:15:58", "commits": {"db1ec5c4fe3fc1e7a41b643c1ff3683d91f29b35": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "793d517a69a292ffbd8e66b76439028b46b60cdd": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "db244e07ad0b32ec4e741698f5a9ed29f6bdc96f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "9cad4cd929fb4f232655befbb45299c4f901066b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "db1ec5c4fe3fc1e7a41b643c1ff3683d91f29b35", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "793d517a69a292ffbd8e66b76439028b46b60cdd", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "db244e07ad0b32ec4e741698f5a9ed29f6bdc96f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["b0fca2fe893ff6a89619cfa8fb789c74f26ea83c"], "nameRev": "db244e07ad0b32ec4e741698f5a9ed29f6bdc96f tags/v3.2.0.M2~76", "commitMessage": "fix #1078 `create` uses onOperatorError hook instead of onErrorDropped\n\nFlux.create and Mono.create don't use `onErrorDropped` anymore,\r\npreventing throws when the default behaviour is still in place. Instead,\r\nthey call `onOperatorError` without signalling the resulting Throwable.\r\n\r\nThis has a saner default of \"swallowing\" the exception rather than\r\nthrowing it out of the reactive chain and causing problems. It can still\r\nbe locally customized using the `Context` undocumented key approach.\r\n\r\nAlso added a missing onNextDropped hook in Mono.create.", "commitDateTime": "2018-02-20 15:15:57", "authoredDateTime": "2018-02-20 06:15:57", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 5, "deletions": 20, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterEmptySuccessBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterSuccessBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterErrorBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "9cad4cd929fb4f232655befbb45299c4f901066b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["ae33c6c780d7921342a73a1287f2acdad9257dc6"], "nameRev": "9cad4cd929fb4f232655befbb45299c4f901066b tags/v3.1.5.RELEASE~9", "commitMessage": "port #1078 `create` uses onOperatorError hook instead of onErrorDropped\n\nFlux.create and Mono.create don't use `onErrorDropped` anymore,\npreventing throws when the default behaviour is still in place. Instead,\nthey call `onOperatorError` without signalling the resulting Throwable.\n\nThis has a saner default of \"swallowing\" the exception rather than\nthrowing it out of the reactive chain and causing problems. It can still\nbe locally customized using the `Context` undocumented key approach.\n\nAlso added a missing onNextDropped hook in Mono.create.\n\nThis is a backport of #1085 (commit db244e07), as tracked in #1083\n", "commitDateTime": "2018-02-26 11:37:28", "authoredDateTime": "2018-02-20 06:15:57", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java", "insertions": 5, "deletions": 20, "lines": 25}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCreateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterEmptySuccessBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterSuccessBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoCreateTest.sinkApiErrorAfterErrorBubblesAndDrops()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["db244e07ad0b32ec4e741698f5a9ed29f6bdc96f"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7.0, "deletions": 6.0, "lines": 13.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 5.0, "UPD": 4.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxCreate.SerializedSink.error(java.lang.Throwable)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.success(java.lang.Object)", "reactor.core.publisher.MonoCreate.DefaultMonoSink.error(java.lang.Throwable)", "reactor.core.publisher.FluxCreate.BaseSink.error(java.lang.Throwable)"]}, {"title": "EventLoopProcessor#shutdownNow should also shutdown the request task", "body": "### Expected behavior\r\nAfter a `shutdownNow()`, both the `executor` and the `requestTaskExecutor` should be terminated.\r\n\r\n### Actual behavior\r\nOnly the `executor` is terminated.", "url": "https://github.com/reactor/reactor-core/issues/1074", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-02-14 17:03:05", "closed": "2018-02-14 17:22:12", "commits": {"e4b6157c65c4cb94e672cbfc2420c60ded494844": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "16c2c4704d9dbd25503d544e539f36bb0188ea4a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "e4b6157c65c4cb94e672cbfc2420c60ded494844", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "16c2c4704d9dbd25503d544e539f36bb0188ea4a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["1a34ef34ea035da282fed2abffc3e8ce4468850c"], "nameRev": "16c2c4704d9dbd25503d544e539f36bb0188ea4a tags/v3.1.4.RELEASE~3", "commitMessage": "fix #1074 Shutdown request task executor in event loop's forceShutdown\n\nThe EventLoopProcessors would fail to shut down their request task\nexecutor when `forceShutdown` was called.\n", "commitDateTime": "2018-02-14 18:22:10", "authoredDateTime": "2018-02-14 18:07:03", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.forceShutdown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["16c2c4704d9dbd25503d544e539f36bb0188ea4a"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 0.0, "lines": 1.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.EventLoopProcessor.forceShutdown()"]}, {"title": "Align completion signal behavior of Mono.zip to Flux.zip", "body": "Currently Mono.zip wait for all source completion before completing. It was initially a way to support Publisher<Void> behavior but we since then reworked when/and to do exactly this. It seems borderline to a bug but it is a behavior change. Cc @nebhale", "url": "https://github.com/reactor/reactor-core/issues/1071", "user": "smaldini", "labels": ["type/bug"], "created": "2018-02-14 15:57:26", "closed": "2018-02-15 09:13:43", "commits": {"8f82d0b6839328d55f62f12bc87c960833ab5a9b": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "d2086a9d01b8e2b49f1b6f32658248b3db6dc66f": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "d1def80fd062cf32222a2ab88d3cbcc0a5684f92": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "020323344e2282aa5a377f52755f129dc4648ead": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "8f82d0b6839328d55f62f12bc87c960833ab5a9b", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d2086a9d01b8e2b49f1b6f32658248b3db6dc66f", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d1def80fd062cf32222a2ab88d3cbcc0a5684f92", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "020323344e2282aa5a377f52755f129dc4648ead", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["16c2c4704d9dbd25503d544e539f36bb0188ea4a"], "nameRev": "020323344e2282aa5a377f52755f129dc4648ead tags/v3.1.4.RELEASE~2", "commitMessage": "fix #1071 Mono.zip short circuits on empty sources unless delayError\n\nAligns the behavior on Flux#zip: any source that errors or completes\r\nempty will short-circuit the resulting Mono, cancelling the other\r\npending sources.\r\n\r\nIf `zipDelayError` is used, it will let other sources run to completion\r\ninstead of cancelling them (providing a more deterministic option).\r\nThe presence of an empty source still leads to the resulting Mono to be\r\nempty.", "commitDateTime": "2018-02-15 10:13:42", "authoredDateTime": "2018-02-15 01:13:42", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 61, "deletions": 42, "lines": 103}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoZip.java", "insertions": 36, "deletions": 24, "lines": 60}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoZipTest.java", "insertions": 90, "deletions": 16, "lines": 106}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": []}, {"spoonFilePath": "MonoWhen.java", "spoonMethods": []}, {"spoonFilePath": "MonoZip.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoZip.ZipCoordinator.signalError(java.lang.Throwable)", "TOT": 17, "UPD": 6, "INS": 0, "MOV": 5, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.MonoZip.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoZip.ZipCoordinator.subscribe(org.reactivestreams.Publisher[])", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 4, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoZip.ZipInner.onError(java.lang.Throwable)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoZip.ZipInner.onComplete()", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoZip.ZipCoordinator.cancelExcept(reactor.core.publisher.MonoZip$ZipInner)", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoZipTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoZipTest.someEmpty()", "TOT": 9, "UPD": 2, "INS": 1, "MOV": 6, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.scanWhenInner()", "TOT": 7, "UPD": 1, "INS": 3, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.scanCoordinator()", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.delayErrorEmptySourceErrorSource()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.delayErrorEmptySourceErrorTwoSource()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.delayErrorEmptySources()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.innerErrorIncrementsParentDone()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoZipTest.emptySources()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["020323344e2282aa5a377f52755f129dc4648ead"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 98.0, "deletions": 69.0, "lines": 167.0, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 37.0, "UPD": 6.0, "INS": 8.0, "MOV": 13.0, "DEL": 10.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoZip.ZipInner.onError(java.lang.Throwable)", "reactor.core.publisher.MonoZip.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.MonoZip.ZipInner.onComplete()", "reactor.core.publisher.MonoZip.ZipCoordinator.signalError(java.lang.Throwable)", "reactor.core.publisher.MonoZip.ZipCoordinator.cancelExcept(reactor.core.publisher.MonoZip$ZipInner)", "reactor.core.publisher.MonoZip.ZipCoordinator.subscribe(org.reactivestreams.Publisher[])"]}, {"title": "ElasticScheduler retains references to evicted executors", "body": "### Expected behavior\r\nThe internal `all` queue should be impacted by TTL eviction.\r\n\r\n### Actual behavior\r\nThe `all` queue retains references to every single `ExecutorService` created by the scheduler.\r\n\r\n### Fix\r\nRemove from both `cache` and `all` during eviction.", "url": "https://github.com/reactor/reactor-core/issues/1070", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-02-13 17:55:50", "closed": "2018-02-14 09:21:31", "commits": {"5625eea66a0eb066f608962acdced4ee933a039d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a6a2630f7a90d064ed13df6b3c37324d87f40ec9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "3c891298e172ccaf435b70c871150152a973e9a1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "1a34ef34ea035da282fed2abffc3e8ce4468850c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "5625eea66a0eb066f608962acdced4ee933a039d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a6a2630f7a90d064ed13df6b3c37324d87f40ec9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3c891298e172ccaf435b70c871150152a973e9a1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "1a34ef34ea035da282fed2abffc3e8ce4468850c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["dcc36e52230b5c2b6fab87d4ab7d0fb72d9dff7c"], "nameRev": "1a34ef34ea035da282fed2abffc3e8ce4468850c tags/v3.1.4.RELEASE~4", "commitMessage": "fix #1070 Don't retain ref to executor during ElasticScheduler eviction\n\nThis commit fixes a retaining issue where `all` elastic workers ever\ncreated would be retained by the `all` collection rather than being\nevicted along their cache-expiry wrapper.\n", "commitDateTime": "2018-02-14 10:21:29", "authoredDateTime": "2018-02-13 19:38:42", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ElasticScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ElasticScheduler.eviction()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1a34ef34ea035da282fed2abffc3e8ce4468850c"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.ElasticScheduler.eviction()"]}, {"title": "doOnEach not executed", "body": "As i started introducing MDC logging (according to https://simonbasle.github.io/2018/02/contextual-logging-with-reactor-context-and-mdc/)\r\ni heavily rely on `doOnEach` for logging.\r\n\r\nI started to experience that sometimes `doOnEach` is not executed. \r\nAt least this is what i observe in tests. \r\n\r\nTo reproduce the behavior please take a look at [https://github.com/jmilkiewicz/doOnEachBug/blob/master/src/test/java/DoOneEachTest.java](https://github.com/jmilkiewicz/doOnEachBug/blob/master/src/test/java/DoOneEachTest.java)\r\n\r\nThe test shows that  `doOnEach`  (the one after `map` ) is simply not executed at all !  \r\nIf i uncomment  `doOnEach`  (before `map` ) than everything works as expected !\r\nSeems like `map` is spoiling something :wink:\r\n\r\nI also tried to  build chain with 2 subsequent  `doOnEach`  (after `map` ) \r\n\r\n```\r\n.map(x -> processMe(x)) \r\n.doOnEach(sig -> System.out.println(\"AFTERMap \" + sig))\r\n.doOnEach(sig -> {throw new RuntimeException(\"expected\");})\r\n``` \r\nbut none of `doOnEach` is  executed\r\n\r\nI experience this behavior in Bismuth-SR5  ( 3.1.3.RELEASE)\r\nIf i **downgrade** to Bismuth-RELEASE  (3.1.0.RELEASE)\r\nthan everything works fine and `doOnEach` is executed as expected\r\n\r\njava version \"1.8.0_60\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_60-b27)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)", "url": "https://github.com/reactor/reactor-core/issues/1067", "user": "jmilkiewicz", "labels": ["type/bug"], "created": "2018-02-10 09:54:50", "closed": "2018-02-11 05:12:26", "commits": {"57ef5e59601222fd386f77e3be5cb63e3d96e286": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "57ef5e59601222fd386f77e3be5cb63e3d96e286", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["f88ea67c7b6caa984a69805df28bab4945a7b616"], "nameRev": "57ef5e59601222fd386f77e3be5cb63e3d96e286 tags/v3.1.4.RELEASE~10", "commitMessage": "Add test from @jmilkiewicz - verify #1067\n", "commitDateTime": "2018-02-10 21:13:43", "authoredDateTime": "2018-02-10 21:13:20", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java", "insertions": 18, "deletions": 2, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.shallExecuteSideEffectsCallback()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["57ef5e59601222fd386f77e3be5cb63e3d96e286"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "doOnEach can be bypassed by async fusion", "body": "### Expected behavior\r\nA `doOnEach` should always be invoked on any signal, whatever the source.\r\n\r\n### Actual behavior\r\nIn some instances, the `doOnEach` is skipped entirely.\r\n\r\n### Steps to reproduce\r\n```java\r\n\t@Test\r\n\tpublic void fusion() {\r\n\t\tAtomicInteger invocationCount = new AtomicInteger();\r\n\r\n\t\tFlux<String> sourceWithFusionAsync = Flux.just(\"foo\")\r\n\t\t    .publishOn(Schedulers.elastic())\r\n\t\t    .flatMap(v -> Flux.just(\"flatMap_\" + v)\r\n\t\t                      .doOnEach(sig -> invocationCount.incrementAndGet())\r\n\t\t    );\r\n\r\n\t\tStepVerifier.create(sourceWithFusionAsync)\r\n\t\t            .expectNoFusionSupport()\r\n\t\t            .expectNext(\"flatMap_foo\")\r\n\t\t            .verifyComplete();\r\n\r\n\t\tassertThat(invocationCount).as(\"doOnEach invoked\").hasValue(2);\r\n\t}\r\n```\r\n\r\n### Investigation\r\nIt seems to be related to fusion, and actually the doOnEach subscriber is not passed to `actual.onSubscribe` at subscription time :(\r\n\r\nNotice [here](https://github.com/reactor/reactor-core/blob/v3.1.3.RELEASE/reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java#L83) how `s` is used.\r\n```\r\n\t\t\tactual.onSubscribe(s);\r\n```\r\n\r\n### Reactor Core version\r\n3.1.3.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/1056", "user": "simonbasle", "labels": ["type/bug"], "created": "2018-02-02 16:50:37", "closed": "2018-02-03 13:34:04", "commits": {"e3768add275fd3ce8956bfcadd60f45c9babed7b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "98b43a004f764349d9730b2b2c013f4c72ff3a77": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a5647fc0ac64111838527857b06a937931fb29d1": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "e3768add275fd3ce8956bfcadd60f45c9babed7b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "98b43a004f764349d9730b2b2c013f4c72ff3a77", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a5647fc0ac64111838527857b06a937931fb29d1", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0fc43f3a4218f7699f4c4dc8c4f82ba4fec728ef"], "nameRev": "a5647fc0ac64111838527857b06a937931fb29d1 tags/v3.1.4.RELEASE~14", "commitMessage": "fix #1056 doOnEach correctly passes itself to onSubscribe\n\nThis commit ensures that the FluxDoOnEach DoOnEachSubscriber correctly\npasses itself to actual.onSubscribe rather than its own upstream\nSubscription, thus ensuring that no short-circuiting fusion is\nestablished between the downstream and upstream.\n", "commitDateTime": "2018-02-03 14:34:01", "authoredDateTime": "2018-02-02 17:56:15", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java", "insertions": 22, "deletions": 0, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoOnEach.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxDoOnEachTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoOnEachTest.fusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a5647fc0ac64111838527857b06a937931fb29d1"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDoOnEach.DoOnEachSubscriber.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "Remove public scope from Flux operator", "body": "The recent releases have inadvertently opened 3 operators to the public API. These API should not be used and will be package scoped. \r\n- FluxDelaySequence\r\n- FluxIndex\r\n- FluxIndexFuseable", "url": "https://github.com/reactor/reactor-core/issues/1036", "user": "smaldini", "labels": ["type/bug", "warn/api-change"], "created": "2018-01-23 00:20:09", "closed": "2018-01-29 17:54:12", "commits": {"2c6d4363c8818cea76733af2202c7b5f623a8245": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "27699ccb461c7ff0bd06456e39a51ce6655d8dd8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "236cb975a56618de00c2c019838e25d0bc4dbab8": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "2c6d4363c8818cea76733af2202c7b5f623a8245", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "27699ccb461c7ff0bd06456e39a51ce6655d8dd8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "236cb975a56618de00c2c019838e25d0bc4dbab8", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["1c0fa6d18a5759c1245d095bc4781adeb17ec163"], "nameRev": "236cb975a56618de00c2c019838e25d0bc4dbab8 tags/v3.1.4.RELEASE~22", "commitMessage": "fix #1036 Remove erroneous public scope from 3 internal operator classes\n\nFluxDelaySequence, FluxIndex and FluxIndexFuseable are internal\nimplementations and should have been package-private instead of public.\n", "commitDateTime": "2018-01-29 18:54:10", "authoredDateTime": "2018-01-23 14:22:13", "commitGitStats": [{"filePath": "build.gradle", "insertions": 2, "deletions": 0, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDelaySequence.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxIndex.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxIndexFuseable.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDelaySequence.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDelaySequence", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "FluxIndex.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxIndex", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxIndexFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxIndexFuseable", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["236cb975a56618de00c2c019838e25d0bc4dbab8"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 4.0, "lines": 10.0, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 2.0, "INS": 0.0, "MOV": 0.0, "DEL": 2.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", ""], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDelaySequence", "reactor.core.publisher.FluxIndexFuseable", "reactor.core.publisher.FluxIndex"]}, {"title": "MpscLinkedQueue is public (it shouldn't)", "body": "MpscLinkedQueue should only be created by a `Queues` factory like all other queues.", "url": "https://github.com/reactor/reactor-core/issues/1035", "user": "smaldini", "labels": ["type/bug", "warn/api-change"], "created": "2018-01-23 00:13:20", "closed": "2018-01-29 17:54:12", "commits": {"4c792f58069ee99aae800cc2cfabb2272a92de75": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "19932cd4f84e3b20593b1dd8e98a9a19358a3b44": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0d59d84d1c21ead8603e53ab975c9f51b475323a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "4c792f58069ee99aae800cc2cfabb2272a92de75", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "19932cd4f84e3b20593b1dd8e98a9a19358a3b44", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0d59d84d1c21ead8603e53ab975c9f51b475323a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["236cb975a56618de00c2c019838e25d0bc4dbab8"], "nameRev": "0d59d84d1c21ead8603e53ab975c9f51b475323a tags/v3.1.4.RELEASE~21", "commitMessage": "fix #1035 Make MPSC queue implementation package private\n\nThe `MpscLinkedQueue` was another class that shouldn't have been\nreleased as public. It is now package private, since all access have\nbeen converted to the new Queues.unboundedMultiproducer() method.\n", "commitDateTime": "2018-01-29 18:54:10", "authoredDateTime": "2018-01-23 16:35:09", "commitGitStats": [{"filePath": "build.gradle", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/util/concurrent/MpscLinkedQueue.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MpscLinkedQueue.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.MpscLinkedQueue", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0d59d84d1c21ead8603e53ab975c9f51b475323a"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 1.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["", "reactor-core/src/main/java/reactor/util/concurrent"], "changesInPackagesSPOON": ["reactor.util.concurrent.MpscLinkedQueue"]}, {"title": "Flux.distinct() does use Object.hashCode() without Object.equals() which is counter-intuitive and not documented", "body": "### Expected behavior\r\nEspecially as a \"default\" without further arguments Flux.distinct() should use Object.hashCode() and then check Object.equals() as e.g. Java Collections normally are expected to do.\r\n\r\nIf using Object.equals() is not intended for any reason (e.g. performance) - it should at least be mentioned in the documentation that this method is solely depending on Object.hashCode(). But at least in my opinion is quite unusual (even java.util.stream.Stream.distinct() seems to honor Object.hashCode() and Object.equals()).\r\n\r\n### Actual behavior\r\nWithout further arguments Flux.distinct() uses a Object.hashCode() key extractor then ignoring the actual Object. \r\n\r\nWithout developer awareness unintended collisions can happen anytime, causing elements to be filtered which wouldn't when e.g. using a normal HashSet.\r\n\r\n### Steps to reproduce\r\nUse Flux.distinct() on a Flux with two objects returning the same integer from Object.hashCode() but not being equal according to Object.equals().\r\n\r\n### Reactor Core version\r\nAt least 3.1.2\r\n\r\n### JVM version (e.g. `java -version`)\r\nNot relevant.\r\n\r\n### OS version (e.g. `uname -a`)\r\nNot relevant.", "url": "https://github.com/reactor/reactor-core/issues/1025", "user": "andmoos", "labels": ["status/has-workaround", "type/bug"], "created": "2018-01-15 11:51:21", "closed": "2018-01-16 17:25:25", "commits": {"ab6a7ec463036f75b348b235cfe588d64afd72ac": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b8e97eed9dcd11c065de4ac3f31eff0f7a7e5eb1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7793e2e7bdd56a8310f2460a3f13e3684de8495f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "ab6a7ec463036f75b348b235cfe588d64afd72ac", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b8e97eed9dcd11c065de4ac3f31eff0f7a7e5eb1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7793e2e7bdd56a8310f2460a3f13e3684de8495f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["f4da436bd9e7b37f46b422e0d53451b92b10fae8"], "nameRev": "7793e2e7bdd56a8310f2460a3f13e3684de8495f tags/v3.1.3.RELEASE~7", "commitMessage": "fix #1025 Avoid using only hashcode as default distinct*() criteria\n\nThis commit replaces the default `distinct()` method (as well as\r\n`distinctUntilChanged()`) to use the full object as the key instead of\r\n just the `hashcode`. The later would be too susceptible to hashcode\r\n collisions (2 equal objects MUST have same hashcode, but two\r\n same-hashcode objects aren't necessarily equal).\r\n\r\nThis has the consequence that the by default retains all distinct source\r\nelements in a `HashSet`, until completion.\r\n\r\nIf this proves too heavy, and the particular elements have a precise\r\nenough hashcode implementation, users might elect to revert back to the\r\nold check by using an overload: `distinct(Object::hashcode)`.", "commitDateTime": "2018-01-16 18:25:23", "authoredDateTime": "2018-01-16 18:25:23", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 12, "deletions": 9, "lines": 21}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java", "insertions": 109, "deletions": 0, "lines": 109}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java", "insertions": 85, "deletions": 0, "lines": 85}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.timeout(java.time.Duration,org.reactivestreams.Publisher,reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.collectMap(java.util.function.Function,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.collectMap(java.util.function.Function,java.util.function.Function,java.util.function.Supplier)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.collectMultimap(java.util.function.Function,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.collectMultimap(java.util.function.Function,java.util.function.Function,java.util.function.Supplier)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.compose(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.delayElements(java.time.Duration,reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.delayUntil(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.distinct()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.distinctUntilChanged()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.doOnTerminate(java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.hasElement(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onBackpressureError()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorMap(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorMap(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorResume(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorReturn(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorReturn(java.lang.Class,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.onErrorReturn(java.util.function.Predicate,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.reduce(java.lang.Object,java.util.function.BiFunction)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.repeat(long,java.util.function.BooleanSupplier)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.retry(long,java.util.function.Predicate)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.sampleFirst(java.time.Duration)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.scan(java.lang.Object,java.util.function.BiFunction)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.subscriberContext(reactor.util.context.Context)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.timestamp(reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.ofType(java.lang.Class)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.hashcodeSupplier()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Flux", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxDistinctTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctDefaulWithHashcodeCollisions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.Foo", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctDefaultDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctDefaultErrorDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctTest.distinctDefaultCancelDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxDistinctUntilChangedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.distinctUntilChangedDefaulWithHashcodeCollisions()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.distinctUntilChangedDefaultDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.distinctUntilChangedDefaultErrorDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.distinctUntilChangedDefaultCancelDoesntRetainObjects()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7793e2e7bdd56a8310f2460a3f13e3684de8495f"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 12.0, "deletions": 9.0, "lines": 21.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 31.0, "UPD": 29.0, "INS": 0.0, "MOV": 0.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 30}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.collectMap(java.util.function.Function,java.util.function.Function)", "reactor.core.publisher.Flux.reduce(java.lang.Object,java.util.function.BiFunction)", "reactor.core.publisher.Flux.onErrorReturn(java.lang.Object)", "reactor.core.publisher.Flux.onErrorMap(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Flux", "reactor.core.publisher.Flux.delayElements(java.time.Duration,reactor.core.scheduler.Scheduler)", "reactor.core.publisher.Flux.collectMultimap(java.util.function.Function,java.util.function.Function,java.util.function.Supplier)", "reactor.core.publisher.Flux.hashcodeSupplier()", "reactor.core.publisher.Flux.onErrorResume(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Flux.distinct()", "reactor.core.publisher.Flux.repeat(long,java.util.function.BooleanSupplier)", "reactor.core.publisher.Flux.delayUntil(java.util.function.Function)", "reactor.core.publisher.Flux.timeout(java.time.Duration,org.reactivestreams.Publisher,reactor.core.scheduler.Scheduler)", "reactor.core.publisher.Flux.retry(long,java.util.function.Predicate)", "reactor.core.publisher.Flux.subscriberContext(reactor.util.context.Context)", "reactor.core.publisher.Flux.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "reactor.core.publisher.Flux.onBackpressureError()", "reactor.core.publisher.Flux.scan(java.lang.Object,java.util.function.BiFunction)", "reactor.core.publisher.Flux.ofType(java.lang.Class)", "reactor.core.publisher.Flux.collectMap(java.util.function.Function,java.util.function.Function,java.util.function.Supplier)", "reactor.core.publisher.Flux.sampleFirst(java.time.Duration)", "reactor.core.publisher.Flux.collectMultimap(java.util.function.Function,java.util.function.Function)", "reactor.core.publisher.Flux.hasElement(java.lang.Object)", "reactor.core.publisher.Flux.distinctUntilChanged()", "reactor.core.publisher.Flux.timestamp(reactor.core.scheduler.Scheduler)", "reactor.core.publisher.Flux.doOnTerminate(java.lang.Runnable)", "reactor.core.publisher.Flux.compose(java.util.function.Function)", "reactor.core.publisher.Flux.onErrorReturn(java.util.function.Predicate,java.lang.Object)", "reactor.core.publisher.Flux.onErrorReturn(java.lang.Class,java.lang.Object)", "reactor.core.publisher.Flux.onErrorMap(java.util.function.Function)"]}, {"title": "Prefetch issues with windowWhile when early cancel", "body": "### Expected behavior\r\nwindowWhile should keep requesting upstream when a window is cancelled prematurely before the condition.\r\n\r\n### Actual behavior\r\nwindowWhile will hang when the current window is cancelled with a fixed prefetch\r\n\r\n### Steps to reproduce\r\n\r\n```\r\n @Test\r\n    public void test() {\r\n        EmitterProcessor<Flux<String>> incomingProcessor = EmitterProcessor.create(false);\r\n\r\n        Flux.just(\"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\", \"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\", \"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\")\r\n            .log(\"stream.incoming\")\r\n            .windowWhile(s -> !\"DELTA\".equals(s), 1)\r\n            .subscribe(incomingProcessor);\r\n\r\n        AtomicInteger windowIndex = new AtomicInteger(0);\r\n        AtomicInteger nextIndex = new AtomicInteger(0);\r\n\r\n        System.out.println(\"ZERO\");\r\n        incomingProcessor\r\n            .next()\r\n            .flatMapMany(flux -> flux\r\n                .takeWhile(s -> !\"CHARLIE\".equals(s))\r\n                .log(String.format(\"stream.window.%d\", windowIndex.getAndIncrement())))\r\n            .log(String.format(\"stream.next.%d\", nextIndex.getAndIncrement()))\r\n            .as(StepVerifier::create)\r\n            .expectNextCount(2)\r\n            .verifyComplete();\r\n\r\n        System.out.println(\"ONE\");\r\n        incomingProcessor.next()\r\n            .flatMapMany(flux -> flux\r\n                .takeWhile(s -> !\"CHARLIE\".equals(s))\r\n                .log(String.format(\"stream.window.%d\", windowIndex.getAndIncrement())))\r\n            .log(String.format(\"stream.next.%d\", nextIndex.getAndIncrement()))\r\n            .as(StepVerifier::create)\r\n            .expectNextCount(2)\r\n            .verifyComplete();\r\n\r\n        System.out.println(\"TWO\");\r\n        incomingProcessor.next()\r\n            .flatMapMany(flux -> flux\r\n                .takeWhile(s -> !\"CHARLIE\".equals(s))\r\n                .log(String.format(\"stream.window.%d\", windowIndex.getAndIncrement())))\r\n            .log(String.format(\"stream.next.%d\", nextIndex.getAndIncrement()))\r\n            .as(StepVerifier::create)\r\n            .expectNextCount(2)\r\n            .verifyComplete();\r\n    }\r\n```\r\n\r\n### Reactor Core version\r\n3.1.2\r\n", "url": "https://github.com/reactor/reactor-core/issues/1017", "user": "smaldini", "labels": ["type/bug"], "created": "2018-01-08 21:21:50", "closed": "2018-01-09 09:20:04", "commits": {"776462c80702b77268bd7331461af0f6e2b7aa37": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "618cb621eba7ee2969ec21ecc167d1e40fab8a9e": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "a961a7f515c7214e24062762fb33826e8cdb4db9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "44ecb6c04f570df8ccbc6ebc818e47015c865ede": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "776462c80702b77268bd7331461af0f6e2b7aa37", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "618cb621eba7ee2969ec21ecc167d1e40fab8a9e", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a961a7f515c7214e24062762fb33826e8cdb4db9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["dc1e3e76e00360458e642fc201bd8c74ce97e94b"], "nameRev": "a961a7f515c7214e24062762fb33826e8cdb4db9 tags/v3.2.0.M1~10", "commitMessage": "fix #1017 - windowWhile now replenishes on premature cancel\n\n - only propagate a window's cancellation if it is the last window\r\n - otherwise request 1 more in the main", "commitDateTime": "2018-01-09 10:20:01", "authoredDateTime": "2018-01-09 01:20:01", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java", "insertions": 12, "deletions": 8, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 45, "deletions": 0, "lines": 45}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxWindowPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowFlux.propagateCancel()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowFlux.cancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxPublishTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishTest.prematureOnComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWindowPredicateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.manualRequestWindowWhileOverRequestingSourceByPrefetch()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "44ecb6c04f570df8ccbc6ebc818e47015c865ede", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["a961a7f515c7214e24062762fb33826e8cdb4db9"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 12.0, "deletions": 8.0, "lines": 20.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 0.0, "INS": 1.0, "MOV": 3.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxWindowPredicate.WindowFlux.cancel()", "reactor.core.publisher.FluxWindowPredicate.WindowFlux.propagateCancel()"]}, {"title": "publish().autoConnect() seems to not onComplete late subscriber", "body": "### Expected behavior\r\n\r\nOnComplete late subscribers if upstream onComplete.\r\n\r\n### Actual behavior\r\n\r\nIt does seem that onComplete is not forwarded to late subscribers :  \r\n\r\n### Steps to reproduce\r\n\r\n```EmitterProcessor<Flux<String>> incomingProcessor = EmitterProcessor.create();\r\n        Flux<Flux<String>> incoming = incomingProcessor.log(\"stream.proc\").publish().autoConnect()\r\n            .log(\"stream.incoming\");\r\n\r\n        Flux.just(\"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\", \"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\", \"ALPHA\", \"BRAVO\", \"CHARLIE\", \"DELTA\")\r\n            .log(\"stream.incoming\")\r\n            .windowWhile(s -> !\"DELTA\".equals(s))\r\n            .subscribe(incomingProcessor);\r\n\r\n        AtomicInteger windowIndex = new AtomicInteger(0);\r\n        AtomicInteger nextIndex = new AtomicInteger(0);\r\n\r\n        System.out.println(\"ZERO\");\r\n        incoming\r\n            .next()\r\n            .flatMapMany(flux -> flux\r\n//                .takeWhile(s -> !\"CHARLIE\".equals(s))\r\n                .log(String.format(\"stream.window.%d\", windowIndex.getAndIncrement())))\r\n            .log(String.format(\"stream.next.%d\", nextIndex.getAndIncrement()))\r\n            .as(StepVerifier::create)\r\n            .expectNextCount(3)\r\n            .verifyComplete();\r\n\r\n        System.out.println(\"ONE\");\r\n        incoming.next()\r\n            .flatMapMany(flux -> flux\r\n//                .takeWhile(s -> !\"CHARLIE\".equals(s))\r\n                .log(String.format(\"stream.window.%d\", windowIndex.getAndIncrement())))\r\n            .log(String.format(\"stream.next.%d\", nextIndex.getAndIncrement()))\r\n            .as(StepVerifier::create)\r\n            .expectNextCount(3)\r\n            .verifyComplete();\r\n```\r\n\r\n### Reactor Core version\r\n\r\n3.1.2\r\n  ", "url": "https://github.com/reactor/reactor-core/issues/1016", "user": "smaldini", "labels": ["type/bug"], "created": "2018-01-08 19:58:29", "closed": "2018-01-08 20:01:46", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "FluxBufferTimeout behavior", "body": "Hi to All.\r\n\r\nAs described [here](https://github.com/reactive-streams/reactive-streams-jvm):\r\n> The total number of onNext\u00b4s signalled by a Publisher to a Subscriber MUST be less than or equal to the total number of elements requested by that Subscriber\u00b4s Subscription at all times.\r\n\r\n### Expected behavior\r\nonNext will be called only one time, only\r\n```\r\nmain / subscribed\r\nparallel-3 / out : [0]\r\n```\r\nwill be printed\r\n\r\n### Actual behavior\r\nonNext called 20 times\r\n\r\n### Steps to reproduce\r\n\r\nThis code\r\n```\r\n        Flux.range(0, 50)\r\n                .delayElements(Duration.ofMillis(300))\r\n                .bufferTimeout(20, Duration.ofMillis(100))\r\n                .subscribe(\r\n                        v -> System.out.println(Thread.currentThread().getName() + \" / out : \" + v),\r\n                        t -> System.out.println(Thread.currentThread().getName() + \" / error: \" + t.getMessage()),\r\n                        () -> System.out.println(Thread.currentThread().getName() + \" / compete\"),\r\n                        s -> {\r\n                            System.out.println(Thread.currentThread().getName() + \" / subscribed\");\r\n                            s.request(1);\r\n                        }\r\n                );\r\n```\r\nprint\r\n```\r\nmain / subscribed\r\nparallel-3 / out : [0]\r\nparallel-3 / out : [1]\r\nparallel-3 / out : [2]\r\nparallel-3 / out : [3]\r\nparallel-3 / out : [4]\r\nparallel-3 / out : [5]\r\nparallel-3 / out : [6]\r\nparallel-3 / out : [7]\r\nparallel-3 / out : [8]\r\nparallel-3 / out : [9]\r\n...\r\n```\r\n\r\n### Reactor Core version\r\n3.1.2.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\njava version \"9.0.1\"\r\nJava(TM) SE Runtime Environment (build 9.0.1+11)\r\nJava HotSpot(TM) 64-Bit Server VM (build 9.0.1+11, mixed mode)\r\n\r\n### OS version (e.g. `uname -a`)\r\nWindows 10\r\n\r\nP.S.: I think this is chained with this issue. As I see in code, each time BufferTimeoutSubscriber requested `n` elements, it will request `n * batchSize` elements from upper source, no matter how many upper source already produced. IMHO it should request from upper source only such count of elements to have possibility to produce elements requested from it (collection with `size = batchSize`)\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/994", "user": "pandemorra", "labels": ["type/bug"], "created": "2017-12-27 18:04:13", "closed": "2018-01-10 07:38:15", "commits": {"14105f6bf9b64152bc75a9e409041cdf7856510f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5a4d38fcb1fbc5b2e4cf70d1390f67bf6fe9f2f2": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 13.000277777777777, "commitsDetails": [{"commitHash": "14105f6bf9b64152bc75a9e409041cdf7856510f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5a4d38fcb1fbc5b2e4cf70d1390f67bf6fe9f2f2", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["90951be99bb991c1cc3e7cc81860034258391662"], "nameRev": "5a4d38fcb1fbc5b2e4cf70d1390f67bf6fe9f2f2 tags/v3.2.0.M1~5", "commitMessage": "fix #994 Notify lack of request on bufferTimeout\n", "commitDateTime": "2018-01-09 23:38:12", "authoredDateTime": "2017-12-30 23:27:03", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java", "insertions": 29, "deletions": 2, "lines": 31}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java", "insertions": 79, "deletions": 0, "lines": 79}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.flushCallback(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.request(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBufferTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.scenario_bufferWithTimeoutThrowingExceptionOnTimeOrSizeIfDownstreamDemandIsLow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.bufferWithTimeoutThrowingExceptionOnTimeOrSizeIfDownstreamDemandIsLow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.shouldShowActualSubscriberDemand()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.downstreamDemandShouldBeAbleToDecreaseOnFullBuffer()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeoutTest.downstreamDemandShouldBeAbleToDecreaseOnTimeSpan()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5a4d38fcb1fbc5b2e4cf70d1390f67bf6fe9f2f2"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 29.0, "deletions": 2.0, "lines": 31.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 3.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.request(long)", "reactor.core.publisher.FluxBufferTimeout.BufferTimeoutSubscriber.flushCallback(java.lang.Object)"]}, {"title": "StepVerifier thenCancel() cause false-pass if event emitted from other thread", "body": "### Expected behavior\r\nthenCancel() event should trigger after expectMatches() completes\r\n### Actual behavior\r\nthenCancel() is triggered before expectMatches() completes even if it fails, so verify() may incorrectly complete without errors.\r\nthenCancel() is triggered correctly if prepended by any then().\r\n### Steps to reproduce\r\nJUnit tests for demonstration:\r\nhttps://gist.github.com/mpapirkovskyy/8938b7f2423b0e6d40866a76f8e41f21\r\n### Reactor Core version\r\n3.1.2.RELEASE\r\n\r\n### Details\r\nSome investigation showed that incorrect behavior is caused by immediate reaction on SubscriptionEvent in script event if previous SingalEvent is still in progress:\r\nhttps://github.com/reactor/reactor-core/blob/75a0ab0574aa5addc3f5da85247019dd81bc7393/reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java#L1499-L1504\r\nworking case is result of wrapping SubscriptionEvent into SubscriptionTaskEvent when prepended by another TaskEvent, so it is added to queue explicitly after SignalEvent completes\r\nhttps://github.com/reactor/reactor-core/blob/75a0ab0574aa5addc3f5da85247019dd81bc7393/reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java#L846-L850\r\n\r\nI cannot get reason why SubscriptionEvent is not always wrapped into SubscriptionTaskEvent.\r\n", "url": "https://github.com/reactor/reactor-core/issues/992", "user": "mpapirkovskyy", "labels": ["type/bug"], "created": "2017-12-20 22:14:24", "closed": "2018-01-03 21:13:44", "commits": {"4658d8032077b67624892ec1c3d792b69a7e4a28": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "9f12cd92f885837b7b0c3cfc8b800b082c030299": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "830a04dc478232cb970ac153f8d9390f23769f45": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "fcb80993a625ec5ff113652645c70180907bd230": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "64ea0d3e305ee4030dc8066c1c4690b40039de19": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "28458e3723e52435cac7827a1dcdae535d0ffb42": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 13.000277777777777, "commitsDetails": [{"commitHash": "4658d8032077b67624892ec1c3d792b69a7e4a28", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "9f12cd92f885837b7b0c3cfc8b800b082c030299", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "830a04dc478232cb970ac153f8d9390f23769f45", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "fcb80993a625ec5ff113652645c70180907bd230", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "64ea0d3e305ee4030dc8066c1c4690b40039de19", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["6858d0dbda642994a5f3eab3f79fdc0a6d6f37b4"], "nameRev": "64ea0d3e305ee4030dc8066c1c4690b40039de19 tags/v3.2.0.M1~17", "commitMessage": "fix #992 Do not short-circuit subscriptionEvent tasks (wait for assert)\n\n\r\n", "commitDateTime": "2018-01-03 13:13:43", "authoredDateTime": "2018-01-03 22:13:43", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 26, "deletions": 26, "lines": 52}, {"filePath": "reactor-test/src/main/java/reactor/test/StepVerifier.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 80, "deletions": 0, "lines": 80}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onExpectation(reactor.core.publisher.Signal)", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.pollTaskEventOrComplete(java.time.Duration)", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 3}, {"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.waitTaskEvent()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StepVerifier.java", "spoonMethods": []}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.thenCancel_cancelsAfterFirst()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.thenCancel_cancelsAfterFirst2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "28458e3723e52435cac7827a1dcdae535d0ffb42", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["5a4d38fcb1fbc5b2e4cf70d1390f67bf6fe9f2f2"], "nameRev": "28458e3723e52435cac7827a1dcdae535d0ffb42 tags/v3.1.3.RELEASE~10", "commitMessage": "fix #959 Test that assertNext + subscribeOn work\n\nThis issue is actually fixed by #992.\n", "commitDateTime": "2018-01-12 16:45:58", "authoredDateTime": "2018-01-12 16:45:58", "commitGitStats": [{"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 32, "deletions": 0, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.assertNextWithSubscribeOnDirectProcessor()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.assertNextWithSubscribeOnJust()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["64ea0d3e305ee4030dc8066c1c4690b40039de19"], "filteredCommitsReason": {"duplicated": 4, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 32.0, "deletions": 27.0, "lines": 59.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 0.0, "INS": 3.0, "MOV": 6.0, "DEL": 4.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": ["reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.pollTaskEventOrComplete(java.time.Duration)", "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onExpectation(reactor.core.publisher.Signal)", "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.waitTaskEvent()"]}, {"title": "fix testNG tests and reactivate task", "body": "The `testNG` task currently excludes all files, resulting in `NO-SOURCE` for the task.\r\nIf the exclude is removed and we add an `includes.clear()`, the correct source set is used for testNG tests, but then some tests fail on CI (see [this Travis CI build](https://travis-ci.org/reactor/reactor-core/jobs/317019440)).\r\n\r\n```\r\nAdditional tests from `testNG` ([**/*Verification.*])\r\n\r\n\r\nGradle suite > Gradle test > reactor.core.publisher.tck.FluxWithProcessorVerification.mustImmediatelyPassOnOnErrorEventsReceivedFromItsUpstreamToItsDownstream FAILED\r\n\r\n    java.lang.AssertionError\r\n\r\n\r\nGradle suite > Gradle test > reactor.core.publisher.tck.FluxWithProcessorVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall FAILED\r\n\r\n    java.lang.AssertionError\r\n\r\n\r\nGradle suite > Gradle test > reactor.core.publisher.tck.FluxWithProcessorVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall FAILED\r\n\r\n    java.lang.AssertionError\r\n\r\n\r\nGradle suite > Gradle test > reactor.core.publisher.tck.FluxWithProcessorVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall FAILED\r\n\r\n    java.lang.AssertionError\r\n\r\n\r\nGradle suite > Gradle test > reactor.core.publisher.tck.FluxWithProcessorVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall FAILED\r\n\r\n    java.lang.AssertionError\r\n\r\n\r\n348 tests completed, 5 failed, 107 skipped\r\n\r\n:reactor-core:testNG FAILED\r\n\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n\r\n* What went wrong:\r\n\r\nExecution failed for task ':reactor-core:testNG'.\r\n\r\n> There were failing tests. See the report at: file:///home/travis/build/reactor/reactor-core/reactor-core/build/reports/tests/testNG/index.html\r\n```", "url": "https://github.com/reactor/reactor-core/issues/990", "user": "simonbasle", "labels": ["type/bug", "type/chores"], "created": "2017-12-18 14:56:56", "closed": "2018-01-02 23:01:21", "commits": {"4b2fd19c13beef03e4a72795b9d267d2cb9fd993": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "4b2fd19c13beef03e4a72795b9d267d2cb9fd993", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["6c0bde70efb52d577f088db46e8267308b006a68"], "nameRev": "4b2fd19c13beef03e4a72795b9d267d2cb9fd993 tags/v3.2.0.M1~22", "commitMessage": "Fix #990 eventual premature termination issue with WorkQueueProcessor \n\n* reactivate (on release) TestNG task, less verbose TCK tests, per-test resources\r\n* Fix premature termination inconsistency on WorkQueueProcessor\r\n", "commitDateTime": "2018-01-02 15:01:19", "authoredDateTime": "2018-01-02 15:01:19", "commitGitStats": [{"filePath": "build.gradle", "insertions": 8, "deletions": 7, "lines": 15}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 3, "deletions": 8, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/AbstractProcessorVerification.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/FluxBlackboxProcessorVerification.java", "insertions": 8, "deletions": 12, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/FluxGenerateVerification.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.onComplete()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.run()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 1}]}, {"spoonFilePath": "AbstractFluxVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.AbstractFluxVerification", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "AbstractProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.AbstractProcessorVerification", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.tck.AbstractProcessorVerification.publisherExecutorService()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "EmitterProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.EmitterProcessorVerification.createIdentityProcessor(int)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBlackboxProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.setupGlobal()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.tearDownGlobal()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.transformFlux(reactor.core.publisher.Flux)", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.init()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.tearDown()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxGenerateVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.FluxGenerateVerification.createPublisher(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWithProcessorVerification.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.FluxWithProcessorVerification.createIdentityProcessor(int)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["4b2fd19c13beef03e4a72795b9d267d2cb9fd993"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 17, "deletions": 17, "lines": 34, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 27, "UPD": 5, "INS": 9, "MOV": 6, "DEL": 7, "spoonFilesChanged": 8, "spoonMethodsChanged": 15}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", ""], "changesInPackagesSPOON": ["reactor.core.publisher.EventLoopProcessor.onError(java.lang.Throwable)", "reactor.core.publisher.tck.EmitterProcessorVerification.createIdentityProcessor(int)", "reactor.core.publisher.tck.FluxGenerateVerification.createPublisher(long)", "reactor.core.publisher.tck.FluxWithProcessorVerification.createIdentityProcessor(int)", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.setupGlobal()", "reactor.core.publisher.tck.AbstractProcessorVerification.publisherExecutorService()", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.init()", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.transformFlux(reactor.core.publisher.Flux)", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.tearDownGlobal()", "reactor.core.publisher.EventLoopProcessor.onComplete()", "reactor.core.publisher.tck.FluxBlackboxProcessorVerification.tearDown()", "reactor.core.publisher.tck.AbstractFluxVerification", "reactor.core.publisher.tck.AbstractProcessorVerification", "reactor.core.publisher.WorkQueueProcessor.WorkQueueInner.run()"]}, {"title": "settings `-Dreactor.trace.operatorStacktrace=true` obtain `NullPointerException`", "body": "### Expected behavior\r\nSuccess\r\n\r\n### Actual behavior\r\n```\r\nCaused by: java.lang.NullPointerException\r\n\tat reactor.core.publisher.Hooks.onEachOperator(Hooks.java:100)\r\n\tat reactor.core.publisher.Hooks.onEachOperator(Hooks.java:69)\r\n\tat reactor.core.publisher.Hooks.<clinit>(Hooks.java:476)\r\n```\r\n\r\n### Steps to reproduce\r\n1. `Mono.just(\"hello\").subscribe()`\r\n2. settings `-Dreactor.trace.operatorStacktrace=true`\r\n3. Running programs\r\n\r\n### Reactor Core version\r\n`reactor-core:3.1.2.RELEASE`\r\n\r\n### JVM version (e.g. `java -version`)\r\n`jdk1.8.0_121`\r\n\r\n### OS version (e.g. `uname -a`)\r\n`Windows`\r\n\r\nInitialization of variable order problems\r\n[Hooks.java#L471](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/Hooks.java#L471)\r\n\r\n[Hooks.java#L516](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/Hooks.java#L516)\r\n\r\nInitialization `globalTrace`  `log` The instance has not been created yet, cause `NullPointerException`", "url": "https://github.com/reactor/reactor-core/issues/985", "user": "kevin70", "labels": ["type/bug"], "created": "2017-12-14 03:22:38", "closed": "2017-12-18 17:01:09", "commits": {"703bb0bd505eb4da568529d2531f4227daeb4c8f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "075526026156679c9ff2cba3f7775f5b1ad3a540": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "75a0ab0574aa5addc3f5da85247019dd81bc7393": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "703bb0bd505eb4da568529d2531f4227daeb4c8f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "075526026156679c9ff2cba3f7775f5b1ad3a540", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "75a0ab0574aa5addc3f5da85247019dd81bc7393", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["14d607bb18b2a89bf50e0786fb761e1871ec0af7"], "nameRev": "75a0ab0574aa5addc3f5da85247019dd81bc7393 tags/v3.2.0.M1~26", "commitMessage": "fix #985 Prevent NPE when debug mode is activated via command line\n\nThis commit fixes an NPE and subsequent initialization error when the\ndebug mode is activated through the `reactor.trace.operatorStacktrace`\nSystem property, by correctly reordering the static fields and blocks.\n\nAdditionally, the debug mode via command line also uses the correct\nhook key, so that activating via System property then deactivating via\nHooks method would work.\n\nFinally, this behavior is tested as an additional test task in Gradle,\nensuring the property is set and no previous classloading of Hooks has\nbeen done by other tests.\n", "commitDateTime": "2017-12-18 18:01:07", "authoredDateTime": "2017-12-15 12:30:59", "commitGitStats": [{"filePath": "build.gradle", "insertions": 9, "deletions": 0, "lines": 9}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Hooks.java", "insertions": 31, "deletions": 26, "lines": 57}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/HooksTestStaticInit.java", "insertions": 67, "deletions": 0, "lines": 67}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Hooks.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Hooks", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Hooks.OnOperatorDebug", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "HooksTestStaticInit.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.HooksTestStaticInit", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["75a0ab0574aa5addc3f5da85247019dd81bc7393"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 40.0, "deletions": 26.0, "lines": 66.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 1.0, "MOV": 3.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["", "reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Hooks", "reactor.core.publisher.Hooks.OnOperatorDebug"]}, {"title": "Subscription to UnicastProcessor retains Subscriber's reference when disposed", "body": "### Expected behavior\r\n```\r\nUnicastProcessor<String> processor = UnicastProcessor.create();\r\nSystem.out.println(processor.downstreamCount());\r\nDisposable subscription = processor.subscribe();\r\nSystem.out.println(processor.downstreamCount());\r\nsubscription.dispose();\r\nSystem.out.println(processor.downstreamCount());\r\n```\r\nto print `0 1 0`\r\n\r\n### Actual behavior\r\nPrints `0 1 1`.\r\n\r\nThis is due to the processor's `cancel()` method not clearing the `actual` field, which in turn makes `downstreamCount()` return 1.\r\n\r\n### Reactor Core version\r\n3.1.2", "url": "https://github.com/reactor/reactor-core/issues/980", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-12-12 17:44:58", "closed": "2017-12-14 12:57:57", "commits": {"9cfb572072fe30ec08e6ddb497e29ea3cad165eb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5a84a82d7eaf9fde9d426f155026b0adc4b54da3": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "9a76624b2e697d3d8b91b69c960e779096ae1e67": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a013231fe0ad5d1f41fc796e04f4ff82cd9dd8ae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "9cfb572072fe30ec08e6ddb497e29ea3cad165eb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5a84a82d7eaf9fde9d426f155026b0adc4b54da3", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["93bdcd7b95380f9d163c16c9c22dea03336f990a"], "nameRev": "5a84a82d7eaf9fde9d426f155026b0adc4b54da3 tags/v3.2.0.M1~31", "commitMessage": "fix #980 Don't retain reference to UnicastProcessor subscriber on cancel\n\nThis commit makes the UnicastProcessor forget about its `actual` when\r\nthe associated Disposable obtained by subscribing is disposed.", "commitDateTime": "2017-12-14 13:57:54", "authoredDateTime": "2017-12-14 13:57:54", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java", "insertions": 28, "deletions": 2, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "UnicastProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.UnicastProcessor.cancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "UnicastProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.UnicastProcessorTest.subscriptionCancelNullifiesActual()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "9a76624b2e697d3d8b91b69c960e779096ae1e67", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a013231fe0ad5d1f41fc796e04f4ff82cd9dd8ae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["9b7bd24e875973e805c5805a3bf2d5b6e0c82082"], "nameRev": "a013231fe0ad5d1f41fc796e04f4ff82cd9dd8ae tags/v3.2.17.RELEASE~3", "commitMessage": "fix #2124 UnicastProcessor discards when onNext/cancel races\n\nThis is a follow-up to #2125, this time targeting the same class of\ndiscarding race but on `UnicastProcessor`.\n\nAs there is a chance that the race references `actual` (to resolve the\ndiscard hook) AFTER `cancel()`, we need to keep that field populated.\nIt was nulled out for the benefit of `downstreamCount()` (see #980) so\nwe replace that by a boolean, set to true when subscribed.\n\nReviewed-in: #2126\n", "commitDateTime": "2020-04-22 19:25:14", "authoredDateTime": "2020-04-20 19:09:31", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 28, "deletions": 19, "lines": 47}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java", "insertions": 482, "deletions": 465, "lines": 947}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java", "insertions": 2, "deletions": 5, "lines": 7}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["5a84a82d7eaf9fde9d426f155026b0adc4b54da3"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 0.0, "lines": 1.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.UnicastProcessor.cancel()"]}, {"title": "Flux#windowWhen does not remove terminated windows (leak)", "body": "Windows with selector (window(timestamp, timeshift) and windowWhen currently suffer a window leak: the windows set keeps growing.\r\nWould be appropriate to review the impl specially now we have access to CompositeDisposable.", "url": "https://github.com/reactor/reactor-core/issues/975", "user": "smaldini", "labels": ["type/bug"], "created": "2017-12-01 23:44:23", "closed": "2018-01-09 09:53:27", "commits": {"b4e385c4cc6b3d167d5f6f263fc85792a0042304": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a2bd4aec5f29f654ca3bcaebaf284e855d2c52ae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "63c796232078595693af8e81bcef7121e67b2165": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "953cf13206dae9b866d58800975441cc784fcb49": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 38.000277777777775, "commitsDetails": [{"commitHash": "b4e385c4cc6b3d167d5f6f263fc85792a0042304", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a2bd4aec5f29f654ca3bcaebaf284e855d2c52ae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "63c796232078595693af8e81bcef7121e67b2165", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "953cf13206dae9b866d58800975441cc784fcb49", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["a961a7f515c7214e24062762fb33826e8cdb4db9"], "nameRev": "953cf13206dae9b866d58800975441cc784fcb49 tags/v3.2.0.M1~9", "commitMessage": "fix #975 windowWhen reimplementation stops retaining windows\n\nThis commit fixes `windowWhen` leaks by changing `FluxWindowWhen`\nimplementation, bringing it in line with that of RxJava (drained windows\nwere retained until main sequence completion previously).\n\nAdded padding test of QueueDrainSubscriber using the Java Object Layout\n(JOL) tool.\n", "commitDateTime": "2018-01-09 10:53:25", "authoredDateTime": "2018-01-06 12:47:00", "commitGitStats": [{"filePath": "build.gradle", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java", "insertions": 254, "deletions": 331, "lines": 585}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/QueueDrainSubscriber.java", "insertions": 316, "deletions": 0, "lines": 316}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java", "insertions": 376, "deletions": 38, "lines": 414}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/QueueDrainSubscriberTest.java", "insertions": 77, "deletions": 0, "lines": 77}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["953cf13206dae9b866d58800975441cc784fcb49"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 572.0, "deletions": 333.0, "lines": 905.0, "gitFilesChange": 4}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", ""]}, {"title": "Flux#bufferWhen memory leak suspicion using Flux#buffer(timespan, timeshift) when timespan != timeshift", "body": "### Expected behavior\r\nexpect Flux.buffer(Duration.ofMillis(3000), Duration.ofMillis(2000)) behaves as Flux.buffer(Duration.ofMillis(3000), Duration.ofMillis(3000))\r\n\r\n### Actual behavior\r\nWhen timespan is different than timeshift, heap dumps assert that buffered elements are never garbagged before flux completion, while when timespan equals timeshift, they are... \r\n\r\nInstances are retained by reactor.core.publisher.FluxBufferWhen$BufferStartEndMainSubscriber\r\n\r\n\r\n### Steps to reproduce\r\n    static class Wrapper {\r\n        final int i;\r\n\r\n        Wrapper(int i) {this.i = i;}\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Wrapper{\" +\r\n                    \"i=\" + i +\r\n                    '}';\r\n        }\r\n    }\r\n\r\n    public void test() throws InterruptedException {\r\n        final CountDownLatch latch = new CountDownLatch(1);\r\n        final UnicastProcessor<Wrapper> processor = UnicastProcessor.create();\r\n        processor.buffer(Duration.ofMillis(3000), Duration.ofMillis(2000))\r\n                 .doOnNext(t -> System.out.println(String.format(\"tuple %s\", t)))\r\n                 .subscribe();\r\n\r\n        Flux.range(1, Integer.MAX_VALUE)\r\n            .delayElements(Duration.ofMillis(10))\r\n            .doOnNext(i -> processor.onNext(new Wrapper(i)))\r\n            .doOnComplete(processor::onComplete)\r\n            .subscribe();\r\n\r\n        latch.await(10, TimeUnit.MINUTES);\r\n    }\r\n\r\n### Reactor Core version\r\n3.1.2.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n1.8.151\r\n\r\n### OS version (e.g. `uname -a`)\r\n", "url": "https://github.com/reactor/reactor-core/issues/969", "user": "rreynaud", "labels": ["type/bug"], "created": "2017-11-29 22:18:24", "closed": "2018-01-10 07:38:15", "commits": {"9cd691a09aaaabd0b5c99da6a0da1459f42c450c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "139b3657ea3bd2e5821a269fd63aa543f6ef3bde": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7cbd8682d57c8eaac0a0758b441399ebe4acf431": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f4dd2770f5d58b149e3ce1eccbd69d64f3c8e36e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f4492c77199ed9291b3a266ccffe3a9d37c0f6bd": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "9808e06cc1556184feff986b108aa2386cea6f86": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "90951be99bb991c1cc3e7cc81860034258391662": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "f4da436bd9e7b37f46b422e0d53451b92b10fae8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2d9863f8ea0abb225898fd91a2c034b6760d3e26": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "da7f33832d7d458f63668770d7ab6fe9038fa086": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "170f39b2f80fc3f67a837ced5287be7a9b653724": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 41.000277777777775, "commitsDetails": [{"commitHash": "9cd691a09aaaabd0b5c99da6a0da1459f42c450c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "139b3657ea3bd2e5821a269fd63aa543f6ef3bde", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7cbd8682d57c8eaac0a0758b441399ebe4acf431", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f4dd2770f5d58b149e3ce1eccbd69d64f3c8e36e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f4492c77199ed9291b3a266ccffe3a9d37c0f6bd", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "9808e06cc1556184feff986b108aa2386cea6f86", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "90951be99bb991c1cc3e7cc81860034258391662", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["2488d0cb883f725fa47724df6a04464064b9aebe"], "nameRev": "90951be99bb991c1cc3e7cc81860034258391662 tags/v3.2.0.M1~6", "commitMessage": "fix #969 Reimplement FluxBufferWhen and avoid buffer leaks\n", "commitDateTime": "2018-01-09 23:38:12", "authoredDateTime": "2018-01-08 20:28:18", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java", "insertions": 218, "deletions": 383, "lines": 601}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java", "insertions": 128, "deletions": 41, "lines": 169}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "f4da436bd9e7b37f46b422e0d53451b92b10fae8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["7b54d2c38b3701094d664657c1500b89e91bd948"], "nameRev": "f4da436bd9e7b37f46b422e0d53451b92b10fae8 tags/v3.1.3.RELEASE~8", "commitMessage": "Improve #969 tests: add a couple of tests and make them quicker\n", "commitDateTime": "2018-01-16 12:24:25", "authoredDateTime": "2018-01-16 12:24:25", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java", "insertions": 43, "deletions": 4, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.gh969_timedOutBuffersDontLeak()", "TOT": 4, "UPD": 3, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.bufferedCanCompleteIfOpenNeverCompletesDropping()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferWhenTest.bufferedCanCompleteIfOpenNeverCompletesOverlapping()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "2d9863f8ea0abb225898fd91a2c034b6760d3e26", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "da7f33832d7d458f63668770d7ab6fe9038fa086", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "170f39b2f80fc3f67a837ced5287be7a9b653724", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["f1dfcc296a48c5d64ed0656e11fd9436ebfa96ca"], "nameRev": "170f39b2f80fc3f67a837ced5287be7a9b653724 tags/v3.1.3.RELEASE~5", "commitMessage": "follow-up on #969 Improve FluxBufferWhen buffer tracking\n\nThis commit improves FluxBufferWhen implementation once again, by:\r\n\r\n - keeping the tracking of buffer in the main subscriber (no reference\r\n to buffers in close subscribers, to prevent retaining)\r\n - tracking request in main\r\n - correctly cancelling the source when the open subscriber completes\r\n (which means that at this point no new buffer will open) IFF last close\r\n subscriber has also completed\r\n - correctly cancel upstream and clear buffers when open/close\r\n subscribers error.\r\n - overall simplifies the inner subscribers", "commitDateTime": "2018-01-17 10:04:43", "authoredDateTime": "2018-01-17 10:04:43", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java", "insertions": 242, "deletions": 156, "lines": 398}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java", "insertions": 234, "deletions": 7, "lines": 241}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["90951be99bb991c1cc3e7cc81860034258391662", "f4da436bd9e7b37f46b422e0d53451b92b10fae8", "170f39b2f80fc3f67a837ced5287be7a9b653724"], "filteredCommitsReason": {"duplicated": 8, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 460.0, "deletions": 539.0, "lines": 999.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": []}, {"title": "ParallelFlux#composeGroup should conserve parallelism and prefetch", "body": "Currently, it reverts back to default due to its use of `ParallelFlux.from()`\r\n\r\nShould also check if there are any other ParallelFlux operators that this applies to", "url": "https://github.com/reactor/reactor-core/issues/968", "user": "dfeist", "labels": ["good first issue", "type/bug"], "created": "2017-11-29 11:12:55", "closed": "2017-12-15 07:57:26", "commits": {"40421ba954242628d0746679c37090815678dcf8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "506c8b4e728940f4319340ce0eeed4962b4ce37f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "40421ba954242628d0746679c37090815678dcf8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "506c8b4e728940f4319340ce0eeed4962b4ce37f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["5a84a82d7eaf9fde9d426f155026b0adc4b54da3"], "nameRev": "506c8b4e728940f4319340ce0eeed4962b4ce37f tags/v3.2.0.M1~30", "commitMessage": "fix #968 ParallelFlux#composeGroup maintains parallelism()\n\n(and prefetch as well if relevant)", "commitDateTime": "2017-12-15 08:57:24", "authoredDateTime": "2017-12-15 08:57:24", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java", "insertions": 42, "deletions": 0, "lines": 42}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ParallelFlux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFlux.doOnEach(java.util.function.Consumer)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelFlux.doOnTerminate(java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelFlux.sorted(java.util.Comparator,int)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelFlux.composeGroup(java.util.function.Function)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "ParallelFluxTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.composeGroupMaintainsParallelismAndPrefetch()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.composeGroupMaintainsParallelism()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["506c8b4e728940f4319340ce0eeed4962b4ce37f"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 8.0, "deletions": 1.0, "lines": 9.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 7.0, "INS": 4.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.ParallelFlux.doOnEach(java.util.function.Consumer)", "reactor.core.publisher.ParallelFlux.sorted(java.util.Comparator,int)", "reactor.core.publisher.ParallelFlux.composeGroup(java.util.function.Function)", "reactor.core.publisher.ParallelFlux.doOnTerminate(java.lang.Runnable)"]}, {"title": "Use provided `LogLevel` even for onError", "body": "### Expected behavior\r\n`Mono.error(new IllegalStateException(\"boom\")).log(\"foo\", FINE)` logs at DEBUG level with SLF4J.\r\n\r\n### Actual behavior\r\nIt always logs at ERROR level.\r\n\r\n### Steps to reproduce\r\n```java\r\nMono.error(new IllegalStateException(\"boom\"))\r\n\t\t    .log(\"foo\", Level.FINEST)\r\n\t\t    .subscribe(v -> {}, e -> {});\r\n```\r\n>\r\n```\r\n20:29:11.251 [main] ERROR foo - onError(java.lang.IllegalStateException: boom)\r\n20:29:11.258 [main] ERROR foo - \r\njava.lang.IllegalStateException: boom\r\n```\r\n\r\n### Reactor Core version\r\n3.1.2", "url": "https://github.com/reactor/reactor-core/issues/967", "user": "simonbasle", "labels": ["type/bug", "type/enhancement"], "created": "2017-11-28 19:29:39", "closed": "2017-11-30 23:59:35", "commits": {"9cde7c83c4f0363592ac7bcc604b977265b19932": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "93bdcd7b95380f9d163c16c9c22dea03336f990a": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "9cde7c83c4f0363592ac7bcc604b977265b19932", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "93bdcd7b95380f9d163c16c9c22dea03336f990a", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["825d07c20c49e879e6c272e1bcf9f46b9b3f8385"], "nameRev": "93bdcd7b95380f9d163c16c9c22dea03336f990a tags/v3.2.0.M1~32", "commitMessage": "fix #967 If Level is FINE/FINEST, log errors using debug()/trace()\n\notherwise, always use the error() method as was the case before.\n\nThis is a middle ground between previous behavior and the ability to\nsay \"I want to log errors in this chain only if logger is configured\nfor verbosity\".\n", "commitDateTime": "2017-11-30 15:59:33", "authoredDateTime": "2017-11-30 12:46:53", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java", "insertions": 23, "deletions": 5, "lines": 28}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java", "insertions": 133, "deletions": 0, "lines": 133}, {"filePath": "reactor-core/src/test/resources/logback.xml", "insertions": 3, "deletions": 0, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SignalLogger.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLogger.onCompleteCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onRequestCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCancelCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onErrorCall()", "TOT": 13, "UPD": 1, "INS": 6, "MOV": 6, "DEL": 0}]}, {"spoonFilePath": "SignalLoggerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.logErrorUsesErrorWhenInfo()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.logErrorUsesErrorWhenWarning()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.logErrorUsesErrorWhenSevere()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.logErrorUsesDebugWhenFine()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.logErrorUsesTraceWhenFinest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLoggerTests.demonstrateLogError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["93bdcd7b95380f9d163c16c9c22dea03336f990a"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 23.0, "deletions": 5.0, "lines": 28.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 17.0, "UPD": 5.0, "INS": 6.0, "MOV": 6.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "reactor.core.publisher.SignalLogger.onCompleteCall()", "reactor.core.publisher.SignalLogger.onRequestCall()", "reactor.core.publisher.SignalLogger.onCancelCall()", "reactor.core.publisher.SignalLogger.onErrorCall()"]}, {"title": "Behaviour of doFinally", "body": "### Expected behavior\r\n```java\r\n@Test\r\npublic void errorBeforeFinallyTest() {\r\n    System.err.println(\"> error before finally\");\r\n    Mono.just(true)\r\n        .map(this::throwError)\r\n        .doFinally(this::doFinalThing)\r\n        .subscribe();\r\n}\r\n\r\n@Test\r\npublic void errorAfterFinallyTest() {\r\n    System.err.println(\"> error after finally\");\r\n    Mono.just(true)\r\n        .doFinally(this::doFinalThing)\r\n        .map(this::throwError)\r\n        .subscribe();\r\n}\r\n\r\nprivate void doFinalThing(SignalType any) {\r\n    System.err.println(\"do finally called\");\r\n}\r\n\r\nprivate Boolean throwError(Boolean x) {\r\n    System.err.println(\"throw exception\");\r\n    throw new IllegalStateException();\r\n}\r\n```\r\n\r\nAccording to the javadoc shouldn't be both tests have the same log output?\r\n\r\n### Actual behavior\r\n\r\n```\r\n> error after finally\r\nthrow exception\r\ndo finally called\r\n\r\n\r\n> error before finally\r\nthrow exception\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nSee code above\r\n\r\n### Reactor Core version\r\n\r\n3.1.1\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\njava version \"1.8.0_151\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_151-b12)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)\r\n\r\n### OS version (e.g. `uname -a`)\r\nMINGW64_NT-10.0", "url": "https://github.com/reactor/reactor-core/issues/951", "user": "LukasHavemann", "labels": ["type/bug"], "created": "2017-11-15 11:29:55", "closed": "2017-11-27 18:29:33", "commits": {"f30e804e2689fb3dbb80f5b1d1c91920bade16e5": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2a127e03008977d30b50130d3680e3c08787de88": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 12.000277777777777, "commitsDetails": [{"commitHash": "f30e804e2689fb3dbb80f5b1d1c91920bade16e5", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2a127e03008977d30b50130d3680e3c08787de88", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d3e6c4b7816063ceccdc01169fb32e9c3080eb70"], "nameRev": "2a127e03008977d30b50130d3680e3c08787de88 tags/v3.2.0.M1~35", "commitMessage": "fix #951 Protect doFinally against subscribe() throwing\n\nThis commit wraps the application of doFinally's handler in a\r\ntry/finally block, so that in the case where a final subscriber throws\r\n(typically because no error handler was defined), it still executes the\r\ndoFinally handler.", "commitDateTime": "2017-11-27 19:29:32", "authoredDateTime": "2017-11-27 19:29:32", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxDoFinally.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxDoFinallyTest.java", "insertions": 98, "deletions": 0, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDoFinally.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoFinally.DoFinallySubscriber.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "FluxDoFinallyTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDoFinallyTest.gh951_withoutConsumerInSubscribe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoFinallyTest.gh951_withConsumerInSubscribe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoFinallyTest.gh951_whithoutDoOnError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxDoFinallyTest.throwError(java.lang.Boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2a127e03008977d30b50130d3680e3c08787de88"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 2.0, "lines": 8.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 1.0, "MOV": 2.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDoFinally.DoFinallySubscriber.onError(java.lang.Throwable)"]}, {"title": "Inconsistent behaviour of concatDelayError", "body": "### Expected behavior\r\n`Flux.concatDelayError` should always delay errors\r\n\r\n### Actual behavior\r\nFor a *publisher* of *publishers* errors are not delayed\r\n\r\n### Steps to reproduce\r\nThe following test is a minor modification of the test `FluxConatMapTest.publisherOfPublisherDelayError`. Just like that test, I expect this to succeed, but it fails with the message:\r\n `java.lang.AssertionError: expectation \"expectNext(3)\" failed (expected: onNext(3); actual: onError(java.lang.Exception: test))`\r\n```java\r\n@Test\r\npublic void publisherOfPublisherDelayErrorX() {\r\n\tStepVerifier.create(\r\n\t\t\tFlux.concatDelayError(\r\n\t\t\t\t\tFlux.just(\r\n\t\t\t\t\t\t\tFlux.just(1, 2),\r\n\t\t\t\t\t\t\tFlux.error(new Exception(\"test\")),\r\n\t\t\t\t\t\t\tFlux.just(3, 4))))\r\n\t\t\t.expectNext(1, 2, 3, 4)\r\n\t\t\t.verifyErrorMessage(\"test\");\r\n}\r\n```\r\nNote that when calling `Flux.concatDelayError` with *sources...* instead of a *publisher* of *publishers*, the above test is successful.\r\n\r\n### Reactor Core version\r\n3.1.0.RELEASE\r\n\r\n### JVM version\r\n1.8.0_121\r\n\r\n### OS version\r\nDarwin 57172 15.6.0 Darwin Kernel Version 15.6.0: Sun Jun  4 21:43:07 PDT 2017; root:xnu-3248.70.3~1/RELEASE_X86_64 x86_64", "url": "https://github.com/reactor/reactor-core/issues/936", "user": "jebl01", "labels": ["type/bug"], "created": "2017-11-07 11:54:56", "closed": "2017-11-07 17:39:13", "commits": {"ad50712f8f1fb17e75e98e9e5be0c44b531f5138": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "af0cb628ece3c0a543512ea9913c4ff72ba18566": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "ad50712f8f1fb17e75e98e9e5be0c44b531f5138", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "af0cb628ece3c0a543512ea9913c4ff72ba18566", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0ad7976bf1c02bccc28bb478758591bc8108b11a"], "nameRev": "af0cb628ece3c0a543512ea9913c4ff72ba18566 tags/v3.1.2.RELEASE~8", "commitMessage": "fix #936 concat[Map]DelayError(veryEnd) delays Callable errors\n\nThis commit ensures that concatDelayError and concatMapDelayError both\r\ncorrectly delay the error from a Callable source (like Mono.error(t))\r\nwhen the `veryEnd` mode is used, letting other sources be concatenated\r\nbefore the error is propagated.", "commitDateTime": "2017-11-07 18:39:11", "authoredDateTime": "2017-11-07 18:39:11", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 8, "deletions": 6, "lines": 14}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 8, "deletions": 3, "lines": 11}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java", "insertions": 26, "deletions": 0, "lines": 26}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "insertions": 52, "deletions": 0, "lines": 52}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 27, "deletions": 0, "lines": 27}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java", "insertions": 56, "deletions": 0, "lines": 56}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java", "insertions": 25, "deletions": 0, "lines": 25}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/ParallelConcatMapTest.java", "insertions": 31, "deletions": 0, "lines": 31}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": []}, {"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.drain()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxFlatMap.java", "spoonMethods": []}, {"spoonFilePath": "FluxConcatArrayTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatArrayTest.concatArrayDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatArrayTest.concatArrayDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxConcatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.concatDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.concatDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.concatMapDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.concatMapDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.delayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.delayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMergeSequentialTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.flatMapSequentialDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.flatMapSequentialDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.mergeSequentialDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.mergeSequentialDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMergeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeTest.delayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeTest.delayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ParallelConcatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelConcatMapTest.concatDelayErrorWithFluxError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelConcatMapTest.concatDelayErrorWithMonoError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["af0cb628ece3c0a543512ea9913c4ff72ba18566"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 19.0, "deletions": 10.0, "lines": 29.0, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 3.0, "UPD": 0.0, "INS": 1.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.drain()"]}, {"title": "Missing cache(duration) javadoc", "body": "", "url": "https://github.com/reactor/reactor-core/issues/930", "user": "smaldini", "labels": ["type/bug", "type/documentation"], "created": "2017-11-01 15:57:59", "closed": "2017-11-02 17:10:31", "commits": {"1cd669b645858b03b16244aeb4fee1fec922ea49": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "1cd669b645858b03b16244aeb4fee1fec922ea49", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["5ccdbb267fac15a977ca731219366687665c718b"], "nameRev": "1cd669b645858b03b16244aeb4fee1fec922ea49 tags/v3.1.2.RELEASE~11", "commitMessage": "fix #930 Add javadoc for Mono.cache(Duration)\n", "commitDateTime": "2017-11-02 18:10:23", "authoredDateTime": "2017-11-02 18:10:23", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 0, "lines": 12}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1cd669b645858b03b16244aeb4fee1fec922ea49"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 12, "deletions": 0, "lines": 12, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"]}, {"title": "Silent failure on StackOverflowException", "body": "### Expected behavior\r\n\r\nError logged.\r\n\r\n### Actual behavior\r\n\r\nSilent failure and pipeline does not complete.\r\n\r\n### Steps to reproduce\r\n\r\n```\r\n    @Test\r\n    void testErrorInScheduler() {\r\n        Scheduler scheduler = Schedulers.fromExecutor(Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()\r\n                .setUncaughtExceptionHandler((t, ex) -> System.err.print(ex.toString()))\r\n                .build()));\r\n\r\n        Flux<String> source = Flux.just(\"hi\");\r\n\r\n        StepVerifier.create(source.flatMap(item -> Mono.<String>fromCallable(() -> {\r\n            throw new StackOverflowError(\"hi\");\r\n        }).log().subscribeOn(scheduler)))\r\n                .expectError()\r\n                .verify();\r\n    }\r\n```\r\n\r\n### Reactor Core version\r\n3.0.4-RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n1.8\r\n\r\n### OS version (e.g. `uname -a`)\r\n\r\nUbuntu 16.04\r\n", "url": "https://github.com/reactor/reactor-core/issues/916", "user": "devrandom", "labels": ["type/bug"], "created": "2017-10-23 20:36:18", "closed": "2018-01-15 13:14:34", "commits": {"022328a28e09a7f85b51d7998dd1dd3bc6163428": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7b54d2c38b3701094d664657c1500b89e91bd948": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 83.00027777777778, "commitsDetails": [{"commitHash": "022328a28e09a7f85b51d7998dd1dd3bc6163428", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7b54d2c38b3701094d664657c1500b89e91bd948", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["28458e3723e52435cac7827a1dcdae535d0ffb42"], "nameRev": "7b54d2c38b3701094d664657c1500b89e91bd948 tags/v3.1.3.RELEASE~9", "commitMessage": "fix #916 Process fatal exceptions in Schedulers.handleError, don't throw\n\nThe fatal exceptions will probably be thrown down the line and they are\r\nstill considered irrecoverable, but when they happen within a Thread\r\nfrom a Scheduler, they should be passed to the handleError hook\r\nas well as to the Thread's uncaughtExceptionHandler if any.\r\n\r\nSuch a sequence may hang, as the test demonstrates, but the fatal error\r\nhas a chance to be logged.", "commitDateTime": "2018-01-15 14:14:32", "authoredDateTime": "2018-01-15 14:14:32", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 0, "deletions": 1, "lines": 1}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 145, "deletions": 25, "lines": 170}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.handleError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "SchedulersTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testUncaughtHookNotCalledWhenThreadDeath()", "TOT": 57, "UPD": 28, "INS": 0, "MOV": 28, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.immediateTaskIsSkippedIfDisposeRightAfter()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.immediateTaskIsExecuted()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.pingPongParallelCall()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.handleErrorWithJvmFatalForwardsToUncaughtHandlerFusedCallable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.handleErrorWithJvmFatalForwardsToUncaughtHandlerSyncCallable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.handleErrorWithJvmFatalForwardsToUncaughtHandlerSyncInnerCallable()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.handleErrorWithJvmFatalForwardsToUncaughtHandlerFusedInnerCallable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testUncaughtHooksCalledWhenThreadDeath()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7b54d2c38b3701094d664657c1500b89e91bd948"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 0.0, "deletions": 1.0, "lines": 1.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.Schedulers.handleError(java.lang.Throwable)"]}, {"title": "WindowTimeout with small timeout can race and reuse same window", "body": "### Reactor Core version 3.1.0.RELEASE\r\nThis results in a `UnicastProcessor allows only a single Subscriber` message.\r\n\r\n### java -version 1.8\r\n\r\n```java\r\n    public static void main(String[] args) {\r\n        Flux.concat(\r\n                Flux.just(\"#\").delayElements(Duration.ofMillis(20)),\r\n                Flux.range(1, 10),\r\n                Flux.range(11, 5).delayElements(Duration.ofMillis(15))\r\n        )\r\n                .windowTimeout(10, Duration.ofMillis(1))\r\n                .subscribe(flx -> flx.subscribe(System.out::println));\r\n    }\r\n```\r\n\r\n### print result\r\n```java\r\n[ERROR] (parallel-1) Scheduler worker in group main failed with an uncaught exception - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException: UnicastProcessor allows only a single Subscriber\r\nreactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException: UnicastProcessor allows only a single Subscriber\r\nCaused by: java.lang.IllegalStateException: UnicastProcessor allows only a single Subscriber\r\n\tat reactor.core.publisher.UnicastProcessor.subscribe(UnicastProcessor.java:380)\r\n\tat reactor.core.publisher.FluxWindowTimeOrSize$Window.subscribe(FluxWindowTimeOrSize.java:98)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6447)\r\n\tat reactor.core.publisher.Flux.subscribeWith(Flux.java:6614)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6440)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6404)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6347)\r\n\tat com.artshell.reactor.operators.FluxWindowTimeout.lambda$main$0(FluxWindowTimeout.java:17)\r\n\tat reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:130)\r\n\tat reactor.core.publisher.SerializedSubscriber.onNext(SerializedSubscriber.java:89)\r\n\tat reactor.core.publisher.FluxWindowTimeOrSize$WindowTimeoutSubscriber.windowCloseByTimeout(FluxWindowTimeOrSize.java:215)\r\n\tat reactor.core.publisher.FluxWindowTimeOrSize$WindowTimeoutSubscriber.lambda$new$0(FluxWindowTimeOrSize.java:178)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:71)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:39)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```", "url": "https://github.com/reactor/reactor-core/issues/912", "user": "artshell", "labels": ["type/bug"], "created": "2017-10-20 06:42:18", "closed": "2017-10-20 23:05:10", "commits": {"4675191cca90f5f9837d2c8ce456b64d1eb5a5d9": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "4d215d924b4260210966e77e3962339444df79ab": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "4675191cca90f5f9837d2c8ce456b64d1eb5a5d9", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "4d215d924b4260210966e77e3962339444df79ab", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["76f22f68a59864f26d7f28688f32f4d018116238"], "nameRev": "4d215d924b4260210966e77e3962339444df79ab tags/v3.1.1.RELEASE~2", "commitMessage": "fix #912 rework windowTimeout internal to ensure consistency (#913)\n\n- The previous windowTimeout implementation inherited from older design\r\nand wasn't aligned with last year work from Reactive Streams Commons.\r\nWith drainLoop design, we can now ensure proper serialization without\r\nrequiring an internal Serialized Subscriber.", "commitDateTime": "2017-10-20 16:05:09", "authoredDateTime": "2017-10-20 16:05:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Disposable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/Disposables.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/{FluxBufferTimeOrSize.java => FluxBufferTimeout.java}", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 0, "deletions": 401, "lines": 401}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeout.java", "insertions": 445, "deletions": 0, "lines": 445}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/{FluxBufferTimeOrSizeTest.java => FluxBufferTimeoutTest.java}", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/{FluxWindowTimeOrSizeTest.java => FluxWindowTimeoutTest.java}", "insertions": 23, "deletions": 6, "lines": 29}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxWindowConsistencyTest.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Parallel should requestFusion with THREAD_BARRIER", "body": "Thanks @akarnokd for the ping - https://github.com/ReactiveX/RxJava/pull/5677\r\n\r\nIssue/Fix is pretty straightforward.", "url": "https://github.com/reactor/reactor-core/issues/905", "user": "smaldini", "labels": ["type/bug"], "created": "2017-10-17 17:53:31", "closed": "2017-10-19 15:54:31", "commits": {"5c0616627aac52430f969a042e10f44ce82c2f84": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ac77e9f4ef1bc8c47a073a30bd3d5ef436802db9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "5c0616627aac52430f969a042e10f44ce82c2f84", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ac77e9f4ef1bc8c47a073a30bd3d5ef436802db9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d16e2c92d516411b632c467b931ba3872910d695"], "nameRev": "ac77e9f4ef1bc8c47a073a30bd3d5ef436802db9 tags/v3.1.1.RELEASE~4", "commitMessage": "fix #905 ParallelFlux now considered a THREAD_BARRIER\n\nThis commit makes ParallelSource request fusion with the THREAD_BARRIER\nflag when subscribing to a Fuseable source. Since most of the time\n`parallel()` is immediately followed by `runOn()`, upstream operators\ncould previously execute on an unwanted thread (which is unexpected for\neg. map and doOn*). Now such operators can decide not to fuse, restoring\ntheir expected behavior.\n", "commitDateTime": "2017-10-19 17:54:29", "authoredDateTime": "2017-10-18 10:40:54", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java", "insertions": 36, "deletions": 0, "lines": 36}], "commitSpoonAstDiffStats": [{"spoonFilePath": "ParallelSource.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelSource.ParallelSourceMain.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "ParallelFluxTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.fromFuseableUsesThreadBarrier()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ac77e9f4ef1bc8c47a073a30bd3d5ef436802db9"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.ParallelSource.ParallelSourceMain.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "A lot of operators don't check they actually have a Scannable for scanUnsafe(Attr<Scannable>)", "body": "### Expected behavior\r\nAll `scanUnsafe` implementations should return a `Scannable` when called with `PARENT` or `ACTUAL`.\r\n\r\n### Actual behavior\r\nA lot of operators don't necessarily check that this is the case. They will happily return e.g. a `CoreSubscriber`, which **happens** to have mostly `Scannable` implementations (including the ones used in tests). But if you create an operator with an `actual` bare `CoreSubsriber`, scanning it for ACTUAL will fail with a `ClassCastException`.\r\n\r\n### Steps to reproduce\r\n```\r\n@Test\r\npublic void scanFail() {\r\n    Scannable scannable = new FluxReplay<>(subscriber -> { }, 2, 2, null);\r\n    Scannable parent = scannable.scan(Scannable.Attr.PARENT); // <-- ClassCastException\r\n\r\n    assertThat(parent).isNotNull();\r\n    assertThat(parent.isScanAvailable()).isFalse();\r\n}\r\n```\r\n\r\n### Reactor Core version\r\n3.1.0.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/895", "user": "simonbasle", "labels": ["type/bug", "type/enhancement"], "created": "2017-10-06 11:03:58", "closed": "2017-10-18 16:32:18", "commits": {"9a4380f37b09723dff9771861f3b99128d4ddbd8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "76b570df329a3237add5af59a92dd8842908297d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7f589bbad0aa536e617f29ac3340b22a2a408aa4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "34e3b624574feb66474998e7876825320b127b57": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 12.000277777777777, "commitsDetails": [{"commitHash": "9a4380f37b09723dff9771861f3b99128d4ddbd8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "76b570df329a3237add5af59a92dd8842908297d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7f589bbad0aa536e617f29ac3340b22a2a408aa4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "34e3b624574feb66474998e7876825320b127b57", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c3dc0d7e94e5bc51aa6bc23a89b14fb50bbd9fca"], "nameRev": "34e3b624574feb66474998e7876825320b127b57 tags/v3.1.1.RELEASE~8", "commitMessage": "fix #895 Safer scan of ACTUAL and PARENT\n\nThis commit makes scanning of ACTUAL and PARENT safer by introducing a\r\nsafe converter in the Attr class. By default, no converter is defined\r\nand the old behavior of force-casting is still used.\r\n\r\nFor the two attributes above however, the value from `scanUnsafe` goes\r\nthrough `Scannable#from` first when calling `scan` or `scanOrDefault`.\r\nThat way, even though a lot of operators blindly return something that\r\nis Scannable _in most case but not necessarily_ (e.g. a Publisher),\r\nthe outer scan will not fail.\r\n", "commitDateTime": "2017-10-18 18:32:16", "authoredDateTime": "2017-10-18 18:32:16", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Scannable.java", "insertions": 66, "deletions": 10, "lines": 76}, {"filePath": "reactor-core/src/test/java/reactor/core/ScannableTest.java", "insertions": 52, "deletions": 0, "lines": 52}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Scannable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Attr", "TOT": 10, "UPD": 2, "INS": 5, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.scan(reactor.core.Scannable$Attr)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.scanOrDefault(reactor.core.Scannable$Attr,java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.Attr.isConversionSafe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.Attr.tryConvert(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ScannableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ScannableTest.scanForParentIsSafe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ScannableTest.scanForActualIsSafe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ScannableTest.scanForRawParentOrActual()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ScannableTest.attributeIsConversionSafe()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["34e3b624574feb66474998e7876825320b127b57"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 66.0, "deletions": 10.0, "lines": 76.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 18.0, "UPD": 2.0, "INS": 9.0, "MOV": 5.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core"], "changesInPackagesSPOON": ["reactor.core.scan(reactor.core.Scannable$Attr)", "reactor.core.scanOrDefault(reactor.core.Scannable$Attr,java.lang.Object)", "reactor.core.Attr.isConversionSafe()", "reactor.core.Attr", "reactor.core.Attr.tryConvert(java.lang.Object)"]}, {"title": "Every java source file is duplicated in the 3.1.0 source jar in the central maven repository", "body": "### Expected behavior\r\nThe java source files should not be duplicated\r\n\r\n### Actual behavior\r\nThey are duplicated\r\n\r\n### Steps to reproduce\r\nDownload file from http://repo1.maven.org/maven2/io/projectreactor/reactor-core/3.1.0.RELEASE/reactor-core-3.1.0.RELEASE-sources.jar\r\nCheck contents of the jar.\r\n\r\n### Reactor Core version\r\n3.1.0.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\nN/A\r\n\r\n### OS version (e.g. `uname -a`)\r\nN/A\r\n", "url": "https://github.com/reactor/reactor-core/issues/887", "user": "akiraly", "labels": ["status/has-workaround", "type/bug", "type/chores"], "created": "2017-09-28 07:43:16", "closed": "2017-10-21 10:11:38", "commits": {"65d8a3328b326dcde2dfb54b11ea377466bd3291": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a0a913aab4ce2d8ec56f264c1ed16e94230c88dd": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 23.00027777777778, "commitsDetails": [{"commitHash": "65d8a3328b326dcde2dfb54b11ea377466bd3291", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a0a913aab4ce2d8ec56f264c1ed16e94230c88dd", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["1be3b2e988c9656df57f77e7ae079f429efe1243"], "nameRev": "a0a913aab4ce2d8ec56f264c1ed16e94230c88dd tags/v3.1.1.RELEASE~19", "commitMessage": "see #887 Workaround the source jar java file duplication issue (#888)\n\nSee https://youtrack.jetbrains.com/issue/KT-17564\r\nWill be fixed in kotlin-gradle-plugin 1.1.60", "commitDateTime": "2017-10-02 13:05:34", "authoredDateTime": "2017-10-02 13:05:34", "commitGitStats": [{"filePath": "build.gradle", "insertions": 7, "deletions": 0, "lines": 7}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Cannot create RingBuffer on jdk9", "body": "### Expected behavior\r\nTo be able to create event loop processors backed by a ring buffer\r\n### Actual behavior\r\n\r\n```\r\nCaused by: java.lang.IllegalStateException: This JVM does not support sun.misc.Unsafe\r\n\tat reactor.core.publisher.RingBuffer.createMultiProducer(RingBuffer.java:129) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.EventLoopProcessor.<init>(EventLoopProcessor.java:270) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.TopicProcessor.<init>(TopicProcessor.java:674) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.TopicProcessor.<init>(TopicProcessor.java:661) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.TopicProcessor.<init>(TopicProcessor.java:645) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.TopicProcessor.share(TopicProcessor.java:550) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\tat reactor.core.publisher.TopicProcessor.share(TopicProcessor.java:356) ~[reactor-core-3.0.6.RELEASE.jar:3.0.6.RELEASE]\r\n\r\n```\r\n\r\n### Steps to reproduce\r\n```TopicProcessor.share(false)```\r\n### Reactor Core version\r\n3.0.6.RELEASE\r\n### JVM version (e.g. `java -version`)\r\n9\r\n### OS version (e.g. `uname -a`)\r\n x86_64 GNU/Linux\r\n\r\n\r\n\r\nSeems like this assumption (https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java#L501) that a heap buffer's address will be 0 is no longer valid, and is now 16\r\n\r\nseems that HeapByteBuffer changed in (http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/5e0fd2cdcd55)  -  something to do with var handles http://openjdk.java.net/jeps/193\r\n", "url": "https://github.com/reactor/reactor-core/issues/881", "user": "tsachev", "labels": ["area/java9", "type/bug"], "created": "2017-09-25 20:53:33", "closed": "2017-10-04 14:40:54", "commits": {"f899529c70396b11850d84298281096a25994bb1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b9a54b7296624d1e23ba00c8b0b821fc7c5c8c86": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "21964938931662234495a1b378c1682cff81107f": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "c230f581dc95ca4f64e43473090af35c83b42be9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "f899529c70396b11850d84298281096a25994bb1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b9a54b7296624d1e23ba00c8b0b821fc7c5c8c86", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "21964938931662234495a1b378c1682cff81107f", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c834955a4ba70c3edd75a241ba5e42f9386b3c1b"], "nameRev": "21964938931662234495a1b378c1682cff81107f tags/v3.1.1.RELEASE~17", "commitMessage": "fix #881 Avoid UnsafeSupport deep reflection, fix buffer address check\n\nfix #881 Avoid UnsafeSupport deep reflection, fix buffer address check\r\n\r\n - For ByteBuffer, Field#setAccessible(true) leads to warning in java 9\r\n - HeapByteBuffer does use the address field in java 9, didn't in java 8\r\n (so we need to cover both cases)\r\n - Added some TRACE and DEBUG logging with the cause of not initializing\r\n Unsafe\r\n\r\nThe whole UnsafeSupport code has been reworked, reordering the checks as\r\nthe address field must now be accessed through Unsafe.\r\n\r\nThis whole commit makes usage of RingBuffer more compatible with Java 9.\r\nIt also now properly credits Netty, including the copyright header from\r\nthe original license.", "commitDateTime": "2017-10-04 16:40:52", "authoredDateTime": "2017-10-04 16:40:52", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java", "insertions": 110, "deletions": 32, "lines": 142}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "reactor-core/src/test/resources/logback.xml", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "RingBuffer.java", "spoonMethods": []}, {"spoonFilePath": "TopicProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.TopicProcessorTest.createSmokeTest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "c230f581dc95ca4f64e43473090af35c83b42be9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["21964938931662234495a1b378c1682cff81107f"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 110.0, "deletions": 32.0, "lines": 142.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": []}, {"title": "Flux.publish(Function) not cancelling upstream", "body": "### Expected behavior\r\n\r\nUpstream receives cancel signal (`Flux.create()` in this case)\r\n\r\n### Actual behavior\r\n\r\n`OutOfMemoryError` because of `Flux.create()` default of `OverflowStrategy.BUFFER`\r\n\r\n### Steps to reproduce\r\n\r\n```java\r\n        CountDownLatch cancelled = new CountDownLatch(1);\r\n        StepVerifier.create(Flux.<Integer>create(sink -> {\r\n            int i = 0;\r\n            sink.onCancel(cancelled::countDown);\r\n            try {\r\n                while (true) {\r\n                    sink.next(i++);\r\n                    Thread.sleep(1);\r\n                    if (sink.isCancelled()) {\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (InterruptedException e) {\r\n                sink.error(e);\r\n            }\r\n        })\r\n                                .subscribeOn(Schedulers.parallel())\r\n                                .publish()\r\n                                .refCount()\r\n//                    .doOnCancel(() -> System.out.println(\"cancel 2\"))\r\n                                .publish(Function.identity())\r\n//                    .doOnCancel(() -> System.out.println(\"cancel 1\"))\r\n                                .take(5))\r\n                    .expectNextCount(5)\r\n                    .verifyComplete();\r\n\r\n        if (!cancelled.await(5, TimeUnit.SECONDS)) {\r\n            fail(\"Flux.create() did not receive cancellation signal\");\r\n        }\r\n```\r\n\r\n### Reactor Core version\r\n\r\n3.1.0.RC1\r\n", "url": "https://github.com/reactor/reactor-core/issues/870", "user": "osi", "labels": ["type/bug"], "created": "2017-09-20 13:53:39", "closed": "2017-09-21 16:58:23", "commits": {"1aca5f8838d1a12c30d3916efaeade2934a7d406": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "b1aa844d259349168e35e2b35ab3f2fc6b17b4fb": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "3dd9f38be50711bc5c40b0ac6dfdfdf5fc645653": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "f0262b78c09fd8dd57e8294cf8d795fafc137127": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "1aca5f8838d1a12c30d3916efaeade2934a7d406", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b1aa844d259349168e35e2b35ab3f2fc6b17b4fb", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3dd9f38be50711bc5c40b0ac6dfdfdf5fc645653", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f0262b78c09fd8dd57e8294cf8d795fafc137127", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["1798dd9b5f99e7808761be83d46151a2c3228c20"], "nameRev": "f0262b78c09fd8dd57e8294cf8d795fafc137127 tags/v3.1.0.RC2~5", "commitMessage": "fix #870 multicast cancel now disposes upstream properly\n\n- Apply some state simplification\r\n- Leave terminal signals racing cancel", "commitDateTime": "2017-09-21 09:58:21", "authoredDateTime": "2017-09-21 09:58:21", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublishMulticast.java", "insertions": 97, "deletions": 93, "lines": 190}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPublishMulticast.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 46, "deletions": 9, "lines": 55}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublishMulticast.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.removeAndDrain(reactor.core.publisher.FluxPublishMulticast$PublishMulticastInner)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.terminate()", "TOT": 9, "UPD": 1, "INS": 1, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.onError(java.lang.Throwable)", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.onError(java.lang.Throwable)", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner.cancel()", "TOT": 7, "UPD": 2, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.subscribe(reactor.core.CoreSubscriber)", "TOT": 6, "UPD": 3, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 5, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.drainSync()", "TOT": 17, "UPD": 0, "INS": 7, "MOV": 6, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.drainAsync()", "TOT": 36, "UPD": 0, "INS": 11, "MOV": 17, "DEL": 8}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.cancel()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.cancel()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.onComplete()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.cancel()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.onComplete()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoPublishMulticast.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishMulticast.subscribe(reactor.core.CoreSubscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishMulticastTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.cancelComposes()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scanMulticaster()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scanMulticastInner()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scanCancelMulticaster()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scanCancelFuseableMulticaster()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scenarios_errorFromUpstreamFailure()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.scenarios_operatorSuccess()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishMulticastTest.gh870()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f0262b78c09fd8dd57e8294cf8d795fafc137127"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 98.0, "deletions": 94.0, "lines": 192.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 112.0, "UPD": 12.0, "INS": 27.0, "MOV": 42.0, "DEL": 31.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 18}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.removeAndDrain(reactor.core.publisher.FluxPublishMulticast$PublishMulticastInner)", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.terminate()", "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.onError(java.lang.Throwable)", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.drainAsync()", "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.cancel()", "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner", "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner.cancel()", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.onError(java.lang.Throwable)", "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.onComplete()", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.drainSync()", "reactor.core.publisher.FluxPublishMulticast.PublishMulticastInner.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxPublishMulticast.CancelMulticaster.onComplete()", "reactor.core.publisher.FluxPublishMulticast.FluxPublishMulticaster.cancel()", "reactor.core.publisher.FluxPublishMulticast.CancelFuseableMulticaster.cancel()", "reactor.core.publisher.MonoPublishMulticast.subscribe(reactor.core.CoreSubscriber)"]}, {"title": "Exception happens even with onErrorReturn", "body": "### Expected behavior\r\nPrint the value inside onErrorReturn and exits without exception.\r\n\r\n### Actual behavior\r\nSometimes the expected behavior is observed, but very often following exception happens. Same thing happens with onErrorResume as well.\r\n\r\nException in thread \"main\" reactor.core.Exceptions$CancelException: The subscriber has denied dispatching\r\n\tat reactor.core.Exceptions.failWithCancel(Exceptions.java:148)\r\n\tat reactor.core.publisher.Operators.onNextDropped(Operators.java:282)\r\n\tat reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onNext(FluxTimeout.java:141)\r\n\tat reactor.core.publisher.FluxGenerate$GenerateSubscription.next(FluxGenerate.java:164)\r\n\tat hillman.reactive.simple.SimpleTest.lambda$print$1(SimpleTest.java:34)\r\n\tat reactor.core.publisher.FluxGenerate.lambda$new$1(FluxGenerate.java:56)\r\n\tat reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:218)\r\n\tat reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:197)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1381)\r\n\tat reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onSubscribe(FluxTimeout.java:120)\r\n\tat reactor.core.publisher.FluxGenerate.subscribe(FluxGenerate.java:83)\r\n\tat reactor.core.publisher.FluxTimeout.subscribe(FluxTimeout.java:82)\r\n\tat reactor.core.publisher.FluxPeek.subscribe(FluxPeek.java:83)\r\n\tat reactor.core.publisher.FluxOnErrorResume.subscribe(FluxOnErrorResume.java:46)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6292)\r\n\tat reactor.core.publisher.Flux.subscribeWith(Flux.java:6360)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6285)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6249)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6192)\r\n\tat hillman.reactive.simple.SimpleTest.print(SimpleTest.java:38)\r\n\tat hillman.reactive.simple.SimpleTest.main(SimpleTest.java:22)\r\n\r\n### Steps to reproduce\r\nI tried with following simple code. The timeout of 3ms is arbitrary to make TimeoutException happens.\r\n`\r\n        Flux.generate(sink -> sink.next(0))\r\n            .timeout(Duration.ofMillis(3L))\r\n            .doOnTerminate(() -> log.info(\"doOnTerminate\"))\r\n            .onErrorReturn(-1)\r\n            .subscribe(v -> log.info(\"{}\", v));\r\n`\r\n### Reactor Core version\r\n3.1.0M3\r\n\r\n### JVM version (e.g. `java -version`)\r\nopenjdk version \"1.8.0_131\"\r\nOpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-2ubuntu1.16.04.2-b11)\r\nOpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)\r\n\r\n### OS version (e.g. `uname -a`)\r\n4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux\r\n", "url": "https://github.com/reactor/reactor-core/issues/851", "user": "hillmanli-seekers", "labels": ["type/bug"], "created": "2017-09-06 03:25:33", "closed": "2017-09-11 01:43:29", "commits": {}, "ttf": 4.000277777777778, "commitsDetails": []}, {"title": "Exceptions.unwrap should never return null", "body": "### Expected behavior\r\n\r\n`Exceptions.unwrap(Throwable)` to return the unwrapped exception\r\n\r\n### Actual behavior\r\n\r\n`null` was returned\r\n\r\n### Steps to reproduce\r\n\r\nI believe that this is coming from a `CancelException` (via `onNextDropped`) which is the only case of a `ReactiveException` that has a null `getCause`.\r\n\r\nThis causes `Schedulers.handleError` (or in my case `ForkJoinPoolScheduler.handleError`) to log no exception, just the message. \r\n\r\n### Reactor Core version\r\n\r\n3.1.0M3\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/848", "user": "osi", "labels": ["type/bug"], "created": "2017-09-05 19:12:19", "closed": "2017-09-05 20:36:10", "commits": {"291dccca81a5fc451a2631b356dbf886cd4a4bf3": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "a5f68da306d5ac2cc94e1970350f8f752da8a740": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "291dccca81a5fc451a2631b356dbf886cd4a4bf3", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["80a321073e896c56ba6bd6831f0f7f078d567e88"], "nameRev": "291dccca81a5fc451a2631b356dbf886cd4a4bf3 tags/v3.1.0.RC1~8", "commitMessage": "fix #848 align Flux.first with Mono.first and Flux.or with Mono.or\n", "commitDateTime": "2017-09-05 13:28:49", "authoredDateTime": "2017-09-05 13:28:49", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 28, "deletions": 27, "lines": 55}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingTest.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingWithTest.java", "insertions": 6, "deletions": 7, "lines": 13}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/docs/asciidoc/operatorChoice.adoc", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.firstEmitting(org.reactivestreams.Publisher[])", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.firstEmitting(java.lang.Iterable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.firstEmittingWith(org.reactivestreams.Publisher)", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxFirstEmittingTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.arrayNull()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.firstWinner()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.firstWinnerBackpressured()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.secondWinner()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.secondEmitsError()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.singleArrayNullSource()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.arrayOneIsNullSource()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.singleIterableNullSource()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingTest.iterableOneIsNullSource()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFirstEmittingWithTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingWithTest.dontBreakAmb()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingWithTest.pairWise()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingWithTest.pairWiseIterable()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFirstEmittingWithTest.noStackOverflow()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "CombinationTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.CombinationTests.sampleAmbTest()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a5f68da306d5ac2cc94e1970350f8f752da8a740", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["291dccca81a5fc451a2631b356dbf886cd4a4bf3"], "nameRev": "a5f68da306d5ac2cc94e1970350f8f752da8a740 tags/v3.1.0.RC1~7", "commitMessage": "fix #848 keep actual reference if unwrapped exception is null\n", "commitDateTime": "2017-09-05 13:36:00", "authoredDateTime": "2017-09-05 13:36:00", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Exceptions.java", "insertions": 26, "deletions": 26, "lines": 52}, {"filePath": "reactor-core/src/test/java/reactor/core/ExceptionsTest.java", "insertions": 9, "deletions": 1, "lines": 10}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions.unwrap(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.Exceptions.unwrapMultiple(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ExceptionsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ExceptionsTest.testNullWrapping()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["291dccca81a5fc451a2631b356dbf886cd4a4bf3", "a5f68da306d5ac2cc94e1970350f8f752da8a740"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 56, "deletions": 54, "lines": 110, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 8, "UPD": 4, "INS": 1, "MOV": 2, "DEL": 1, "spoonFilesChanged": 2, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", "src/docs/asciidoc/operatorChoice.adoc", "reactor-core/src/main/java/reactor/core"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.firstEmitting(java.lang.Iterable)", "reactor.core.publisher.Flux.firstEmitting(org.reactivestreams.Publisher[])", "reactor.core.publisher.Flux.firstEmittingWith(org.reactivestreams.Publisher)", "reactor.core.Exceptions.unwrapMultiple(java.lang.Throwable)", "reactor.core.Exceptions.unwrap(java.lang.Throwable)"]}, {"title": "Infinite loop in Flux.create(...).sort(...).toStream().collect(toSet())", "body": "### Expected behavior\r\nHave an exception raised\r\n\r\n### Actual behavior\r\nInfinite loop during execution\r\n\r\n### Steps to reproduce\r\n```\r\nFlux.<String>create(sink -> {\r\n\tsink.next(\"a\");\r\n\tsink.next(\"b\");\r\n\tsink.complete();\r\n}).sort((a, b) -> {\r\n\tthrow new RuntimeException(\"test\");\r\n}).toStream().collect(toSet());\r\n```\r\n\r\n### Reactor Core version\r\n3.0.4.RELEASE\r\n\r\n### JVM version (e.g. `java -version`)\r\njava version \"1.8.0_144\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_144-b01)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)\r\n\r\n### OS version (e.g. `uname -a`)\r\nLinux my-pc 3.16.0-38-generic #52~14.04.1-Ubuntu SMP Fri May 8 09:43:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\n\r\n### Comment\r\nWhen I use `Flux.fromIterable(asList(\"a\",\"b\"))` instead of `Flux.create`, it works as expected.\r\nWhen I use `toIterable()` instead of `toStream().collect(toSet())`, it works as expected.\r\n\r\nSo I don't understand what's happening", "url": "https://github.com/reactor/reactor-core/issues/841", "user": "micolator", "labels": ["type/bug"], "created": "2017-09-04 16:11:24", "closed": "2017-09-05 16:38:45", "commits": {"be4aea3c95de926fbd10ef42e0f22de3ad1f96a3": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "8b0197bcf0c6c5f5a6308b0f3f3c31759fb4fe59": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "cb5f67d9f4d69d29f35343823783d3c6767c1393": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "be4aea3c95de926fbd10ef42e0f22de3ad1f96a3", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8b0197bcf0c6c5f5a6308b0f3f3c31759fb4fe59", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "cb5f67d9f4d69d29f35343823783d3c6767c1393", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["66d97f8ba3f8e75a69461508767c157fa2f4998c"], "nameRev": "cb5f67d9f4d69d29f35343823783d3c6767c1393 tags/v3.1.0.RC1~10", "commitMessage": "fix #841 Catch fused flattenIterable polling failures\n\nThis commit catches exceptions when polling queues in the\nFluxFlattenIterable drain methods, ensuring the operator short circuits\nand propagates the error to its actual.\n\nThis would notably impact BlockingIterable with a fused source like a\nFlux.create: the iterable would not see the error early and would enter\nits hasNext loop, looping indefinitely.\n", "commitDateTime": "2017-09-05 18:38:42", "authoredDateTime": "2017-09-05 16:17:38", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "insertions": 17, "deletions": 3, "lines": 20}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/BlockingIterableTest.java", "insertions": 98, "deletions": 1, "lines": 99}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFlattenIterableTest.java", "insertions": 24, "deletions": 0, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFlattenIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainSync()", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainAsync()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "BlockingIterableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_streamCreate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_streamCreateDeferredError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_streamFromIterable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_iteratorFromCreate()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_workaroundFlux()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.BlockingIterableTest.gh841_workaroundStream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlattenIterableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlattenIterableTest.asyncDrainWithPollFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlattenIterableTest.syncDrainWithPollFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["cb5f67d9f4d69d29f35343823783d3c6767c1393"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 17.0, "deletions": 3.0, "lines": 20.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 9.0, "UPD": 0.0, "INS": 4.0, "MOV": 4.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainAsync()", "reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainSync()"]}, {"title": "Rename Mono.currentContext", "body": "Currently the interface clashes in MonoProcessor if we want it to implement CoreSubscriber.\r\nThe simplest way to go around that before RC1 on Context API is to change Mono.currentContext to something else. We have the next few days to choose so suggestions box is open.\r\n\r\nIf nothing else we can go with Mono.subscriberContext() to map the existing instance method subscriberContext(Context) and subscriberContext(Function<Context,Context>). \r\n\r\ncc @rwinch @rstoyanchev @yschimke ", "url": "https://github.com/reactor/reactor-core/issues/831", "user": "smaldini", "labels": ["type/bug"], "created": "2017-08-31 04:16:29", "closed": "2017-09-01 17:28:58", "commits": {"1b209a7e251aadb95c79eb805cfc800a9cd16980": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "b3d17aeedc38231142f89dfae9097fdef3b7f6e4": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "1b209a7e251aadb95c79eb805cfc800a9cd16980", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["2cd83c2ff770d800010d0a7f060b803f7279299c"], "nameRev": "1b209a7e251aadb95c79eb805cfc800a9cd16980 tags/v3.1.0.RC1~26", "commitMessage": "fix #831 Rename Mono.currentContext to subscriberContext()\n", "commitDateTime": "2017-09-01 10:28:55", "authoredDateTime": "2017-09-01 10:28:30", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 18, "deletions": 18, "lines": 36}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/ContextTests.java", "insertions": 8, "deletions": 8, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.currentContext()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ContextTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ContextTests.currentContextWithEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.monoSubscriberContextPutsAll()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.monoSubscriberContextWithMergedEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.monoSubscriberContextWithBothEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.fluxSubscriberContextPutsAll()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.fluxSubscriberContextWithMergedEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.fluxSubscriberContextWithBothEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ContextTests.currentContext()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "b3d17aeedc38231142f89dfae9097fdef3b7f6e4", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1b209a7e251aadb95c79eb805cfc800a9cd16980"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 18.0, "deletions": 18.0, "lines": 36.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 1.0, "INS": 0.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Mono.currentContext()"]}, {"title": "StepVerifier.withVirtualTime and Spring Data Hangs", "body": "### Expected behavior\r\n\r\n`StepVerifier.withVirtualTime` with Spring Data should be used without causing the test to hang\r\n\r\n### Actual behavior\r\n\r\n`StepVerifier.withVirtualTime` and Spring Data cause the test to hang\r\n\r\n### Steps to reproduce\r\n\r\n#### Update\r\n\r\nThis test will reproduce the issue without any dependencies. I'd like to ensure before this is resolved that we test the original issue too.\r\n\r\n```java\r\n@Test\r\npublic void gh783() {\r\n    int size = 1;\r\n    Scheduler parallel = Schedulers.newParallel(\"gh-783\");\r\n    StepVerifier.withVirtualTime(() -> Flux.just(\"Oops\")\r\n            .take(size)\r\n            .subscribeOn(parallel)\r\n            .flatMap(message -> {\r\n                Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));\r\n                return interval.map( tick -> message);\r\n            })\r\n            .take(size)\r\n            .collectList()\r\n        )\r\n        .thenAwait(Duration.ofHours(1))\r\n        .consumeNextWith(list -> Assert.assertTrue(list.size() == size))\r\n        .verifyComplete();\r\n}\r\n```\r\n\r\n#### Original Issue\r\n\r\nYou can find a complete sample at https://github.com/rwinch/flux-flix-service/tree/reactor-778 The relevant tests can be found in [FluxFlixServiceApplicationTests](https://github.com/rwinch/flux-flix-service/blob/reactor-778/flux-flix-service/src/test/java/com/example/fluxflixservice/FluxFlixServiceApplicationTests.java#L56-L102) and are copied below:\r\n\r\n```java\r\n@Test\r\npublic void withVirtualTimeAndSpringDataThenHangs() {\r\n    StepVerifier.withVirtualTime(() -> this.movies.findAll() // only this line differs\r\n            .take(1)\r\n            .flatMap(movie -> {\r\n                Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));\r\n                return interval.map( tick -> new MovieEvent(new Date(), movie));\r\n            })\r\n            .take(SIZE)\r\n            .collectList()\r\n        )\r\n        .thenAwait(Duration.ofHours(1))\r\n        .consumeNextWith(list -> Assert.assertTrue(list.size() == SIZE))\r\n        .verifyComplete();\r\n}\r\n\r\n@Test\r\npublic void withNoVirtualTimeAndSpringDataThenWorks() {\r\n    StepVerifier.create(this.movies.findAll() // only this line differs\r\n            .take(1)\r\n            .flatMap(movie -> {\r\n                Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));\r\n                return interval.map( tick -> new MovieEvent(new Date(), movie));\r\n            })\r\n            .take(SIZE)\r\n            .collectList()\r\n        )\r\n        .thenAwait(Duration.ofHours(1))\r\n        .consumeNextWith(list -> Assert.assertTrue(list.size() == SIZE))\r\n        .verifyComplete();\r\n}\r\n\r\n@Test\r\npublic void withVirtualTimeAndNoSpringDataThenWorks() {\r\n    StepVerifier.withVirtualTime(() -> Flux.just(new Movie(\"Mocked\")) // only this line differs\r\n            .take(1)\r\n            .flatMap(movie -> {\r\n                Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));\r\n                return interval.map( tick -> new MovieEvent(new Date(), movie));\r\n            })\r\n            .take(SIZE)\r\n            .collectList()\r\n        )\r\n        .thenAwait(Duration.ofHours(1))\r\n        .consumeNextWith(list -> Assert.assertTrue(list.size() == SIZE))\r\n        .verifyComplete();\r\n}\r\n```\r\n\r\nIt is worth pointing out that both Spring Data and `StepVerifier.withVirtualTime` need to be called to cause the application to hang. \r\n\r\nThis is related to #776 but the test [gh776](https://github.com/rwinch/flux-flix-service/blob/reactor-778/flux-flix-service/src/test/java/com/example/fluxflixservice/FluxFlixServiceApplicationTests.java#L104-L114) passes and demonstrates that the fix is found but does not resolve this specific issue.\r\n\r\n### Reactor Core version\r\n\r\n3.1.0.BUILD-SNAPSHOT\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```bash\r\njava -version\r\njava version \"1.8.0_121\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\r\n```\r\n\r\n### OS version (e.g. `uname -a`)\r\n\r\n```bash\r\nuname -a\r\nLinux obladi 4.8.0-56-generic #61~16.04.1-Ubuntu SMP Wed Jun 14 11:58:22 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\r\n```", "url": "https://github.com/reactor/reactor-core/issues/783", "user": "rwinch", "labels": ["area/reactor-test", "type/bug"], "created": "2017-08-08 16:12:14", "closed": "2018-05-01 13:20:15", "commits": {"41a81ac76b4583ecc8a6f5a2c9537367d8d6a795": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5a55222683735fc9713b18b7f8dfa455e9008788": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "135047dbb0e86fde9e953710523e7ad805eba1fb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "62d657928fa1b9ae11b767c0abd8c3d4c927243e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "59081bcdd19c24f0336310d5f033cc504343d4cc": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a07a4ab0b6872dc927b70648a1e9815ffc286aae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ab4b72b765144b6ada22f5df3e58b483780628b8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "36289cf98ac0afac12aa2e78e1e07ad43fca47cb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "66051ffd53632db92b00b0c8ccd0cc27e90432d0": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "4b4f20a55d2f39218e374b0632518da74c600a0f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "559e2f58e00bce2cdf3fabef00b2c369a274c16f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0534d6b97ffd4f69b788eef5d2827b409d08447a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "37ce9e5a69ba184a20af75443948a0691071bf1a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "092c2c8e2209da9676c3bec445897b4d3cd6220b": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "ba5383e6a707c044df2171779db476ec6e565120": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "8d942e145c9d1d4a0b75085ffad291c1513edb60": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 265.0002777777778, "commitsDetails": [{"commitHash": "41a81ac76b4583ecc8a6f5a2c9537367d8d6a795", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5a55222683735fc9713b18b7f8dfa455e9008788", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "135047dbb0e86fde9e953710523e7ad805eba1fb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "62d657928fa1b9ae11b767c0abd8c3d4c927243e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "59081bcdd19c24f0336310d5f033cc504343d4cc", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a07a4ab0b6872dc927b70648a1e9815ffc286aae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ab4b72b765144b6ada22f5df3e58b483780628b8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "36289cf98ac0afac12aa2e78e1e07ad43fca47cb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "66051ffd53632db92b00b0c8ccd0cc27e90432d0", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d9d76aba749022466d125890d13e3ba0f23702cd"], "nameRev": "66051ffd53632db92b00b0c8ccd0cc27e90432d0 tags/v3.2.0.M2~38", "commitMessage": "fix #783 Let VirtualTimeScheduler defer advanceTime if queue is empty\n\nThis commit changes the way clock advanceTime is performed when the\r\n`VirtualTimeScheduler`'s task queue is empty, deferring the clock move\r\nuntil a task is scheduled.\r\n\r\nThis eliminates ordering issues where a scheduling task (like interval)\r\nwould happen AFTER the clock was moved (eg. by a `StepVerifier`'s\r\n`thenAwait`), resulting in the interval being scheduled too far away in\r\nthe \"future\" and never happening.\r\n\r\nThe commit also moves `RaceTestUtils` from core test sourceset to\r\nreactor-test main sourceset and fixes an issue in\r\n`DefaultVerifierSubscriber` where the current expectation is not\r\nrefreshed from the script queue after wait tasks have been extracted.\r\n\r\nReviewed-In: #1127\r\n", "commitDateTime": "2018-05-01 15:20:11", "authoredDateTime": "2018-05-01 15:20:11", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/CompositeDisposableTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/DisposablesTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/ExceptionsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/WorkerTaskTest.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 9, "deletions": 8, "lines": 17}, {"filePath": "reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java", "insertions": 60, "deletions": 19, "lines": 79}, {"filePath": "{reactor-core/src/test/java/reactor/test => reactor-test/src/main/java/reactor/test/util}/RaceTestUtils.java", "insertions": 22, "deletions": 3, "lines": 25}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 87, "deletions": 1, "lines": 88}, {"filePath": "reactor-test/src/test/java/reactor/test/scheduler/VirtualTimeSchedulerTests.java", "insertions": 135, "deletions": 0, "lines": 135}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CompositeDisposableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.CompositeDisposableTest.disposeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.CompositeDisposableTest.removeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.CompositeDisposableTest.sizeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DisposablesTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.DisposablesTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.DisposablesTest.setReplace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.DisposablesTest.setRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExceptionsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ExceptionsTest.addThrowableRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxExpandTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthEmitCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthCompleteCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxLimitRequestTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxLimitRequestTest.raceRequest()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.raceSubscribeAndCache()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoExpandTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthEmitCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthCompleteCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OperatorDisposablesTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.setReplace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.setRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OperatorsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorsTest.addAndGetAtomicField()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkerTaskTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.setFutureCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.setFutureRunRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.runDispose()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.runFuture()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.syncWorkerCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onTaskEvent()", "TOT": 7, "UPD": 1, "INS": 5, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onExpectation(reactor.core.publisher.Signal)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "VirtualTimeScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTime(long)", "TOT": 12, "UPD": 2, "INS": 3, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.PeriodicTask.run()", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTimeBy(java.time.Duration)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTimeTo(java.time.Instant)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.now(java.util.concurrent.TimeUnit)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "RaceTestUtils.java", "spoonMethods": [{"spoonMethodName": "reactor.test.RaceTestUtils.race(java.lang.Object,java.util.function.Function,java.util.function.Predicate,java.util.function.BiPredicate)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.RaceTestUtils.race(java.lang.Runnable,java.lang.Runnable,reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.gh783()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_deferredAdvanceTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_withInnerFlatmap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_intervalFullyEmitted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_firstSmallAdvance()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "VirtualTimeSchedulerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.captureNowInScheduledTask()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.nestedSchedule()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnEmptyQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnFullQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnVaryingQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4b4f20a55d2f39218e374b0632518da74c600a0f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["df637bf696b78096fdad9485e824194e6f2fa3cb"], "nameRev": "4b4f20a55d2f39218e374b0632518da74c600a0f tags/v3.1.7.RELEASE~8", "commitMessage": "port #783 Let VirtualTimeScheduler defer advanceTime if queue is empty\n\nThis commit changes the way clock advanceTime is performed when the\n`VirtualTimeScheduler`'s task queue is empty, deferring the clock move\nuntil a task is scheduled.\n\nThis eliminates ordering issues where a scheduling task (like interval)\nwould happen AFTER the clock was moved (eg. by a `StepVerifier`'s\n`thenAwait`), resulting in the interval being scheduled too far away in\nthe \"future\" and never happening.\n\nThe commit also moves `RaceTestUtils` from core test sourceset to\nreactor-test main sourceset and fixes an issue in\n`DefaultVerifierSubscriber` where the current expectation is not\nrefreshed from the script queue after wait tasks have been extracted.\n\nReviewed-In: #1127\nThis is a backport of #783 (commit 66051ff), as tracked in #1175\n", "commitDateTime": "2018-05-01 09:21:17", "authoredDateTime": "2018-05-01 15:20:11", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/CompositeDisposableTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/DisposablesTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/ExceptionsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/WorkerTaskTest.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 9, "deletions": 8, "lines": 17}, {"filePath": "reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java", "insertions": 60, "deletions": 19, "lines": 79}, {"filePath": "{reactor-core/src/test/java/reactor/test => reactor-test/src/main/java/reactor/test/util}/RaceTestUtils.java", "insertions": 22, "deletions": 3, "lines": 25}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 87, "deletions": 1, "lines": 88}, {"filePath": "reactor-test/src/test/java/reactor/test/scheduler/VirtualTimeSchedulerTests.java", "insertions": 135, "deletions": 0, "lines": 135}], "commitSpoonAstDiffStats": [{"spoonFilePath": "CompositeDisposableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.CompositeDisposableTest.disposeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.CompositeDisposableTest.removeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.CompositeDisposableTest.sizeConcurrent()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DisposablesTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.DisposablesTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.DisposablesTest.setReplace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.DisposablesTest.setRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExceptionsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ExceptionsTest.addThrowableRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxExpandTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthEmitCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxExpandTest.depthCompleteCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxLimitRequestTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxLimitRequestTest.raceRequest()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCacheTimeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCacheTimeTest.raceSubscribeAndCache()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoExpandTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthEmitCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoExpandTest.depthCompleteCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OperatorDisposablesTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.setReplace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.OperatorDisposablesTest.setRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "OperatorsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.OperatorsTest.addAndGetAtomicField()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkerTaskTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.setFutureCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.setFutureRunRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.disposeRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.runDispose()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.runFuture()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.WorkerTaskTest.syncWorkerCancelRace()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onTaskEvent()", "TOT": 7, "UPD": 1, "INS": 5, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.DefaultVerifySubscriber.onExpectation(reactor.core.publisher.Signal)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "VirtualTimeScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTime(long)", "TOT": 12, "UPD": 2, "INS": 3, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.PeriodicTask.run()", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTimeBy(java.time.Duration)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.advanceTimeTo(java.time.Instant)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.drain()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.now(java.util.concurrent.TimeUnit)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "RaceTestUtils.java", "spoonMethods": [{"spoonMethodName": "reactor.test.RaceTestUtils.race(java.lang.Object,java.util.function.Function,java.util.function.Predicate,java.util.function.BiPredicate)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.RaceTestUtils.race(java.lang.Runnable,java.lang.Runnable,reactor.core.scheduler.Scheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.gh783()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_deferredAdvanceTime()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_withInnerFlatmap()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_intervalFullyEmitted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.gh783_firstSmallAdvance()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "VirtualTimeSchedulerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.captureNowInScheduledTask()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.nestedSchedule()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnEmptyQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnFullQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeSchedulerTests.racingAdvanceTimeOnVaryingQueue()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "559e2f58e00bce2cdf3fabef00b2c369a274c16f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0534d6b97ffd4f69b788eef5d2827b409d08447a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "37ce9e5a69ba184a20af75443948a0691071bf1a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["07b3e12555b6ff6f2c8df2693a1e1e14be936ee4"], "nameRev": "37ce9e5a69ba184a20af75443948a0691071bf1a tags/v3.1.7.RELEASE~6", "commitMessage": "see #783 Disable doubly-nested schedules VTS thenAwait test\n\nThis case isn't fully taken care of by the previous fix, which still\r\nimproves the situation for delayed schedules on a single nesting level.", "commitDateTime": "2018-05-01 12:10:56", "authoredDateTime": "2018-05-01 12:10:56", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/StepVerifier.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 4, "deletions": 1, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "StepVerifier.java", "spoonMethods": []}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.gh783_withInnerFlatmap()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "092c2c8e2209da9676c3bec445897b4d3cd6220b", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ba5383e6a707c044df2171779db476ec6e565120", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "8d942e145c9d1d4a0b75085ffad291c1513edb60", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["64318b5f36e30c5cb9ddc0742d15778ce773d5f7"], "nameRev": "8d942e145c9d1d4a0b75085ffad291c1513edb60 tags/v3.2.0.M2~34", "commitMessage": "see #783 Disable doubly-nested schedules VTS thenAwait test\n\nThis case isn't fully taken care of by the previous fix, which still\r\nimproves the situation for delayed schedules on a single nesting level.", "commitDateTime": "2018-05-02 12:51:22", "authoredDateTime": "2018-05-01 12:10:56", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/StepVerifier.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 4, "deletions": 1, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "StepVerifier.java", "spoonMethods": []}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.gh783_withInnerFlatmap()", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["37ce9e5a69ba184a20af75443948a0691071bf1a"], "filteredCommitsReason": {"duplicated": 13, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 28.0, "deletions": 0.0, "lines": 28.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": []}, {"title": "Using StepVerifier.withVirtualTime can cause test to hang", "body": "### Expected behavior\r\n\r\nIt should not hang\r\n\r\n### Actual behavior\r\n\r\nIt hangs\r\n\r\n### Steps to reproduce\r\n\r\nThe only difference between the two tests below is the duration of 1 hour (works) vs duration of 1000 hours which hangs.\r\n\r\n```java\r\nint size = 2;\r\n\r\n@Test\r\npublic void works() {\r\n\tStepVerifier.withVirtualTime(() -> Flux.interval(Duration.ofMillis(1))\r\n\t\t\t\t.map(tick -> new Date())\r\n\t\t\t\t.take(size)\r\n\t\t\t\t.collectList()\r\n\t\t\t)\r\n\t\t\t.thenAwait(Duration.ofHours(1))\r\n\t\t\t.consumeNextWith(list -> Assert.assertTrue(list.size() == size))\r\n\t\t\t.verifyComplete();\r\n}\r\n\r\n@Test\r\npublic void hangs() {\r\n\tStepVerifier.withVirtualTime(() -> Flux.interval(Duration.ofMillis(1))\r\n\t\t\t\t.map(tick -> new Date())\r\n\t\t\t\t.take(size)\r\n\t\t\t\t.collectList()\r\n\t\t\t)\r\n\t\t\t.thenAwait(Duration.ofHours(1000))\r\n\t\t\t.consumeNextWith(list -> Assert.assertTrue(list.size() == size))\r\n\t\t\t.verifyComplete();\r\n}\r\n```\r\n### Reactor Core version\r\n\r\nBismuth-BUILD-SNAPSHOT\r\n\r\n### JVM version (e.g. `java -version`)\r\n\r\n```\r\njava -version\r\njava version \"1.8.0_121\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\r\n````\r\n\r\n### OS version (e.g. `uname -a`)\r\n\r\n```\r\nuname -a\r\nLinux obladi 4.8.0-56-generic #61~16.04.1-Ubuntu SMP Wed Jun 14 11:58:22 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\r\n```", "url": "https://github.com/reactor/reactor-core/issues/776", "user": "rwinch", "labels": ["type/bug"], "created": "2017-08-03 15:43:59", "closed": "2017-08-07 21:22:54", "commits": {"701ccc9411d83ef2a16af257552bb9ca993c1dd4": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 4.000277777777778, "commitsDetails": [{"commitHash": "701ccc9411d83ef2a16af257552bb9ca993c1dd4", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["914e06487b15861c5e02dc0e60e5da74146157bb"], "nameRev": "701ccc9411d83ef2a16af257552bb9ca993c1dd4 tags/v3.1.0.RC1~70", "commitMessage": "fix #776 VirtualTimeScheduler shutdown is not correctly handled with periods\n", "commitDateTime": "2017-08-07 14:22:00", "authoredDateTime": "2017-08-07 14:22:00", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java", "insertions": 47, "deletions": 46, "lines": 93}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "reactor-test/src/test/resources/logback.xml", "insertions": 32, "deletions": 0, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "VirtualTimeScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask", "TOT": 6, "UPD": 5, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask.run()", "TOT": 20, "UPD": 17, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask.dispose()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.PeriodicTask.run()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.isDisposed()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.virtualTimeSchedulerVeryLong()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["701ccc9411d83ef2a16af257552bb9ca993c1dd4"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 47, "deletions": 46, "lines": 93, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 39, "UPD": 25, "INS": 2, "MOV": 10, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test/scheduler"], "changesInPackagesSPOON": ["reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask.run()", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.isDisposed()", "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.dispose()", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.PeriodicTask.run()", "reactor.test.scheduler.VirtualTimeScheduler.PeriodicTask.dispose()", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable)", "reactor.test.scheduler.VirtualTimeScheduler.VirtualTimeWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)"]}, {"title": "Exceptions.addThrowable always creates a nested structure", "body": "### Expected behavior\r\n`Exceptions.addThrowable` would create a \"composite\" exception as soon as a second exception is seen, then keep adding new exceptions as suppressed to that first composite exception.\r\nThis would result in a structure like this:\r\n\r\n> - *Composite*\r\n>   - exception 1\r\n>   - exception 2\r\n>   - exception 3\r\n>   - exception 4\r\n\r\n### Actual behavior\r\n`addThrowable` creates a deeply nested structure with a new composite for each subsequent exception, resulting in a structure like this:\r\n\r\n> - *Composite*\r\n>   - exception 1\r\n>   - *Composite*\r\n>     - exception 2\r\n>     - *Composite*\r\n>       - exception 3\r\n>       - exception 4\r\n\r\n### Steps to reproduce\r\nShould be easily reproduced with a `flatMapDelayError` with just errors, by looking at the whole stacktrace rather than just the `Multiple exceptions` message.\r\n\r\n### Reactor Core version\r\n3.1.0.M3 and below\r\n", "url": "https://github.com/reactor/reactor-core/issues/771", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-08-02 14:07:35", "closed": "2017-08-03 15:30:01", "commits": {"73fc2614dd0b0905fabcb8e971f48a5eb713e812": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e482fc2cdfbe204192f8495bba546b4ff44d52cb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "062280d2f6cb943ff3d8d8f125d6785a742061ac": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "daffbb3cebd7bf485641f762256434732d3ae35d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "73fc2614dd0b0905fabcb8e971f48a5eb713e812", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e482fc2cdfbe204192f8495bba546b4ff44d52cb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "062280d2f6cb943ff3d8d8f125d6785a742061ac", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "daffbb3cebd7bf485641f762256434732d3ae35d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c28b638a73059fcf50bccd158cb612e08cd79f14"], "nameRev": "daffbb3cebd7bf485641f762256434732d3ae35d tags/v3.1.0.RC1~83", "commitMessage": "fix #771 Exceptions.addThrowable now reuse same root composite\n\nThis commit fixes a bug where `addThrowable` would keep creating nested\ncomposite exceptions for Throwables past the second one, resulting in a\ndeeply nested structure with composites of 1 composite + 1 legit error.\n\nThis is now fixed, and past the first error a single CompositeException\nis created and reused for further errors, which all end up as suppressed\nsiblings.\n", "commitDateTime": "2017-08-03 17:29:58", "authoredDateTime": "2017-08-02 18:40:42", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Exceptions.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/ExceptionsTest.java", "insertions": 53, "deletions": 0, "lines": 53}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions.addThrowable(java.util.concurrent.atomic.AtomicReferenceFieldUpdater,java.lang.Object,java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExceptionsTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ExceptionsTest", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ExceptionsTest.resetAddThrowable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ExceptionsTest.addThrowable()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.ExceptionsTest.addThrowableRace()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["daffbb3cebd7bf485641f762256434732d3ae35d"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 7.0, "deletions": 2.0, "lines": 9.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core"], "changesInPackagesSPOON": ["reactor.core.Exceptions.addThrowable(java.util.concurrent.atomic.AtomicReferenceFieldUpdater,java.lang.Object,java.lang.Throwable)"]}, {"title": "Getting UnsupportedOperationException in publishOn", "body": "Hi Reactor Team,\r\n\r\nConsider the following code. The motivation is to enrich each value from Publisher `a` with a single value from Publisher `b` (it's known that `b` emits exactly one value) to make a pair.\r\n\r\n```\r\npublic class Main {\r\n\r\n    public static void main(String... args) {\r\n        Publisher<String> a = Flux.just(\"a\");\r\n        Publisher<String> b = Mono.just(\"b\");\r\n\r\n        Flux<Tuple2<String, String>> result =\r\n                Flux.from(a)\r\n                        .flatMap(value -> Mono.just(value).and(Mono.from(b)))\r\n                        .publishOn(Schedulers.single());\r\n\r\n        result.subscribe();\r\n    }\r\n}\r\n```\r\n\r\nThis crashes with following exception:\r\n\r\n```\r\nException in thread \"main\" java.lang.UnsupportedOperationException: Operators should not use this method!\r\n\tat reactor.core.Fuseable$QueueSubscription.offer(Fuseable.java:117)\r\n\tat reactor.core.publisher.FluxPublishOn$PublishOnSubscriber.onNext(FluxPublishOn.java:225)\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:947)\r\n\tat reactor.core.publisher.MonoWhen$WhenCoordinator.signal(MonoWhen.java:249)\r\n\tat reactor.core.publisher.MonoWhen$WhenInner.onNext(MonoWhen.java:308)\r\n\tat reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1668)\r\n\tat reactor.core.publisher.MonoWhen$WhenInner.onSubscribe(MonoWhen.java:298)\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\tat reactor.core.publisher.MonoWhen$WhenCoordinator.subscribe(MonoWhen.java:178)\r\n\tat reactor.core.publisher.MonoWhen.subscribe(MonoWhen.java:124)\r\n\tat reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:168)\r\n\tat reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:91)\r\n\tat reactor.core.publisher.FluxPublishOn.subscribe(FluxPublishOn.java:94)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6575)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6542)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:6431)\r\n\tat ru.stepuk.bergamo.Main.main(Main.java:20)\r\n\r\n```\r\n\r\nIf I put more values in Publisher `a` i.e. `Publisher<String> a = Flux.just(\"a\", \"x\");` the error disappears.\r\n\r\nIt also disappears if I put empty `doOnNext` (`.doOnNext(x->{})`) before `publishOn`.\r\n\r\nI guess it's some kind of assembly-time optimization bug? Reproducing in 3.0.7.RELEASE and in 3.1.0.M3. Please let me know if any additional information is required from me.", "url": "https://github.com/reactor/reactor-core/issues/767", "user": "Stepuk", "labels": ["type/bug"], "created": "2017-07-29 21:58:12", "closed": "2017-07-31 16:23:18", "commits": {"8928511053579c7b1d038e2365cb5da3a19b15cc": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0be308bcab785b75d90383a751cc3b18c81eaa5e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "475ca5e50c52217fb46e4f25e890984e64fa6a9d": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "8928511053579c7b1d038e2365cb5da3a19b15cc", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0be308bcab785b75d90383a751cc3b18c81eaa5e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "475ca5e50c52217fb46e4f25e890984e64fa6a9d", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["73daad474c578136e09a6b63063f5a33bdbbe0ec"], "nameRev": "475ca5e50c52217fb46e4f25e890984e64fa6a9d tags/v3.1.0.RC1~97", "commitMessage": "fix #767 Revert publishOn async path detection over-optimization\n\nThis commit reverts an optimization from 5254299 that causes a bug\nin some cases where the ASYNC fusion mode is enabled but the onNext is\ncalled with a non-null value.\n\nThis would result in calling `offer` on some QueueSubscription, most of\nwhich will just throw an `UnsupportedOperationException`.\n", "commitDateTime": "2017-07-31 18:23:15", "authoredDateTime": "2017-07-31 15:54:09", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 45, "deletions": 1, "lines": 46}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "FluxPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.publishOnAsyncDetection()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.publishOnAsyncDetectionConditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["475ca5e50c52217fb46e4f25e890984e64fa6a9d"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 8.0, "UPD": 0.0, "INS": 4.0, "MOV": 0.0, "DEL": 4.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.onNext(java.lang.Object)"]}, {"title": "Restore Scannable attribute LARGE_BUFFERED default to `null` ", "body": "In M3 the `LARGE_BUFFERED` attribute's default value was switched to `0`. The original value of `null` was chosen so as to avoid a change in all operators that answer `BUFFERED` and never grow past the integer limit (the majority of them). With that default in place, there was no need to cover every buffering operator as it would default to saying \"LARGE_BUFFERED is irrelevant\".\r\n\r\nWith the mistaken change in M3, it can be a little misguiding since an operator that is buffering could answer eg. `32` to `BUFFERED` but would most likely provide a different answer (`0`) to `LARGE_BUFFERED`... The javadoc is also misaligned with the behavior (still documents a default of `null`)", "url": "https://github.com/reactor/reactor-core/issues/751", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-07-24 14:39:35", "closed": "2017-07-25 15:11:51", "commits": {"3fb9a2302dd82dcc6c81e78758983df64cd6de9e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "16b7697236909a6f62802b95ee062ead0cb26221": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "3fb9a2302dd82dcc6c81e78758983df64cd6de9e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "16b7697236909a6f62802b95ee062ead0cb26221", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["eabc608e2f21882fd09379882b962f8942b037f1"], "nameRev": "16b7697236909a6f62802b95ee062ead0cb26221 tags/v3.1.0.RC1~109", "commitMessage": "fix #751 Attr.LARGE_BUFFERED defaults back to null (as in \"irrelevant\")\n", "commitDateTime": "2017-07-25 17:11:49", "authoredDateTime": "2017-07-25 16:48:50", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Scannable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/ScannableTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Scannable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Attr", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ScannableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.ScannableTest.meaningfulDefaults()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SerializedSubscriberTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SerializedSubscriberTest.scanSerializedSubscriberMaxBuffered()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["16b7697236909a6f62802b95ee062ead0cb26221"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 1.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core"], "changesInPackagesSPOON": ["reactor.core.Attr"]}, {"title": "CancellationException: Disconnected when using Flux.any().delayElement() together with refCnt(2)", "body": "It seems that `Flux.any().delayElement()` cancels the subscription multiple times. If used in conjunction with `Flux.refCnt(2)`, this leads to unexpeted exceptions or missing signals.\r\n\r\n### Steps to reproduce\r\n\r\nIn the following test case a `Flux.refCnt(2)` has two subscribers. One subscriber simply collects all elements. The other subscriber uses `any()` and `delayElement()` to wait for an element matching a predicate and waiting a short time afterwards.\r\n\r\n**Expected behaviour:** The \"collecting\" subsciber collects all emitted elements.\r\n**Actual behaviour:** The \"collecting\" subscriber receives a onError signal with `java.util.concurrent.CancellationException: Disconnected`.\r\n\r\n```java\r\n\r\n  @Test\r\n  public void delayElementShouldNotCancelTwice() throws Exception {\r\n    DirectProcessor<Long> p = DirectProcessor.create();\r\n\r\n    Flux<Long> publishedFlux = p\r\n        .publish()\r\n        .refCount(2);\r\n\r\n    publishedFlux\r\n        .any(x -> x > 5)\r\n        .delayElement(Duration.ofMillis(2))\r\n        .subscribe();\r\n\r\n    CompletableFuture<List<Long>> result = publishedFlux.collectList().toFuture();\r\n\r\n    for (long i = 0; i < 10; i++) {\r\n      p.onNext(i);\r\n      Thread.sleep(1);\r\n    }\r\n    p.onComplete();\r\n\r\n    assertEquals(10, result.get(10, TimeUnit.MILLISECONDS).size());\r\n  }\r\n```\r\n\r\nIf you replace `any().delayElement()` with `delayElements()` everything works as expected. \r\n\r\n### Reactor Core version\r\ncurrent master 2e63297e231eae0c01a1f7c95fd950c8c04bb55a\r\n\r\n### JVM version (e.g. `java -version`)\r\njava version \"1.8.0_121\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\r\n\r\n### OS version (e.g. `uname -a`)\r\nDarwin 16.6.0 Darwin Kernel Version 16.6.0", "url": "https://github.com/reactor/reactor-core/issues/749", "user": "mlex", "labels": ["type/bug"], "created": "2017-07-19 14:45:37", "closed": "2017-07-27 16:17:32", "commits": {"7deacae67db19b69964b910db6b03f38fd5d22b3": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "7deacae67db19b69964b910db6b03f38fd5d22b3", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["e01c7385de7d723e10fa693fef878f47187c7d86"], "nameRev": "7deacae67db19b69964b910db6b03f38fd5d22b3 tags/v3.1.0.RC1~104", "commitMessage": "fix #749 remove cancel during onNext for MonoDelayElement", "commitDateTime": "2017-07-27 09:17:29", "authoredDateTime": "2017-07-27 14:24:03", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 30, "deletions": 0, "lines": 30}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDelayElementTest.java", "insertions": 32, "deletions": 0, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoDelayElement.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onNext(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 3}]}, {"spoonFilePath": "FluxRefCountTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountTest.delayElementShouldNotCancelTwice()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoDelayElementTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayElementTest.completeOnNextWithoutCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7deacae67db19b69964b910db6b03f38fd5d22b3"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 0, "deletions": 3, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 3, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onNext(java.lang.Object)"]}, {"title": "FluxTimeout race between next event and timeout signal", "body": "I encountered the following stack trace:\r\n\r\n```\r\n        at reactor.core.Exceptions.failWithCancel(Exceptions.java:148)\r\n        at reactor.core.publisher.Operators.onNextDropped(Operators.java:279)\r\n        at reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onNext(FluxTimeout.java:135)\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:109)\r\n        at reactor.core.publisher.FluxFilter$FilterSubscriber.onNext(FluxFilter.java:97)\r\n        at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:77)\r\n        at reactor.core.publisher.FluxReplay$SizeBoundReplayBuffer.replayNormal(FluxReplay.java:787)\r\n        at reactor.core.publisher.FluxReplay$SizeBoundReplayBuffer.replay(FluxReplay.java:871)\r\n        at reactor.core.publisher.ReplayProcessor$ReplayInner.request(ReplayProcessor.java:561)\r\n        at reactor.core.publisher.MonoNext$NextSubscriber.request(MonoNext.java:103)\r\n        at reactor.core.publisher.FluxFilter$FilterSubscriber.request(FluxFilter.java:161)\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:150)\r\n        at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1300)\r\n        at reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onSubscribe(FluxTimeout.java:119)\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:87)\r\n        at reactor.core.publisher.FluxFilter$FilterSubscriber.onSubscribe(FluxFilter.java:76)\r\n        at reactor.core.publisher.MonoNext$NextSubscriber.onSubscribe(MonoNext.java:65)\r\n        at reactor.core.publisher.ReplayProcessor.subscribe(ReplayProcessor.java:313)\r\n        at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:41)\r\n        at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46)\r\n        at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55)\r\n        at reactor.core.publisher.MonoTimeout.subscribe(MonoTimeout.java:77)\r\n```\r\n\r\nWith code that's similar to:\r\n\r\n```\r\nreplayProcessorInstance\r\n    .next()\r\n    .filter()\r\n    .map()\r\n    .timeout(duration, replacement, scheduler)\r\n```\r\n\r\nI don't think I have anything wrong. In reading the code of `FluxTimeout` it is unclear how it protects against a race between the timeout firing and the cancellation of the main subscription.\r\n\r\nspecifically, https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxTimeout.java#L134 isn't checking to see if the timeout has fired and cancelled and the onNext is a valid event that can occur prior to cancellation (since it is async).\r\n\r\nis my analysis correct?", "url": "https://github.com/reactor/reactor-core/issues/744", "user": "osi", "labels": ["type/bug"], "created": "2017-07-17 19:49:36", "closed": "2017-08-30 17:25:17", "commits": {"59f656a1568e3e4a88954758a694360ffb9e7219": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5c116f395275e66ba689056a5388b98f5053e62b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 43.000277777777775, "commitsDetails": [{"commitHash": "59f656a1568e3e4a88954758a694360ffb9e7219", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5c116f395275e66ba689056a5388b98f5053e62b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["7d1f12e0815340207604899840fb1e067965959b"], "nameRev": "5c116f395275e66ba689056a5388b98f5053e62b tags/v3.1.0.RC1~31", "commitMessage": "close #744 which is fixed by #823 + test timeout continues after drop\n\nSince the Operators.onNextDropped now doesn't throw, when a timeout\noccurs at the same time as an onNext (or if the cancellation from the\ntimeout isn't propagated), we can safely drop the value without failing\nthe sequence.\n\nAdded a test to that effect.\n", "commitDateTime": "2017-08-30 19:25:15", "authoredDateTime": "2017-08-30 19:11:01", "commitGitStats": [{"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java", "insertions": 37, "deletions": 0, "lines": 37}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxTimeoutTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTimeoutTest.timeoutDropWhenNoCancelWithoutFallback()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxTimeoutTest.timeoutDropWhenNoCancelWithFallback()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Make MonoProcessor.block() infinite ", "body": "Inconsistent with current Mono.block() : \r\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java#L124", "url": "https://github.com/reactor/reactor-core/issues/722", "user": "smaldini", "labels": ["type/bug", "warn/api-change"], "created": "2017-07-10 16:58:58", "closed": "2017-07-12 21:55:15", "commits": {"d8c7bf03f5229626cddda15c337754f9af1afba2": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2773a777b3e260789bcb3a6c12683f33a6de995e": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "a027dd902e2ffc698c7b44f4fc0a24c8ac18e8d6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "1cf9364ca057cdb5aab63dd29b7d79c283b8ea96": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "d8c7bf03f5229626cddda15c337754f9af1afba2", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2773a777b3e260789bcb3a6c12683f33a6de995e", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["f04616be48ecdd9f2321bce5835742db881298e9"], "nameRev": "2773a777b3e260789bcb3a6c12683f33a6de995e tags/v3.1.0.M3~18", "commitMessage": "fix #722 MonoProcessor.block() has no timeout\n", "commitDateTime": "2017-07-12 22:55:13", "authoredDateTime": "2017-07-12 19:31:23", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 17, "deletions": 7, "lines": 24}, {"filePath": "reactor-core/src/main/java/reactor/util/concurrent/WaitStrategy.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java", "insertions": 14, "deletions": 0, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor.block(java.time.Duration)", "TOT": 8, "UPD": 1, "INS": 4, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.block()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "WaitStrategy.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.WaitStrategy", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.monoProcessorBlock()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a027dd902e2ffc698c7b44f4fc0a24c8ac18e8d6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "1cf9364ca057cdb5aab63dd29b7d79c283b8ea96", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["24ae8afdfc4145ea07b20808807f942a8bc3777a"], "nameRev": "1cf9364ca057cdb5aab63dd29b7d79c283b8ea96 tags/v3.1.0.M3~11", "commitMessage": "follow-up #722 MonoProcessor block(Duration) always applies timeout\n\nThis commit follows-up on d8c7bf0 to restore the semantic of the block\r\ntimeout: a Duration.ZERO and even a negative Duration will effectively\r\nimmediately timeout.\r\n\r\n`block()` still indefinitely blocks, by using a no-op spinObserver.", "commitDateTime": "2017-07-13 18:26:17", "authoredDateTime": "2017-07-13 18:26:17", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 18, "deletions": 17, "lines": 35}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java", "insertions": 31, "deletions": 1, "lines": 32}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor.block()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.block(java.time.Duration)", "TOT": 10, "UPD": 0, "INS": 1, "MOV": 5, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.block(java.lang.Runnable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.monoProcessorBlock()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.monoProcessorBlockNegativeIsImmediateTimeout()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.monoProcessorBlockZeroIsImmediateTimeout()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2773a777b3e260789bcb3a6c12683f33a6de995e", "1cf9364ca057cdb5aab63dd29b7d79c283b8ea96"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 42.0, "deletions": 26.0, "lines": 68.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 24.0, "UPD": 1.0, "INS": 9.0, "MOV": 8.0, "DEL": 6.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", "reactor-core/src/main/java/reactor/util/concurrent"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoProcessor.block(java.time.Duration)", "reactor.core.publisher.MonoProcessor.block()", "reactor.util.concurrent.WaitStrategy", "reactor.core.publisher.MonoProcessor.block(java.lang.Runnable)"]}, {"title": "MonoProcessor should null 'source' when complete", "body": "When using `MonoProcessor` via `Mono#cache`, there can be unexpected object retention of the upstream `source`\r\n\r\n`MonoProcessor` nulls its `subscription` field upon reaching a terminal state. It should do the same for `source`.", "url": "https://github.com/reactor/reactor-core/issues/690", "user": "osi", "labels": ["type/bug"], "created": "2017-06-29 14:16:34", "closed": "2017-06-30 17:07:23", "commits": {"6d9e1b511115c413772ea2279c09bc1d3d71019f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "24a3d388798404514c290872aa6fb64a3a91438e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b2614c7201ac2304dce922de27ba133e94b9048c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "75f461b6d7c6a09e36fac3800c3e1bd13ea581bb": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "6d9e1b511115c413772ea2279c09bc1d3d71019f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "24a3d388798404514c290872aa6fb64a3a91438e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b2614c7201ac2304dce922de27ba133e94b9048c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "75f461b6d7c6a09e36fac3800c3e1bd13ea581bb", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["6b9b7fcf21992188c6d42f53d9bec131dea08967"], "nameRev": "75f461b6d7c6a09e36fac3800c3e1bd13ea581bb tags/v3.1.0.M3~41", "commitMessage": "fix #690 Null out source in MonoProcessor upon all terminations\n\nThis commit nulls out the reference to the source whenever the processor\r\nterminates. This helps preventing retention of a source and potentially\r\ndata that is only associated with it, while still holding on the final\r\ndata in the MonoProcessor.\r\n\r\nFor example, having a Future as the source, and letting the processor\r\ncache a mapped version of the future's data would still retain both the\r\nFuture, its value and the mapped value before this change. Now only the\r\nmap value is tied to the lifecycle of the processor.", "commitDateTime": "2017-06-30 19:07:22", "authoredDateTime": "2017-06-30 19:07:22", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 10, "deletions": 4, "lines": 14}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java", "insertions": 91, "deletions": 0, "lines": 91}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessor.drainLoop()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.noRetentionOnTermination()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.noRetentionOnTerminationError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoProcessorTest.noRetentionOnTerminationCancel()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["75f461b6d7c6a09e36fac3800c3e1bd13ea581bb"], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 10.0, "deletions": 4.0, "lines": 14.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 6.0, "UPD": 0.0, "INS": 4.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoProcessor.onError(java.lang.Throwable)", "reactor.core.publisher.MonoProcessor.drainLoop()", "reactor.core.publisher.MonoProcessor", "reactor.core.publisher.MonoProcessor.onNext(java.lang.Object)"]}, {"title": "filterWhen + flatMap makes the flux stop to emit", "body": "I have the following flux:\r\n\r\n```\r\n@StreamListener(Sink.INPUT)\r\n    public void listenEvent(Flux<Message<Event>> flux) {\r\n        flux\r\n                .doOnNext(System.out::println)\r\n                .filterWhen(o1 -> Mono.just(false)) //REMOVE\r\n                .flatMap(s -> Flux.just(new Object())) //REMOVE\r\n                .subscribe();\r\n    }\r\n```\r\n\r\nAfter process a bunch of message the flux just stop to emit new messages. I debugged Spring Cloud Streams and everything is fine from it perspective, the application continue to push new messages using `Flux.create(emitter ...)`.\r\n\r\nToday I realized that if I remove `.filterWhen(o1 -> Mono.just(false))`  and keep the `.flatMap(s -> Flux.just(new Object()))` it will work fine (the opposite is also true).\r\n\r\nAm I doing something wrong or is it a bug?\r\n\r\n_(There are a also a case connected with publish(flux) as well but I couldn't reproduce it yet in a short version)_\r\n\r\n_**Reactor Core 3.0.7.RELEASE and 3.1.0.M2**_", "url": "https://github.com/reactor/reactor-core/issues/689", "user": "rotilho", "labels": ["type/bug"], "created": "2017-06-29 11:45:09", "closed": "2017-06-29 17:08:26", "commits": {"b01d10107744024df3a6239f08011ce3d01cbd2c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e0bff96b15d2bbf1d53bd129ab2615dd376c9597": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "b01d10107744024df3a6239f08011ce3d01cbd2c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e0bff96b15d2bbf1d53bd129ab2615dd376c9597", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["5b9942bda4894646fb46187c58110854fae79c4c"], "nameRev": "e0bff96b15d2bbf1d53bd129ab2615dd376c9597 tags/v3.1.0.M3~51", "commitMessage": "fix #689 Track filterWhen emitted separately from the consumerIndex (#692)\n\nThis commit fixes a misuse of consumerIndex instead of a separate\r\ndedicated `emitted` tracking variable.\r\n\r\nThis would sometimes prevent replenishment when eg. filtering all out\r\nand combining with a prefetching operator like flatMap.", "commitDateTime": "2017-06-29 18:08:25", "authoredDateTime": "2017-06-29 19:08:25", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java", "insertions": 35, "deletions": 7, "lines": 42}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFilterWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFilterWhen.FluxFilterWhenSubscriber.drain()", "TOT": 6, "UPD": 2, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFilterWhen.FluxFilterWhenSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFilterWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFilterWhenTest.introspectionNormal()", "TOT": 8, "UPD": 4, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxFilterWhenTest.introspectionCancel()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFilterWhenTest.filterAllOut()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFilterWhenTest.filterAllOutHidden()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "a completed flux that's 'hot' via RefCountGrace fails when using next", "body": "```\r\n        VirtualTimeScheduler scheduler = VirtualTimeScheduler.create();\r\n        Duration gracePeriod = Duration.ofMillis(10);\r\n        Flux<String> f = Flux.just(\"hello world\")\r\n                             .replay(1)\r\n                             .refCount(1, gracePeriod, scheduler);\r\n\r\n        f.subscribe();\r\n\r\n        StepVerifier.create(f.next())\r\n                    .expectNext(\"hello world\")\r\n                    .verifyComplete();\r\n\r\n        scheduler.advanceTimeBy(gracePeriod);\r\n```\r\n\r\nThis throws\r\n\r\n```\r\nreactor.core.Exceptions$BubblingException: java.util.concurrent.CancellationException: Disconnected\r\n\tat reactor.core.Exceptions.bubble(Exceptions.java:112)\r\n\tat reactor.core.publisher.Operators.onErrorDropped(Operators.java:263)\r\n\tat reactor.core.publisher.LambdaSubscriber.onError(LambdaSubscriber.java:116)\r\n\tat reactor.core.publisher.FluxRefCountGrace$RefCountInner.onError(FluxRefCountGrace.java:203)\r\n\tat reactor.core.publisher.FluxReplay$ReplaySubscriber.disconnectAction(FluxReplay.java:1180)\r\n\tat reactor.core.publisher.FluxReplay$ReplaySubscriber.dispose(FluxReplay.java:1172)\r\n\tat reactor.core.publisher.Disposables.dispose(Disposables.java:147)\r\n\tat reactor.core.publisher.FluxRefCountGrace.timeout(FluxRefCountGrace.java:137)\r\n\tat reactor.core.publisher.FluxRefCountGrace$RefConnection.run(FluxRefCountGrace.java:165)\r\n\tat reactor.test.scheduler.VirtualTimeScheduler.advanceTime(VirtualTimeScheduler.java:297)\r\n\tat reactor.test.scheduler.VirtualTimeScheduler.advanceTimeBy(VirtualTimeScheduler.java:205)\r\nCaused by: java.util.concurrent.CancellationException: Disconnected\r\n\tat reactor.core.publisher.FluxReplay$ReplaySubscriber.disconnectAction(FluxReplay.java:1177)\r\n\t... 29 more\r\n```\r\n\r\nthat felt like a \"safe\" sequence of operators", "url": "https://github.com/reactor/reactor-core/issues/675", "user": "osi", "labels": ["type/bug"], "created": "2017-06-16 15:20:18", "closed": "2017-06-19 23:24:07", "commits": {"510c78030a0bae76875a145ad7861f1d309ef2b5": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "0f5ad28f2ac7eae34b215dfcda66375d1a5e13f1": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "510c78030a0bae76875a145ad7861f1d309ef2b5", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0f5ad28f2ac7eae34b215dfcda66375d1a5e13f1", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["eac1628de992a762a85c1226369586ddca5528a6"], "nameRev": "0f5ad28f2ac7eae34b215dfcda66375d1a5e13f1 tags/v3.1.0.M3~72", "commitMessage": "fix #675 only recycle replay() subscription if disposed\ntweak subscribe callstack in pub/replay\n", "commitDateTime": "2017-06-20 00:24:05", "authoredDateTime": "2017-06-19 16:21:49", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 8, "deletions": 15, "lines": 23}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 26, "deletions": 42, "lines": 68}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 23, "deletions": 0, "lines": 23}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 10, "deletions": 6, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublish.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublish.subscribe(org.reactivestreams.Subscriber)", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublish.PublishSubscriber.trySubscribe(reactor.core.publisher.FluxPublish$PublishInner)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.dispose()", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.connect(java.util.function.Consumer)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.subscribe(org.reactivestreams.Subscriber)", "TOT": 15, "UPD": 0, "INS": 6, "MOV": 5, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onComplete()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.disconnectAction()", "TOT": 5, "UPD": 0, "INS": 0, "MOV": 4, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.trySubscribe(reactor.core.publisher.FluxReplay$ReplayInner)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.isDisposed()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.shouldNotRetainSubscriptionToSourceWhenComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxReplayTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplayTest.scanInner()", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplayTest.cancel()", "TOT": 13, "UPD": 4, "INS": 2, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxReplayTest.cacheFluxHistoryTTLFused()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0f5ad28f2ac7eae34b215dfcda66375d1a5e13f1"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 34.0, "deletions": 57.0, "lines": 91.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 47.0, "UPD": 2.0, "INS": 13.0, "MOV": 16.0, "DEL": 16.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPublish.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxReplay.ReplaySubscriber.trySubscribe(reactor.core.publisher.FluxReplay$ReplayInner)", "reactor.core.publisher.FluxReplay.ReplaySubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxPublish.PublishSubscriber.trySubscribe(reactor.core.publisher.FluxPublish$PublishInner)", "reactor.core.publisher.FluxReplay.ReplaySubscriber.onComplete()", "reactor.core.publisher.FluxReplay.ReplaySubscriber.dispose()", "reactor.core.publisher.FluxReplay.ReplaySubscriber.disconnectAction()", "reactor.core.publisher.FluxReplay.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxReplay.ReplaySubscriber.isDisposed()", "reactor.core.publisher.FluxReplay.connect(java.util.function.Consumer)"]}, {"title": "When fused, failing doOnNext don't propagate exceptions to doOnError", "body": "This test works:\r\n\r\n        Flux<Integer> f = Flux.just(1)\r\n                .doOnNext(i -> {\r\n                    throw new IllegalArgumentException();\r\n                })\r\n                .doOnError(e -> {\r\n                    throw new IllegalStateException(e);\r\n                });\r\n        f.subscribe(i -> fail(), e -> assertTrue(e instanceof IllegalStateException));\r\n\r\nBut this one does not:\r\n\r\n        ConnectableFlux<Integer> f = Flux.just(1)\r\n                .doOnNext(i -> {\r\n                    throw new IllegalArgumentException();\r\n                })\r\n                .doOnError(e -> {\r\n                    throw new IllegalStateException(e);\r\n                }).publish();\r\n        f.subscribe(i -> fail(), e -> assertTrue(e instanceof IllegalStateException));\r\n        f.connect();\r\n\r\nIn fact, the doOnError closure is never visited. \r\n\r\nMaybe related to #272.\r\n\r\nUsing 3.0.7.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/664", "user": "lbovet", "labels": ["type/bug"], "created": "2017-06-13 11:43:30", "closed": "2017-06-14 20:00:28", "commits": {"43f25532843277b3f38630fbfaeb7eaae734c94b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6a621d8c4df7728a0afc166d5290f7fc5d651844": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "c4a6ea0525aee62b63a6d27441eae6fb0f22824c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e7216863bf08b97da5b6d775f11c9aff658cbf80": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "43f25532843277b3f38630fbfaeb7eaae734c94b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6a621d8c4df7728a0afc166d5290f7fc5d651844", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["d04c545c30049c66e4cd0c676a6dbd45b507a99a"], "nameRev": "6a621d8c4df7728a0afc166d5290f7fc5d651844 tags/v3.1.0.M3~81", "commitMessage": "fix #664 Propagate failing callback from doOnNext to doOnError if fused\n\nThis commit resolves the situation when a doOnNext and a doOnError are\nchained, there is async fusion and the first callback throws an\nexception.\n\nThis would result in the `doOnError` never being invoked, due to its\n`poll` invoking the `doOnNext.poll` without a try/catch.\n\nNow the inner poll call is protected in a try/catch block and if it\nfails, the doOnError callback is invoked. Additionally, the exception\nwill be _propagated_ (and the sequence most probably stopped), and the\ncase where the error callback itself also fails is covered as well.\n", "commitDateTime": "2017-06-14 13:00:24", "authoredDateTime": "2017-06-14 19:25:11", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 16, "deletions": 1, "lines": 17}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 39, "deletions": 0, "lines": 39}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPeekFuseableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.fusedDoOnNextOnErrorBothFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.fusedDoOnNextCallsOnErrorWhenFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "c4a6ea0525aee62b63a6d27441eae6fb0f22824c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e7216863bf08b97da5b6d775f11c9aff658cbf80", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["00ca28c28ca86d4dc2a185f1ceff408571e3b0ad"], "nameRev": "e7216863bf08b97da5b6d775f11c9aff658cbf80 tags/v3.1.0.M3~79", "commitMessage": "apply #664 fix to conditional fused case too, increase test coverage\n\nThe fix for #664 was only applied to the PeekFuseableSubscriber in\n6a621d8, overlooking the PeekFuseableConditionalSubscriber.\n\nThis commit applies the fix to the conditional case.\n\nAdditionally, it increases the test coverage to cover this conditional\ncase but also the parts of poll() that apply the doOnComplete and\ndoAfterTerminate callbacks.\n", "commitDateTime": "2017-06-15 15:19:15", "authoredDateTime": "2017-06-15 12:07:14", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 16, "deletions": 1, "lines": 17}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 177, "deletions": 15, "lines": 192}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPeekFuseableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncCompleteCalled()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncdoAfterTerminateCalled()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.scanFuseableConditionalSubscriber()", "TOT": 10, "UPD": 6, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.scanFuseableSubscriber()", "TOT": 10, "UPD": 6, "INS": 0, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.afterTerminateCallbackFatalIsThrownDirectly()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.afterTerminateCallbackErrorDoesNotInvokeOnError()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.fusedDoOnNextCallsOnErrorWhenFailing()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollCompleteCalled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalCompleteCalled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollAfterTerminateCalled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.syncPollConditionalAfterTerminateCalled()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.fusedDoOnNextOnErrorDoOnErrorAllFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.conditionalFusedDoOnNextOnErrorBothFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.conditionalFusedDoOnNextOnErrorDoOnErrorAllFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseableTest.conditionalFusedDoOnNextCallsOnErrorWhenFailing()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6a621d8c4df7728a0afc166d5290f7fc5d651844", "e7216863bf08b97da5b6d775f11c9aff658cbf80"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 32.0, "deletions": 2.0, "lines": 34.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 2.0, "MOV": 2.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()"]}, {"title": "ArrayStoreException when chaining then(Mono<V>) calls in 3.1.0.M2", "body": "Hi,\r\n\r\nI currently use the 3.1.0.M2 reactor version and i discovered a strange exception when chaining 2 \"then\" calls. I couldn't find any issue talking about this behaviour so i decided to submit a new one (i hope this is not a duplicate).\r\n\r\n<pre>\r\nException in thread \"main\" java.lang.ArrayStoreException\r\n\tat java.lang.System.arraycopy(Native Method)\r\n\tat reactor.core.publisher.MonoThenIgnore.shift(MonoThenIgnore.java:69)\r\n\tat reactor.core.publisher.Mono.then(Mono.java:3002)\r\n\t...\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\r\n</pre>\r\n\r\nBelow, you will find a reproductible case  :\r\n\r\n```java\r\nFlux.just(\"Good Morning\", \"Hello\").then(Mono.just(\"Good Afternoon\")).then(Mono.just(\"Bye\")).subscribe(s -> System.out.println(s));\r\n```\r\n\r\n**Note** : it only happens when starting from Flux. \r\n**Second note** : if you include a map(s -> s) between the 2 then calls, the exception disappears :\r\n\r\n```java\r\nFlux.just(\"Good Morning\", \"Hello\").then(Mono.just(\"Good Afternoon\")).map(s -> s).then(Mono.just(\"Bye\")).subscribe(s -> System.out.println(s));\r\n```\r\n\r\nHope this will help.", "url": "https://github.com/reactor/reactor-core/issues/661", "user": "jhaeyaert", "labels": ["type/bug"], "created": "2017-06-12 12:15:04", "closed": "2017-06-12 19:15:12", "commits": {"4c22520579da8052b131c5960b7c4ba255ea0530": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7ef6d6aedffa85ae58a4393126667f4a2349cc03": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "021d512e51bbea9d2281ef15be82e54748fa7596": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "fc8a795f8cfe1d6cbbe362d5dfefa72af87c57dc": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "4c22520579da8052b131c5960b7c4ba255ea0530", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7ef6d6aedffa85ae58a4393126667f4a2349cc03", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "021d512e51bbea9d2281ef15be82e54748fa7596", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["81238012919f9d956e780d8405a52a2554ae5edf"], "nameRev": "021d512e51bbea9d2281ef15be82e54748fa7596 tags/v3.1.0.M3~86", "commitMessage": "fix #661 Macro-fusion of flux then and mono then use incompatible T[]\n\nThis commit fixes a bug around macro-fusion of `then(Mono<T>)` when\nmixing a Flux suppressed source and a Mono suppressed source (see #547).\n\nThis is due to the Flux's usage of `then` resulting in a Publisher array\nof sources whereas the Mono usage still results in a Mono array. When\nattempting the two, the type difference causes an ArrayStoreException.\n", "commitDateTime": "2017-06-12 20:15:10", "authoredDateTime": "2017-06-12 15:45:10", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoThenIgnore.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.then(reactor.core.publisher.Mono)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoThenIgnore.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoThenIgnore.shift(reactor.core.publisher.Mono)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoThenIgnoreTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoThenIgnoreTest.fluxThenMonoAndShift()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoThenIgnoreTest.monoThenMonoAndShift()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "fc8a795f8cfe1d6cbbe362d5dfefa72af87c57dc", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 3, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Empty multivalue expectations consume an onNext", "body": "_From @simonbasle on April 11, 2017 14:10_\n\nWhen a multivalue expectation (`expectNextCount` or `expectNextSequence`) is effectively empty (count of 0 or empty iterable), it should be ignored. However, these expectations instead consume one `onNext` event.\r\n\r\nFor instance:\r\n\r\n```\r\nStepVerifier.create(Flux.just(\"foo\", \"bar\"))\r\n            .expectNextCount(0)\r\n            .expectNext(\"foo\", \"bar\")\r\n            .expectComplete()\r\n            .verify();\r\n```\r\nThe test above should work but fails with message\r\n```\r\nexpectation \"expectNext(foo)\" failed (expected value: foo; actual value: bar)\r\n```\r\n\n\n_Copied from original issue: reactor/reactor-addons#101_", "url": "https://github.com/reactor/reactor-core/issues/650", "user": "simonbasle", "labels": ["area/reactor-test", "type/bug"], "created": "2017-06-02 10:56:47", "closed": "2017-07-12 08:56:04", "commits": {"f04616be48ecdd9f2321bce5835742db881298e9": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 39.000277777777775, "commitsDetails": [{"commitHash": "f04616be48ecdd9f2321bce5835742db881298e9", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["3458c69c76f0c680d459600851c756e7798386cb"], "nameRev": "f04616be48ecdd9f2321bce5835742db881298e9 tags/v3.1.0.M3~19", "commitMessage": "fix #650 Ignore empty multivalue expectations\n\nAdded logic to handle empty multivalue expectations\r\nin DefaultStepVerifierBuilder", "commitDateTime": "2017-07-12 10:56:03", "authoredDateTime": "2017-07-12 11:56:03", "commitGitStats": [{"filePath": "reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java", "insertions": 13, "deletions": 11, "lines": 24}, {"filePath": "reactor-test/src/test/java/reactor/test/StepVerifierTests.java", "insertions": 19, "deletions": 0, "lines": 19}], "commitSpoonAstDiffStats": [{"spoonFilePath": "DefaultStepVerifierBuilder.java", "spoonMethods": [{"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.expectNextSequence(java.lang.Iterable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.test.DefaultStepVerifierBuilder.expectNextCount(long)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 0}]}, {"spoonFilePath": "StepVerifierTests.java", "spoonMethods": [{"spoonMethodName": "reactor.test.StepVerifierTests.expectNextCountZeroBeforeExpectNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.test.StepVerifierTests.expectNextSequenceEmptyListBeforeExpectNext()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f04616be48ecdd9f2321bce5835742db881298e9"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 13, "deletions": 11, "lines": 24, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 7, "UPD": 0, "INS": 2, "MOV": 5, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-test/src/main/java/reactor/test"], "changesInPackagesSPOON": ["reactor.test.DefaultStepVerifierBuilder.expectNextCount(long)", "reactor.test.DefaultStepVerifierBuilder.expectNextSequence(java.lang.Iterable)"]}, {"title": "FluxRefCountGrace advertises Fuseable but doesn't implement fusion.", "body": "I got this stacktrace at runtime:\r\n\r\n```\r\njava.lang.ClassCastException: reactor.core.publisher.FluxRefCountGrace$RefCountSubscriber cannot be cast to reactor.core.Fuseable$QueueSubscription\r\n    at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onSubscribe(FluxMapFuseable.java:243)\r\n    at reactor.core.publisher.FluxRefCountGrace$RefCountSubscriber.onSubscribe(FluxRefCountGrace.java:241)\r\n    at reactor.core.publisher.FluxReplay.subscribe(FluxReplay.java:1026)\r\n    at reactor.core.publisher.FluxRefCountGrace.subscribe(FluxRefCountGrace.java:100)\r\n    at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:60)\r\n    at reactor.core.publisher.FluxFilterFuseable.subscribe(FluxFilterFuseable.java:50)\r\n    at reactor.core.publisher.FluxSample.subscribe(FluxSample.java:71)\r\n    at reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62)\r\n```\r\n\r\n`FluxRefCountGrace` implements `Fuseable`, but then doesn't honor the contract (it could be Fuseable and I'll try and fix it to be)\r\n", "url": "https://github.com/reactor/reactor-core/issues/627", "user": "osi", "labels": ["type/bug"], "created": "2017-05-26 17:36:58", "closed": "2017-05-26 19:40:41", "commits": {"c805e0ae2d42fad5d34a904a11c63408e918ee21": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "c805e0ae2d42fad5d34a904a11c63408e918ee21", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["f98eb130722151003b35e8a279839156db44a812"], "nameRev": "c805e0ae2d42fad5d34a904a11c63408e918ee21 tags/v3.1.0.M2~18", "commitMessage": "fix #627 - support fusion in refCountGrace\n", "commitDateTime": "2017-05-26 12:40:30", "authoredDateTime": "2017-05-26 12:40:30", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 78, "deletions": 78, "lines": 156}, {"filePath": "src/main/java/reactor/core/publisher/FluxRefCountGrace.java", "insertions": 48, "deletions": 15, "lines": 63}, {"filePath": "src/test/java/reactor/core/SequentialDisposableTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java", "insertions": 12, "deletions": 5, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxRefCount.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(org.reactivestreams.Subscriber)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onNext(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onError(java.lang.Throwable)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onComplete()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.request(long)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.cancel()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.actual()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.clear()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner", "TOT": 3, "UPD": 2, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.requestFusion(int)", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.poll()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.size()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.isEmpty()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.scan(reactor.core.publisher.Attr)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onSubscribe(org.reactivestreams.Subscription)", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor", "TOT": 11, "UPD": 0, "INS": 1, "MOV": 9, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.accept(reactor.core.Disposable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.doDisconnect()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.isDisconnected()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.innerCancelled()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCount.RefCountMonitor.upstreamFinished()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxRefCountGrace.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber", "TOT": 6, "UPD": 6, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.request(long)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.cancel()", "TOT": 5, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onError(java.lang.Throwable)", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onComplete()", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 5, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxRefCountGrace", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}]}, {"spoonFilePath": "SequentialDisposableTest.java", "spoonMethods": []}, {"spoonFilePath": "FluxRefCountGraceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRefCountGraceTest.testFusion()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["c805e0ae2d42fad5d34a904a11c63408e918ee21"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 126, "deletions": 93, "lines": 219, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 73, "UPD": 53, "INS": 1, "MOV": 16, "DEL": 3, "spoonFilesChanged": 2, "spoonMethodsChanged": 30}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxRefCount.RefCountMonitor.isDisconnected()", "reactor.core.publisher.FluxRefCountGrace.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.scan(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.accept(reactor.core.Disposable)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner", "reactor.core.publisher.FluxRefCount.RefCountMonitor.doDisconnect()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.poll()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.actual()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.innerCancelled()", "reactor.core.publisher.FluxRefCountGrace", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.cancel()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.size()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onNext(java.lang.Object)", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onComplete()", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.cancel()", "reactor.core.publisher.FluxRefCount.RefCountMonitor", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onComplete()", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.request(long)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.onError(java.lang.Throwable)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.isEmpty()", "reactor.core.publisher.FluxRefCountGrace.RefCountSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.upstreamFinished()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.clear()", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.requestFusion(int)", "reactor.core.publisher.FluxRefCount.RefCountMonitor.RefCountInner.request(long)"]}, {"title": "EmitterProcessor not delivering after subscriber exception", "body": "Test case:\r\n```java\r\npublic static void main(String[] args) {\r\n    EmitterProcessor<String> proc = EmitterProcessor.create(false);\r\n    FluxSink<String> sink = proc.sink(FluxSink.OverflowStrategy.DROP);\r\n\r\n    Disposable bad = proc.subscribe(s -> {\r\n        System.err.println(\"Bad: \" + s);\r\n        throw new IllegalStateException();\r\n    });\r\n    Disposable good = proc.subscribe(s -> System.err.println(\"Good: \" + s));\r\n\r\n    try {\r\n        sink.next(\"1\");\r\n    } catch (Exception e) {\r\n        // ignore\r\n    }\r\n    try {\r\n        sink.next(\"2\");\r\n    } catch (Exception e) {\r\n        // ignore\r\n    }\r\n    try {\r\n        sink.next(\"3\");\r\n    } catch (Exception e) {\r\n        // ignore\r\n    }\r\n\r\n    System.err.println(bad.isDisposed());\r\n    System.err.println(good.isDisposed());\r\n    System.err.println(proc.isTerminated());\r\n    System.err.println(proc.isCancelled());\r\n}\r\n```\r\nOutput:\r\n```\r\nBad: 1\r\ntrue\r\nfalse\r\nfalse\r\nfalse\r\n```\r\n\r\nThe problem lies in SerializedSink - `wip` field is not decremented correctly. ", "url": "https://github.com/reactor/reactor-core/issues/613", "user": "lightoze", "labels": ["type/bug"], "created": "2017-05-19 14:24:25", "closed": "2017-09-21 21:28:50", "commits": {}, "ttf": 125.00027777777778, "commitsDetails": []}, {"title": "scan(initial, accumulator) variant that will accumulate-then-emit", "body": "To make `Flux#scan(initial, accumulator)` more useful with infinite streams, it would be nice if it behaved like this:\r\n\r\n```\r\n        StepVerifier.create(Flux.<Integer>create(sink -> {\r\n            sink.next(3);\r\n            sink.next(4);\r\n            sink.next(5);\r\n        }).scan(10, (a, b) -> a + b))\r\n                    .expectNext(10, 13, 17, 22)\r\n                    .thenCancel()\r\n                    .verify(Duration.ofMillis(250));\r\n```\r\n\r\nIf scan is being used for a \"live\" reduction, the accumulation always lags by one. This confused me for awhile since it seems to contradict the flow diagram at http://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction- (at least in how the timing works)", "url": "https://github.com/reactor/reactor-core/issues/609", "user": "osi", "labels": ["type/bug", "type/enhancement"], "created": "2017-05-17 20:49:56", "closed": "2017-06-06 00:20:48", "commits": {"bb3111c81f3616d7f16ddd806a2cbb860c9258e2": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 19.00027777777778, "commitsDetails": [{"commitHash": "bb3111c81f3616d7f16ddd806a2cbb860c9258e2", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["b73d2d9c9de05159047b73a3a223db03e0a92997"], "nameRev": "bb3111c81f3616d7f16ddd806a2cbb860c9258e2 tags/v3.1.0.M3~95", "commitMessage": "Fix #609 - scanWith will emit in lockstep\n\nFix #609 - scanWith will emit in lockstep w/prior\r\n\r\nModify FluxScanSeed so that it is implemented as the concatenation of two subscriptions: \r\n- a scalar for the initial seed.\r\n- a very simple accumulator for ongoing operation.\r\nThis fixes a problem where the accumulated value lagged the upstream by one.\r\n\r\n\r\n", "commitDateTime": "2017-06-06 01:20:46", "authoredDateTime": "2017-06-05 19:20:46", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java", "insertions": 120, "deletions": 110, "lines": 230}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxScanSeedTest.java", "insertions": 25, "deletions": 4, "lines": 29}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxScanSeed.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber", "TOT": 14, "UPD": 3, "INS": 1, "MOV": 10, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.request(long)", "TOT": 19, "UPD": 7, "INS": 0, "MOV": 12, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "TOT": 7, "UPD": 1, "INS": 0, "MOV": 6, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onComplete()", "TOT": 28, "UPD": 8, "INS": 0, "MOV": 14, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.subscribe(org.reactivestreams.Subscriber)", "TOT": 10, "UPD": 0, "INS": 3, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedCoordinator.onComplete()", "TOT": 5, "UPD": 0, "INS": 5, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.actual()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.cancel()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxScanSeedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxScanSeedTest.scanSubscriber()", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeedTest.scenarios_errorFromUpstreamFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxScanSeedTest.onlyConsumerPartOfRange()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["bb3111c81f3616d7f16ddd806a2cbb860c9258e2"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 120, "deletions": 110, "lines": 230, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 89, "UPD": 19, "INS": 9, "MOV": 52, "DEL": 9, "spoonFilesChanged": 1, "spoonMethodsChanged": 11}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onComplete()", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.actual()", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.request(long)", "reactor.core.publisher.FluxScanSeed.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.scanUnsafe(reactor.core.publisher.Attr)", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.cancel()", "reactor.core.publisher.FluxScanSeed.ScanSeedSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxScanSeed.ScanSeedCoordinator.onComplete()"]}, {"title": "Memory leaks when using concatMap and subscribeOn Schedulers.newSingle", "body": "When running the following test:\r\n```\r\n@Test\r\n    public void test() throws Exception {\r\n        AtomicLong counter = new AtomicLong(0L);\r\n        Scheduler scheduler = Schedulers.newParallel(\"scheduler\", 10);\r\n        Flux\r\n            .<Long>generate(sink -> sink.next(counter.getAndIncrement()))\r\n            .concatMap(i -> {\r\n                return Mono.just(i)\r\n                    .publishOn(scheduler)\r\n                    .map(number -> number * 2L);\r\n            })\r\n            .subscribeOn(Schedulers.newSingle(\"subscriber\"))\r\n            .subscribe(new BaseSubscriber<Long>() {\r\n                @Override\r\n                protected void hookOnSubscribe(Subscription subscription) {\r\n                    subscription.request(10);\r\n                }\r\n\r\n                @Override\r\n                protected void hookOnNext(Long value) {\r\n                    upstream().request(1);\r\n                }\r\n            });\r\n\r\n        Thread.sleep(100000000);\r\n    }\r\n```\r\nMemory starts to leak.\r\nThanks to @dfeist the leak seems to be here `reactor.core.scheduler.SingleScheduler.SingleWorker#tasks` and as a workaround scheduler can be replaced with\r\n`.subscribeOn(Schedulers.fromExecutorService(Executors.newSingleThreadExecutor()))`.", "url": "https://github.com/reactor/reactor-core/issues/578", "user": "fvlad", "labels": ["type/bug"], "created": "2017-05-02 13:38:20", "closed": "2017-05-04 12:18:24", "commits": {"ae54548c922c87574b711d86cec3a754b9e7e859": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "ae54548c922c87574b711d86cec3a754b9e7e859", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["515b3aae8ae06f484a3d564ca20eb7dcdacb101c"], "nameRev": "ae54548c922c87574b711d86cec3a754b9e7e859 tags/v3.1.0.M2~38", "commitMessage": "fix #578 Address memory leak in SingleScheduler.schedule\n\n", "commitDateTime": "2017-05-04 14:18:23", "authoredDateTime": "2017-05-04 14:18:23", "commitGitStats": [{"filePath": "src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/scheduler/SingleSchedulerTest.java", "insertions": 39, "deletions": 6, "lines": 45}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SingleScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SingleScheduler.SingleWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SingleSchedulerTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SingleSchedulerTest.smokeTestDelay()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleSchedulerTest.smokeTestInterval()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleSchedulerTest.lotsOfTasks()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ae54548c922c87574b711d86cec3a754b9e7e859"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.SingleScheduler.SingleWorker.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)"]}, {"title": "chaining Mono.untilOther has side effects", "body": "Needs to return a new MonoUntilOther reference.", "url": "https://github.com/reactor/reactor-core/issues/515", "user": "smaldini", "labels": ["type/bug"], "created": "2017-04-05 13:03:55", "closed": "2017-04-05 15:38:59", "commits": {"3d9123d8cf7cd6aae4bd52033a231057f6e4e713": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f8786d7112b14ee23b5aa348e153081dc1634d46": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "0e9e83df594c41be95e8fdf9b11b06261971e79d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "187e5a7c34a75a634a075e0109d2ec17f993d16e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "3d9123d8cf7cd6aae4bd52033a231057f6e4e713", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f8786d7112b14ee23b5aa348e153081dc1634d46", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["ebe4c19de464415f0d46081860956860954099fc"], "nameRev": "f8786d7112b14ee23b5aa348e153081dc1634d46 tags/v3.1.0.M1~34", "commitMessage": "fix #515 Return new instance when chaining Mono.untilOther\n\nPreviously it would mutate the same instance, which could have side\r\neffects if the same original MonoUntilOther was chained with additional\r\nuntilOthers in 2 places at once.", "commitDateTime": "2017-04-05 17:38:57", "authoredDateTime": "2017-04-05 17:38:57", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 2, "deletions": 4, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/MonoUntilOther.java", "insertions": 15, "deletions": 4, "lines": 19}, {"filePath": "src/test/java/reactor/core/publisher/MonoUntilOtherTest.java", "insertions": 24, "deletions": 10, "lines": 34}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.untilOther(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.untilOtherDelayError(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoUntilOther.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUntilOther.addTrigger(org.reactivestreams.Publisher)", "TOT": 13, "UPD": 1, "INS": 5, "MOV": 4, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoUntilOther", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoUntilOtherTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUntilOtherTest.testAPIchainingCombines()", "TOT": 12, "UPD": 3, "INS": 7, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoUntilOtherTest.testAPIchainingCombinesWithFirstDelayErrorParameter()", "TOT": 12, "UPD": 3, "INS": 7, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoUntilOtherTest.testAPIChainingCombinesDifferentInstances()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "0e9e83df594c41be95e8fdf9b11b06261971e79d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "187e5a7c34a75a634a075e0109d2ec17f993d16e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["345da87a7a88f03b50b10f4388299123cdf836c8"], "nameRev": "187e5a7c34a75a634a075e0109d2ec17f993d16e tags/v3.0.7.RELEASE~15", "commitMessage": "backport #515 Return new instance when chaining Mono.untilOther\n\nPreviously it would mutate the same instance, which could have side\r\neffects if the same original MonoUntilOther was chained with additional\r\nuntilOthers in 2 places at once.\r\n\r\n(cherry picked from commit f8786d7)", "commitDateTime": "2017-04-10 16:23:09", "authoredDateTime": "2017-04-10 16:23:09", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 2, "deletions": 4, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/MonoUntilOther.java", "insertions": 15, "deletions": 4, "lines": 19}, {"filePath": "src/test/java/reactor/core/publisher/MonoUntilOtherTest.java", "insertions": 16, "deletions": 10, "lines": 26}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.untilOther(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.untilOtherDelayError(org.reactivestreams.Publisher)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoUntilOther.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUntilOther.addTrigger(org.reactivestreams.Publisher)", "TOT": 13, "UPD": 1, "INS": 5, "MOV": 4, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoUntilOther", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoUntilOtherTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUntilOtherTest.testAPIchainingCombines()", "TOT": 12, "UPD": 3, "INS": 7, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoUntilOtherTest.testAPIchainingCombinesWithFirstDelayErrorParameter()", "TOT": 12, "UPD": 3, "INS": 7, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f8786d7112b14ee23b5aa348e153081dc1634d46", "187e5a7c34a75a634a075e0109d2ec17f993d16e"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 34.0, "deletions": 16.0, "lines": 50.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 36.0, "UPD": 2.0, "INS": 12.0, "MOV": 12.0, "DEL": 10.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoUntilOther", "reactor.core.publisher.Mono.untilOtherDelayError(org.reactivestreams.Publisher)", "reactor.core.publisher.MonoUntilOther.addTrigger(org.reactivestreams.Publisher)", "reactor.core.publisher.Mono.untilOther(org.reactivestreams.Publisher)"]}, {"title": "Flux.windowTimeout to start timer right away", "body": "`Flux.windowTimeout(int, Duration)` starts the timer after the first element of a window is received.  This means that empty windows are not generated.  It would be desirable to have an alternative behavior where the timer is started right after subscription and after each window is emitted, so that we always get a window emitted at least once per duration.\r\n\r\nThe use case is where we want the output to also function as a heartbeat.\r\n\r\nIf both behaviors are desirable, then perhaps a second version of this method or a flag could be added.  Alternatively, if the old behavior is dropped, then that behavior could be still be easily obtained by adding a filter stage for window size `> 0`.\r\n", "url": "https://github.com/reactor/reactor-core/issues/484", "user": "devrandom", "labels": ["type/bug", "type/enhancement"], "created": "2017-03-16 00:46:37", "closed": "2017-05-26 09:04:52", "commits": {"7197ac25364e1f4629ac26aa2d147a062c3217ce": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f2a5d0cf2aaf77f2d81e750aae366f881eabcd79": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 71.00027777777778, "commitsDetails": [{"commitHash": "7197ac25364e1f4629ac26aa2d147a062c3217ce", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f2a5d0cf2aaf77f2d81e750aae366f881eabcd79", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d7e7209f239be8c691fd149b89b009d241361226"], "nameRev": "f2a5d0cf2aaf77f2d81e750aae366f881eabcd79 tags/v3.1.0.M2~21", "commitMessage": "fix #484 Fix windowTimeout timeout starting behavior\n\nThis commit changes the behavior of windowTimeout so that it starts its\r\ntimer right from the subscription. Subsequent timers are started\r\nwhenever a window closes (either from timeout or from size).\r\n\r\nAdditionally, this has the effect of emitting empty windows, even in the\r\ncase where multiple timeouts occurred. Thus, this operator can be used\r\nfor heartbeat kind of scenarios, where a new empty window will complete\r\nevery \"maxDuration\".\r\n\r\nIn order to not impact the bufferTimeout operator, the operator classes\r\ndon't share a common base class anymore.", "commitDateTime": "2017-05-26 11:04:50", "authoredDateTime": "2017-05-26 11:04:50", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxBatch.java", "insertions": 0, "deletions": 290, "lines": 290}, {"filePath": "src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 227, "deletions": 10, "lines": 237}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 262, "deletions": 57, "lines": 319}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferTimeOrSizeTest.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowTimeOrSizeTest.java", "insertions": 154, "deletions": 12, "lines": 166}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["f2a5d0cf2aaf77f2d81e750aae366f881eabcd79"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 489.0, "deletions": 357.0, "lines": 846.0, "gitFilesChange": 3}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"]}, {"title": "windowWhile does not replenish queue as quickly as it drains", "body": "Currently, when `windowWhile`'s (and possibly other related operators) predicate returns `false` generating a new window, it only requests upstream for replacements for the data that the predicate returned true for.  Therefore, given a bounded prefetch buffer, each window will shrink the available pool of data by one, until that buffer is starved without data, hanging the subscriber.\r\n\r\nThe `windowWhile` operator should ensure that for every element consumed, an upstream request is made to replenish it's prefetch buffer.\r\n\r\n```\r\nstream.preWindowWhile  onNext(DELIMITER)\r\nstream.insideConcatMap | onComplete()\r\nstream.preConcatMap    | onNext(WindowGroupedFlux[DELIMITER])\r\nstream.insideConcatMap | onSubscribe([Fuseable] FluxWindowPredicate.WindowGroupedFlux)\r\nstream.insideConcatMap | request(unbounded)\r\nstream.preWindowWhile  onNext(AbstractPooledDerivedByteBuf$PooledNonRetainedSlicedByteBuf(ridx: 0, widx: 646, cap: 646/646, unwrapped: PooledUnsafeDirectByteBuf(ridx: 8446, widx: 8446, cap: 8475)))\r\nstream.insideConcatMap | onNext(AbstractPooledDerivedByteBuf$PooledNonRetainedSlicedByteBuf(ridx: 0, widx: 646, cap: 646/646, unwrapped: PooledUnsafeDirectByteBuf(ridx: 8446, widx: 8446, cap: 8475)))\r\nstream.preWindowWhile  request(1)\r\n```", "url": "https://github.com/reactor/reactor-core/issues/477", "user": "nebhale", "labels": ["type/bug"], "created": "2017-03-14 16:10:36", "closed": "2017-03-21 16:46:04", "commits": {"9af3f9ce23014b012849c7392ebfd64ea75ac294": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "dfea7cba3733b55c0af9d924c6e5f4d40c9eff97": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "2f47e1b0ed85cfdd6ee03b808ee50df481b1a04c": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "9af3f9ce23014b012849c7392ebfd64ea75ac294", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "dfea7cba3733b55c0af9d924c6e5f4d40c9eff97", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "2f47e1b0ed85cfdd6ee03b808ee50df481b1a04c", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["c1c5f632e0f35b663e98e5a1f3848fbc72dead17"], "nameRev": "2f47e1b0ed85cfdd6ee03b808ee50df481b1a04c tags/v3.0.6.RELEASE~18", "commitMessage": "fix #477 Let windowWhile request one more when encountering delimiter\n\nAlso removes the notion of limit from the WindowGroupedFlux (unused).", "commitDateTime": "2017-03-21 17:46:03", "authoredDateTime": "2017-03-21 17:46:03", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxWindowPredicate.java", "insertions": 5, "deletions": 13, "lines": 18}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 133, "deletions": 0, "lines": 133}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxWindowPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.initializeWindow()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.offerNewWindow(java.lang.Object,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux.limit()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWindowPredicateTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.manualRequestWindowUntilOverRequestingSourceByPrefetch()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.manualRequestWindowWhileOverRequestingSourceByPrefetch()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileOneByOneStartingDelimiterReplenishes()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowWhileUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicateTest.windowUntilUnboundedStartingDelimiterReplenishes()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["2f47e1b0ed85cfdd6ee03b808ee50df481b1a04c"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5.0, "deletions": 13.0, "lines": 18.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 7.0, "UPD": 2.0, "INS": 1.0, "MOV": 0.0, "DEL": 4.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 5}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux", "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.onNext(java.lang.Object)", "reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux.limit()", "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.initializeWindow()", "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.offerNewWindow(java.lang.Object,java.lang.Object)"]}, {"title": "concatMap does not properly translate demand", "body": "Currently, when the `prefetch` parameter of `concatMap` is set to `Integer.MAX`, the demand it passes on is also `Integer.MAX`.  This demand should instead by translated to unbounded demand.", "url": "https://github.com/reactor/reactor-core/issues/476", "user": "nebhale", "labels": ["type/bug"], "created": "2017-03-14 16:03:07", "closed": "2017-03-15 08:48:43", "commits": {"cf7d7d6d1d75e270afede0a478a40f71a4ca917a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "bc6d61ba76ea71563968f082865925e8367e8853": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "cf7d7d6d1d75e270afede0a478a40f71a4ca917a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "bc6d61ba76ea71563968f082865925e8367e8853", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["64274da079500ee75193ac272dea8f2b822f7aff"], "nameRev": "bc6d61ba76ea71563968f082865925e8367e8853 tags/v3.0.6.RELEASE~24", "commitMessage": "fix #476 ConcatMap MAX prefetch switches to unbounded request\n\n", "commitDateTime": "2017-03-15 09:48:41", "authoredDateTime": "2017-03-15 09:48:41", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "insertions": 33, "deletions": 0, "lines": 33}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxConcatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapImmediate.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxConcatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.prefetchMaxTranslatesToUnboundedRequest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxConcatMapTest.prefetchMaxTranslatesToUnboundedRequest2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["bc6d61ba76ea71563968f082865925e8367e8853"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 0.0, "INS": 2.0, "MOV": 2.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxConcatMap.ConcatMapImmediate.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxConcatMap.ConcatMapDelayed.onSubscribe(org.reactivestreams.Subscription)"]}, {"title": "BaseSubscriber `dispose()` doesn't cancel the upstream", "body": "`dispose` should call `cancel()` to both propagate the cancellation as lambdaSubscribers do and trigger the `hookFinally` properly.", "url": "https://github.com/reactor/reactor-core/issues/461", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-03-03 15:10:51", "closed": "2017-03-13 10:40:15", "commits": {"be898bdd7cf35e76fad7075df9b52acd599ef37d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ecfc7f76dabf14f19e75f19a1ef4276acfd95e90": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 9.000277777777777, "commitsDetails": [{"commitHash": "be898bdd7cf35e76fad7075df9b52acd599ef37d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ecfc7f76dabf14f19e75f19a1ef4276acfd95e90", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["caf9b85259e3f7c5c9163eaecff9dd45d60379e1"], "nameRev": "ecfc7f76dabf14f19e75f19a1ef4276acfd95e90 tags/v3.0.6.RELEASE~31", "commitMessage": "fix #461 BaseSubscriber dispose() calls cancel()\n", "commitDateTime": "2017-03-13 11:40:14", "authoredDateTime": "2017-03-03 16:25:15", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BaseSubscriber.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/BaseSubscriberTest.java", "insertions": 35, "deletions": 0, "lines": 35}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BaseSubscriber.dispose()", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "BaseSubscriberTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BaseSubscriberTest.disposeCancels()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ecfc7f76dabf14f19e75f19a1ef4276acfd95e90"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5.0, "deletions": 1.0, "lines": 6.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 1.0, "INS": 1.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.BaseSubscriber.dispose()"]}, {"title": "Mono.fromRunnable(...) never emits where Mono.fromCallable(...) does", "body": "We encountered what seems like a bug (could be wrong!)\r\n\r\nWe have found that this code works (all events are asynchonously passed to `processEvent`):\r\n```\r\nreplayEventsStream\r\n            .flatMap(event -> Mono.fromCallable(() -> {\r\n                pipelines.get(event.getQueueId()).processEvent(event);\r\n                return event;\r\n            }).subscribeOn(Schedulers.elastic()), concurrency)\r\n            .doOnComplete(completionHook::countDown)\r\n            .doOnError((e) -> completionHook.countDown())\r\n            .subscribe();\r\n```\r\nwhile this code will complete immediately with no events processed via processEvent\r\n```\r\nreplayEventsStream\r\n            .flatMap(event -> Mono.fromRunnable(() -> {\r\n                pipelines.get(event.getQueueId()).processEvent(event);\r\n            }).subscribeOn(Schedulers.elastic()), concurrency)\r\n            .doOnComplete(completionHook::countDown)\r\n            .doOnError((e) -> completionHook.countDown())\r\n            .subscribe();\r\n```\r\n\r\nThe only difference is `fromCallable()` vs `fromRunnable()`. Any ideas?", "url": "https://github.com/reactor/reactor-core/issues/455", "user": "Jamalarm", "labels": ["type/bug"], "created": "2017-03-02 15:23:37", "closed": "2017-03-02 15:59:29", "commits": {"64f75678b64c8b282d3a7df236d4f995e833cdfe": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "64f75678b64c8b282d3a7df236d4f995e833cdfe", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["31983c798b1f5d347280aa279515ae4d5102af53"], "nameRev": "64f75678b64c8b282d3a7df236d4f995e833cdfe tags/v3.0.6.RELEASE~37", "commitMessage": "fix #455 missing callback invokation in fused callable path\n", "commitDateTime": "2017-03-02 15:59:25", "authoredDateTime": "2017-03-02 15:58:49", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoRunnable.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/reactor/core/publisher/MonoRunnableTest.java", "insertions": 13, "deletions": 1, "lines": 14}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoRunnable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoRunnable.call()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoRunnableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoRunnableTest.test()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["64f75678b64c8b282d3a7df236d4f995e833cdfe"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 1, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoRunnable.call()"]}, {"title": "Incorrect behavior sort() and zipWith() in the same chain", "body": "I tried to run the following code and got an unexpected result:\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.junit.Test;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.util.function.Tuple2;\r\nimport java.util.List;\r\nimport static java.util.Arrays.asList;\r\nimport static org.apache.commons.lang3.RandomStringUtils.randomAlphabetic;\r\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\r\n\r\n@Slf4j\r\npublic class Tests {\r\n\r\n    @Test\r\n    public void shouldEmitsAllLetters() throws Exception {\r\n        int capacity = 46;\r\n        Flux<String> flux = Flux.fromIterable(generateRandomLetters(capacity));\r\n\r\n        List<Tuple2<String, Integer>> letters = flux\r\n                .log()\r\n                .sort()\r\n                .log()\r\n                .zipWith(Flux.range(1, Integer.MAX_VALUE))\r\n                .collectList().block();\r\n        assertThat(letters.size()).isEqualTo(capacity);\r\n    }\r\n\r\n    private List<String> generateRandomLetters(int capacity) {\r\n        if (capacity <= 0) throw new IllegalArgumentException(\"capacity should be > 0\");\r\n        return asList(randomAlphabetic(capacity).split(\"\"));\r\n    }\r\n}\r\n\r\nThis Flux emits only first 32 items and completes execution. This behavior is observed only in this chain. If i'll remove sort() or zipWith() method from chain then everything starts working properly. (Flux emits first 32 letters then requests another batch. And so on.)\r\n\r\nOutput:\r\n```\r\n2017-03-02 12:27:27,144 INFO  [main] - reactor.Flux.Iterable.1 : | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)\r\n2017-03-02 12:27:27,148 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onSubscribe([Fuseable] FluxFlattenIterable.FlattenIterableSubscriber)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.FlattenIterable.2 : | request(32)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | request(unbounded)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(M)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(E)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(v)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(v)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(B)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(e)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(V)\r\n2017-03-02 12:27:27,150 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(p)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(A)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(N)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(o)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(B)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(e)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(o)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(w)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(y)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(f)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(e)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(L)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(X)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(y)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(o)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(L)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(q)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(c)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(Y)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(M)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(h)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(L)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(R)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(n)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(e)\r\n2017-03-02 12:27:27,151 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(Y)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(a)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(n)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(r)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(h)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(H)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(d)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(k)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(c)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(U)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(s)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(T)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(K)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onNext(L)\r\n2017-03-02 12:27:27,152 INFO  [main] - reactor.Flux.Iterable.1 : | onComplete()\r\n2017-03-02 12:27:27,153 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(A)\r\n2017-03-02 12:27:27,153 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(B)\r\n2017-03-02 12:27:27,153 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(B)\r\n2017-03-02 12:27:27,153 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(E)\r\n2017-03-02 12:27:27,153 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(H)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(K)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(L)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(L)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(L)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(L)\r\n2017-03-02 12:27:27,158 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(M)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(M)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(N)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(R)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(T)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(U)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(V)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(X)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(Y)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(Y)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(a)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(c)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(c)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(d)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(e)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(e)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(e)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(e)\r\n2017-03-02 12:27:27,159 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(f)\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(h)\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(h)\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onNext(k)\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.FlattenIterable.2 : | onComplete()\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.FlattenIterable.2 : | cancel()\r\n2017-03-02 12:27:27,160 INFO  [main] - reactor.Flux.Iterable.1 : | cancel()\r\n\r\norg.junit.ComparisonFailure: \r\nExpected :46\r\nActual   :32\r\n```", "url": "https://github.com/reactor/reactor-core/issues/453", "user": "slav9nin", "labels": ["type/bug"], "created": "2017-03-02 10:12:03", "closed": "2017-03-02 15:21:33", "commits": {"2e3e521560ce58d59e535dcf5cea293b4b46770a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "95ab35ce3344046e4cbd63c81df02399a4f34c11": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2e3e521560ce58d59e535dcf5cea293b4b46770a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "95ab35ce3344046e4cbd63c81df02399a4f34c11", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["6349406230d58254b85440fb00156f97f3df16bf"], "nameRev": "95ab35ce3344046e4cbd63c81df02399a4f34c11 tags/v3.0.6.RELEASE~39", "commitMessage": "fix #453 Fix FluxFlattenIterable completes too early in async drain\n\nThis commit fixes an issue where the FluxFlattenIterable would complete\r\ndespite the iterator not having been depleted (and downstream preparing\r\nto make more request). This would happen in drainAsync() but not in SYNC\r\nfusion mode.", "commitDateTime": "2017-03-02 16:21:32", "authoredDateTime": "2017-03-02 16:21:32", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlattenIterableTest.java", "insertions": 33, "deletions": 2, "lines": 35}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFlattenIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainAsync()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxFlattenIterableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlattenIterableTest.testDrainSyncCompletesSeveralBatches()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlattenIterableTest.testDrainAsyncCompletesSeveralBatches()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["95ab35ce3344046e4cbd63c81df02399a4f34c11"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 1.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxFlattenIterable.FlattenIterableSubscriber.drainAsync()"]}, {"title": "README.md describes EmitterProcessor behavior incorrectly", "body": "See https://github.com/reactor/reactor-core/blame/5bdac9a12e7bc6a294a516d490470008b66bcb4d/README.md#L153-L161\r\n\r\n```java\r\nEmitterProcessor<Integer> emitter = EmitterProcessor.create();\r\nBlockingSink<Integer> sink = emitter.connectSink();\r\nsink.next(1);\r\nsink.next(2);\r\nemitter.subscribe(System.out::println);\r\nsink.next(3); //output : 3\r\nsink.finish();\r\n```\r\n\r\nI tried to execute the code snippet using `io.projectreactor:reactor-core:3.0.5.RELEASE` and it failed with an exception:\r\n```\r\nException in thread \"main\" reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)\r\n\tat reactor.core.Exceptions.failWithOverflow(Exceptions.java:140)\r\n\tat reactor.core.publisher.Operators.reportMoreProduced(Operators.java:477)\r\n\tat reactor.core.publisher.BlockingSink.next(BlockingSink.java:160)\r\n```\r\n\r\nIt works as described, if I add a dummy (skipping) subscriber before the sink invocations:\r\n```java\r\nEmitterProcessor<Integer> emitter = EmitterProcessor.create();\r\n\r\n// Subscribe before the emitting\r\nemitter.subscribe(i -> {});\r\n\r\nBlockingSink<Integer> sink = emitter.connectSink();\r\nsink.next(1);\r\nsink.next(2);\r\nemitter.subscribe(System.out::println);\r\nsink.next(3); //output : 3\r\nsink.finish();\r\n```", "url": "https://github.com/reactor/reactor-core/issues/452", "user": "a-voloshyn", "labels": ["type/bug", "type/documentation", "warn/api-change"], "created": "2017-03-01 23:55:42", "closed": "2017-05-11 10:13:28", "commits": {"88716515553b9e731184a0e28bb7b41b36077c4b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "55df9e87e5dabfc60147463bef18416e5f2a1e13": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6d6f5f814750dc4506ac8f24b95132be136ed8b7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "692813df8d3c4f31a9b9bb46d36e18d76058ba9a": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6129efc3a21fa4a2d0758a0fcf063c10ad7792fb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0be54679a14c031ad380299a90f18710d7c96098": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "c66944ec39da8374dde0ecf41adbe197649bb264": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 70.00027777777778, "commitsDetails": [{"commitHash": "88716515553b9e731184a0e28bb7b41b36077c4b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "55df9e87e5dabfc60147463bef18416e5f2a1e13", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6d6f5f814750dc4506ac8f24b95132be136ed8b7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "692813df8d3c4f31a9b9bb46d36e18d76058ba9a", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["d0cea73e3c637ae61a614d826221677499a8ccb0"], "nameRev": "692813df8d3c4f31a9b9bb46d36e18d76058ba9a tags/v3.1.0.M1~29", "commitMessage": "see #525 Deep Processor rework\n\nThis commit is a big rework of FluxProcessors in general, and of\nEmitterProcessor in particular. It introduces breaking changes.\n\n[API changes]\n* `BlockingSink` has been removed\n* in `FluxProcessor`: `#connect`, `#connectSink` have been removed\n* `FluxProcessor` now exposes a `sink()` instead, with default blocking\n  behavior and as-needed serialization\n* `FluxSink#next` now returns the FluxSink for fluent chaining\n* Removed `maxConcurrency` concept from `EmitterProcessor`\n\n[Behavior changes]\n* `EmitterProcessor` now supports fusion\n* `EmitterProcessor` must be subscribed before onSubscribed in order\n  not to lose any event\n* Simply subscribing to an `EmitterProcessor` is now equivalent to\n  connecting to a `ConnectableFlux`\n\n[Implementation changes]\n* `FluxPublish` has been tweaked to remove synchronization\n* Internal classes from ReplayProcessor have been moved to `FluxReplay`\n* `EmitterProcessor` has been entirely reworked to internally align with\n  `FluxPublish` (fusion support, no more ringbuffer...)\n\nFixes #510\nFixes #304\nFixes #248\n\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:46:35", "authoredDateTime": "2017-04-10 19:19:53", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BlockingSink.java", "insertions": 0, "deletions": 455, "lines": 455}, {"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 8, "deletions": 6, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 294, "deletions": 433, "lines": 727}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 11, "deletions": 15, "lines": 26}, {"filePath": "src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 15, "deletions": 21, "lines": 36}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 62, "deletions": 74, "lines": 136}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 102, "deletions": 98, "lines": 200}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 935, "deletions": 27, "lines": 962}, {"filePath": "src/main/java/reactor/core/publisher/FluxSink.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 29, "deletions": 954, "lines": 983}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 35, "deletions": 45, "lines": 80}, {"filePath": "src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "insertions": 3, "deletions": 5, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 0, "deletions": 6, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxProcessorTest.java", "insertions": 12, "deletions": 33, "lines": 45}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 1, "deletions": 5, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ReplayProcessorTest.java", "insertions": 2, "deletions": 6, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 9, "deletions": 12, "lines": 21}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java", "insertions": 26, "deletions": 32, "lines": 58}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 5, "deletions": 15, "lines": 20}, {"filePath": "src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java", "insertions": 1, "deletions": 9, "lines": 10}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}, {"commitHash": "6129efc3a21fa4a2d0758a0fcf063c10ad7792fb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0be54679a14c031ad380299a90f18710d7c96098", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "c66944ec39da8374dde0ecf41adbe197649bb264", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["bf3bc3dc1896cfb473994d851c31a483b56163d9"], "nameRev": "c66944ec39da8374dde0ecf41adbe197649bb264 tags/v3.0.7.RELEASE~11", "commitMessage": "Prepare migration path for deep Processor rework in #525\n\nThis commit prepares for breaking Processor API changes in 3.1.0 by\ndeprecating a number of methods around processors and sinks.\n\n[Added API]\n* `FluxProcessor` now exposes a `sink()` method, with default blocking\n  behavior and as-needed serialization\n\n[API deprecations]\nThe following APIs have been deprecated and will be removed in 3.1.0:\n* `BlockingSink` has been deprecated\n* in `FluxProcessor`: `#connect`, `#connectSink` have been deprecated\n  (use `#sink` instead to migrate to the new behavior before 3.1.0)\n* `maxConcurrency` concept from `EmitterProcessor` has been deprecated\n\nAdapted from PR #525 (commit 692813df8d3c4f31a9b9bb46d36e18d76058ba9a)\n\nSee #510, #304 and #248\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:50:11", "authoredDateTime": "2017-04-13 12:11:31", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BlockingSink.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 44, "deletions": 20, "lines": 64}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 20, "deletions": 3, "lines": 23}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 87, "deletions": 40, "lines": 127}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingSink.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingSink", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DelegateProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.DelegateProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor.create(int,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.create(int,int,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.upstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.getPending()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.isSerialized()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.EventLoopContext", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxProcessor.isSerialized()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.sink()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connectSink()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connectSink(boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.getCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.isStarted()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.downstreams()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.serialize()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.isTerminated()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.downstreamCount()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ReplayProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ReplayProcessor.getBufferSize()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "UnicastProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.UnicastProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.failTooMuchSubscribers()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["e6b50b8b3b5077df892936c4319d42a63911eecf"], "nameRev": "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c tags/v3.0.7.RELEASE~9", "commitMessage": "Backport some Processor changes from #525\n\nThis commit additionally prepares for Processor behavioral changes in\n3.1.0 by implementing new behaviors of `EmitterProcessor`, in order to\nhelp with the migration path.\n\n[Behavior changes]\n* `EmitterProcessor` now supports fusion\n* `EmitterProcessor` must be subscribed before onSubscribed in order not\n  to lose any event\n* Simply subscribing to an `EmitterProcessor` is now equivalent to\n  connecting to a `ConnectableFlux`\n\n[Implementation changes]\n* `FluxPublish` has been tweaked to remove synchronization\n* Internal classes from ReplayProcessor have been moved to `FluxReplay`\n* `EmitterProcessor` has been entirely reworked to internally align with\n  `FluxPublish` (fusion support, no more ringbuffer...)\n\nAdapted from PR #525 (commit 692813df8d3c4f31a9b9bb46d36e18d76058ba9a)\n\nSee #510, #304 and #248\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:50:11", "authoredDateTime": "2017-04-13 12:20:48", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 277, "deletions": 383, "lines": 660}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 102, "deletions": 97, "lines": 199}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 935, "deletions": 27, "lines": 962}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 29, "deletions": 938, "lines": 967}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 37, "deletions": 40, "lines": 77}, {"filePath": "src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "insertions": 3, "deletions": 5, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 0, "deletions": 6, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxProcessorTest.java", "insertions": 12, "deletions": 33, "lines": 45}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 1, "deletions": 5, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ReplayProcessorTest.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 9, "deletions": 12, "lines": 21}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java", "insertions": 26, "deletions": 32, "lines": 58}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 5, "deletions": 15, "lines": 20}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 5, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 3, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "TopicProcessor share(..) and create(..) fail silently when backlog size is 1.", "body": "See this gist for a testcase demonstrating the behavior: [ReactorMultiSubscribeBehaviorTest.java](https://gist.github.com/masterav10/14f9f5f1628ad370f9fb9fcfbf8e9db6).\r\n\r\nEssentially, a cryptic error appears at some point during the subscriptions, and I can't tell if it fails silently or if the logger is printing the exception since it doesn't bubble up from the test case.\r\n\r\nI would have expected static factory method to throw the exception.\r\n\r\nTested using 3.0.5.RELEASE on Windows and LInux.", "url": "https://github.com/reactor/reactor-core/issues/445", "user": "masterav10", "labels": ["type/bug"], "created": "2017-02-24 20:55:38", "closed": "2017-03-22 11:03:18", "commits": {"9353ec2c6350ff581d01012ce461a14b7b697070": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "df8ecfa1344bcb04e1a7c0dae38508bc0237abb3": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 25.00027777777778, "commitsDetails": [{"commitHash": "9353ec2c6350ff581d01012ce461a14b7b697070", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "df8ecfa1344bcb04e1a7c0dae38508bc0237abb3", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0ff6f5218424d37a316ce0cb8b15ac9635c5a6a6"], "nameRev": "df8ecfa1344bcb04e1a7c0dae38508bc0237abb3 tags/v3.0.6.RELEASE~15", "commitMessage": "fix #445 Ensure request min 1 when bufferSize is 1 in TopicProcessor\n\nThis commit changes the EventLoopProcessor base class so it also affects\r\nthe WorkQueueProcessor. In RequestTask, it ensures the request(limit...)\r\nisn't 0 for bufferSize of 1, but rather 1.", "commitDateTime": "2017-03-22 12:03:17", "authoredDateTime": "2017-03-22 12:03:17", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 52, "deletions": 0, "lines": 52}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 52, "deletions": 0, "lines": 52}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.RequestTask.run()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "TopicProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.TopicProcessorTest.testBufferSize1Shared()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.TopicProcessorTest.testBufferSize1Created()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.testBufferSize1Shared()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.testBufferSize1Created()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["df8ecfa1344bcb04e1a7c0dae38508bc0237abb3"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 1.0, "lines": 2.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 0.0, "INS": 1.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.EventLoopProcessor.RequestTask.run()"]}, {"title": "ExecutorServiceScheduler interruptIfNeeded is not fully respected in worker", "body": "", "url": "https://github.com/reactor/reactor-core/issues/443", "user": "smaldini", "labels": ["type/bug"], "created": "2017-02-24 11:26:42", "closed": "2017-03-13 11:22:04", "commits": {"8684a735f101295d663b92212dbfa7213034d213": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 16.00027777777778, "commitsDetails": [{"commitHash": "8684a735f101295d663b92212dbfa7213034d213", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["1400225d36e44f5a3693db5e8d6ff4d7f3a662bb"], "nameRev": "8684a735f101295d663b92212dbfa7213034d213 tags/v3.0.6.RELEASE~29", "commitMessage": "fix #451 Merge TimedScheduler features into Scheduler\n\nThis commit merges the functionality of SingleTimedScheduler into its\r\nSingleTimeScheduler sibling, now that both expose an API for delayed\r\nsubmit:\r\n\r\n - moving the methods into Scheduler as default methods (will return\r\n a REJECTED by default)\r\n - using Scheduler as input everywhere a TimedScheduler was used\r\n - deprecating `TimedScheduler` and `TimedWorker`\r\n\r\nThe 3 task implementations of SingleTimedScheduler and SingleScheduler\r\nhave all been replaced by an extracted ScheduledRunnable.\r\n\r\n\"delayXXX\" methods now use `parallel()` as default Scheduler.\r\n\r\nAdded tests in AbstractSchedulerTests, skipped if scheduler isn't time\r\ncapable.\r\n\r\n[Behavior Change]\r\nAs demonstrated in SchedulersTest, the single scheduler Worker won't\r\nexecute an immediate task anymore if it is disposed right after\r\n`submit(task)`.\r\n\r\nAlso fixes #443 ", "commitDateTime": "2017-03-13 12:22:02", "authoredDateTime": "2017-03-13 12:22:02", "commitGitStats": [{"filePath": "build.gradle", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 95, "deletions": 99, "lines": 194}, {"filePath": "src/main/java/reactor/core/publisher/FluxBatch.java", "insertions": 4, "deletions": 5, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxElapsed.java", "insertions": 5, "deletions": 6, "lines": 11}, {"filePath": "src/main/java/reactor/core/publisher/FluxInterval.java", "insertions": 7, "deletions": 7, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 34, "deletions": 34, "lines": 68}, {"filePath": "src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 2, "deletions": 3, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/MonoDelayElement.java", "insertions": 4, "deletions": 5, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoElapsed.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "src/main/java/reactor/core/scheduler/DisposableContainer.java", "insertions": 61, "deletions": 0, "lines": 61}, {"filePath": "src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 140, "deletions": 29, "lines": 169}, {"filePath": "src/main/java/reactor/core/scheduler/EmptyDisposableContainer.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 169, "deletions": 57, "lines": 226}, {"filePath": "src/main/java/reactor/core/scheduler/ImmediateScheduler.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 126, "deletions": 31, "lines": 157}, {"filePath": "src/main/java/reactor/core/scheduler/ScheduledRunnable.java", "insertions": 131, "deletions": 0, "lines": 131}, {"filePath": "src/main/java/reactor/core/scheduler/Scheduler.java", "insertions": 105, "deletions": 7, "lines": 112}, {"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 45, "deletions": 73, "lines": 118}, {"filePath": "src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 122, "deletions": 141, "lines": 263}, {"filePath": "src/main/java/reactor/core/scheduler/SingleTimedScheduler.java", "insertions": 0, "deletions": 462, "lines": 462}, {"filePath": "src/main/java/reactor/core/scheduler/SingleWorkerScheduler.java", "insertions": 17, "deletions": 2, "lines": 19}, {"filePath": "src/main/java/reactor/core/scheduler/TimedScheduler.java", "insertions": 14, "deletions": 81, "lines": 95}, {"filePath": "src/test/java/reactor/core/publisher/FluxCacheTest.java", "insertions": 6, "deletions": 3, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/FluxIntervalTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/MonoDelayElementTest.java", "insertions": 13, "deletions": 16, "lines": 29}, {"filePath": "src/test/java/reactor/core/publisher/MonoDelayTest.java", "insertions": 21, "deletions": 0, "lines": 21}, {"filePath": "src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/scheduler/AbstractSchedulerTest.java", "insertions": 191, "deletions": 10, "lines": 201}, {"filePath": "src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java", "insertions": 81, "deletions": 0, "lines": 81}, {"filePath": "src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java", "insertions": 36, "deletions": 0, "lines": 36}, {"filePath": "src/test/java/reactor/core/scheduler/ExecutorSchedulerTrampolineTest.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/test/java/reactor/core/scheduler/ExecutorServiceInterruptSchedulerTest.java", "insertions": 10, "deletions": 1, "lines": 11}, {"filePath": "src/test/java/reactor/core/scheduler/ExecutorServiceSchedulerTest.java", "insertions": 102, "deletions": 2, "lines": 104}, {"filePath": "src/test/java/reactor/core/scheduler/ImmediateSchedulerTest.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "src/test/java/reactor/core/scheduler/ParallelSchedulerTest.java", "insertions": 82, "deletions": 0, "lines": 82}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 53, "deletions": 30, "lines": 83}, {"filePath": "src/test/java/reactor/core/scheduler/SingleSchedulerTest.java", "insertions": 64, "deletions": 0, "lines": 64}, {"filePath": "src/test/java/reactor/core/scheduler/SingleTimedSchedulerTest.java", "insertions": 0, "deletions": 281, "lines": 281}, {"filePath": "src/test/java/reactor/core/scheduler/SingleWorkerAroundTimerSchedulerTest.java", "insertions": 37, "deletions": 0, "lines": 37}, {"filePath": "src/test/java/reactor/core/scheduler/SingleWorkerSchedulerTest.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/test/java/reactor/core/scheduler/TimedSchedulerTest.java", "insertions": 107, "deletions": 0, "lines": 107}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "onAssembly suppressed exception can be a circular reference", "body": "Look out for `addSuppressed` and try to check that the added exception isn't the same as the base (in which case Java would throw).", "url": "https://github.com/reactor/reactor-core/issues/439", "user": "smaldini", "labels": ["type/bug"], "created": "2017-02-21 11:38:28", "closed": "2017-03-16 14:41:41", "commits": {"a41ab4daf56fed6566a350a698a46ab83bf7cbd9": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "5a052c2ee8ce358536c232db3c32fea591a842e8": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 23.00027777777778, "commitsDetails": [{"commitHash": "a41ab4daf56fed6566a350a698a46ab83bf7cbd9", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5a052c2ee8ce358536c232db3c32fea591a842e8", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["bc6d61ba76ea71563968f082865925e8367e8853"], "nameRev": "5a052c2ee8ce358536c232db3c32fea591a842e8 tags/v3.0.6.RELEASE~23", "commitMessage": "fix #439 Ensure suppressed exceptions are not circular references\n\n", "commitDateTime": "2017-03-16 15:41:39", "authoredDateTime": "2017-03-16 15:41:39", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BaseSubscriber.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxOnAssembly.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxRetryPredicate.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxUsing.java", "insertions": 10, "deletions": 4, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/MonoUsing.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/FluxUsingTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "src/test/java/reactor/core/publisher/MonoUsingTest.java", "insertions": 30, "deletions": 0, "lines": 30}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BaseSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BaseSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.coldSource(reactor.core.publisher.RingBuffer,java.lang.Throwable,java.lang.Throwable,reactor.core.publisher.RingBuffer$Sequence)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxOnAssembly.java", "spoonMethods": []}, {"spoonFilePath": "FluxRetryPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxRetryPredicate.RetryPredicateSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxUsing.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxUsing.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsing.UsingSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsing.UsingFuseableSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxUsing.UsingConditionalSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoUsing.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUsing.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.onErrorDropped(java.lang.Throwable,java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxUsingTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxUsingTest.sourceFactoryAndResourceCleanupThrow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoUsingTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoUsingTest.sourceFactoryAndResourceCleanupThrow()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["5a052c2ee8ce358536c232db3c32fea591a842e8"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 22.0, "deletions": 10.0, "lines": 32.0, "gitFilesChange": 7}, "spoonStatsSummary": {"TOT": 16.0, "UPD": 2.0, "INS": 7.0, "MOV": 7.0, "DEL": 0.0, "spoonFilesChanged": 6, "spoonMethodsChanged": 9}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxUsing.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxUsing.UsingSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxUsing.UsingFuseableSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.EventLoopProcessor.coldSource(reactor.core.publisher.RingBuffer,java.lang.Throwable,java.lang.Throwable,reactor.core.publisher.RingBuffer$Sequence)", "reactor.core.publisher.MonoUsing.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.BaseSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxUsing.UsingConditionalSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.Operators.onErrorDropped(java.lang.Throwable,java.lang.Throwable)", "reactor.core.publisher.FluxRetryPredicate.RetryPredicateSubscriber.onError(java.lang.Throwable)"]}, {"title": "ArrayIndexOutOfBoundsException on flattening Flux<Mono.publish(f)>", "body": "## Simplest test case that throws the exception\r\n\r\n```\r\nMono<Integer> simpleMono = Mono.just(1);\r\nMono<Integer> publishMulticastMono = simpleMono.publish(m -> m);\r\nFlux<Mono<Integer>> fluxThatHasPublishMulticastMonos = Flux.just(publishMulticastMono);\r\n\r\nfluxThatHasPublishMulticastMonos\r\n        .flatMap(mono -> mono)  // flatten\r\n        .blockLast();           // fire. Note: No problem with `blockFirst()`\r\n```\r\n<details>\r\n<summary>stacktrace</summary>\r\njava.lang.ArrayIndexOutOfBoundsException: 0\r\n\r\n\tat reactor.core.publisher.FluxPublishMulticast$FluxPublishMulticaster.drainSync(FluxPublishMulticast.java:308)\r\n\tat reactor.core.publisher.FluxPublishMulticast$FluxPublishMulticaster.drain(FluxPublishMulticast.java:250)\r\n\tat reactor.core.publisher.FluxPublishMulticast$FluxPublishMulticaster.onSubscribe(FluxPublishMulticast.java:181)\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\tat reactor.core.publisher.FluxPublishMulticast.subscribe(FluxPublishMulticast.java:90)\r\n\tat reactor.core.publisher.MonoSource.subscribe(MonoSource.java:65)\r\n\tat reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:192)\r\n\tat reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:110)\r\n\tat reactor.core.publisher.Flux.blockLast(Flux.java:1716)\r\n\tat com.orange.odu.prepaid.proxy.unitTest.ReactorTest.testBranchingOfMonoInsideFluxSimplified(ReactorTest.java:150)\r\n</details>\r\n\r\n## Similar test cases that pass\r\n```\r\nMono<Integer> simpleMono = Mono.just(1);\r\nMono<Integer> publishMulticastMono = simpleMono.publish(m -> m);\r\npublishMulticastMono.block();\r\n```\r\n```\r\nMono<Integer> simpleMono = Mono.just(1);\r\nMono<Integer> publishMulticastMono = simpleMono.publish(m -> m);\r\nFlux<Mono<Integer>> fluxThatHasPublishMulticastMonos = Flux.just(publishMulticastMono);\r\n\r\nfluxThatHasPublishMulticastMonos\r\n        .flatMap(mono -> mono)  // flatten\r\n        .blockFirst();           // fire. This time, `blockFirst()` instead of `blockLast()`\r\n```\r\n\r\n## Versions tested\r\n3.0.3.RELEASE\r\n3.0.4.RELEASE\r\n3.0.5.RELEASE\r\n\r\n## Code tracing\r\nThis part is probably just noise and not even that hard to know, I'm just trying to be helpful. Feel free to ignore it.\r\n\r\nIn [FluxPublishMulticast::drainSync()](https://github.com/reactor/reactor-core/blob/aadabec0004261efce80eda9b8504df4c8da5185/src/main/java/reactor/core/publisher/FluxPublishMulticast.java#L266):\r\n- `a[i].actual` is a `MonoNext`, `s` of which is a [PublishClientSubscription](https://github.com/reactor/reactor-core/blob/aadabec0004261efce80eda9b8504df4c8da5185/src/main/java/reactor/core/publisher/FluxPublishMulticast.java#L576) whose `parent` is the original `FluxPublishMulticast`.\r\n- in `while(e != r)`:\r\n    - In the first iteration, `a[i].actual.onNext(v);` calls [`s.cancel()`](https://github.com/reactor/reactor-core/blob/aadabec0004261efce80eda9b8504df4c8da5185/src/main/java/reactor/core/publisher/MonoNext.java#L77), so [`removeAndDrain`](https://github.com/reactor/reactor-core/blob/aadabec0004261efce80eda9b8504df4c8da5185/src/main/java/reactor/core/publisher/FluxPublishMulticast.java#L514) is called on the original `FluxPublishMulticast`, which sets `subscribes` to an empty array.\r\n    - In the second iteration, `n` would remain one, while `subscribers` became an empty array.\r\n\r\ni.e., completion is trying to be done twice, I think. Once, because of `MonoNext::onNext()` knows it has only one element to emit, and another in the next iteration of `FluxPublishMulticast` when it finds no more elements in its `queue`. Maybe, the first iteration of the `while(e != r)` should've cancelled the `FluxPublishMulticast` in this case.\r\nThat's what I understood from the code, that is. May be totally wrong.\r\n\r\nI really wanted to help more but can't understand what `wip`, `missed` & `FluxFlatMap::trySubscribeScalarMap()` are. Was hoping for this to be my 1st meaningful PR but seems like the dream is gone :cry:. I now hope anything I've said is correct :joy:. Remember: You've been warned to not read this part :P.", "url": "https://github.com/reactor/reactor-core/issues/438", "user": "hossameldeen", "labels": ["type/bug"], "created": "2017-02-21 10:50:09", "closed": "2017-02-21 11:43:44", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Add tests for  #425, WorkQueueProcessor async cancel fix", "body": "#425 introduced a fix to the previous async cancel change in `WorkQueueProcessor` and it was mentioned that it needed more tests.\r\n\r\n@dfeist you said you had 70 failing tests around that in your code, any chance you could derive a few tests suitable for reactor out of that?", "url": "https://github.com/reactor/reactor-core/issues/426", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-02-09 09:27:13", "closed": "2017-02-20 14:08:30", "commits": {}, "ttf": 11.000277777777777, "commitsDetails": []}, {"title": "concatMap/concatMapIterable/flatMapIterable on a cached Flux longer than 256 works wrong", "body": "Please see the code at https://github.com/dynaxis/reactor-bug .\r\nThe `Flux.concatMapIterable` on a cached `Flux`  longer than `256` doesn't pass the original elements as they are. Instead, the elements from the 2nd to 2567th, are repeated. `flatMapIterable` has the same problem though the code doesn't include code for showing it. `flatMap` works fine but `concatMap` not, FYI.\r\n\r\nIn the repo above, I added `RxJava2Test` to see if the equivalent operator works fine with RxJava2. Actually it does. Maybe this is helpful to point out what's wrong with Reactor's implementation.", "url": "https://github.com/reactor/reactor-core/issues/422", "user": "dynaxis", "labels": ["type/bug"], "created": "2017-02-08 10:25:42", "closed": "2017-02-08 14:59:28", "commits": {"2d616c8b0eb0f4c959708948afc40a26b7732f03": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "c2d7b7429d537181e04c27330a76369b0c2adcc1": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2d616c8b0eb0f4c959708948afc40a26b7732f03", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "c2d7b7429d537181e04c27330a76369b0c2adcc1", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["295b7d92160bbffc72b53708737eb7731d0aa7c9"], "nameRev": "c2d7b7429d537181e04c27330a76369b0c2adcc1 tags/v3.0.5.RELEASE~19", "commitMessage": "Tck improvements and fixes (#424)\n\n* fix #422 Fix replay/cache issue with paging buffer\r\n* Deprecate WaitStrategy.throwAlert\r\n* Rework processor using failWithCancel to use WaitStrategy alert\r\n* Add callable-fusion support for MonoRunnable and open subscribeOn to fuse with it\r\n* Add Operators#drainSubscriber helper\r\n* Fix fusion issue with ParallelFlux#subcribe\r\n* cleanups and  tck scope increase\r\n", "commitDateTime": "2017-02-08 14:59:26", "authoredDateTime": "2017-02-08 14:59:26", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxDefaultIfEmpty.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/FluxHide.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/FluxScan.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxSource.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java", "insertions": 8, "deletions": 4, "lines": 12}, {"filePath": "src/main/java/reactor/core/publisher/MonoAll.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/MonoAny.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/MonoCollect.java", "insertions": 0, "deletions": 10, "lines": 10}, {"filePath": "src/main/java/reactor/core/publisher/MonoDelayElement.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/MonoElementAt.java", "insertions": 0, "deletions": 4, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/MonoReduce.java", "insertions": 21, "deletions": 4, "lines": 25}, {"filePath": "src/main/java/reactor/core/publisher/MonoReduceSeed.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "src/main/java/reactor/core/publisher/MonoRunnable.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoSingle.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/MonoSource.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 40, "deletions": 9, "lines": 49}, {"filePath": "src/main/java/reactor/core/publisher/ParallelFlux.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/ParallelMergeSequential.java", "insertions": 9, "deletions": 5, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/TopicProcessor.java", "insertions": 4, "deletions": 9, "lines": 13}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 10, "deletions": 15, "lines": 25}, {"filePath": "src/main/java/reactor/util/concurrent/WaitStrategy.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/AbstractFluxOperatorTest.java", "insertions": 0, "deletions": 1359, "lines": 1359}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 288, "deletions": 0, "lines": 288}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java", "insertions": 9, "deletions": 11, "lines": 20}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferTest.java", "insertions": 18, "deletions": 25, "lines": 43}, {"filePath": "src/test/java/reactor/core/publisher/FluxCombineLatestTest.java", "insertions": 13, "deletions": 22, "lines": 35}, {"filePath": "src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "insertions": 34, "deletions": 14, "lines": 48}, {"filePath": "src/test/java/reactor/core/publisher/FluxDematerializeTest.java", "insertions": 17, "deletions": 19, "lines": 36}, {"filePath": "src/test/java/reactor/core/publisher/FluxDistinctTest.java", "insertions": 13, "deletions": 16, "lines": 29}, {"filePath": "src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java", "insertions": 5, "deletions": 5, "lines": 10}, {"filePath": "src/test/java/reactor/core/publisher/FluxFilterTest.java", "insertions": 6, "deletions": 4, "lines": 10}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlattenIterableTest.java", "insertions": 15, "deletions": 107, "lines": 122}, {"filePath": "src/test/java/reactor/core/publisher/FluxGroupByTest.java", "insertions": 11, "deletions": 15, "lines": 26}, {"filePath": "src/test/java/reactor/core/publisher/FluxHandleTest.java", "insertions": 10, "deletions": 12, "lines": 22}, {"filePath": "src/test/java/reactor/core/publisher/FluxIterableTest.java", "insertions": 1, "deletions": 70, "lines": 71}, {"filePath": "src/test/java/reactor/core/publisher/FluxMapSignalTest.java", "insertions": 6, "deletions": 5, "lines": 11}, {"filePath": "src/test/java/reactor/core/publisher/FluxMapTest.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/FluxMaterializeTest.java", "insertions": 14, "deletions": 4, "lines": 18}, {"filePath": "src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTest.java", "insertions": 4, "deletions": 7, "lines": 11}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekTest.java", "insertions": 26, "deletions": 49, "lines": 75}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 14, "deletions": 17, "lines": 31}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 27, "deletions": 30, "lines": 57}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 3, "deletions": 5, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/FluxScanSeedTest.java", "insertions": 16, "deletions": 22, "lines": 38}, {"filePath": "src/test/java/reactor/core/publisher/FluxScanTest.java", "insertions": 11, "deletions": 14, "lines": 25}, {"filePath": "src/test/java/reactor/core/publisher/FluxSkipLastTest.java", "insertions": 7, "deletions": 5, "lines": 12}, {"filePath": "src/test/java/reactor/core/publisher/FluxSkipTest.java", "insertions": 7, "deletions": 6, "lines": 13}, {"filePath": "src/test/java/reactor/core/publisher/FluxSkipUntilOtherTest.java", "insertions": 5, "deletions": 5, "lines": 10}, {"filePath": "src/test/java/reactor/core/publisher/FluxSkipUntilTest.java", "insertions": 10, "deletions": 7, "lines": 17}, {"filePath": "src/test/java/reactor/core/publisher/FluxSkipWhileTest.java", "insertions": 10, "deletions": 7, "lines": 17}, {"filePath": "src/test/java/reactor/core/publisher/FluxUsingTest.java", "insertions": 8, "deletions": 12, "lines": 20}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java", "insertions": 30, "deletions": 42, "lines": 72}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowTest.java", "insertions": 13, "deletions": 15, "lines": 28}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipIterableTest.java", "insertions": 71, "deletions": 1, "lines": 72}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 5, "deletions": 9, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/MonoMapTest.java", "insertions": 19, "deletions": 1, "lines": 20}, {"filePath": "src/test/java/reactor/core/publisher/MonoReduceSeedTest.java", "insertions": 27, "deletions": 1, "lines": 28}, {"filePath": "src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 23, "deletions": 1, "lines": 24}, {"filePath": "src/test/java/reactor/core/publisher/MonoRunnableTest.java", "insertions": 28, "deletions": 0, "lines": 28}, {"filePath": "src/test/java/reactor/core/publisher/OperatorsTest.java", "insertions": 39, "deletions": 2, "lines": 41}, {"filePath": "src/test/java/reactor/core/publisher/ParallelReduceSeedTest.java", "insertions": 24, "deletions": 1, "lines": 25}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 13, "deletions": 0, "lines": 13}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 16, "deletions": 1, "lines": 17}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/BaseProcessorGettersTests.java", "insertions": 0, "deletions": 57, "lines": 57}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/EmitterProcessorDemandTests.java", "insertions": 0, "deletions": 330, "lines": 330}, {"filePath": "src/test/java/reactor/test/publisher/BaseOperatorTest.java", "insertions": 1198, "deletions": 0, "lines": 1198}, {"filePath": "src/test/java/reactor/test/publisher/FluxEmptySyncFuseable.java", "insertions": 62, "deletions": 0, "lines": 62}, {"filePath": "src/test/java/reactor/test/publisher/FluxFuseableExceptionOnPoll.java", "insertions": 143, "deletions": 0, "lines": 143}, {"filePath": "src/test/java/reactor/test/publisher/FluxOperatorTest.java", "insertions": 279, "deletions": 0, "lines": 279}, {"filePath": "src/test/java/reactor/test/publisher/MonoOperatorTest.java", "insertions": 257, "deletions": 0, "lines": 257}, {"filePath": "src/test/java/reactor/test/publisher/OperatorScenario.java", "insertions": 308, "deletions": 0, "lines": 308}, {"filePath": "src/test/java/reactor/test/publisher/ParallelOperatorTest.java", "insertions": 268, "deletions": 0, "lines": 268}, {"filePath": "src/test/java/reactor/test/publisher/ReduceOperatorTest.java", "insertions": 261, "deletions": 0, "lines": 261}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Race condition in WorkQueueProcessor when onNext() is called during re-subscribe due to retry causing event to be dropped.", "body": "I'm seeing this is 3.0.5-SNAPSHOT, but if i roll back to 3.0.4-SNAPSHOT it's not an issue.  It's going to be hard to reproduce this in a test I assume, but I'll try.\r\n\r\nMeantime, maybe worth seeing if there is anything obvious in updated code that may be causing this. \r\n\r\nIt's happening when WorkQueueProcessor receives two almost concurrent onNext() calls and one of these fails downstream and the other one doesn't (i'm using retry())\r\nif the first event is the one that fails, then the second event never gets processed, if the first event is the one that doesn't fail then both are processed fine.\r\n\r\n```\r\nWorkQueueProcessor wkp = WorkQueueProcessor.create(false)\r\nwkp.doOnNext(e -> if(e == 1){throw new Exception()})\r\n   .doOnNext(System.out::println)\r\n   .doOnError(ex -> {Thread.sleep(2)})\r\n   .retry()\r\n   .subscribe();\r\nBlockingSink sink = wkp.connectSink()\r\nexecutor.submit(() -> sink.onNext(1));\r\nexecutor.submit(() -> sink.onNext(2));\r\n```\r\n\r\nThats the scenario basically, but in order to produce race condition you may need to delay resubscribe/doOnError slightly to force it. What happens is that `2` is never printed, this second event (which seems to arrives while resubscribe is happening) gets lost. It's put on ring-buffer, but is either never taken off, of gets lost..\r\n\r\n\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/415", "user": "dfeist", "labels": ["type/bug"], "created": "2017-02-06 22:39:54", "closed": "2017-02-07 17:01:37", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Use SpscLinkedQueue in operators that can overflow or unwanted overflow can occur", "body": "Currently, groupBy, window, buffer, switchMap can suffer an overflow issue by being fixed queues even configured with prefetch they are not limiting downstream request.\r\n\r\nSome queue.offer() not using a linked queue are also not safely checked for overflow.\r\n\r\nAnother related issue has been fixed in this commit https://github.com/reactor/reactor-core/commit/ee1170f5939396e55579e862cb8147ca8bd1bf53.", "url": "https://github.com/reactor/reactor-core/issues/411", "user": "smaldini", "labels": ["type/bug"], "created": "2017-02-05 22:45:17", "closed": "2017-02-05 22:48:29", "commits": {"97201f1dbe08babce56ba6a1e2315530be49f545": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "44037cd495f708927d624906ad244ecc4df09edc": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "97201f1dbe08babce56ba6a1e2315530be49f545", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["ee1170f5939396e55579e862cb8147ca8bd1bf53"], "nameRev": "97201f1dbe08babce56ba6a1e2315530be49f545 tags/v3.0.5.RELEASE~28", "commitMessage": "Fix #411 : carefully choose the linked queue and check offer if not\n", "commitDateTime": "2017-02-05 22:48:21", "authoredDateTime": "2017-02-05 22:48:21", "commitGitStats": [{"filePath": "src/main/java/reactor/core/Exceptions.java", "insertions": 11, "deletions": 18, "lines": 29}, {"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 11, "deletions": 17, "lines": 28}, {"filePath": "src/main/java/reactor/core/publisher/FluxBuffer.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxBufferStartEnd.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxCombineLatest.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxGroupBy.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxIterable.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxMergeSequential.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxSwitchMap.java", "insertions": 13, "deletions": 5, "lines": 18}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindow.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowBoundary.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowPredicate.java", "insertions": 7, "deletions": 10, "lines": 17}, {"filePath": "src/main/java/reactor/core/publisher/FluxWithLatestFrom.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxZip.java", "insertions": 5, "deletions": 2, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/MonoSequenceEqual.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/util/concurrent/QueueSupplier.java", "insertions": 4, "deletions": 3, "lines": 7}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.Exceptions.failWithCancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.Exceptions.isCancel(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.Exceptions.ReactiveException", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.Exceptions.BubblingException", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.Exceptions.CancelException", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.Exceptions.CancelException.fillInStackTrace()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function)", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.buffer(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Supplier)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.groupBy(java.util.function.Function,java.util.function.Function,int)", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.switchMap(java.util.function.Function,int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.windowUntil(java.util.function.Predicate,boolean,int)", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.windowWhile(java.util.function.Predicate,int)", "TOT": 2, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.window(int,int)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function,int)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxBuffer.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBuffer.BufferSkipSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxBuffer.BufferSkipSubscriber.request(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxBufferStartEnd.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferStartEnd", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxBufferStartEnd.BufferStartEndMainSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxCombineLatest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCombineLatest.CombineLatestCoordinator.innerValue(int,java.lang.Object)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 4, "DEL": 0}]}, {"spoonFilePath": "FluxCreate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxCreate.BufferAsyncSink", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxGroupBy.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxGroupBy.GroupByMain", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxGroupBy.UnicastGroupedFlux.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxIterable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxIterable.IterableSubscription", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxIterable.IterableSubscription.clear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxIterable.IterableSubscriptionConditional.clear()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxMergeSequential.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeSequential.MergeSequentialMain.innerNext(reactor.core.publisher.FluxMergeSequential$MergeSequentialInner,java.lang.Object)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxSwitchMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSwitchMap.SwitchMapMain.innerNext(reactor.core.publisher.FluxSwitchMap$SwitchMapInner,java.lang.Object)", "TOT": 7, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxSwitchMap", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxSwitchMap.SwitchMapMain", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxWindow.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindow.WindowExactSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxWindowBoundary.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowBoundary", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxWindowPredicate.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.offerNewWindow(java.lang.Object,java.lang.Object)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxWithLatestFrom.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWithLatestFrom", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWithLatestFrom.WithLatestFromSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxWithLatestFrom.WithLatestFromOtherSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxZip.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxZip.ZipInner", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxZip.ZipInner.onNext(java.lang.Object)", "TOT": 7, "UPD": 0, "INS": 3, "MOV": 3, "DEL": 1}]}, {"spoonFilePath": "MonoSequenceEqual.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "QueueSupplier.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.QueueSupplier.unbounded(int)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "44037cd495f708927d624906ad244ecc4df09edc", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["97201f1dbe08babce56ba6a1e2315530be49f545"], "nameRev": "44037cd495f708927d624906ad244ecc4df09edc tags/v3.0.5.RELEASE~27", "commitMessage": "#411 missing unbounded on switchMap\n", "commitDateTime": "2017-02-06 10:03:40", "authoredDateTime": "2017-02-06 10:03:40", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.switchOnNext(org.reactivestreams.Publisher,int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["97201f1dbe08babce56ba6a1e2315530be49f545", "44037cd495f708927d624906ad244ecc4df09edc"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 77, "deletions": 74, "lines": 151, "gitFilesChange": 17}, "spoonStatsSummary": {"TOT": 96, "UPD": 11, "INS": 26, "MOV": 22, "DEL": 37, "spoonFilesChanged": 17, "spoonMethodsChanged": 44}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/util/concurrent", "src/main/java/reactor/core"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoSequenceEqual.EqualCoordinator", "reactor.core.publisher.FluxCreate.BufferAsyncSink", "reactor.core.publisher.FluxBuffer.BufferSkipSubscriber.request(long)", "reactor.core.publisher.Flux.groupBy(java.util.function.Function,java.util.function.Function,int)", "reactor.core.publisher.FluxWindowPredicate.WindowGroupedFlux.onNext(java.lang.Object)", "reactor.core.publisher.FluxIterable.IterableSubscription.clear()", "reactor.core.Exceptions", "reactor.core.publisher.FluxWithLatestFrom.WithLatestFromOtherSubscriber", "reactor.core.Exceptions.BubblingException", "reactor.core.publisher.FluxWithLatestFrom.WithLatestFromSubscriber", "reactor.core.publisher.FluxCombineLatest.CombineLatestCoordinator.innerValue(int,java.lang.Object)", "reactor.core.publisher.Flux.switchOnNext(org.reactivestreams.Publisher,int)", "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.onSubscribe(org.reactivestreams.Subscription)", "reactor.util.concurrent.QueueSupplier.unbounded(int)", "reactor.core.publisher.FluxIterable.IterableSubscriptionConditional.clear()", "reactor.core.publisher.Flux.switchMap(java.util.function.Function,int)", "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function,int)", "reactor.core.Exceptions.CancelException.fillInStackTrace()", "reactor.core.publisher.FluxWithLatestFrom", "reactor.core.publisher.Flux.buffer(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Supplier)", "reactor.core.publisher.FluxWindowPredicate.WindowPredicateMain.offerNewWindow(java.lang.Object,java.lang.Object)", "reactor.core.publisher.FluxWindow.WindowExactSubscriber", "reactor.core.publisher.FluxBuffer.BufferSkipSubscriber", "reactor.core.publisher.FluxBufferStartEnd.BufferStartEndMainSubscriber", "reactor.core.publisher.FluxSwitchMap.SwitchMapMain.innerNext(reactor.core.publisher.FluxSwitchMap$SwitchMapInner,java.lang.Object)", "reactor.core.publisher.FluxBufferStartEnd", "reactor.core.publisher.Flux.windowUntil(java.util.function.Predicate,boolean,int)", "reactor.core.Exceptions.ReactiveException", "reactor.core.publisher.Flux.window(int,int)", "reactor.core.publisher.FluxZip.ZipInner", "reactor.core.publisher.FluxSwitchMap", "reactor.core.publisher.FluxGroupBy.GroupByMain", "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function)", "reactor.core.publisher.FluxSwitchMap.SwitchMapMain", "reactor.core.publisher.MonoSequenceEqual.EqualSubscriber", "reactor.core.publisher.FluxWindowBoundary", "reactor.core.Exceptions.failWithCancel()", "reactor.core.publisher.FluxIterable.IterableSubscription", "reactor.core.Exceptions.isCancel(java.lang.Throwable)", "reactor.core.Exceptions.CancelException", "reactor.core.publisher.Flux.windowWhile(java.util.function.Predicate,int)", "reactor.core.publisher.FluxZip.ZipInner.onNext(java.lang.Object)", "reactor.core.publisher.FluxMergeSequential.MergeSequentialMain.innerNext(reactor.core.publisher.FluxMergeSequential$MergeSequentialInner,java.lang.Object)", "reactor.core.publisher.FluxGroupBy.UnicastGroupedFlux.onNext(java.lang.Object)"]}, {"title": "Cache/FluxReplay incorrect behavior with fusion", "body": "Hey Reactor team,\r\n\r\nI have a flux which has multiple subscribers. To prevent duplication upstream, we use cache(1) before we the subscribers. One of three subscribers uses a parallel stream. The stream never receives data, which was unxpected. I'm not sure if this is a bug or not, but we have a test case which demonstrates the behavior. See gist below:\r\n\r\nhttps://gist.github.com/masterav10/c686bdcf0c70c7817a19e6b9e03f3a41\r\n\r\nTested using Reactor 3.0.4.RELEASE.", "url": "https://github.com/reactor/reactor-core/issues/392", "user": "masterav10", "labels": ["type/bug"], "created": "2017-01-25 19:12:23", "closed": "2017-01-27 15:25:44", "commits": {"3c343569702f1639d7101d28bd9e2a33fb25de20": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "3c343569702f1639d7101d28bd9e2a33fb25de20", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["70c2144e2054f42567107310c0205cd73a85dc07"], "nameRev": "3c343569702f1639d7101d28bd9e2a33fb25de20 tags/v3.0.5.RELEASE~64", "commitMessage": "fix #392 Flux.replay/cache fusion is invalid with operators using its isEmpty\n", "commitDateTime": "2017-01-27 15:25:04", "authoredDateTime": "2017-01-27 15:25:04", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ParallelFluxTest.java", "insertions": 47, "deletions": 0, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.InnerSubscription.isEmpty()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplay.InnerSubscription.size()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ParallelFluxTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.testParallelism()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ParallelFluxTest.tryToSleep(long)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3c343569702f1639d7101d28bd9e2a33fb25de20"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 2, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxReplay.InnerSubscription.size()", "reactor.core.publisher.FluxReplay.InnerSubscription.isEmpty()"]}, {"title": "Operators.addAndGet returns old value instead of new if != Long.MAX", "body": "", "url": "https://github.com/reactor/reactor-core/issues/372", "user": "smaldini", "labels": ["type/bug"], "created": "2017-01-17 14:57:20", "closed": "2017-01-17 15:46:30", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "RejectedDisposable should not be public", "body": "", "url": "https://github.com/reactor/reactor-core/issues/362", "user": "smaldini", "labels": ["type/bug", "warn/api-change"], "created": "2017-01-13 01:52:52", "closed": "2017-01-13 01:53:10", "commits": {"faea67ebf37e405c8b7bc6a40694861e87b68c2a": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "4b3128fc0b214e0d902d316c1fdbc509bee56e39": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "cdd39fcff80879e457f60eaf94d07bf388e93553": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "309769c34b4d6a14b13c7d9ea2f8f4bf6720eebb": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "faea67ebf37e405c8b7bc6a40694861e87b68c2a", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["5518c27d1ae7f5be19ec13509295bf1b457414dc"], "nameRev": "faea67ebf37e405c8b7bc6a40694861e87b68c2a tags/v3.0.5.RELEASE~100", "commitMessage": "fix #362 fixHide internal disposable instance - Some Scheduler coverage\n", "commitDateTime": "2017-01-13 01:53:02", "authoredDateTime": "2017-01-13 01:53:02", "commitGitStats": [{"filePath": "src/main/java/reactor/core/scheduler/RejectedDisposable.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 93, "deletions": 5, "lines": 98}], "commitSpoonAstDiffStats": [{"spoonFilePath": "RejectedDisposable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.RejectedDisposable", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersTest.parallelSchedulerThreadCheck()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.singleSchedulerThreadCheck()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.elasticSchedulerThreadCheck()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.timerSchedulerThreadCheck()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.pingPongParallelCall()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.executorThreadCheck()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.executorThreadCheck2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.sharedSingleCheck()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testShutdownOldOnSetFactory()", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4b3128fc0b214e0d902d316c1fdbc509bee56e39", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "cdd39fcff80879e457f60eaf94d07bf388e93553", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "309769c34b4d6a14b13c7d9ea2f8f4bf6720eebb", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["b47ce5e31d94af64fa1bd71386c285eb6ac4432a"], "nameRev": "309769c34b4d6a14b13c7d9ea2f8f4bf6720eebb tags/v3.0.5.RELEASE~87", "commitMessage": "fix #362 Operators should return old value\n", "commitDateTime": "2017-01-17 15:44:38", "authoredDateTime": "2017-01-17 14:58:00", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 19, "deletions": 2, "lines": 21}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.addAndGet(java.util.concurrent.atomic.AtomicLongFieldUpdater,java.lang.Object,long)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxFlatMapTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.prematureCancelInnerArrayMoreThanDefaultArraySize4()", "TOT": 7, "UPD": 5, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxFlatMapTest.assertOnSubscribeStateMainAndInner3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["faea67ebf37e405c8b7bc6a40694861e87b68c2a", "309769c34b4d6a14b13c7d9ea2f8f4bf6720eebb"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 2.0, "deletions": 2.0, "lines": 4.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 2.0, "UPD": 2.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.RejectedDisposable", "reactor.core.publisher.Operators.addAndGet(java.util.concurrent.atomic.AtomicLongFieldUpdater,java.lang.Object,long)"]}, {"title": "Cached `TimedScheduler`s don't delegate `now()` method", "body": "source: [stackoverflow](http://stackoverflow.com/questions/41553604/mono-elapse-does-not-work-with-stepverifier/)\r\n\r\nWhen using the `elapsed` operator on a `StepVerifier.withVirtualTime`, scheduling is virtualized correctly but the reported deltas are wrong.\r\n\r\nThis is due to the `VirtualTimeScheduler` being cached in the factory, and that cached version being used by `elapsed`. Turns out the `CacheTimedScheduler` doesn't delegate the `now` method, which defaults to using `System.currentTimeMillis` (real time).", "url": "https://github.com/reactor/reactor-core/issues/351", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-01-10 14:44:34", "closed": "2017-01-10 16:50:43", "commits": {"2241157e64ec2cc2bbaa70612405c8733b55e8ca": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "4a7eda875a259f4ab02cd4d81aa5c6c0ac5f3115": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2241157e64ec2cc2bbaa70612405c8733b55e8ca", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "4a7eda875a259f4ab02cd4d81aa5c6c0ac5f3115", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["1a46f9a11641dc93e60db90532f137ef5ab1242a"], "nameRev": "4a7eda875a259f4ab02cd4d81aa5c6c0ac5f3115 tags/v3.0.5.RELEASE~133", "commitMessage": "fix #351 CachedTimedScheduler.now() delegates to underlying\n\nThis commits fixes the situation where the default implementation of\n`now` (using System.currentTimeMillis) would be used as soon as a\nTimedScheduler was cached. This would for instance impact `elapsed` if\nthe timer scheduler was overridden through the factory.\n", "commitDateTime": "2017-01-10 17:50:41", "authoredDateTime": "2017-01-10 16:02:50", "commitGitStats": [{"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 90, "deletions": 0, "lines": 90}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.CachedTimedScheduler.now(java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testCachedSchedulerDelegates()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["4a7eda875a259f4ab02cd4d81aa5c6c0ac5f3115"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5.0, "deletions": 0.0, "lines": 5.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.Schedulers.CachedTimedScheduler.now(java.util.concurrent.TimeUnit)"]}, {"title": "Ensure consistent behaviour of scheduler RejectedExecution across different usage scenarios.", "body": "While reactor's built-in schedulers use an unbounded queue, in real-life situations executors will almost always be bounded and often schedulers will also be shared too.\r\n\r\nIt is clear from previous discussions with @smaldini that reactor if not designed to, and has no plans to handle scheduler rejection by permitting retry or applying back-pressure in reaction to this type of failures and instead scheduler rejection is treated as an unexpected/terminal exception which should fail/cancel the flux.\r\n\r\nAssuming this is the case, it is important that:\r\n- Behaviuor is as consistent as possible across different scenarios\r\n- Data signals do not get dropped silently\r\n- There is a way to receive notification via hook on all data signals dropped due to scheduler rejection.\r\n\r\nCurrently, there are a number of significant inconsistencies, and also some behaviour changes in 3.0.4 that could do with being reviewed. (as a side note, some things are also very different between reactor and rxJava)\r\n\r\nIn my mind the main/primary scenarios are:\r\n1) `.publishOn(scheduler).doOnNext(..)`\r\n2) `flaptMap(d -> just(d).publishOn(scheduler).doOnNext(..)).`\r\n3) `.paralell(n).runOn(scheduler).doOnNext(..).sequential().`\r\n4) `.doOnNext().subscribeOn(scheduler).subscribe()`\r\n5) `.flatMap(d -> just(d).doOnNext(..).subscribeOn(..))`\r\n\r\nLet's determine expected behaviour, ensure there is test coverage for behaviuor and create issues as required for any gaps.\r\n\r\n**publishOn**\r\n- PublishOn should fail/terminate by bubbling exception up on rejectedExecution, no onError signal means this can't be handled or re-tried. onOperatorError is invoked with failed signal & bubbled exception.  **[TO BE REVIEWED]**\r\n- If the above scenario occurs in an inner stream of, for example a flatMap, should flatMap simply propagate bubbled exception up parent flux? The flatMap onNext call shouldn't call onOperatorError in this scenario really as this would result in duplicate error notification for a given data signal. **[TO BE REVIEWED]**\r\n\r\n**parrelel**\r\n- TODO\r\n\r\n**subscribeOn**\r\n- TODO\r\n\r\n@smaldini Can we use GitHub Wiki to document and work through these scenarios or use and continually update this issue desciption? WDYT?", "url": "https://github.com/reactor/reactor-core/issues/347", "user": "dfeist", "labels": ["type/bug", "type/enhancement"], "created": "2017-01-09 14:48:36", "closed": "2017-08-02 17:55:17", "commits": {"03657cc194337fed024f17c9906f37349ed8fbd1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a9d173c49b59fd547b54a82f1aef4b5c360d34e1": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "823d8c3e4ff2403e8fabc7fdd98315b720897b44": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "46fe3c4d77e5bd918db85da503060b9ee96629ad": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "bc2056cd9dcaaaf2991d75991a98f1411dbb6f78": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "de435bf70d6838943907d9b6150b76d02e58ad9a": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "81e2593cf8d710b125e60ce3fd1dfacfc4ba6647": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "1d4a8643e7f4a59da281cd936b902459bbdc4425": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6f468f9992a9eb9885f6546cf889ca20852b1722": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "18e8d67c200381867ce9b5f0a95f8be06b9b09ea": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "a073c4d5f4b6c1a2d49e38d59a59dac406315f37": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 205.00027777777777, "commitsDetails": [{"commitHash": "03657cc194337fed024f17c9906f37349ed8fbd1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "a9d173c49b59fd547b54a82f1aef4b5c360d34e1", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "823d8c3e4ff2403e8fabc7fdd98315b720897b44", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "46fe3c4d77e5bd918db85da503060b9ee96629ad", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "bc2056cd9dcaaaf2991d75991a98f1411dbb6f78", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "de435bf70d6838943907d9b6150b76d02e58ad9a", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "81e2593cf8d710b125e60ce3fd1dfacfc4ba6647", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "1d4a8643e7f4a59da281cd936b902459bbdc4425", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6f468f9992a9eb9885f6546cf889ca20852b1722", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "18e8d67c200381867ce9b5f0a95f8be06b9b09ea", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["7c015a62956f7df0904335b6f3f7040cc06e594e"], "nameRev": "18e8d67c200381867ce9b5f0a95f8be06b9b09ea tags/v3.1.0.RC1~88", "commitMessage": "see #347 Test consistency of scheduler RejectedExecutionException\n\n - Schedulers now throw RejectedExecutionException instead of returning\n  a constant REJECTED.\n - if the underlying executor throws a REE, it is propagated. Otherwise\n  a constant REE is thrown.\n - All places where there was a check == REJECTED, a try catch has been\n put in place. The Scheduler's REE is for now always wrapped in a outer\n REE with suppressed exceptions when needed\n - test non-timed schedulers and always test a new Scheduler rather than\n  cached one\n - hide REJECTED_EXECUTION, use failWithRejected()\n - fix a few operators not catching REE, forgot to rethrow REE in\n ElasticScheduler\n - changed the common base for REE test to better reflect state of\n publishOn\n", "commitDateTime": "2017-08-02 10:55:15", "authoredDateTime": "2017-07-17 13:05:00", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Exceptions.java", "insertions": 18, "deletions": 0, "lines": 18}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 6, "deletions": 4, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java", "insertions": 6, "deletions": 5, "lines": 11}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java", "insertions": 9, "deletions": 1, "lines": 10}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 35, "deletions": 39, "lines": 74}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java", "insertions": 16, "deletions": 6, "lines": 22}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java", "insertions": 12, "deletions": 11, "lines": 23}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 16, "deletions": 13, "lines": 29}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 13, "deletions": 12, "lines": 25}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 8, "deletions": 8, "lines": 16}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java", "insertions": 6, "deletions": 5, "lines": 11}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 27, "deletions": 16, "lines": 43}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 22, "deletions": 6, "lines": 28}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java", "insertions": 7, "deletions": 6, "lines": 13}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java", "insertions": 7, "deletions": 6, "lines": 13}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 19, "deletions": 45, "lines": 64}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 10, "deletions": 14, "lines": 24}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 21, "deletions": 27, "lines": 48}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ImmediateScheduler.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 28, "deletions": 50, "lines": 78}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/RejectedDisposable.java", "insertions": 0, "deletions": 40, "lines": 40}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Scheduler.java", "insertions": 13, "deletions": 11, "lines": 24}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 19, "deletions": 28, "lines": 47}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeOrSizeTest.java", "insertions": 6, "deletions": 5, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/AbstractSchedulerTest.java", "insertions": 141, "deletions": 122, "lines": 263}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java", "insertions": 5, "deletions": 6, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java", "insertions": 15, "deletions": 8, "lines": 23}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ExecutorServiceSchedulerTest.java", "insertions": 19, "deletions": 13, "lines": 32}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ImmediateSchedulerTest.java", "insertions": 15, "deletions": 8, "lines": 23}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/ParallelSchedulerTest.java", "insertions": 5, "deletions": 6, "lines": 11}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/RejectedExecutionTest.java", "insertions": 433, "deletions": 0, "lines": 433}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 7, "deletions": 28, "lines": 35}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/TimedSchedulerTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java", "insertions": 6, "deletions": 7, "lines": 13}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}, {"commitHash": "a073c4d5f4b6c1a2d49e38d59a59dac406315f37", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["18e8d67c200381867ce9b5f0a95f8be06b9b09ea"], "nameRev": "a073c4d5f4b6c1a2d49e38d59a59dac406315f37 tags/v3.1.0.RC1~87", "commitMessage": "[resolve #347] Polish scheduler wrt its operator use with RejectedException\n\n- FluxSubscribeOn which still throws on late request failure\n- Precise Flux.subscribeOn rejected doc\n", "commitDateTime": "2017-08-02 10:55:15", "authoredDateTime": "2017-08-01 15:14:35", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/Exceptions.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 11, "deletions": 22, "lines": 33}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java", "insertions": 49, "deletions": 27, "lines": 76}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 11, "deletions": 25, "lines": 36}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java", "insertions": 8, "deletions": 11, "lines": 19}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 27, "deletions": 19, "lines": 46}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 2, "deletions": 4, "lines": 6}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java", "insertions": 3, "deletions": 4, "lines": 7}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 34, "deletions": 35, "lines": 69}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 30, "deletions": 47, "lines": 77}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/MonoDelayElementTest.java", "insertions": 2, "deletions": 5, "lines": 7}, {"filePath": "reactor-core/src/test/java/reactor/core/scheduler/RejectedExecutionTest.java", "insertions": 132, "deletions": 105, "lines": 237}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": []}, {"spoonFilePath": "Flux.java", "spoonMethods": []}, {"spoonFilePath": "FluxBufferTimeOrSize.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.checkedError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.toString()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxOnBackpressureBufferTimeout.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.doComplete(org.reactivestreams.Subscriber)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.doError(org.reactivestreams.Subscriber,java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.doComplete(org.reactivestreams.Subscriber)", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.doError(org.reactivestreams.Subscriber,java.lang.Throwable)", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxSubscribeOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOn.subscribe(reactor.core.CoreSubscriber)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber.onComplete()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "FluxSubscribeOnValue.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValue.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar.request(long)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxWindowTimeOrSize.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxWindowTimeOrSize.WindowTimeoutSubscriber.subscribeAndCreateWindow()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxWindowTimeOrSize.WindowTimeoutSubscriber.timerStart()", "TOT": 7, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 2}]}, {"spoonFilePath": "MonoDelay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelay.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "MonoDelayElement.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onNext(java.lang.Object)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "MonoPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.schedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object,boolean)", "TOT": 11, "UPD": 3, "INS": 0, "MOV": 7, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onError(java.lang.Throwable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onComplete()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.run()", "TOT": 15, "UPD": 1, "INS": 4, "MOV": 6, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.schedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.cancel()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSubscribeOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.requestMore(long)", "TOT": 6, "UPD": 3, "INS": 0, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.request(long)", "TOT": 4, "UPD": 2, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 11, "UPD": 2, "INS": 2, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.subscribe(reactor.core.CoreSubscriber)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onComplete()", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}]}, {"spoonFilePath": "MonoSubscribeOnCallable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnCallable.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "MonoSubscribeOnValue.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnValue.subscribe(reactor.core.CoreSubscriber)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "MonoDelayElementTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelayElementTest.upstreamIsDelayedSource()", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 3}]}, {"spoonFilePath": "RejectedExecutionTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.publishOnFlatMap()", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn().1.hookOnSubscribe(org.reactivestreams.Subscription)", "TOT": 7, "UPD": 2, "INS": 0, "MOV": 5, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn().1.hookOnNext(java.lang.Long)", "TOT": 8, "UPD": 2, "INS": 0, "MOV": 6, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn().1.hookFinally(reactor.core.publisher.SignalType)", "TOT": 5, "UPD": 2, "INS": 0, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.flatMapSubscribeOn()", "TOT": 8, "UPD": 4, "INS": 0, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn()", "TOT": 27, "UPD": 5, "INS": 1, "MOV": 20, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.TestSub", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.publishOnFilter()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOnJust()", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn().1", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.RejectedExecutionTest.subscribeOn().1.hookOnError(java.lang.Throwable)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["18e8d67c200381867ce9b5f0a95f8be06b9b09ea", "a073c4d5f4b6c1a2d49e38d59a59dac406315f37"], "filteredCommitsReason": {"duplicated": 9, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 525.0, "deletions": 568.0, "lines": 1093.0, "gitFilesChange": 28}, "spoonStatsSummary": {"TOT": 133.0, "UPD": 15.0, "INS": 22.0, "MOV": 56.0, "DEL": 40.0, "spoonFilesChanged": 12, "spoonMethodsChanged": 39}, "statsSkippedReason": "", "changesInPackagesGIT": ["reactor-core/src/main/java/reactor/core/publisher", "reactor-core/src/main/java/reactor/core", "reactor-core/src/main/java/reactor/core/scheduler", "reactor-test/src/main/java/reactor/test/scheduler"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.requestMore(long)", "reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber.onComplete()", "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.doError(org.reactivestreams.Subscriber,java.lang.Throwable)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.checkedError(java.lang.Throwable)", "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.schedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.MonoDelay.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxWindowTimeOrSize.WindowTimeoutSubscriber.subscribeAndCreateWindow()", "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.doComplete(org.reactivestreams.Subscriber)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.MonoSubscribeOn.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.MonoDelayElement.DelayElementSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "reactor.core.publisher.FluxSubscribeOn.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onComplete()", "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onComplete()", "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.trySchedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.cancel()", "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.request(long)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.schedule(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object,boolean)", "reactor.core.publisher.FluxSubscribeOn.SubscribeOnSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxWindowTimeOrSize.WindowTimeoutSubscriber.timerStart()", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.run()", "reactor.core.publisher.MonoSubscribeOnValue.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.MonoSubscribeOn.SubscribeOnSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxSubscribeOnValue.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.doError(org.reactivestreams.Subscriber,java.lang.Throwable)", "reactor.core.publisher.FluxOnBackpressureBufferTimeout.BackpressureBufferTimeoutSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferTimeoutSubscriber.toString()", "reactor.core.publisher.MonoSubscribeOnCallable.subscribe(reactor.core.CoreSubscriber)", "reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar.request(long)", "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.doComplete(org.reactivestreams.Subscriber)", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber", "reactor.core.publisher.MonoPublishOn.PublishOnSubscriber.onNext(java.lang.Object)"]}, {"title": "subscribeOn(Schedulers.parallel()) doesn't execute in parallel when located right after a just()", "body": "I've noticed a different behaviour when you place a subscribeOn straigh after a just from when you put another operator in-between.\r\nFor example:\r\n```java\r\nCountDownLatch latch = new CountDownLatch(1);\r\n\r\nFlux<Integer> flux = Flux.range(0, 30);\r\nflux.flatMap(count -> Flux.just(count)\r\n     .subscribeOn(Schedulers.parallel())\r\n     .map(i -> highCpuProcess(i)))\r\n     .doAfterTerminate(latch::countDown)\r\n     .subscribe( m -> System.out.println(\"Subscriber received - \" + m + \" on thread: \" + Thread.currentThread().getName()));\r\n\r\nlatch.await();\r\n```\r\nThis always creates four threads but only uses one and never runs the processes in parallel. \r\n![singlethread](https://cloud.githubusercontent.com/assets/3987991/21726061/f9bcc4ae-d432-11e6-82dd-ac4400667202.png)\r\n\r\nOn the contrary, when you put an operator in the middle the four threads are used, I use log() in my example but it can be any operator:\r\n```java\r\nCountDownLatch latch = new CountDownLatch(1);\r\n\r\nFlux<Integer> flux = Flux.range(0, 30);\r\nflux.flatMap(count -> Flux.just(count)\r\n     .log()\r\n     .subscribeOn(Schedulers.parallel())\r\n     .map(i -> highCpuProcess(i)))\r\n     .doAfterTerminate(latch::countDown)\r\n     .subscribe( m -> System.out.println(\"Subscriber received - \" + m + \" on thread: \" + Thread.currentThread().getName()));\r\n\r\nlatch.await();\r\n```\r\n\r\nIn this last case, the four threads are used:\r\n![multithread](https://cloud.githubusercontent.com/assets/3987991/21726166/7545320a-d433-11e6-9ee8-e6d38fa6938d.png)\r\n", "url": "https://github.com/reactor/reactor-core/issues/342", "user": "antonio-marrero", "labels": ["type/bug"], "created": "2017-01-06 17:13:48", "closed": "2017-01-09 12:41:47", "commits": {"74abd03c3feef96fcf442c47fc909e5e10d57957": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "ee736255eca72c819d8b4d4f9790012d4f94cb7c": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 2.000277777777778, "commitsDetails": [{"commitHash": "74abd03c3feef96fcf442c47fc909e5e10d57957", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["4bd312ff361617c793fe16c7f994b26e9a5a989d"], "nameRev": "74abd03c3feef96fcf442c47fc909e5e10d57957 tags/v3.0.5.RELEASE~140", "commitMessage": "fix #342 Fix fusion request handling for SubscribeOnValue and add THREAD_BARRIER to flatMap/mergeSequential\n", "commitDateTime": "2017-01-09 12:41:15", "authoredDateTime": "2017-01-09 12:41:15", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxMergeSequential.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 2, "deletions": 5, "lines": 7}, {"filePath": "src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java", "insertions": 23, "deletions": 1, "lines": 24}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxFlatMap.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxFlatMap.FlatMapInner.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxMergeSequential.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeSequential.MergeSequentialInner.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxSubscribeOnValue.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar.requestFusion(int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty.requestFusion(int)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "FluxSubscribeOnValueTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValueTest.normal()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValueTest.slow(int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ee736255eca72c819d8b4d4f9790012d4f94cb7c", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["74abd03c3feef96fcf442c47fc909e5e10d57957"], "nameRev": "ee736255eca72c819d8b4d4f9790012d4f94cb7c tags/v3.0.5.RELEASE~139", "commitMessage": "polish test for #342\n", "commitDateTime": "2017-01-09 12:53:08", "authoredDateTime": "2017-01-09 12:53:08", "commitGitStats": [{"filePath": "src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java", "insertions": 20, "deletions": 0, "lines": 20}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxSubscribeOnValueTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValueTest.testSubscribeOnValueFusion()", "TOT": 6, "UPD": 2, "INS": 3, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValueTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValueTest.slow(int)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["74abd03c3feef96fcf442c47fc909e5e10d57957", "ee736255eca72c819d8b4d4f9790012d4f94cb7c"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 4, "deletions": 7, "lines": 11, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 9, "UPD": 1, "INS": 3, "MOV": 1, "DEL": 4, "spoonFilesChanged": 3, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty.requestFusion(int)", "reactor.core.publisher.FluxMergeSequential.MergeSequentialInner.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxFlatMap.FlatMapInner.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar.requestFusion(int)"]}, {"title": "Binary incompatiblilty for apps using library compiled against 3.0.3", "body": "You can use the sample here to reproduce the problem: https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/reactive-processor-kafka. First run it as it is (with reactor-core 3.0.1) and it will launch successfully (and fail to connect to Kafka, but that's OK). Then change the reactor version to 3.0.4 and then the app fails to start:\r\n\r\n```\r\nCaused by: java.lang.NoSuchMethodError: reactor.core.publisher.Flux.subscribe(Ljava/util/function/Consumer;)Lreactor/core/Cancellation;\r\n\tat org.springframework.cloud.stream.reactive.FluxToMessageChannelResultAdapter.adapt(FluxToMessageChannelResultAdapter.java:47)\r\n\tat org.springframework.cloud.stream.reactive.FluxToMessageChannelResultAdapter.adapt(FluxToMessageChannelResultAdapter.java:33)\r\n...\r\n```", "url": "https://github.com/reactor/reactor-core/issues/339", "user": "dsyer", "labels": ["status/declined", "type/bug", "warn/api-change"], "created": "2017-01-04 13:03:13", "closed": "2017-01-13 23:34:39", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "IllegalArgumentException when trying to zip an iterable of several FluxJust-s", "body": "```\r\n@Test\r\npublic void zipFluxJustIterable() {\r\n\tFlux<Integer> flux1 = Flux.just(1);\r\n\tFlux<Integer> flux2 = Flux.just(2);\r\n\tFlux<Tuple2> zipped = Flux.zip(Arrays.asList(flux1, flux2));\r\n\tStepVerifier.create(zipped)\r\n\t\t\t.expectNextCount(1)\r\n\t\t\t.expectComplete()\r\n\t\t\t.verify();\r\n}\r\n```\r\n\r\nThis test fails due to the IllegalArgumentException, thrown by a FluxZip::handleBoth.\r\n\r\nException is caused by two factors:\r\n- zipper function, used in a handleBoth method, is a Tuples::fromArray method, which can work only with arrays of length **1-7**\r\n- array of scalars, retrieved from FluxJust-s, is created initially with length of **8**\r\n\r\n", "url": "https://github.com/reactor/reactor-core/issues/338", "user": "kirmerzlikin", "labels": ["type/bug", "warn/api-change"], "created": "2017-01-04 12:29:02", "closed": "2017-01-06 11:32:17", "commits": {"b81dc6525ad7be5c42fc7b21261b6745f243455e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "239c64338ebf8427f76ad92c0d4b2e967cc4db96": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "cb19317c1dd89355317458b34ae065271a5a801c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "a5a8f3da7468e8503277ad085593a3e3fc49413a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "b81dc6525ad7be5c42fc7b21261b6745f243455e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "239c64338ebf8427f76ad92c0d4b2e967cc4db96", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "cb19317c1dd89355317458b34ae065271a5a801c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["1fed1e7a8fb77854820f607f8b5f425b2c0ab30b"], "nameRev": "cb19317c1dd89355317458b34ae065271a5a801c tags/v3.0.5.RELEASE~143", "commitMessage": "see #338 Fix Tuples.fromArray for size 0 and 8\n\nSize 8 to Tuple8 should have been acceptable but wasn't covered.\nSize 0 was rejected but with misleading message.\n\nAdded special message and shortcircuit for null or empty arrays.\nMade oversize error message more explicit.\n\nAdded tests to TupleTests for these different cases.\n", "commitDateTime": "2017-01-06 12:32:15", "authoredDateTime": "2017-01-04 17:32:11", "commitGitStats": [{"filePath": "src/main/java/reactor/util/function/Tuples.java", "insertions": 12, "deletions": 5, "lines": 17}, {"filePath": "src/test/java/reactor/util/function/TupleTests.java", "insertions": 112, "deletions": 0, "lines": 112}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Tuples.java", "spoonMethods": [{"spoonMethodName": "reactor.util.function.Tuples.fromArray(java.lang.Object[])", "TOT": 5, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "TupleTests.java", "spoonMethods": [{"spoonMethodName": "reactor.util.function.TupleTests.fromArrayRejects0()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple2CreatedFromArray1()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple2CreatedFromArray2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple3CreatedFromArray3()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple4CreatedFromArray4()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple5CreatedFromArray5()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple6CreatedFromArray6()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple7CreatedFromArray7()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.tuple8CreatedFromArray8()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.util.function.TupleTests.fromArrayRejects9()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "a5a8f3da7468e8503277ad085593a3e3fc49413a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["cb19317c1dd89355317458b34ae065271a5a801c"], "nameRev": "a5a8f3da7468e8503277ad085593a3e3fc49413a tags/v3.0.5.RELEASE~142", "commitMessage": "fix #338 Deprecate zip(Iterable), fix bug with size < 8\n\nFlux.zip(Iterable) is a clunky API: as it combines to Tuples, it limits\nthe number of acceptable sources to 1-8. Furthermore, the Tuple2 return\ntype means that you either need to know the number of sources in order\nto cast to the relevant TupleN (in which case you should instead use\nzip(source1, source2, ...)) OR you can only use the tuple as Iterable.\n\nIn all cases, combining to a List would be more relevant, and usage of\na custom combinator or of the fixed sources alternatives is to be\npreferred from now on.\n\nUsing a custom combinator like Arrays::asList is susceptible to a bug\nif the number of sources is below 8 though: the scalars Object array is\ninitialized to a length of 8 in any case, and grows beyond if needed,\nbut it is not trimmed in FluxZip#handleIterableMode if we have less than\n8 sources. This is now fixed and tested.\n", "commitDateTime": "2017-01-06 12:32:15", "authoredDateTime": "2017-01-04 17:41:25", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/main/java/reactor/core/publisher/FluxZip.java", "insertions": 5, "deletions": 1, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 56, "deletions": 0, "lines": 56}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.zip(java.lang.Iterable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxZip.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxZip.handleIterableMode(org.reactivestreams.Subscriber,java.lang.Iterable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxZipTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxZipTest.iterableWithCombinatorHasCorrectLength()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxZipTest.iterableWithoutCombinatorReturnsCorrectTuple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxZipTest.publisherOfPublishersUsesCorrectTuple()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["cb19317c1dd89355317458b34ae065271a5a801c", "a5a8f3da7468e8503277ad085593a3e3fc49413a"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 32.0, "deletions": 6.0, "lines": 38.0, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 7.0, "UPD": 1.0, "INS": 4.0, "MOV": 1.0, "DEL": 1.0, "spoonFilesChanged": 3, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/util/function"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxZip.handleIterableMode(org.reactivestreams.Subscriber,java.lang.Iterable)", "reactor.util.function.Tuples.fromArray(java.lang.Object[])", "reactor.core.publisher.Flux.zip(java.lang.Iterable)"]}, {"title": "Hung WorkQueueProcessor threads after shutdown/completion", "body": "I get hung threads with the following stack even once WorkQueueProcessor is shutdown and/or completed.  I noticed that only some thread hang like this, but if i cancel all subscribers before shutdown then **all** threads hang, so it maybe that the hung thread are just the ones that have been cancelled.\r\n\r\nThis is probably related to #335 \r\n\r\n```\r\nsourceFailed.event-loop.01 [WAITING]\r\njava.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await() AbstractQueuedSynchronizer.java:2039\r\nreactor.util.concurrent.WaitStrategy$LiteBlocking.waitFor(long, LongSupplier, Runnable) WaitStrategy.java:374\r\nreactor.util.concurrent.WaitStrategy$PhasedOff.waitFor(long, LongSupplier, Runnable) WaitStrategy.java:439\r\nreactor.core.publisher.RingBuffer$Reader.waitFor(long) RingBuffer.java:491\r\nreactor.core.publisher.WorkQueueProcessor$QueueSubscriberLoop.run() WorkQueueProcessor.java:840\r\njava.lang.Thread.run() Thread.java:745\r\n```", "url": "https://github.com/reactor/reactor-core/issues/336", "user": "dfeist", "labels": ["type/bug"], "created": "2017-01-04 10:05:56", "closed": "2017-01-10 20:49:14", "commits": {"c753e0614c30e48f725f2c2af9af3fcd1be86466": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "c753e0614c30e48f725f2c2af9af3fcd1be86466", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["29f78fb40c33e62a1bc261d2bd0eec8082ed926b"], "nameRev": "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8 tags/v3.0.5.RELEASE~137", "commitMessage": "fix #335 #336 Improve WorkQueueProcessor retry handling (#353)\n\n", "commitDateTime": "2017-01-10 16:36:02", "authoredDateTime": "2017-01-10 16:36:02", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 67, "deletions": 100, "lines": 167}, {"filePath": "src/test/java/reactor/core/publisher/FluxIntervalTest.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 149, "deletions": 23, "lines": 172}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 55, "deletions": 35, "lines": 90}, {"filePath": "src/test/java/reactor/core/publisher/loop/FluxPublishOnLoop.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 0, "deletions": 143, "lines": 143}, {"filePath": "src/test/resources/logback.xml", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "WorkQueueProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor", "TOT": 8, "UPD": 2, "INS": 1, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.reschedule(reactor.core.publisher.Slot)", "TOT": 11, "UPD": 2, "INS": 2, "MOV": 3, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.retryBuffer()", "TOT": 4, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.getPending()", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.replay(boolean)", "TOT": 46, "UPD": 12, "INS": 9, "MOV": 17, "DEL": 8}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.run()", "TOT": 24, "UPD": 1, "INS": 6, "MOV": 12, "DEL": 5}]}, {"spoonFilePath": "FluxIntervalTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxIntervalTest.scenario2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxIntervalTest.normal2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.mapNotifiesOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.mapManyFlushesAllValuesThoroughly()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TopicProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.TopicProcessorTest.drainTest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.drainTest()", "TOT": 23, "UPD": 10, "INS": 0, "MOV": 11, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.simpleTest()", "TOT": 8, "UPD": 2, "INS": 2, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.cancelDoesNotHang()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.completeDoesNotHang()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnLoop.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.loop.FluxPublishOnLoop.mapNotifiesOnceConsistent()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.loop.FluxPublishOnLoop.mapManyFlushesAllValuesConsistently()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.shouldNotFlushStreamOnTimeoutPrematurely()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThrowWithoutOnErrorShowsUpInSchedulerHandler()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testBufferUntilSubscribe()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapManyFlushesAllValuesThoroughly()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapManyFlushesAllValuesConsistently()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapNotifiesOnceConsistent()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapNotifiesOnce()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "WorkQueueProcessor uses new thread per subscriber but does not free them on cancellation", "body": "When using WorkQueueProcessor with retry(), cancellation removes subscriber but does not free thread, while re-subscription use a new work thread.  This is especially an issue when used with retry() as a the number of threads used by WorkQueueProcessor, even for a single subscriber just keeps growing.\r\n\r\nPotentially related to this is the fact that in I'm struggling to shutdown WorkQueueProcessor without hung threads. #336 ", "url": "https://github.com/reactor/reactor-core/issues/335", "user": "dfeist", "labels": ["type/bug"], "created": "2017-01-03 19:35:27", "closed": "2017-01-10 16:36:04", "commits": {"c753e0614c30e48f725f2c2af9af3fcd1be86466": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 6.000277777777778, "commitsDetails": [{"commitHash": "c753e0614c30e48f725f2c2af9af3fcd1be86466", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["29f78fb40c33e62a1bc261d2bd0eec8082ed926b"], "nameRev": "6d9dddb76fb41dcd188eb0329b5db1063c95fbf8 tags/v3.0.5.RELEASE~137", "commitMessage": "fix #335 #336 Improve WorkQueueProcessor retry handling (#353)\n\n", "commitDateTime": "2017-01-10 16:36:02", "authoredDateTime": "2017-01-10 16:36:02", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/WorkQueueProcessor.java", "insertions": 67, "deletions": 100, "lines": 167}, {"filePath": "src/test/java/reactor/core/publisher/FluxIntervalTest.java", "insertions": 14, "deletions": 0, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 149, "deletions": 23, "lines": 172}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 55, "deletions": 35, "lines": 90}, {"filePath": "src/test/java/reactor/core/publisher/loop/FluxPublishOnLoop.java", "insertions": 15, "deletions": 0, "lines": 15}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 0, "deletions": 143, "lines": 143}, {"filePath": "src/test/resources/logback.xml", "insertions": 2, "deletions": 0, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "WorkQueueProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor", "TOT": 8, "UPD": 2, "INS": 1, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.reschedule(reactor.core.publisher.Slot)", "TOT": 11, "UPD": 2, "INS": 2, "MOV": 3, "DEL": 4}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.retryBuffer()", "TOT": 4, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.getPending()", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.replay(boolean)", "TOT": 46, "UPD": 12, "INS": 9, "MOV": 17, "DEL": 8}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessor.QueueSubscriberLoop.run()", "TOT": 24, "UPD": 1, "INS": 6, "MOV": 12, "DEL": 5}]}, {"spoonFilePath": "FluxIntervalTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxIntervalTest.scenario2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxIntervalTest.normal2()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.mapNotifiesOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.mapManyFlushesAllValuesThoroughly()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "TopicProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.TopicProcessorTest.drainTest()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.drainTest()", "TOT": 23, "UPD": 10, "INS": 0, "MOV": 11, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.simpleTest()", "TOT": 8, "UPD": 2, "INS": 2, "MOV": 4, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.cancelDoesNotHang()", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.WorkQueueProcessorTest.completeDoesNotHang()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnLoop.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.loop.FluxPublishOnLoop.mapNotifiesOnceConsistent()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.loop.FluxPublishOnLoop.mapManyFlushesAllValuesConsistently()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.shouldNotFlushStreamOnTimeoutPrematurely()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThrowWithoutOnErrorShowsUpInSchedulerHandler()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testBufferUntilSubscribe()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapManyFlushesAllValuesThoroughly()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapManyFlushesAllValuesConsistently()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapNotifiesOnceConsistent()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.mapNotifiesOnce()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Mono.whenDelayError with 3 parameters are only taking the last 2 parameter", "body": "The issue can be reproduced with the following test\r\n\r\n    Mono<Tuple3<Integer, String, Long>> mono = Mono.whenDelayError(Mono.just(1), Mono.just(\"one), Mono.just(1L));\r\n    StepVerifier.create(mono)\r\n        .expectNextCount(1)\r\n        .verifyComplete();\r\n\r\nThe issue lies in Mono.java lines 864, where it only takes p2 and p3.\r\nI'm using version 3.0.4.RELEASE", "url": "https://github.com/reactor/reactor-core/issues/333", "user": "sinwe", "labels": ["type/bug"], "created": "2017-01-03 16:58:28", "closed": "2017-01-05 08:46:16", "commits": {"1fed1e7a8fb77854820f607f8b5f425b2c0ab30b": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "1fed1e7a8fb77854820f607f8b5f425b2c0ab30b", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["731707c8a7734ff2b6063a3f3eefee0f88b318de"], "nameRev": "1fed1e7a8fb77854820f607f8b5f425b2c0ab30b tags/v3.0.5.RELEASE~144", "commitMessage": "fix #333 Mono.whenDelayError with 3 params only uses last 2\n\n", "commitDateTime": "2017-01-05 09:46:15", "authoredDateTime": "2017-01-05 15:46:15", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/groovy/reactor/core/MonoSpec.groovy", "insertions": 17, "deletions": 0, "lines": 17}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1fed1e7a8fb77854820f607f8b5f425b2c0ab30b"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)"]}, {"title": "Mono.sequenceEquals double inner subscription, fails to cancel right part", "body": "```\r\n\t@Test\r\n\tpublic void cancelCancelsBothSources() {\r\n\t\tAtomicReference<Subscription> sub1 = new AtomicReference<>();\r\n\t\tAtomicReference<Subscription> sub2 = new AtomicReference<>();\r\n\t\tAtomicBoolean cancel1 = new AtomicBoolean();\r\n\t\tAtomicBoolean cancel2 = new AtomicBoolean();\r\n\r\n\t\tFlux<Integer> source1 = Flux.range(1, 5)\r\n\t\t                            .doOnSubscribe(sub1::set)\r\n\t\t                            .doOnCancel(() -> cancel1.set(true))\r\n\t\t                            .hide();\r\n\t\tFlux<Integer> source2 = Flux.just(1, 2, 3, 7, 8)\r\n\t\t                            .doOnSubscribe(sub2::set)\r\n\t\t                            .doOnCancel(() -> cancel2.set(true))\r\n\t\t                            .hide();\r\n\r\n\t\tMono.sequenceEqual(source1, source2)\r\n\t\t    .subscribe(System.out::println, Throwable::printStackTrace, null,\r\n\t\t\t\t    Subscription::cancel);\r\n\r\n\t\tAssert.assertNotNull(\"left not subscribed\", sub1.get());\r\n\t\tAssert.assertTrue(\"left not cancelled\", cancel1.get());\r\n\t\tAssert.assertNotNull(\"right not subscribed\", sub2.get());\r\n\t\tAssert.assertTrue(\"right not cancelled\", cancel2.get());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void subscribeInnerOnce() {\r\n\t\tLongAdder innerSub1 = new LongAdder();\r\n\t\tLongAdder innerSub2 = new LongAdder();\r\n\r\n\t\tFlux<Integer> source1 = Flux.range(1, 5)\r\n\t\t                            .doOnSubscribe((t) -> innerSub1.increment());\r\n\t\tFlux<Integer> source2 = Flux.just(1, 2, 3, 7, 8)\r\n\t\t                            .doOnSubscribe((t) -> innerSub2.increment());\r\n\r\n\t\tMono.sequenceEqual(source1, source2)\r\n\t        .subscribe();\r\n\r\n\t\tAssert.assertEquals(\"left has been subscribed multiple times\", 1, innerSub1.intValue());\r\n\t\tAssert.assertEquals(\"right has been subscribed multiple times\", 1, innerSub2.intValue());\r\n\t}\r\n```", "url": "https://github.com/reactor/reactor-core/issues/329", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-01-02 14:19:55", "closed": "2017-01-03 14:14:46", "commits": {"68fb1d994fd82e437a8e63b1d9c5703663823ea0": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0f7cf11a20489ad9d6e432c1b657f6823a2f3d32": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "68fb1d994fd82e437a8e63b1d9c5703663823ea0", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0f7cf11a20489ad9d6e432c1b657f6823a2f3d32", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0dea8075b1f9b75f0466a369e3175f6b58f2340a"], "nameRev": "0f7cf11a20489ad9d6e432c1b657f6823a2f3d32 tags/v3.0.5.RELEASE~151", "commitMessage": "fix #329 Fix sequenceEqual 1/2 cancel and 2x subscribe\n\nThis commit fixes three bugs with sequenceEqual:\n\n - a cancellation would only cancel the first inner subscriber\n - a drain-cancellation would only clear the inner queues and not cancel\n the inner subscribers\n - in certain subscription scenarios where a request comes in first, the\n inner subscribers are subscribed to twice\n\n It adds the relevant unit tests for these three fixes.\n", "commitDateTime": "2017-01-03 15:14:44", "authoredDateTime": "2017-01-02 15:41:06", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoSequenceEqual.java", "insertions": 26, "deletions": 24, "lines": 50}, {"filePath": "src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java", "insertions": 85, "deletions": 0, "lines": 85}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoSequenceEqual.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel()", "TOT": 15, "UPD": 1, "INS": 1, "MOV": 11, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel(java.util.Queue,java.util.Queue)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 5, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel(reactor.core.publisher.MonoSequenceEqual$EqualSubscriber,java.util.Queue,reactor.core.publisher.MonoSequenceEqual$EqualSubscriber,java.util.Queue)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancelInner(reactor.core.publisher.MonoSequenceEqual$EqualSubscriber)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.subscribe()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.drain()", "TOT": 10, "UPD": 0, "INS": 10, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSequenceEqualTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.differenceCancelsBothSources()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.cancelCancelsBothSources()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.cancelCancelsBothSourcesIncludingNever()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.subscribeInnerOnce()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0f7cf11a20489ad9d6e432c1b657f6823a2f3d32"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 26.0, "deletions": 24.0, "lines": 50.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 37.0, "UPD": 1.0, "INS": 15.0, "MOV": 18.0, "DEL": 3.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel(java.util.Queue,java.util.Queue)", "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.subscribe()", "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel()", "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancelInner(reactor.core.publisher.MonoSequenceEqual$EqualSubscriber)", "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.cancel(reactor.core.publisher.MonoSequenceEqual$EqualSubscriber,java.util.Queue,reactor.core.publisher.MonoSequenceEqual$EqualSubscriber,java.util.Queue)", "reactor.core.publisher.MonoSequenceEqual.EqualCoordinator.drain()"]}, {"title": "Mono.sequenceEquals doesn't signal subscription", "body": "As made obvious by this sample test:\r\n\r\n```\r\nMono<Boolean> mono = Mono.sequenceEqual(Mono.just(1), Mono.just(1));\r\n\r\nStepVerifier.create(mono)\r\n    .expectNext(true)\r\n    .expectComplete()\r\n    .verify();\r\n```\r\nthrows\r\n```\r\n- java.lang.Throwable: Multiple exceptions\r\n- java.lang.AssertionError: expectation \"defaultOnSubscribe\" failed (expected: onSubscribe(); actual: onNext(true))\r\n- java.lang.AssertionError: expectation \"expectNext(true)\" failed (expected: onNext(true); actual: onComplete())\r\n...\r\n```", "url": "https://github.com/reactor/reactor-core/issues/328", "user": "simonbasle", "labels": ["type/bug"], "created": "2017-01-02 10:26:44", "closed": "2017-01-03 14:14:46", "commits": {"049539338fcb18f2177f72da87ac18f839053403": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0dea8075b1f9b75f0466a369e3175f6b58f2340a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "049539338fcb18f2177f72da87ac18f839053403", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0dea8075b1f9b75f0466a369e3175f6b58f2340a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["246525bc18914019d53c2b372f9d74db4c374c26"], "nameRev": "0dea8075b1f9b75f0466a369e3175f6b58f2340a tags/v3.0.5.RELEASE~152", "commitMessage": "fix #328 sequenceEqual propagate subscription signal, add tests\n\nMono.sequenceEqual would not propagate the onSubscribe signal to its\nsubscriber before this fix. Added unit tests for sequenceEqual.\n", "commitDateTime": "2017-01-03 15:14:44", "authoredDateTime": "2017-01-02 15:27:43", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoSequenceEqual.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java", "insertions": 116, "deletions": 1, "lines": 117}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoSequenceEqual.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSequenceEqual.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSequenceEqualTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.normal()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceLongerLeft()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceLongerRight()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceErrorsLeft()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceErrorsRight()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceErrorsBothPropagatesLeftError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceEmptyLeft()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceEmptyRight()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.sequenceEmptyBoth()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.equalPredicateFailure()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.largeSequence()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSequenceEqualTest.syncFusedCrash()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0dea8075b1f9b75f0466a369e3175f6b58f2340a"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1.0, "deletions": 0.0, "lines": 1.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoSequenceEqual.subscribe(org.reactivestreams.Subscriber)"]}, {"title": "Javadoc jar is released with BUILD-SNAPSHOT version", "body": "See the `3.0.4` javadoc jar, eg [here](http://repo.spring.io/release/io/projectreactor/reactor-core/3.0.4.RELEASE/reactor-core-3.0.4.RELEASE-javadoc.jar!/index.html)", "url": "https://github.com/reactor/reactor-core/issues/327", "user": "simonbasle", "labels": ["type/bug", "type/documentation"], "created": "2016-12-26 13:59:33", "closed": "2017-01-04 11:00:51", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "FluxBufferTimeOrSize buffer can be concurrently modified", "body": "This for example causes the `WorkQueueProcessorTest#highRate` to fail:\r\n\r\n```\r\n@Override\r\npublic void onNext(List<String> strings) {\r\n  int size = strings.size();\r\n  counter += size;\r\n  if (strings.contains(s)) {\r\n    synchronized (s) {\r\n      //logger.debug(\"Synchronizer!\");\r\n      s.notifyAll();\r\n    }\r\n  } //added to showcase the bug:\r\n  else if (size > 1) {\r\n    System.out.println(strings.contains(s));\r\n  }\r\n}\r\n```\r\nThe bug manifests itself in the else branch above, where the sysout would print `true` (contradicting the if/else condition).", "url": "https://github.com/reactor/reactor-core/issues/320", "user": "simonbasle", "labels": ["type/bug"], "created": "2016-12-22 15:28:36", "closed": "2016-12-22 16:16:51", "commits": {"18be0793a5f56e549fa2b1283c273d7e41799698": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ac4e9c7275f778dad23ca1a5b45b097495ec0ff4": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "18be0793a5f56e549fa2b1283c273d7e41799698", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ac4e9c7275f778dad23ca1a5b45b097495ec0ff4", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["7b53aed556f7cc79f346c497eaace1a7fd7776f0"], "nameRev": "ac4e9c7275f778dad23ca1a5b45b097495ec0ff4 tags/v3.0.4.RELEASE~14", "commitMessage": "fix #320 FluxBufferTimeOrSize concurrently modified buffer\n", "commitDateTime": "2016-12-22 17:16:50", "authoredDateTime": "2016-12-22 16:30:06", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 22, "deletions": 11, "lines": 33}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxBufferTimeOrSize.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.checkedError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.nextCallback(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.flushCallback(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["ac4e9c7275f778dad23ca1a5b45b097495ec0ff4"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 22.0, "deletions": 11.0, "lines": 33.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 0.0, "INS": 6.0, "MOV": 7.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 3}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.flushCallback(java.lang.Object)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.checkedError(java.lang.Throwable)", "reactor.core.publisher.FluxBufferTimeOrSize.BufferAction.nextCallback(java.lang.Object)"]}, {"title": "SingleTimedScheduler doesn't reject immediately on shutdown", "body": "", "url": "https://github.com/reactor/reactor-core/issues/311", "user": "simonbasle", "labels": ["type/bug"], "created": "2016-12-15 16:42:50", "closed": "2017-03-13 10:45:07", "commits": {}, "ttf": 87.00027777777778, "commitsDetails": []}, {"title": "BlockingSink drops events on FAILED/CANCELLED emission rather than throwing exception.", "body": "", "url": "https://github.com/reactor/reactor-core/issues/304", "user": "dfeist", "labels": ["type/bug", "type/enhancement"], "created": "2016-12-14 14:57:39", "closed": "2017-04-13 12:46:37", "commits": {"88716515553b9e731184a0e28bb7b41b36077c4b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "55df9e87e5dabfc60147463bef18416e5f2a1e13": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6d6f5f814750dc4506ac8f24b95132be136ed8b7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "692813df8d3c4f31a9b9bb46d36e18d76058ba9a": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "6129efc3a21fa4a2d0758a0fcf063c10ad7792fb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0be54679a14c031ad380299a90f18710d7c96098": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "c66944ec39da8374dde0ecf41adbe197649bb264": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 119.00027777777778, "commitsDetails": [{"commitHash": "88716515553b9e731184a0e28bb7b41b36077c4b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "55df9e87e5dabfc60147463bef18416e5f2a1e13", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6d6f5f814750dc4506ac8f24b95132be136ed8b7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "692813df8d3c4f31a9b9bb46d36e18d76058ba9a", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["d0cea73e3c637ae61a614d826221677499a8ccb0"], "nameRev": "692813df8d3c4f31a9b9bb46d36e18d76058ba9a tags/v3.1.0.M1~29", "commitMessage": "see #525 Deep Processor rework\n\nThis commit is a big rework of FluxProcessors in general, and of\nEmitterProcessor in particular. It introduces breaking changes.\n\n[API changes]\n* `BlockingSink` has been removed\n* in `FluxProcessor`: `#connect`, `#connectSink` have been removed\n* `FluxProcessor` now exposes a `sink()` instead, with default blocking\n  behavior and as-needed serialization\n* `FluxSink#next` now returns the FluxSink for fluent chaining\n* Removed `maxConcurrency` concept from `EmitterProcessor`\n\n[Behavior changes]\n* `EmitterProcessor` now supports fusion\n* `EmitterProcessor` must be subscribed before onSubscribed in order\n  not to lose any event\n* Simply subscribing to an `EmitterProcessor` is now equivalent to\n  connecting to a `ConnectableFlux`\n\n[Implementation changes]\n* `FluxPublish` has been tweaked to remove synchronization\n* Internal classes from ReplayProcessor have been moved to `FluxReplay`\n* `EmitterProcessor` has been entirely reworked to internally align with\n  `FluxPublish` (fusion support, no more ringbuffer...)\n\nFixes #510\nFixes #304\nFixes #248\n\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:46:35", "authoredDateTime": "2017-04-10 19:19:53", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BlockingSink.java", "insertions": 0, "deletions": 455, "lines": 455}, {"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 8, "deletions": 6, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 294, "deletions": 433, "lines": 727}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 11, "deletions": 15, "lines": 26}, {"filePath": "src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 15, "deletions": 21, "lines": 36}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 62, "deletions": 74, "lines": 136}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 102, "deletions": 98, "lines": 200}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 935, "deletions": 27, "lines": 962}, {"filePath": "src/main/java/reactor/core/publisher/FluxSink.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 29, "deletions": 954, "lines": 983}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 0, "deletions": 5, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 35, "deletions": 45, "lines": 80}, {"filePath": "src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "insertions": 3, "deletions": 5, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 0, "deletions": 6, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxProcessorTest.java", "insertions": 12, "deletions": 33, "lines": 45}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 1, "deletions": 5, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ReplayProcessorTest.java", "insertions": 2, "deletions": 6, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 9, "deletions": 12, "lines": 21}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java", "insertions": 26, "deletions": 32, "lines": 58}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 5, "deletions": 15, "lines": 20}, {"filePath": "src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java", "insertions": 1, "deletions": 9, "lines": 10}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}, {"commitHash": "6129efc3a21fa4a2d0758a0fcf063c10ad7792fb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0be54679a14c031ad380299a90f18710d7c96098", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "c66944ec39da8374dde0ecf41adbe197649bb264", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["bf3bc3dc1896cfb473994d851c31a483b56163d9"], "nameRev": "c66944ec39da8374dde0ecf41adbe197649bb264 tags/v3.0.7.RELEASE~11", "commitMessage": "Prepare migration path for deep Processor rework in #525\n\nThis commit prepares for breaking Processor API changes in 3.1.0 by\ndeprecating a number of methods around processors and sinks.\n\n[Added API]\n* `FluxProcessor` now exposes a `sink()` method, with default blocking\n  behavior and as-needed serialization\n\n[API deprecations]\nThe following APIs have been deprecated and will be removed in 3.1.0:\n* `BlockingSink` has been deprecated\n* in `FluxProcessor`: `#connect`, `#connectSink` have been deprecated\n  (use `#sink` instead to migrate to the new behavior before 3.1.0)\n* `maxConcurrency` concept from `EmitterProcessor` has been deprecated\n\nAdapted from PR #525 (commit 692813df8d3c4f31a9b9bb46d36e18d76058ba9a)\n\nSee #510, #304 and #248\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:50:11", "authoredDateTime": "2017-04-13 12:11:31", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/BlockingSink.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 44, "deletions": 20, "lines": 64}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 20, "deletions": 3, "lines": 23}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 87, "deletions": 40, "lines": 127}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 1, "deletions": 0, "lines": 1}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "BlockingSink.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.BlockingSink", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "DelegateProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.DelegateProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor.create(int,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.create(int,int,boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.upstream()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.getPending()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.isSerialized()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.EventLoopContext", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxProcessor.isSerialized()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.sink()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connectSink()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.connectSink(boolean)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.getCapacity()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.isStarted()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.downstreams()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.serialize()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.dispose()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.isTerminated()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxProcessor.downstreamCount()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ReplayProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.ReplayProcessor.getBufferSize()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.ReplayProcessor.connect()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "UnicastProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.UnicastProcessor.isStarted()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "EmitterProcessorTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessorTest.failTooMuchSubscribers()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["e6b50b8b3b5077df892936c4319d42a63911eecf"], "nameRev": "f1f74b4693d79f86f38f77aa1d807cd47dc6aa0c tags/v3.0.7.RELEASE~9", "commitMessage": "Backport some Processor changes from #525\n\nThis commit additionally prepares for Processor behavioral changes in\n3.1.0 by implementing new behaviors of `EmitterProcessor`, in order to\nhelp with the migration path.\n\n[Behavior changes]\n* `EmitterProcessor` now supports fusion\n* `EmitterProcessor` must be subscribed before onSubscribed in order not\n  to lose any event\n* Simply subscribing to an `EmitterProcessor` is now equivalent to\n  connecting to a `ConnectableFlux`\n\n[Implementation changes]\n* `FluxPublish` has been tweaked to remove synchronization\n* Internal classes from ReplayProcessor have been moved to `FluxReplay`\n* `EmitterProcessor` has been entirely reworked to internally align with\n  `FluxPublish` (fusion support, no more ringbuffer...)\n\nAdapted from PR #525 (commit 692813df8d3c4f31a9b9bb46d36e18d76058ba9a)\n\nSee #510, #304 and #248\nSee also documentation issues #452 and #469\n", "commitDateTime": "2017-04-13 14:50:11", "authoredDateTime": "2017-04-13 12:20:48", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/DelegateProcessor.java", "insertions": 8, "deletions": 0, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 277, "deletions": 383, "lines": 660}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxProcessor.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 102, "deletions": 97, "lines": 199}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 935, "deletions": 27, "lines": 962}, {"filePath": "src/main/java/reactor/core/publisher/ReplayProcessor.java", "insertions": 29, "deletions": 938, "lines": 967}, {"filePath": "src/test/java/reactor/core/publisher/EmitterProcessorTest.java", "insertions": 37, "deletions": 40, "lines": 77}, {"filePath": "src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "insertions": 3, "deletions": 5, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxBufferStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxFlatMapTest.java", "insertions": 0, "deletions": 6, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxProcessorTest.java", "insertions": 12, "deletions": 33, "lines": 45}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 1, "deletions": 4, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 1, "deletions": 3, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 1, "deletions": 5, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxWindowStartEndTest.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/FluxZipTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ReplayProcessorTest.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 6, "deletions": 8, "lines": 14}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 9, "deletions": 12, "lines": 21}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 2, "deletions": 7, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java", "insertions": 26, "deletions": 32, "lines": 58}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 5, "deletions": 15, "lines": 20}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 5, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 3, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "flatMapSequential is broken with more than `prefetch` source elements", "body": "The logic in creating the bounded queue for inner subscribers is inverted and thus takes the minimum of `maxConcurrency` and `prefetch`, undersizing the queue.\r\n\r\nUnfortunately, the queue offering of new subscribers isn't checked, and thus as soon as there are more than `prefetch` subscribers, the excess is silently discarded :(\r\n\r\n**Workaround**: Use the same value for prefetch and maxConcurrency: `.flatMapSequential(v -> ..., CONCURRENCY, CONCURRENCY)`.\r\n\r\n**Fix**: Fix the queue sizing logic and add a sanity check when doing the eager inner subscribing.", "url": "https://github.com/reactor/reactor-core/issues/301", "user": "simonbasle", "labels": ["type/bug"], "created": "2016-12-14 10:55:38", "closed": "2016-12-14 12:25:17", "commits": {"c23ee2b11694856aa0bae616d97a165307cdff7e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "26d57e32eded9816afbb90087a1e4446b3c8d362": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "c23ee2b11694856aa0bae616d97a165307cdff7e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "26d57e32eded9816afbb90087a1e4446b3c8d362", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["5e8f1b33f7f3b84217623a64bc7d5da42c6d052b"], "nameRev": "26d57e32eded9816afbb90087a1e4446b3c8d362 tags/v3.0.4.RELEASE~31", "commitMessage": "fix #301 flatMapSequential broken with more than prefetch src elements\n\nThe logic in creating the bounded queue for inner subscribers is\ninverted and thus takes the minimum of maxConcurrency and prefetch,\nundersizing the queue.\n\nUnfortunately, the queue offering of new subscribers isn't checked, and\nthus as soon as there are more than prefetch subscribers, the excess is\nsilently discarded :(\n\nThis commit fixes the situation by using the correct \"max\" logic for\nqueue sizing.\n\nAdditionally it adds a sanity check when doing the eager inner\nsubscribe, and allow testing of that logic by passing a custom queue\nsupplier.\n\nReworded javadoc to highlight the difference with concat/concatMap and\nmerge/flatMap.\n", "commitDateTime": "2016-12-14 13:25:17", "authoredDateTime": "2016-12-14 12:04:55", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 30, "deletions": 27, "lines": 57}, {"filePath": "src/main/java/reactor/core/publisher/FluxMergeSequential.java", "insertions": 31, "deletions": 9, "lines": 40}, {"filePath": "src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java", "insertions": 53, "deletions": 7, "lines": 60}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": []}, {"spoonFilePath": "FluxMergeSequential.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeSequential.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequential.MergeSequentialMain", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequential", "TOT": 6, "UPD": 0, "INS": 4, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequential.MergeSequentialMain.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxMergeSequentialTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.MaxConcurrencyAndPrefetch()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.longEager()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.mergeSequentialLargeUnorderedEach100()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.mergeSequentialLargeBadQueueSize()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxMergeSequentialTest.longEager().2.apply(java.lang.Integer)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["26d57e32eded9816afbb90087a1e4446b3c8d362"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 61.0, "deletions": 36.0, "lines": 97.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 15.0, "UPD": 2.0, "INS": 7.0, "MOV": 4.0, "DEL": 2.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxMergeSequential.MergeSequentialMain.onNext(java.lang.Object)", "reactor.core.publisher.FluxMergeSequential.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.FluxMergeSequential", "reactor.core.publisher.FluxMergeSequential.MergeSequentialMain"]}, {"title": "Poor handling of RejectedExecutionException during processing", "body": "If an Executor throws a `RejectedExecutionException` for some reason during processing of a data signal it is not handled resulting hung requests or loss of signals.  This appears to be an issue with both ExecutorScheduler and ExecutorServiceScheduler.\r\n\r\nI understand that the expected behaviour is potentially questionable because passing a RejectedExecutionException downstream in a way violates the expectation that publishOn always signals on the scheduler.  *But,* I'd argue that a more pragmatic solution is needed here to avoid loss of signals, and `1.4 If a Publisher fails it MUST signal an onError.` should be respected so that if `FluxPublishOn` (which is a `Publisher`) fails, due to an issue with its scheduler, then it must signal this error downstream.  Also, for practical reasons such as message loss and hung subscribers, I think respecting this is more important than violating the expectation regarding the thread it's signalling on.\r\n\r\nTo make things clearer, it may make sense to signal a specific Reactor exception when this happens with the RejectedExecutionException as its cause.\r\n\r\n```\r\nAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\r\nMono.just(1).publishOn(fromExecutor(executor)).doOnNext(s -> {\r\n\ttry {\r\n\t\tlatch.await();\r\n\t} catch (InterruptedException e) {\r\n\t\tthrow Exceptions.propagate(e);\r\n\t}\r\n}).publishOn(fromExecutor(executor)).subscribe(assertSubscriber);\r\n\r\nexecutor.shutdownNow();\r\n\r\nassertSubscriber\r\n\t\t.await()\r\n\t\t.assertError(RejectedExecutionException.class)\r\n\t\t.assertNotComplete();\r\n```\r\n\r\nIn this example, when the executor is shutdown the `onNext` exits throwing an `InterruptedException` which is signalled downstream.  When the second `publishOn` attempts to schedule the onError signal, a `RejectedExecutionException` is thrown but this is not handled in any way and the `assertSubscriber.await()` just hangs as neither error/complete signal ever arrives.", "url": "https://github.com/reactor/reactor-core/issues/275", "user": "dfeist", "labels": ["status/need-decision", "type/bug", "type/enhancement"], "created": "2016-11-28 00:21:16", "closed": "2016-12-13 12:38:55", "commits": {"c1ffe0d3f45758be4898df6ce16a8f2f2d9ef1af": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "500c731c7bb0d2ca8d57fef043765476ee83f7f8": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "c37f67bb9fc7e773d14360388d2229686f215c2c": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "c1ffe0d3f45758be4898df6ce16a8f2f2d9ef1af", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["7e956f12717cb799761dc878cf48281887074ea3"], "nameRev": "c1ffe0d3f45758be4898df6ce16a8f2f2d9ef1af tags/v3.0.4.RELEASE~40", "commitMessage": "Fixes #275 Poor handling of RejectedExecutionException during processing (#293)\n\n", "commitDateTime": "2016-12-13 12:38:54", "authoredDateTime": "2016-12-13 12:38:54", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 17, "deletions": 2, "lines": 19}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 3, "deletions": 6, "lines": 9}, {"filePath": "src/test/java/reactor/core/publisher/MonoPublishOnTest.java", "insertions": 239, "deletions": 1, "lines": 240}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishOn.MonoPublishOnSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOn.MonoPublishOnSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "ExecutorScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorScheduler.schedule(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutor()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutor()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutorService()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutorService()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "500c731c7bb0d2ca8d57fef043765476ee83f7f8", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["c1ffe0d3f45758be4898df6ce16a8f2f2d9ef1af"], "nameRev": "500c731c7bb0d2ca8d57fef043765476ee83f7f8 tags/v3.0.4.RELEASE~39", "commitMessage": "improve #275, make bubbling consistent across publishOn\n", "commitDateTime": "2016-12-13 12:56:51", "authoredDateTime": "2016-12-13 12:56:51", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxConcatMap.java", "insertions": 8, "deletions": 14, "lines": 22}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 12, "deletions": 5, "lines": 17}, {"filePath": "src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 136, "deletions": 128, "lines": 264}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 6, "deletions": 3, "lines": 9}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "c37f67bb9fc7e773d14360388d2229686f215c2c", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["500c731c7bb0d2ca8d57fef043765476ee83f7f8"], "nameRev": "c37f67bb9fc7e773d14360388d2229686f215c2c tags/v3.0.4.RELEASE~38", "commitMessage": "Fixes #275 Poor handling of RejectedExecutionException during processing (#298)\n\n* Fixes #275 Poor handling of RejectedExecutionException during processing\r\n\r\n* Review\r\n", "commitDateTime": "2016-12-13 14:48:43", "authoredDateTime": "2016-12-13 14:48:43", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 46, "deletions": 20, "lines": 66}, {"filePath": "src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 20, "deletions": 8, "lines": 28}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 226, "deletions": 1, "lines": 227}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.trySchedule()", "TOT": 7, "UPD": 1, "INS": 2, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.onError(java.lang.Throwable)", "TOT": 13, "UPD": 0, "INS": 4, "MOV": 8, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.trySchedule()", "TOT": 6, "UPD": 0, "INS": 1, "MOV": 4, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.request(long)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 4, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.onNext(java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOn.PublishOnConditionalSubscriber.onComplete()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoPublishOn.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishOn.MonoPublishOnSubscriber.onNext(java.lang.Object)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ExecutorServiceScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.schedule(java.lang.Runnable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.ExecutorServiceWorker.schedule(java.lang.Runnable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "FluxPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutor()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutor()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutorService()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutorService()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["500c731c7bb0d2ca8d57fef043765476ee83f7f8"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 162, "deletions": 150, "lines": 312, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": []}, {"title": "Inconsistent handling of RejectedExecutionException in publishOn during subscribe/block.", "body": "When an Executor/ExecutorService throws a `RejectedExecutionException` as part of the subscribe/request the way in which it is handled differs between `ExecutorScheduler` and `ExecutorServiceScheduler`\r\n\r\n```\r\ni. Mono.just(1).publishOn(Schedulers.fromExecutor(executor)).block();\r\nii. Mono.just(1).publishOn(Schedulers.fromExecutorService(executor)).block();\r\n\r\n```\r\n\r\nWhen using `ExecutorScheduler` the example above **hangs** whereas with the `ExecutorServiceScheduler` the block()/subscribe() method throws `RejectedExecutionException`.\r\n\r\nI've seen this with both Flux and Mono with cold sources.  ", "url": "https://github.com/reactor/reactor-core/issues/274", "user": "dfeist", "labels": ["type/bug"], "created": "2016-11-27 23:53:16", "closed": "2016-12-13 16:23:44", "commits": {"1acc90427c9459c71c9c37ffd197f8174e562512": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "ec98960a3511be7a711e8dacbbfd45ed1907f8cd": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "ad08a576a35221bffb7d0f10bd87b16af8d65739": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "7511eb7d9b12b8d5d6df0e7d2bca5647db48be92": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "659dd4e76333d8a05d9ec1ab7591d51b85f9b5eb": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "35c2bad68f34f5eb7e694158437120003f81f39b": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "39ed99e1f6924f16e41bc1efb8e9947836e1ffae": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 15.000277777777777, "commitsDetails": [{"commitHash": "1acc90427c9459c71c9c37ffd197f8174e562512", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["1ee21ad18c3df9be198b643b57427821a021d470"], "nameRev": "1acc90427c9459c71c9c37ffd197f8174e562512 tags/v3.0.4.RELEASE~35", "commitMessage": "Fixes #274 Inconsistent handling of RejectedExecutionException in publishOn during subscribe/block. (#299)\n\n", "commitDateTime": "2016-12-13 16:23:43", "authoredDateTime": "2016-12-13 16:23:43", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 7, "deletions": 1, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java", "insertions": 9, "deletions": 1, "lines": 10}, {"filePath": "src/test/java/reactor/core/publisher/MonoPublishOnTest.java", "insertions": 88, "deletions": 9, "lines": 97}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxSubscribeOnValue.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar.request(long)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoSubscribeOnValue.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnValue.subscribe(org.reactivestreams.Subscriber)", "TOT": 7, "UPD": 0, "INS": 2, "MOV": 5, "DEL": 0}]}, {"spoonFilePath": "MonoPublishOnTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutor()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutor()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnDataSignalExecutorService()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionExceptionOnErrorSignalExecutorService()", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionSubsribeExecutorScheduler()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoPublishOnTest.rejectedExecutionSubsribeExecutorServiceScheduler()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "ec98960a3511be7a711e8dacbbfd45ed1907f8cd", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "ad08a576a35221bffb7d0f10bd87b16af8d65739", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "7511eb7d9b12b8d5d6df0e7d2bca5647db48be92", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["d9ca2fb49fcf8042e38cd605bbc06a41583e05c7"], "nameRev": "7511eb7d9b12b8d5d6df0e7d2bca5647db48be92 tags/v3.0.4.RELEASE~17", "commitMessage": "rework #274 Consistent scheduler rejection/shutdown, Worker.isShutdown\n\nThis commit reworks #274 by more consistently checking the REJECTED\r\nresult of scheduling so it can be transformer to a\r\nRejectedExecutionException.\r\n\r\nThat RejectedExecutionException is often thrown, but is passed to\r\nonError instead when it is possible. If it happens during onNext, the\r\nsubscription is cancelled. In request, the REJECTED state is ignored as\r\nit cannot be taken into account (no possibility of throwing or calling\r\nonError).\r\n\r\nThe shutdown of Schedulers has been mutualized in a method that attempt\r\nto make it safer.\r\n\r\nLastly, the `isShutdown` method has been added to Worker. This allows\r\nFluxPublishOn to check that state in onComplete, preventing it to\r\nwrongly throw the RejectedExecutionException.", "commitDateTime": "2016-12-21 19:08:36", "authoredDateTime": "2016-12-21 19:08:36", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxBatch.java", "insertions": 4, "deletions": 0, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxCancelOn.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 16, "deletions": 28, "lines": 44}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOn.java", "insertions": 4, "deletions": 1, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 9, "deletions": 6, "lines": 15}, {"filePath": "src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 8, "deletions": 1, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoFirst.java", "insertions": 0, "deletions": 2, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 3, "deletions": 10, "lines": 13}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java", "insertions": 1, "deletions": 2, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 38, "deletions": 0, "lines": 38}, {"filePath": "src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/main/java/reactor/core/scheduler/ImmediateScheduler.java", "insertions": 5, "deletions": 0, "lines": 5}, {"filePath": "src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 8, "deletions": 3, "lines": 11}, {"filePath": "src/main/java/reactor/core/scheduler/Scheduler.java", "insertions": 7, "deletions": 0, "lines": 7}, {"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 16, "deletions": 0, "lines": 16}, {"filePath": "src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 41, "deletions": 36, "lines": 77}, {"filePath": "src/main/java/reactor/core/scheduler/SingleTimedScheduler.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/reactor/core/publisher/MonoDematerializeTest.java", "insertions": 3, "deletions": 2, "lines": 5}, {"filePath": "src/test/java/reactor/core/publisher/MonoPublishOnTest.java", "insertions": 6, "deletions": 1, "lines": 7}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 52, "deletions": 0, "lines": 52}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}, {"commitHash": "659dd4e76333d8a05d9ec1ab7591d51b85f9b5eb", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "35c2bad68f34f5eb7e694158437120003f81f39b", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "39ed99e1f6924f16e41bc1efb8e9947836e1ffae", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["ac4e9c7275f778dad23ca1a5b45b097495ec0ff4"], "nameRev": "39ed99e1f6924f16e41bc1efb8e9947836e1ffae tags/v3.0.4.RELEASE~13", "commitMessage": "fix #322 Add Disposable + rework #274 refine REJECTED checks\n\nDeprecate Cancellation but keep it on Scheduler#schedule for backward\ncompatibility.\n\nScheduler is now Disposable. Even though dispose is a default method,\nimplementors still should migrate asap to implement all logic in\ndispose() and have shutdown() call dispose...\n\ndispose() will end up defaulting to no-op in 3.1.0 and shutdown() will\ndisappear.\n\nRefine Scheduler REJECTED handling, autoconvert Executor if possible to\navoid using Executor scheduler if ExecutorService scheduler can be used.\n", "commitDateTime": "2016-12-22 19:20:30", "authoredDateTime": "2016-12-22 17:02:31", "commitGitStats": [{"filePath": "src/main/java/reactor/core/Cancellation.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/Disposable.java", "insertions": 42, "deletions": 0, "lines": 42}, {"filePath": "src/main/java/reactor/core/publisher/BaseSubscriber.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/ConnectableFlux.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 19, "deletions": 19, "lines": 38}, {"filePath": "src/main/java/reactor/core/publisher/FluxAutoConnect.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxBatch.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxCreate.java", "insertions": 8, "deletions": 8, "lines": 16}, {"filePath": "src/main/java/reactor/core/publisher/FluxFlatMap.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxGroupJoin.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/FluxInterval.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxJoin.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublish.java", "insertions": 3, "deletions": 4, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/FluxPublishOn.java", "insertions": 28, "deletions": 15, "lines": 43}, {"filePath": "src/main/java/reactor/core/publisher/FluxRefCount.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/FluxSink.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOn.java", "insertions": 22, "deletions": 29, "lines": 51}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java", "insertions": 12, "deletions": 6, "lines": 18}, {"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java", "insertions": 17, "deletions": 8, "lines": 25}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindow.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowBoundary.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowOnCancel.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowStartEnd.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/FluxZip.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/LambdaFirstSubscriber.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/LambdaSubscriber.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 7, "deletions": 7, "lines": 14}, {"filePath": "src/main/java/reactor/core/publisher/MonoCreate.java", "insertions": 12, "deletions": 12, "lines": 24}, {"filePath": "src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 5, "deletions": 2, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 7, "deletions": 2, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoPublishOn.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/MonoSink.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOn.java", "insertions": 33, "deletions": 18, "lines": 51}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java", "insertions": 6, "deletions": 3, "lines": 9}, {"filePath": "src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/main/java/reactor/core/publisher/ParallelUnorderedRunOn.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/UnicastProcessor.java", "insertions": 9, "deletions": 9, "lines": 18}, {"filePath": "src/main/java/reactor/core/scheduler/ElasticScheduler.java", "insertions": 26, "deletions": 5, "lines": 31}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorScheduler.java", "insertions": 48, "deletions": 8, "lines": 56}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 27, "deletions": 5, "lines": 32}, {"filePath": "src/main/java/reactor/core/scheduler/ImmediateScheduler.java", "insertions": 20, "deletions": 5, "lines": 25}, {"filePath": "src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 34, "deletions": 13, "lines": 47}, {"filePath": "src/main/java/reactor/core/scheduler/RejectedDisposable.java", "insertions": 35, "deletions": 0, "lines": 35}, {"filePath": "src/main/java/reactor/core/scheduler/Scheduler.java", "insertions": 44, "deletions": 27, "lines": 71}, {"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 31, "deletions": 14, "lines": 45}, {"filePath": "src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 30, "deletions": 13, "lines": 43}, {"filePath": "src/main/java/reactor/core/scheduler/SingleTimedScheduler.java", "insertions": 46, "deletions": 24, "lines": 70}, {"filePath": "src/main/java/reactor/core/scheduler/SingleWorkerScheduler.java", "insertions": 13, "deletions": 4, "lines": 17}, {"filePath": "src/main/java/reactor/core/scheduler/TimedScheduler.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/groovy/reactor/core/FluxSpec.groovy", "insertions": 19, "deletions": 11, "lines": 30}, {"filePath": "src/test/groovy/reactor/core/MonoSpec.groovy", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/test/groovy/reactor/core/ProcessorsSpec.groovy", "insertions": 6, "deletions": 6, "lines": 12}, {"filePath": "src/test/java/reactor/HooksTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/AbstractReactorTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/BlockingTests.java", "insertions": 1, "deletions": 6, "lines": 7}, {"filePath": "src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxIntervalTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 12, "deletions": 4, "lines": 16}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishOnTest.java", "insertions": 1, "deletions": 38, "lines": 39}, {"filePath": "src/test/java/reactor/core/publisher/FluxPublishTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxRefCountTest.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/ParallelFluxTest.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/TopicProcessorTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/loop/FluxPublishOnLoop.java", "insertions": 59, "deletions": 0, "lines": 59}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/CombinationTests.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 15, "deletions": 15, "lines": 30}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/tck/FluxBlackboxProcessorVerification.java", "insertions": 2, "deletions": 2, "lines": 4}, {"filePath": "src/test/java/reactor/core/scheduler/HashWheelTimerTest.java", "insertions": 5, "deletions": 5, "lines": 10}, {"filePath": "src/test/java/reactor/core/scheduler/ProcessorsSpecTest.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 9, "deletions": 11, "lines": 20}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyFiles"}], "filteredCommits": ["7511eb7d9b12b8d5d6df0e7d2bca5647db48be92"], "filteredCommitsReason": {"duplicated": 4, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 208.0, "deletions": 94.0, "lines": 302.0, "gitFilesChange": 22}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/scheduler", "src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": []}, {"title": "ExecutorServiceScheduler does not handle RejectedExecutionException, inconsistent with ExecutorScheduler", "body": "Change FluxPublishOnTest to use an executor with a `SynchronousQueue` and you'll see tests start failing with `java.util.concurrent.RejectedExecutionException`.  If instead `ExecutorService` is used the behaviour is different. Tests may time out, but they do not fail with an exception.\r\n\r\nWhen running some tests with a single-threaded executor with `SynchronousQueue` and `AbortPolicy` that is blocked for 2 seconds I see the following inconsistencies between ExecutorServiceScheduler and ExecutorScheduler.\r\n\r\n- **Mono**\r\n`Mono.just(1).publishOn(fromExecutor(single)).block()`    **<- Hangs, no error signal**\r\n`Mono.just(1).publishOn(fromExecutorService(single)).block()`     **<- Throws RejectedExecutionException**\r\n\r\n- **Cold Publisher**\r\n`range(0,10).publishOn(fromExecutor(single)).subscribe(System.out::println);`    **<- No items processed**\r\n`range(0,10).publishOn(fromExecutorService(single)).subscribe(System.out::println);`    **<- Throws reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.RejectedExecutionException**\r\n\r\n- **Hot Publisher** (using UnicastProcessor and BlockingSink)\r\n`fromExectutor(single)`   **<-  Processes no events including those fired after thread becomes free. No error signal.**\r\n`fromExectutorService(single)`     **< - Throws reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.RejectedExecutionException**\r\n\r\nA number of questions arise from this:\r\n\r\n1. Surely ExecutorServiceScheduler should handle RejectedExecutionException as ExecutorScheduler does.\r\n2. Is Mono hanging (even after executor thread is freed up) instead of failing correct/desired behaviour?\r\n3. It's not clear to me why, with a hot publisher, events fired once the thread is free are seemingly not processed.\r\n", "url": "https://github.com/reactor/reactor-core/issues/265", "user": "dfeist", "labels": ["type/bug", "type/enhancement"], "created": "2016-11-23 00:21:51", "closed": "2016-11-28 00:22:10", "commits": {}, "ttf": 5.000277777777778, "commitsDetails": []}, {"title": "Log4J2 fails when reactor logs its objects", "body": "I'm using `slf4j-over-log4j2` with `reactor-core:3.0.3`. When I subscribe to my `Flux`, I get the following exception.\r\n\r\nI'm using `spring web reactive` and it's interesting to note that with `tomcat` I get the data while it's not the case with `netty`\r\n\r\n```\r\njava.lang.UnsupportedOperationException: Operators should not use this method!\r\n\tat reactor.core.Fuseable$QueueSubscription.iterator(Fuseable.java:137) ~[reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendCollection(ParameterFormatter.java:599) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:507) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:432) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.message.ParameterFormatter.formatMessage2(ParameterFormatter.java:189) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.message.ReusableParameterizedMessage.formatTo(ReusableParameterizedMessage.java:311) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.core.impl.MutableLogEvent.setMessage(MutableLogEvent.java:210) ~[log4j-core-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.core.impl.ReusableLogEventFactory.createEvent(ReusableLogEventFactory.java:81) ~[log4j-core-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:400) ~[log4j-core-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:63) ~[log4j-core-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.core.Logger.logMessage(Logger.java:146) ~[log4j-core-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2091) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:1999) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1868) ~[log4j-api-2.7.jar:2.7]\r\n\tat org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:194) ~[log4j-slf4j-impl-2.7.jar:2.7]\r\n\tat reactor.util.Loggers$Slf4JLogger.info(Loggers.java:145) ~[reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.SignalLogger.log(SignalLogger.java:154) ~[reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.SignalLogger.lambda$onSubscribeCall$0(SignalLogger.java:167) ~[reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:135) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxResume$ResumeSubscriber.onSubscribe(FluxResume.java:64) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.SerializedSubscriber.onSubscribe(SerializedSubscriber.java:67) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxTimeout.subscribe(FluxTimeout.java:54) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxResume.subscribe(FluxResume.java:45) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:81) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:113) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxSkipLast.subscribe(FluxSkipLast.java:50) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:212) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:93) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat org.springframework.http.server.reactive.ChannelSendOperator.subscribe(ChannelSendOperator.java:54) [spring-web-5.0.0.BUILD-20161117.095337-409.jar:5.0.0.BUILD-SNAPSHOT]\r\n\tat reactor.core.publisher.MonoPeek.subscribe(MonoPeek.java:85) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:132) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain$SecondSubscriber.onNext(MonoThenMap.java:202) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain$SecondSubscriber.onNext(MonoThenMap.java:202) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxResume$ResumeSubscriber.onNext(FluxResume.java:71) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:162) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:126) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoWhen$MonoWhenCoordinator.signal(MonoWhen.java:231) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoWhen$MonoWhenSubscriber.onNext(MonoWhen.java:275) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:162) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:86) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:68) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:124) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1565) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:394) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:180) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:394) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1282) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1245) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:94) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoCallableOnAssembly.subscribe(MonoCallableOnAssembly.java:70) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:64) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwiseIfEmpty.subscribe(MonoOtherwiseIfEmpty.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoWhen$MonoWhenCoordinator.subscribe(MonoWhen.java:155) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoWhen.subscribe(MonoWhen.java:121) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:132) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenIgnore$MonoThenIgnoreMain.drain(MonoThenIgnore.java:143) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenIgnore.subscribe(MonoThenIgnore.java:54) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:132) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:68) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:78) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:258) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:740) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:124) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:316) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1565) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:394) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:180) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:394) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1282) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1245) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:94) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoCallableOnAssembly.subscribe(MonoCallableOnAssembly.java:70) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:64) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:397) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:189) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:378) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:93) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:56) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:113) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:219) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoNext.subscribe(MonoNext.java:41) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwiseIfEmpty.subscribe(MonoOtherwiseIfEmpty.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenIgnore$MonoThenIgnoreMain.drain(MonoThenIgnore.java:166) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoThenIgnore.subscribe(MonoThenIgnore.java:54) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:63) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:187) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:47) [reactor-core-3.0.3.RELEASE.jar:?]\r\n\tat reactor.ipc.netty.http.NettyHttpServerHandler.channelRead(NettyHttpServerHandler.java:94) [reactor-netty-0.5.2.RELEASE.jar:?]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:435) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:267) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:250) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:571) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877) [netty-all-4.1.3.Final.jar:4.1.3.Final]\r\n\tat java.lang.Thread.run(Thread.java:745) [?:1.8.0_101]\r\n\tSuppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: \r\nAssembly trace from producer [reactor.core.publisher.FluxPeekFuseable] :\r\n\treactor.core.publisher.Flux.doOnSignal(Flux.java:6599)\r\n\treactor.core.publisher.Flux.log(Flux.java:3798)\r\n\treactor.core.publisher.Flux.log(Flux.java:3764)\r\n\treactor.core.publisher.Flux.log(Flux.java:3739)\r\n\tio.reactivity.core.broadcaster.service.FluxDecorator.decorate(FluxDecorator.java:84)\r\n\tio.reactivity.core.broadcaster.service.FluxDecorator.decorate(FluxDecorator.java:66)\r\n\torg.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629)\r\n\torg.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618)\r\n\torg.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)\r\n\torg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\r\n\torg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)\r\n\torg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\r\n\torg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655)\r\n\tio.reactivity.core.broadcaster.web.EventController.subscribe(EventController.java:92)\r\n\torg.springframework.web.reactive.result.method.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:196)\r\n\torg.springframework.web.reactive.result.method.InvocableHandlerMethod.lambda$invoke$0(InvocableHandlerMethod.java:103)\r\n\treactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:98)\r\n\treactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942)\r\n\treactor.core.publisher.MonoWhen$MonoWhenCoordinator.signal(MonoWhen.java:231)\r\n\treactor.core.publisher.MonoWhen$MonoWhenSubscriber.onNext(MonoWhen.java:275)\r\n\treactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:162)\r\n\treactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:86)\r\n\treactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:68)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:124)\r\n\treactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1565)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:180)\r\n\treactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1282)\r\n\treactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1245)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:94)\r\n\treactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\treactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:64)\r\n\treactor.core.publisher.MonoOtherwiseIfEmpty.subscribe(MonoOtherwiseIfEmpty.java:44)\r\n\treactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37)\r\n\treactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78)\r\n\treactor.core.publisher.MonoWhen$MonoWhenCoordinator.subscribe(MonoWhen.java:155)\r\n\treactor.core.publisher.MonoWhen.subscribe(MonoWhen.java:121)\r\n\treactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55)\r\n\treactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78)\r\n\treactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44)\r\n\treactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:132)\r\n\treactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:942)\r\n\treactor.core.publisher.MonoThenIgnore$MonoThenIgnoreMain.drain(MonoThenIgnore.java:143)\r\n\treactor.core.publisher.MonoThenIgnore.subscribe(MonoThenIgnore.java:54)\r\n\treactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55)\r\n\treactor.core.publisher.MonoThenMap$MonoThenApplyMain.onNext(MonoThenMap.java:132)\r\n\treactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:68)\r\n\treactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:78)\r\n\treactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:258)\r\n\treactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:740)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:124)\r\n\treactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1565)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:180)\r\n\treactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1282)\r\n\treactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1245)\r\n\treactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:94)\r\n\treactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\treactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:64)\r\n\treactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:397)\r\n\treactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:189)\r\n\treactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:93)\r\n\treactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:56)\r\n\treactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:113)\r\n\treactor.core.publisher.MonoNext.subscribe(MonoNext.java:41)\r\n\treactor.core.publisher.MonoOtherwiseIfEmpty.subscribe(MonoOtherwiseIfEmpty.java:44)\r\n\treactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55)\r\n\treactor.core.publisher.MonoThenMap.subscribe(MonoThenMap.java:55)\r\n\treactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44)\r\n\treactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44)\r\n\treactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44)\r\n\treactor.core.publisher.MonoThenIgnore$MonoThenIgnoreMain.drain(MonoThenIgnore.java:166)\r\n\treactor.core.publisher.MonoThenIgnore.subscribe(MonoThenIgnore.java:54)\r\n\treactor.core.publisher.MonoOtherwise.subscribe(MonoOtherwise.java:44)\r\n\treactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:78)\r\n\treactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:63)\r\n\treactor.ipc.netty.http.NettyHttpServerHandler.channelRead(NettyHttpServerHandler.java:94)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)\r\n\tio.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:435)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:267)\r\n\tio.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:250)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)\r\n\tio.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)\r\n\tio.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:571)\r\n\tio.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)\r\n\tio.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)\r\n\tio.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)\r\n\tio.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)\r\nComposition chain until failing Operator :\r\n\t|_\tFlux.log(FluxDecorator.java:84)\r\n\t|_\tFlux.concatMap(Jackson2JsonEncoder.java:96)\r\n\t|_\tFlux.skipLast(Jackson2JsonEncoder.java:101)\r\n\r\n```", "url": "https://github.com/reactor/reactor-core/issues/262", "user": "gdrouet", "labels": ["type/bug"], "created": "2016-11-18 21:00:07", "closed": "2016-11-28 13:43:28", "commits": {"7692f345bc56292a58aa4d7578c91959a8b457a0": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "cf88165230f47fb52bf33809c9a28c42b3bca876": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 9.000277777777777, "commitsDetails": [{"commitHash": "7692f345bc56292a58aa4d7578c91959a8b457a0", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "cf88165230f47fb52bf33809c9a28c42b3bca876", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["257396cc57b22cdaaf7d71d57dff790e05669cfb"], "nameRev": "cf88165230f47fb52bf33809c9a28c42b3bca876 tags/v3.0.4.RELEASE~52", "commitMessage": "fix #262 Prevent log() of Subscription as a Collection\n\nwhy\r\n---\r\nWhen log() is used, the Subscription itself is logged. Some logger\r\nimplementations (eg. Log4j) attempt to detect a Collection in the list\r\nof arguments it logs, in order to apply special logic (log the string\r\nrepresentation of all elements using the iterator).\r\nSince some Subscription implementations partially implement Collection\r\n(usually a Queue), but without implementing `iterator()`, these fail.\r\n\r\nmodifications\r\n-------------\r\nThis commit makes SignalLogger log a special string representation of\r\nthe Subscription, so that underlying loggers won't wrongfully attempt\r\nto log it as a Collection.\r\n\r\nThe representation identifies fuseable and synchronous fuseable\r\nsubscriptions and works with anonymous classes as well.\r\n\r\nAdditionally, SignalLogger can be instantiated with a Logger supplier,\r\nmainly used for tests.", "commitDateTime": "2016-11-28 14:43:27", "authoredDateTime": "2016-11-28 14:43:27", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/SignalLogger.java", "insertions": 35, "deletions": 2, "lines": 37}, {"filePath": "src/test/java/reactor/core/publisher/SignalLoggerTests.java", "insertions": 249, "deletions": 0, "lines": 249}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SignalLogger.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLogger", "TOT": 3, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onSubscribeCall()", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onNextCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onErrorCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCompleteCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onRequestCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.onCancelCall()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalLogger.subscriptionAsString(org.reactivestreams.Subscription)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SignalLoggerTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalLoggerTests", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["cf88165230f47fb52bf33809c9a28c42b3bca876"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 35.0, "deletions": 2.0, "lines": 37.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 13.0, "UPD": 8.0, "INS": 4.0, "MOV": 1.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 9}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.SignalLogger.subscriptionAsString(org.reactivestreams.Subscription)", "reactor.core.publisher.SignalLogger.onNextCall()", "reactor.core.publisher.SignalLogger.onCancelCall()", "reactor.core.publisher.SignalLogger.onCompleteCall()", "reactor.core.publisher.SignalLogger.onErrorCall()", "reactor.core.publisher.SignalLogger.onSubscribeCall()", "reactor.core.publisher.SignalLogger.onAfterTerminateCall()", "reactor.core.publisher.SignalLogger", "reactor.core.publisher.SignalLogger.onRequestCall()"]}, {"title": "The FluxSubscribeOnCallable doesn't check Callable result for null", "body": "I have a sample like:\r\n````java\r\nMono.fromCallable(...)\r\n\t\t\t.doOnNext(result1 -> {\r\n\t\t\t\tlogger.info(\"Result of multiplication of \" + number + \" by 2 is \" + result1);\r\n\t\t\t\tlatch.countDown();\r\n\t\t\t})\r\n\t\t\t.doOnError(t -> {\r\n\t\t\t\tfailures.incrementAndGet();\r\n\t\t\t\tlogger.error(\"Unexpected exception for \" + number, t);\r\n\t\t\t}).subscribe();\r\n````\r\n\r\nWhen my `Callable` returns `null`, it ends up in the `doOnError()`, because of `MonoCallable` logic:\r\n```\r\nif (t == null) {\r\n\ts.onError(Operators.onOperatorError(new NullPointerException(\"The \" +\r\n\t\t\t\"callable returned null\")));\r\n\treturn;\r\n}\r\n\r\n```\r\n\r\nFor better underlying `Callable` performance  I decided to make it async with the:\r\n````\r\nMono.fromCallable(...)\r\n        .subscribeOn(Schedulers.elastic())\r\n````\r\nIndeed, it is much faster because `Callable` executions are performed on different threads.\r\nBut at the same time `MonoSubscribeOnCallable` delegates to the `FluxSubscribeOnCallable`, where the logic is present with the lack of `null` check:\r\n```\r\npublic void run() {\r\n\t\t\tT v;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tv = callable.call();\r\n\t\t\t}\r\n...\r\n    \tactual.onNext(v);\r\n```\r\nTherefore my subscriber receives `null` as a value.\r\n\r\nFirst of all that looks like inconsistency between two `Callable` usage, but on the other hand it seems for me Reactive Streams Spec doesn't allow `null` for `onNext()`: https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.0/README.md#2-subscriber-code, rule `13`", "url": "https://github.com/reactor/reactor-core/issues/261", "user": "artembilan", "labels": ["type/bug"], "created": "2016-11-17 17:39:55", "closed": "2016-11-23 16:50:57", "commits": {"5d75ae6bc589d0d5bac92f1e8ce5163f2300797c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "76583e59b995d50036ecaf03f9c001b5832a7b25": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 5.000277777777778, "commitsDetails": [{"commitHash": "5d75ae6bc589d0d5bac92f1e8ce5163f2300797c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "76583e59b995d50036ecaf03f9c001b5832a7b25", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["5cc93e9607f883295c2a9990e6a70109855a7f94"], "nameRev": "76583e59b995d50036ecaf03f9c001b5832a7b25 tags/v3.0.4.RELEASE~56", "commitMessage": "fix #261 Callable returning null now always trigger onError(NPE)\n\nThis commit fixes the case where a Flux/Mono created from a Callable\nwould not fail with a NullPointerException when said Callable returns\nnull and the publisher has been subscribedOn a Scheduler.\n\nImplemented missing tests for FluxSubscribeOnCallable and its Mono\ncounterpart.\n", "commitDateTime": "2016-11-23 17:50:56", "authoredDateTime": "2016-11-23 17:33:26", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java", "insertions": 6, "deletions": 0, "lines": 6}, {"filePath": "src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java", "insertions": 38, "deletions": 0, "lines": 38}, {"filePath": "src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java", "insertions": 38, "deletions": 0, "lines": 38}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxSubscribeOnCallable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnCallable.CallableSubscribeOnSubscription.run()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxSubscribeOnCallableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnCallableTest.callableReturnsNull()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnCallableTest.normalBackpressured()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnCallableTest.callableThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxSubscribeOnCallableTest.normal()", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoSubscribeOnCallableTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnCallableTest.callableReturnsNull()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnCallableTest.normalBackpressured()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnCallableTest.callableThrows()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoSubscribeOnCallableTest.normal()", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["76583e59b995d50036ecaf03f9c001b5832a7b25"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 6.0, "deletions": 0.0, "lines": 6.0, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1.0, "UPD": 0.0, "INS": 1.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxSubscribeOnCallable.CallableSubscribeOnSubscription.run()"]}, {"title": "Uncaught exceptions are silently ignored", "body": "In 3.0.2.RELEASE an uncaught exception thrown by a subscriber without an error consumer would be logged via the thread's UncaughtExceptionHandler.  In 3.0.3.RELEASE the uncaught exception is silently thrown away.  I would consider this a bug since otherwise I believe I would have to add an error consumer to every subscriber to be sure no subscriber threw an exception.\r\n\r\nThe following code reproduces the issue. In 3.0.2.RELEASE the code would display the exception.  In 3.0.3.RELEASE nothing is shown.\r\n\r\n```\r\nimport reactor.core.publisher.Flux;\r\n\r\nimport static reactor.core.scheduler.Schedulers.parallel;\r\n\r\npublic class UncaughtExceptionHandler {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Flux.intervalMillis(100)\r\n                .take(1)\r\n                .publishOn(parallel())\r\n                .subscribe(i -> throwEx());\r\n        Thread.sleep(3000);\r\n    }\r\n\r\n    private static void throwEx() {\r\n        System.out.println(\"About to throw...\");\r\n        throw new IllegalStateException();\r\n    }\r\n}\r\n```", "url": "https://github.com/reactor/reactor-core/issues/257", "user": "graememoss", "labels": ["type/bug"], "created": "2016-11-17 13:41:04", "closed": "2016-11-24 14:22:36", "commits": {"58f534da259e1554968abe675042816fd0e8f5b6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "3eba502100d575a04eb31b4e8850d2527ec011aa": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 7.000277777777778, "commitsDetails": [{"commitHash": "58f534da259e1554968abe675042816fd0e8f5b6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "3eba502100d575a04eb31b4e8850d2527ec011aa", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["76583e59b995d50036ecaf03f9c001b5832a7b25"], "nameRev": "3eba502100d575a04eb31b4e8850d2527ec011aa tags/v3.0.4.RELEASE~55", "commitMessage": "fix #257 Don't silence errorNotImplemented in Schedulers\n\nThis commit fixes the fact that Scheduler workers can silence 2 classes\nof Exceptions specific to Reactor: BubbleException and\nOnErrorNotImplemented. This is due to Exceptions.throwIfFatal throwing\nthese, which in turn prevents Schedulers.handleError to forward them to\nthe Thread uncaught exception handlers.\n\nThe throwIfFatal has been split, introducing a throwIfJvmFatal that only\ndeals with JVM-specific fatal errors. This new method is used to handle\nSchedulers fatal errors.\n\nAdditionally, a hook has been introduced that will be executed if\nSchedulers.handleError actually handles the errors (ie it isn't thrown).\n", "commitDateTime": "2016-11-24 15:22:35", "authoredDateTime": "2016-11-23 11:40:31", "commitGitStats": [{"filePath": "src/main/java/reactor/core/Exceptions.java", "insertions": 17, "deletions": 5, "lines": 22}, {"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 33, "deletions": 5, "lines": 38}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 61, "deletions": 0, "lines": 61}, {"filePath": "src/test/java/reactor/core/scheduler/SchedulersTest.java", "insertions": 42, "deletions": 1, "lines": 43}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions.throwIfFatal(java.lang.Throwable)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.handleError(java.lang.Throwable)", "TOT": 7, "UPD": 1, "INS": 4, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.SchedulerThreadFactory.uncaughtException(java.lang.Thread,java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.Schedulers", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.onHandleError(java.util.function.BiConsumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.resetOnHandleError()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThrowWithoutOnErrorShowsUpInSchedulerHandler()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testJvmFatalDoesntShowUpInSchedulerHandler()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SchedulersTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testOverride()", "TOT": 5, "UPD": 5, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testShutdownOldOnSetFactory()", "TOT": 8, "UPD": 8, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testUncaughtHookCalledWhenOnErrorNotImplemented()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testUncaughtHookCalledWhenCommonException()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SchedulersTest.testUncaughtHookNotCalledWhenThreadDeath()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["3eba502100d575a04eb31b4e8850d2527ec011aa"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 50.0, "deletions": 10.0, "lines": 60.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 16.0, "UPD": 2.0, "INS": 9.0, "MOV": 3.0, "DEL": 2.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core", "src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.Schedulers.onHandleError(java.util.function.BiConsumer)", "reactor.core.scheduler.Schedulers.resetOnHandleError()", "reactor.core.Exceptions.throwIfFatal(java.lang.Throwable)", "reactor.core.scheduler.Schedulers.SchedulerThreadFactory.uncaughtException(java.lang.Thread,java.lang.Throwable)", "reactor.core.scheduler.Schedulers.handleError(java.lang.Throwable)", "reactor.core.scheduler.Schedulers"]}, {"title": "Exceptions thrown in doOnError are not propagated back when publishOn is used", "body": "The following scenario causes a hung thread:\r\n\r\n```\r\n    Mono.just(1)\r\n        .publishOn(parallel())\r\n        .doOnNext(i -> {\r\n          throw new IllegalStateException();\r\n        })\r\n        .doOnError(e -> {\r\n          throw new RuntimeException(e);\r\n        })\r\n        .block();\r\n```\r\n\r\nIf the `publishOn()` is removed this behaves as expected and the `block()` exits with exception rather than hanging.", "url": "https://github.com/reactor/reactor-core/issues/253", "user": "dfeist", "labels": ["type/bug"], "created": "2016-11-11 12:39:40", "closed": "2016-11-28 10:54:15", "commits": {"7225415d1177e274b0e8a31d66e18442e0d14476": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "257396cc57b22cdaaf7d71d57dff790e05669cfb": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 16.00027777777778, "commitsDetails": [{"commitHash": "7225415d1177e274b0e8a31d66e18442e0d14476", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "257396cc57b22cdaaf7d71d57dff790e05669cfb", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["14de43ed35ae05a2fa0da42be998036eb3282dfb"], "nameRev": "257396cc57b22cdaaf7d71d57dff790e05669cfb tags/v3.0.4.RELEASE~53", "commitMessage": "fix #247 Improve doOn callback failures handling\n\nThis commit improves the handling of failing callbacks in both FluxPeek\r\nand FluxPeekFuseable, notably:\r\n\r\n - a failing complete callback is correctly processed by the onError\r\n - a failing error callback is caught and propagated to actual's\r\n   onError with the original throwable as a suppressed exception\r\n   (unless the failure is fatal)\r\n - all variants now throwIfFatal first on afterTerminate failure\r\n - errors during onComplete callback now cancels the subscription\r\n\r\nFluxPeekTest now correctly tests non-fuseable internals, using `hide`.\r\nThe FluxPeekFuseable alternative is now tested in a similar way in\r\nFluxPeekFuseableTest (although not with 100% coverage).\r\n\r\nThe handling of failure of the afterTerminate callback is mutualized\r\nin order to improve readability of nested try-catch blocks.\r\n\r\nAdded tests for 2 duplicate issues:\r\nFixes #253\r\nFixes #272", "commitDateTime": "2016-11-28 11:54:14", "authoredDateTime": "2016-11-28 11:54:14", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeek.java", "insertions": 83, "deletions": 17, "lines": 100}, {"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 41, "deletions": 62, "lines": 103}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 618, "deletions": 0, "lines": 618}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekTest.java", "insertions": 240, "deletions": 9, "lines": 249}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Add a `doFinally` operator that executes once after completion/error/cancel", "body": "Example code:\r\n\r\n```\r\n    public static Mono<String> validateCredentials() {\r\n        return validateCredentialsHelper(\"Hello\", \"Stefane\")\r\n        .doOnSubscribe((e) -> {\r\n            System.out.println(\"Starting validation...\");\r\n        })\r\n        .doAfterTerminate((result, error) -> {\r\n            System.out.println(\"Validation terminated: \"+result+\", \"+error);\r\n        });\r\n    }\r\n\r\n    private static Mono<String> validateCredentialsHelper(String string, String string2) {\r\n        return Mono.delay(Duration.ofSeconds(1))\r\n        .then((x) -> Mono.just(string+\" \"+string2));\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        System.out.println(\"Triggering...\");\r\n        validateCredentials().subscribeOn(Schedulers.elastic()).subscribe((result)-> System.out.println(\"result: \"+result));\r\n        System.out.println(\"Triggered!\");\r\n\r\n\r\n        while (true) {\r\n            Thread.sleep(2000);\r\n        }\r\n    }\r\n```\r\n\r\nExample output:\r\n\r\n```Triggering...\r\nTriggered!\r\nStarting validation...\r\nresult: Hello Stefane\r\n```\r\n\r\nNotice that it does not print the 'Validation Terminated' message.", "url": "https://github.com/reactor/reactor-core/issues/251", "user": "kdvolder", "labels": ["type/bug"], "created": "2016-11-07 17:07:28", "closed": "2016-12-01 11:47:55", "commits": {"c7c816cbdad8c1cbc8e36525d1cebc8c3ee8075f": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d663cc173d9afaa5c95c5f00afbfca51b746d8f7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "0ebd48bdb86fadf97288c8aea1e13d7338de5adb": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 23.00027777777778, "commitsDetails": [{"commitHash": "c7c816cbdad8c1cbc8e36525d1cebc8c3ee8075f", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d663cc173d9afaa5c95c5f00afbfca51b746d8f7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "0ebd48bdb86fadf97288c8aea1e13d7338de5adb", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["836d10cbb3ce70e9bc8a47db9280989c6195431a"], "nameRev": "0ebd48bdb86fadf97288c8aea1e13d7338de5adb tags/v3.0.4.RELEASE~48", "commitMessage": "fix #251 Add doFinally operator\n\nThis commit adds the `doFinally` operator to both Flux and Mono. The\noperator allows a callback to be executed only once after any of the\nonComplete, onError and cancel events. The actual event that triggered\nthe callback is passed to the callback.\n", "commitDateTime": "2016-12-01 12:47:54", "authoredDateTime": "2016-11-30 20:03:25", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "src/main/java/reactor/core/publisher/FluxDoFinally.java", "insertions": 243, "deletions": 0, "lines": 243}, {"filePath": "src/main/java/reactor/core/publisher/FluxDoFinallyFuseable.java", "insertions": 51, "deletions": 0, "lines": 51}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 12, "deletions": 0, "lines": 12}, {"filePath": "src/main/java/reactor/core/publisher/MonoDoFinally.java", "insertions": 51, "deletions": 0, "lines": 51}, {"filePath": "src/main/java/reactor/core/publisher/MonoDoFinallyFuseable.java", "insertions": 52, "deletions": 0, "lines": 52}, {"filePath": "src/test/java/reactor/core/publisher/FluxDoFinallyTest.java", "insertions": 359, "deletions": 0, "lines": 359}, {"filePath": "src/test/java/reactor/core/publisher/MonoDoFinallyTest.java", "insertions": 188, "deletions": 0, "lines": 188}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["0ebd48bdb86fadf97288c8aea1e13d7338de5adb"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 421.0, "deletions": 0.0, "lines": 421.0, "gitFilesChange": 6}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"]}, {"title": "Improve doOn callback failures handling", "body": "Currently peek set done property to true onComplete but when onComplete callbacks fail it might delegate to onError handling which first checks that done property.", "url": "https://github.com/reactor/reactor-core/issues/247", "user": "smaldini", "labels": ["type/bug"], "created": "2016-11-05 13:26:00", "closed": "2016-11-28 10:54:15", "commits": {"39f07e40aaaa6d4597c29544cfcc26e33d3f7aa0": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "6222f3328c258d0dec875aabae668bdd41b6f4b8": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "257396cc57b22cdaaf7d71d57dff790e05669cfb": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 22.00027777777778, "commitsDetails": [{"commitHash": "39f07e40aaaa6d4597c29544cfcc26e33d3f7aa0", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "6222f3328c258d0dec875aabae668bdd41b6f4b8", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "257396cc57b22cdaaf7d71d57dff790e05669cfb", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["14de43ed35ae05a2fa0da42be998036eb3282dfb"], "nameRev": "257396cc57b22cdaaf7d71d57dff790e05669cfb tags/v3.0.4.RELEASE~53", "commitMessage": "fix #247 Improve doOn callback failures handling\n\nThis commit improves the handling of failing callbacks in both FluxPeek\r\nand FluxPeekFuseable, notably:\r\n\r\n - a failing complete callback is correctly processed by the onError\r\n - a failing error callback is caught and propagated to actual's\r\n   onError with the original throwable as a suppressed exception\r\n   (unless the failure is fatal)\r\n - all variants now throwIfFatal first on afterTerminate failure\r\n - errors during onComplete callback now cancels the subscription\r\n\r\nFluxPeekTest now correctly tests non-fuseable internals, using `hide`.\r\nThe FluxPeekFuseable alternative is now tested in a similar way in\r\nFluxPeekFuseableTest (although not with 100% coverage).\r\n\r\nThe handling of failure of the afterTerminate callback is mutualized\r\nin order to improve readability of nested try-catch blocks.\r\n\r\nAdded tests for 2 duplicate issues:\r\nFixes #253\r\nFixes #272", "commitDateTime": "2016-11-28 11:54:14", "authoredDateTime": "2016-11-28 11:54:14", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeek.java", "insertions": 83, "deletions": 17, "lines": 100}, {"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 41, "deletions": 62, "lines": 103}, {"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java", "insertions": 618, "deletions": 0, "lines": 618}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekTest.java", "insertions": 240, "deletions": 9, "lines": 249}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}, {"title": "Fix multisubscription issue with Mono#doAfterTerminate", "body": "Might need a dedicated operator to also optimize doOnSuccess. Besides current doAfterTerminate has a state issues when shared by multiple subscribers", "url": "https://github.com/reactor/reactor-core/issues/246", "user": "smaldini", "labels": ["type/bug"], "created": "2016-11-05 13:09:48", "closed": "2016-12-21 11:51:09", "commits": {"64e6c346204f8d580c28841906345146c05d9783": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "94c5c6c7fc1fd0c26dcc58c15ed53016ae6ec6f3": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "d9ca2fb49fcf8042e38cd605bbc06a41583e05c7": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "a91f079c3aa4a3f3c46d5536362426ded9d7d0b7": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "e52228086acb7614938e692f3794b4166eedebf6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "72687922199b15d04ebe82254ff94828a1b4eb01": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 45.000277777777775, "commitsDetails": [{"commitHash": "64e6c346204f8d580c28841906345146c05d9783", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "94c5c6c7fc1fd0c26dcc58c15ed53016ae6ec6f3", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "d9ca2fb49fcf8042e38cd605bbc06a41583e05c7", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["72ed7599cd236fcdf3469a25336f21664f4c796a"], "nameRev": "d9ca2fb49fcf8042e38cd605bbc06a41583e05c7 tags/v3.0.4.RELEASE~18", "commitMessage": "fix #246 Mono terminal peek without state sharing\n\nThis commit fixes the state sharing of Mono's doOnSuccess, doOnTerminate\r\nand doAfterTerminate by implementing them as a dedicated operator\r\nrather than the more generic FluxPeek with shared callbacks to register\r\nthe value.\r\n", "commitDateTime": "2016-12-21 12:51:08", "authoredDateTime": "2016-12-21 12:51:08", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 3, "deletions": 13, "lines": 16}, {"filePath": "src/main/java/reactor/core/publisher/MonoPeek.java", "insertions": 0, "deletions": 68, "lines": 68}, {"filePath": "src/main/java/reactor/core/publisher/MonoPeekAfter.java", "insertions": 391, "deletions": 0, "lines": 391}, {"filePath": "src/test/java/reactor/core/publisher/MonoPeekAfterTest.java", "insertions": 632, "deletions": 0, "lines": 632}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}, {"commitHash": "a91f079c3aa4a3f3c46d5536362426ded9d7d0b7", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "e52228086acb7614938e692f3794b4166eedebf6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "72687922199b15d04ebe82254ff94828a1b4eb01", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["39ed99e1f6924f16e41bc1efb8e9947836e1ffae"], "nameRev": "72687922199b15d04ebe82254ff94828a1b4eb01 tags/v3.0.4.RELEASE~12", "commitMessage": "rework #246 rename to MonoPeekTerminal + fix SYNC logic\n", "commitDateTime": "2016-12-22 19:20:30", "authoredDateTime": "2016-12-22 17:06:23", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/{MonoPeekAfter.java => MonoPeekTerminal.java}", "insertions": 73, "deletions": 67, "lines": 140}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoPeekTerminal.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.tryOnNext(java.lang.Object)", "TOT": 22, "UPD": 2, "INS": 4, "MOV": 13, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 15, "UPD": 1, "INS": 1, "MOV": 11, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.poll()", "TOT": 17, "UPD": 4, "INS": 5, "MOV": 5, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onNext(java.lang.Object)", "TOT": 6, "UPD": 0, "INS": 0, "MOV": 3, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onComplete()", "TOT": 9, "UPD": 0, "INS": 2, "MOV": 5, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.downstream()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.isEmpty()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.clear()", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d9ca2fb49fcf8042e38cd605bbc06a41583e05c7", "72687922199b15d04ebe82254ff94828a1b4eb01"], "filteredCommitsReason": {"duplicated": 4, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 467.0, "deletions": 148.0, "lines": 615.0, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 80.0, "UPD": 7.0, "INS": 13.0, "MOV": 42.0, "DEL": 18.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 10}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onComplete()", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.poll()", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.isEmpty()", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.clear()", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.downstream()", "reactor.core.publisher.MonoPeekTerminal.MonoTerminalPeekSubscriber.tryOnNext(java.lang.Object)"]}, {"title": "Mono.doOnTerminate is not safe when subscribed multiple times", "body": "", "url": "https://github.com/reactor/reactor-core/issues/242", "user": "smaldini", "labels": ["type/bug"], "created": "2016-10-28 13:37:34", "closed": "2016-10-28 14:20:43", "commits": {"1ebcbef049b751ed397e8a80ca1430649c250679": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "1ebcbef049b751ed397e8a80ca1430649c250679", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["1a0b64d5c1febe73cbd3729e6a76b4e6f063b1fc"], "nameRev": "1ebcbef049b751ed397e8a80ca1430649c250679 tags/v3.0.4.RELEASE~62", "commitMessage": "fix #242 : safe state on multi subscriber for Mono#doOnTerminate\n", "commitDateTime": "2016-10-28 15:20:39", "authoredDateTime": "2016-10-28 15:19:07", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 5, "deletions": 3, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.mapError(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.mapError(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwise(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Class,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.util.function.Predicate,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.timestamp(reactor.core.scheduler.TimedScheduler)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.ofType(java.lang.Class)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminate(java.util.function.BiConsumer)", "TOT": 5, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["1ebcbef049b751ed397e8a80ca1430649c250679"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5, "deletions": 3, "lines": 8, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 17, "UPD": 13, "INS": 1, "MOV": 3, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 11}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Mono.otherwise(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Class,java.lang.Object)", "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Object)", "reactor.core.publisher.Mono.ofType(java.lang.Class)", "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "reactor.core.publisher.Mono.mapError(java.util.function.Function)", "reactor.core.publisher.Mono.otherwiseReturn(java.util.function.Predicate,java.lang.Object)", "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "reactor.core.publisher.Mono.doOnTerminate(java.util.function.BiConsumer)", "reactor.core.publisher.Mono.mapError(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Mono.timestamp(reactor.core.scheduler.TimedScheduler)"]}, {"title": "Multiple calls to Mono.doOnSuccess if on reduce operation", "body": "Multiple calls to Mono.doOnSuccess is called (one with null, one with value) if reduce is used on Scheduled flux.\nTest case: https://gist.github.com/jurna/353a2bd8ff83f0b24f0b5bc772077d61\n", "url": "https://github.com/reactor/reactor-core/issues/230", "user": "jurna", "labels": ["type/bug"], "created": "2016-10-25 11:09:06", "closed": "2016-10-28 14:17:45", "commits": {"3ba8b5559d528ed80c817ea3c1592279f03197b3": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "31211e5b54cf2b706cfc321b839d9a3df4c0d76e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "1ca12b457600bf5bb19ea09d7a8e40b7e7edb630": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "1a0b64d5c1febe73cbd3729e6a76b4e6f063b1fc": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "982d3921c25c4282c844072b9f0bd1e5440130c2": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "3ba8b5559d528ed80c817ea3c1592279f03197b3", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "31211e5b54cf2b706cfc321b839d9a3df4c0d76e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "1ca12b457600bf5bb19ea09d7a8e40b7e7edb630", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["0af3c7c1a3260fdcd48149aa3b1c000cf13a99b3"], "nameRev": "1ca12b457600bf5bb19ea09d7a8e40b7e7edb630 tags/v3.0.3.RELEASE~20", "commitMessage": "fix #230 Fix MonoSubscriber fusion logic\n\nRework the Operators.MonoSubscriber code to use more resilient logic,\r\nnotably using a single volatile state with bitwise logic. This impacts\r\ncomplete(), poll() and request(n) methods mostly.", "commitDateTime": "2016-10-25 18:11:59", "authoredDateTime": "2016-10-25 18:11:59", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Operators.java", "insertions": 107, "deletions": 53, "lines": 160}, {"filePath": "src/test/java/reactor/core/publisher/MonoReduceTest.java", "insertions": 41, "deletions": 0, "lines": 41}, {"filePath": "src/test/java/reactor/core/publisher/MonoSubscriberTest.java", "insertions": 175, "deletions": 0, "lines": 175}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Operators.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber", "TOT": 29, "UPD": 18, "INS": 1, "MOV": 10, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.complete(java.lang.Object)", "TOT": 39, "UPD": 10, "INS": 10, "MOV": 13, "DEL": 6}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.requestFusion(int)", "TOT": 8, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 5}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.cancel()", "TOT": 4, "UPD": 1, "INS": 2, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.isCancelled()", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.isStarted()", "TOT": 2, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.poll()", "TOT": 12, "UPD": 2, "INS": 6, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.isEmpty()", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.request(long)", "TOT": 16, "UPD": 7, "INS": 5, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.onNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Operators.MonoSubscriber.clear()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "MonoReduceTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoReduceTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoReduceTest.should_reduce_to_10_events()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoReduceTest.blockingOp(java.lang.Integer,java.lang.Integer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoSubscriberTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoSubscriberTest", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "1a0b64d5c1febe73cbd3729e6a76b4e6f063b1fc", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["36bbec74230e5dd05b0627a46d7ef1f480801332"], "nameRev": "1a0b64d5c1febe73cbd3729e6a76b4e6f063b1fc tags/v3.0.4.RELEASE~63", "commitMessage": "Fix #230: the onNext/onComplete callback reversal in async-fused sequences (#243)\n\n", "commitDateTime": "2016-10-28 15:17:43", "authoredDateTime": "2016-10-28 16:17:43", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 60, "deletions": 50, "lines": 110}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekTest.java", "insertions": 45, "deletions": 3, "lines": 48}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.onComplete()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 3, "UPD": 0, "INS": 2, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxPeekTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekTest.should_reduce_to_10_events()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekTest.should_reduce_to_10_events_conditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekTest.blockingOp(java.lang.Integer,java.lang.Integer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "982d3921c25c4282c844072b9f0bd1e5440130c2", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["1ebcbef049b751ed397e8a80ca1430649c250679"], "nameRev": "982d3921c25c4282c844072b9f0bd1e5440130c2 tags/v3.0.4.RELEASE~61", "commitMessage": "Reformat fix #230\n", "commitDateTime": "2016-10-28 15:26:02", "authoredDateTime": "2016-10-28 15:26:02", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 172, "deletions": 129, "lines": 301}, {"filePath": "src/test/java/reactor/core/publisher/FluxPeekTest.java", "insertions": 115, "deletions": 99, "lines": 214}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["1ca12b457600bf5bb19ea09d7a8e40b7e7edb630", "982d3921c25c4282c844072b9f0bd1e5440130c2"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 279.0, "deletions": 182.0, "lines": 461.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 122.0, "UPD": 44.0, "INS": 29.0, "MOV": 30.0, "DEL": 19.0, "spoonFilesChanged": 1, "spoonMethodsChanged": 11}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Operators.MonoSubscriber.isEmpty()", "reactor.core.publisher.Operators.MonoSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.Operators.MonoSubscriber.cancel()", "reactor.core.publisher.Operators.MonoSubscriber.request(long)", "reactor.core.publisher.Operators.MonoSubscriber.complete(java.lang.Object)", "reactor.core.publisher.Operators.MonoSubscriber.poll()", "reactor.core.publisher.Operators.MonoSubscriber.clear()", "reactor.core.publisher.Operators.MonoSubscriber.isCancelled()", "reactor.core.publisher.Operators.MonoSubscriber.requestFusion(int)", "reactor.core.publisher.Operators.MonoSubscriber.isStarted()", "reactor.core.publisher.Operators.MonoSubscriber"]}, {"title": "Unattributed code in RingBuffer", "body": "https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/publisher/RingBuffer.java\n\nLooks like at some point this was forked from the @LMAX-Exchange disruptor, yet the copyright only acknowledges Pivotal\n", "url": "https://github.com/reactor/reactor-core/issues/229", "user": "nitsanw", "labels": ["type/bug"], "created": "2016-10-25 08:01:53", "closed": "2016-10-25 08:37:05", "commits": {"0af3c7c1a3260fdcd48149aa3b1c000cf13a99b3": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0af3c7c1a3260fdcd48149aa3b1c000cf13a99b3", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["3caf7a831ebcd7438ce251c7567adcad1389fa42"], "nameRev": "0af3c7c1a3260fdcd48149aa3b1c000cf13a99b3 tags/v3.0.3.RELEASE~21", "commitMessage": "fix #229 : ring buffer code missing attribution to https://lmax-exchange.github.io/disruptor/\n", "commitDateTime": "2016-10-25 09:36:17", "authoredDateTime": "2016-10-25 09:36:17", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/RingBuffer.java", "insertions": 3, "deletions": 0, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "RingBuffer.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0af3c7c1a3260fdcd48149aa3b1c000cf13a99b3"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 0, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"]}, {"title": "Images in javadoc too big", "body": "Chrome Browser\n![flux__reactor-core_3_0_2_release_api_](https://cloud.githubusercontent.com/assets/4996289/19563186/09c916a2-96d7-11e6-8308-740f442cd9b2.png)\n", "url": "https://github.com/reactor/reactor-core/issues/224", "user": "natros", "labels": ["type/bug"], "created": "2016-10-20 14:09:37", "closed": "2016-10-26 15:42:53", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "distinctUntilChanged(..) always filters under certain conditions.", "body": "Hello reactor team:\n\nCertain combinations of operators cause distinctUntilChanged(...) to incorrectly filter values that should pass through. I've provided a simple test case to demonstrate the issue.\n\nIf you look at [line 228](https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java#L228) in FluxDistinctUntilChanged (onNext method), you'll see the following statement + condition:\n\n```\nlastKey = k;\nif( Objects.equals(lastKey, k))\n{\n    s.request(1);\n} ...\n```\n\nThis condition above will always be true, and therefore will always filter. I suspect the solution is as simple as moving lastKey = k; after the conditional or inside the branches, depending on how the content of that conditional works. I'll leave that decision to the experts.\n\nhttps://gist.github.com/masterav10/ea15689763150c31df42fc82b4ca148d\n3.0.2.RELEASE \nWindows 7/10 x64 \nOracle JDK 8\n", "url": "https://github.com/reactor/reactor-core/issues/215", "user": "masterav10", "labels": ["type/bug"], "created": "2016-10-14 21:49:00", "closed": "2016-10-15 18:16:30", "commits": {"40569277cedb63df2180d89b7c72a1d500cc3501": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "40569277cedb63df2180d89b7c72a1d500cc3501", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["6f95596204f3ec951f775afd50761036a3d8fd5e"], "nameRev": "40569277cedb63df2180d89b7c72a1d500cc3501 tags/v3.0.3.RELEASE~30", "commitMessage": "fix #215, sync with RSC fixes by @akarnokd\n", "commitDateTime": "2016-10-15 19:16:25", "authoredDateTime": "2016-10-15 19:16:25", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java", "insertions": 1, "deletions": 18, "lines": 19}, {"filePath": "src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java", "insertions": 16, "deletions": 0, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxDistinctUntilChanged.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onNext(java.lang.Object)", "TOT": 8, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 6}]}, {"spoonFilePath": "FluxDistinctUntilChangedTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxDistinctUntilChangedTest.allDistinctConditional()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["40569277cedb63df2180d89b7c72a1d500cc3501"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 18, "lines": 19, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 8, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 6, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber.onNext(java.lang.Object)"]}, {"title": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber#poll does not use Operators.onOperatorError", "body": "Exceptions are rather caught and handled in the previous operator.\n", "url": "https://github.com/reactor/reactor-core/issues/205", "user": "dfeist", "labels": ["type/bug"], "created": "2016-10-11 11:51:32", "closed": "2016-10-11 12:36:09", "commits": {"82b07963558e34d0fbfc7010f0b090e057c0c4c9": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "064407e8dbdf5d1543b8171eb3883db7f8258f2d": {"commitGHEventType": "referenced", "commitUser": "smaldini"}, "8d655340ea0cc3a030dd33d34165f2e8189fab6d": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "82b07963558e34d0fbfc7010f0b090e057c0c4c9", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["de3a2bbbdadc767ba568373feec5d5a72a568e65"], "nameRev": "82b07963558e34d0fbfc7010f0b090e057c0c4c9 tags/v3.0.3.RELEASE~37^2", "commitMessage": "Fixes #205 reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber#poll does not use Operators.onOperatorError\n", "commitDateTime": "2016-10-11 13:23:36", "authoredDateTime": "2016-10-11 13:23:36", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 13, "deletions": 3, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "064407e8dbdf5d1543b8171eb3883db7f8258f2d", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["ecc28f29e5b59dd35033bf127dee2a8b99d468af", "82b07963558e34d0fbfc7010f0b090e057c0c4c9"], "nameRev": "064407e8dbdf5d1543b8171eb3883db7f8258f2d tags/v3.0.3.RELEASE~37", "commitMessage": "Merge pull request #207 from dfeist/issue-205\n\nFixes #205 reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscr\u2026", "commitDateTime": "2016-10-11 13:36:07", "authoredDateTime": "2016-10-11 13:36:07", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 13, "deletions": 3, "lines": 16}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "8d655340ea0cc3a030dd33d34165f2e8189fab6d", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["c876c401d705c23287449552d951ae8f288840d4", "660602cff86937aff2dfcb718cd2cb82c4c158e4"], "nameRev": "8d655340ea0cc3a030dd33d34165f2e8189fab6d tags/v3.0.3.RELEASE~33", "commitMessage": "Merge pull request #208 from dfeist/issue-205\n\nFixes #205 reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscr\u2026", "commitDateTime": "2016-10-11 17:42:08", "authoredDateTime": "2016-10-11 17:42:08", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxPeekFuseable.java", "insertions": 2, "deletions": 2, "lines": 4}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxPeekFuseable.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()", "TOT": 4, "UPD": 2, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["82b07963558e34d0fbfc7010f0b090e057c0c4c9"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 2, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 13, "deletions": 3, "lines": 16, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxPeekFuseable.PeekFuseableSubscriber.poll()", "reactor.core.publisher.FluxPeekFuseable.PeekFuseableConditionalSubscriber.poll()"]}, {"title": "Self Suppression IllegalArgumentException when 'onErrorResume' propagates existing exception", "body": "Sometime conditional logic is required to determine if an error signal should be handled or propagated.  The easiest and most flexible way to do this is via the use of something like this:\n\n```\nflux.onErrorResume(e -> {\n   if(something){\n      return just(someValue);\n   else {\n      throw propagate(e);\n   });\n```\n\nIn this above example the else clause propagates the existing exception.  This fails though due to FluxResume attempting to do `e.addSuppressed(e)` [here](https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/publisher/FluxResume.java#L92)\n", "url": "https://github.com/reactor/reactor-core/issues/204", "user": "dfeist", "labels": ["type/bug"], "created": "2016-10-11 11:45:31", "closed": "2016-10-11 12:28:20", "commits": {"6327441f30b599594a31db4d5e1a4604274e5219": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "4ac0d2192682720d120ad6b6abfdc99dd17d2fa5": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "6327441f30b599594a31db4d5e1a4604274e5219", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["de3a2bbbdadc767ba568373feec5d5a72a568e65"], "nameRev": "6327441f30b599594a31db4d5e1a4604274e5219 tags/v3.0.3.RELEASE~40^2", "commitMessage": "Fixes #204 Self Suppression IllegalArgumentException when 'onErrorResume' propagates existing exception\n", "commitDateTime": "2016-10-11 13:14:46", "authoredDateTime": "2016-10-11 13:07:54", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxResume.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 15, "deletions": 0, "lines": 15}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxResume.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxResume.ResumeSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxResumeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxResumeTest.errorPropagated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "4ac0d2192682720d120ad6b6abfdc99dd17d2fa5", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["de3a2bbbdadc767ba568373feec5d5a72a568e65", "6327441f30b599594a31db4d5e1a4604274e5219"], "nameRev": "4ac0d2192682720d120ad6b6abfdc99dd17d2fa5 tags/v3.0.3.RELEASE~40", "commitMessage": "Merge pull request #206 from dfeist/issue-204\n\nFixes #204 Self Suppression IllegalArgumentException when 'onErrorRes\u2026", "commitDateTime": "2016-10-11 13:28:19", "authoredDateTime": "2016-10-11 13:28:19", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxResume.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/FluxResumeTest.java", "insertions": 15, "deletions": 0, "lines": 15}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxResume.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxResume.ResumeSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxResumeTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxResumeTest.errorPropagated()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["6327441f30b599594a31db4d5e1a4604274e5219"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 1, "lines": 4, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxResume.ResumeSubscriber.onError(java.lang.Throwable)"]}, {"title": "MonoProcessor doesn't propagate cancel upstream if manually disposed", "body": "", "url": "https://github.com/reactor/reactor-core/issues/202", "user": "smaldini", "labels": ["type/bug"], "created": "2016-10-04 14:56:31", "closed": "2016-10-04 15:28:33", "commits": {"578864fddad3757260d3613d533b876345e5fc58": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "578864fddad3757260d3613d533b876345e5fc58", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["dae04734895aa5118d04d70927c90b1a9fe68feb"], "nameRev": "578864fddad3757260d3613d533b876345e5fc58 tags/v3.0.3.RELEASE~48", "commitMessage": "fix #202 : Do not override subscription with a cancelled one.\n", "commitDateTime": "2016-10-04 16:28:30", "authoredDateTime": "2016-10-04 16:25:38", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoProcessor.java", "insertions": 0, "deletions": 1, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoProcessor.cancel()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["578864fddad3757260d3613d533b876345e5fc58"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 0, "deletions": 1, "lines": 1, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoProcessor.cancel()"]}, {"title": "Publisher#then() should allow type mapping, like #thenMany() does", "body": "The `then` family of methods is inconsistent:\n\n```\nPublisher<X>#then(Publisher<X>) p)\nvs\nPublisher<X>#thenMany(Publisher<Y> p)\n```\n\nit should be possible to change types in the Mono (`then()`) case as well.\n", "url": "https://github.com/reactor/reactor-core/issues/198", "user": "ericbottard", "labels": ["type/bug", "type/enhancement"], "created": "2016-09-28 12:38:36", "closed": "2016-10-26 17:28:50", "commits": {"cbdc64d348bbb79a372502bb47b77e97da4e6c2c": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "1c09230d82f5390d0899f57cc8e3bfe029f4399e": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "dbc8ba23c5cf035ef26e9951fcbc7dd91ad60e00": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 28.00027777777778, "commitsDetails": [{"commitHash": "cbdc64d348bbb79a372502bb47b77e97da4e6c2c", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "1c09230d82f5390d0899f57cc8e3bfe029f4399e", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "dbc8ba23c5cf035ef26e9951fcbc7dd91ad60e00", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["554a4aa17675bd72f74edb341f7bd542f52177f2"], "nameRev": "dbc8ba23c5cf035ef26e9951fcbc7dd91ad60e00 tags/v3.0.3.RELEASE~14", "commitMessage": "fix #198 Better synchronize then/thenMany API between Flux and Mono\n\nThis commit attempts to better synchronize the APIs for then/thenMany\r\nbetween Flux and Mono, where possible:\r\n\r\n - a `then(Mono<V>)` method was added to Flux.\r\n - the `thenMany(Supplier<Mono>)` method in Mono now accepts a\r\n `Supplier<Publisher>` instead (the signature is now more permissive but\r\n backward compatible).\r\n\r\n Javadocs were reworded to better convey what exactly happens with\r\n these operators.", "commitDateTime": "2016-10-26 19:28:49", "authoredDateTime": "2016-10-26 19:28:49", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 40, "deletions": 20, "lines": 60}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 23, "deletions": 19, "lines": 42}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "insertions": 31, "deletions": 1, "lines": 32}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.then(reactor.core.publisher.Mono)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.thenMany(java.util.function.Supplier)", "TOT": 3, "UPD": 2, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThenMono()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThenManySameType()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.scenarios.FluxTests.testThenManyDifferentType()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.MonoTests.testMonoThenManySupplier()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["dbc8ba23c5cf035ef26e9951fcbc7dd91ad60e00"], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 63.0, "deletions": 39.0, "lines": 102.0, "gitFilesChange": 2}, "spoonStatsSummary": {"TOT": 4.0, "UPD": 2.0, "INS": 2.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 2, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.then(reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.thenMany(java.util.function.Supplier)"]}, {"title": "Mono#then(Publisher<T>) should act after complete alone too", "body": "", "url": "https://github.com/reactor/reactor-core/issues/197", "user": "smaldini", "labels": ["type/bug"], "created": "2016-09-28 12:02:31", "closed": "2016-10-06 13:12:02", "commits": {}, "ttf": 8.000277777777777, "commitsDetails": []}, {"title": "Flux.buffer() has wrong doc comment", "body": "https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/publisher/Flux.java#L1611\n\nIt returns `Flux<List<T>>`, but its doc comment says it returns a `Mono`.\n", "url": "https://github.com/reactor/reactor-core/issues/194", "user": "dynaxis", "labels": ["type/bug"], "created": "2016-09-27 16:54:57", "closed": "2016-10-06 13:11:17", "commits": {"42a75916bc0a78ed99d0568240e52329ac55c6ec": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 8.000277777777777, "commitsDetails": [{"commitHash": "42a75916bc0a78ed99d0568240e52329ac55c6ec", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["f9098a0b5b5106c7e0f3a3db94589d9b73653f93"], "nameRev": "42a75916bc0a78ed99d0568240e52329ac55c6ec tags/v3.0.3.RELEASE~46", "commitMessage": "fix #194 fix javadoc\n", "commitDateTime": "2016-10-06 14:11:10", "authoredDateTime": "2016-10-06 14:11:10", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["42a75916bc0a78ed99d0568240e52329ac55c6ec"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 1, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"]}, {"title": "Flux#last should enforce onNext signal", "body": "", "url": "https://github.com/reactor/reactor-core/issues/169", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-28 14:54:27", "closed": "2016-08-28 14:55:15", "commits": {"cf751b92698a463d8fb6472f99c2c5c977408ddb": {"commitGHEventType": "closed", "commitUser": "smaldini"}, "49ba8315a11b467304ecc21f30c70767ba7b4802": {"commitGHEventType": "referenced", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "cf751b92698a463d8fb6472f99c2c5c977408ddb", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["8f98968e4b45dda4df8e7272c003fa3b4258655d"], "nameRev": "cf751b92698a463d8fb6472f99c2c5c977408ddb tags/v3.0.1.RELEASE~28", "commitMessage": "- Fix #169 Enforce one signal at least in Flux#last\n- GIve minimum boundary to buffer size\n", "commitDateTime": "2016-08-28 15:55:06", "authoredDateTime": "2016-08-28 15:55:06", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/FluxTakeLast.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/main/java/reactor/core/publisher/FluxTakeLastOne.java", "insertions": 0, "deletions": 47, "lines": 47}, {"filePath": "src/main/java/reactor/core/publisher/MonoTakeLastOne.java", "insertions": 16, "deletions": 4, "lines": 20}, {"filePath": "src/main/java/reactor/util/concurrent/QueueSupplier.java", "insertions": 4, "deletions": 4, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.takeLast(int)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "FluxTakeLast.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTakeLast.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTakeLastOne.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTakeLastOne", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "MonoTakeLastOne.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoTakeLastOne", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOne.subscribe(reactor.core.publisher.Subscriber)", "TOT": 2, "UPD": 2, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber", "TOT": 5, "UPD": 2, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber.onSubscribe(reactor.core.publisher.Subscription)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber.onComplete()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "QueueSupplier.java", "spoonMethods": [{"spoonMethodName": "reactor.util.concurrent.QueueSupplier", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}, {"commitHash": "49ba8315a11b467304ecc21f30c70767ba7b4802", "commitGHEventType": "referenced", "commitUser": "smaldini", "commitParents": ["cf751b92698a463d8fb6472f99c2c5c977408ddb"], "nameRev": "49ba8315a11b467304ecc21f30c70767ba7b4802 tags/v3.0.1.RELEASE~27", "commitMessage": "- Tweak #169 Fix potential misleading Fuseable\n", "commitDateTime": "2016-08-28 15:58:19", "authoredDateTime": "2016-08-28 15:58:19", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 3, "deletions": 0, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/FluxTakeLast.java", "insertions": 3, "deletions": 4, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/FluxTakeLastOne.java", "insertions": 47, "deletions": 0, "lines": 47}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.takeLast(int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxTakeLast.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTakeLast.subscribe(org.reactivestreams.Subscriber)", "TOT": 5, "UPD": 0, "INS": 1, "MOV": 3, "DEL": 1}]}, {"spoonFilePath": "FluxTakeLastOne.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxTakeLastOne", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["cf751b92698a463d8fb6472f99c2c5c977408ddb", "49ba8315a11b467304ecc21f30c70767ba7b4802"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 2, "gitStatsSummary": {"insertions": 74, "deletions": 63, "lines": 137, "gitFilesChange": 5}, "spoonStatsSummary": {"TOT": 25, "UPD": 7, "INS": 9, "MOV": 6, "DEL": 3, "spoonFilesChanged": 5, "spoonMethodsChanged": 9}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/util/concurrent"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxTakeLast.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.Flux.takeLast(int)", "reactor.core.publisher.FluxTakeLastOne", "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber.onComplete()", "reactor.core.publisher.MonoTakeLastOne.subscribe(reactor.core.publisher.Subscriber)", "reactor.core.publisher.MonoTakeLastOne", "reactor.util.concurrent.QueueSupplier", "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber.onSubscribe(reactor.core.publisher.Subscription)", "reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber"]}, {"title": "Flux subscribe(prefetch) is not correctly applied (prefetch = Long.MAX)", "body": "", "url": "https://github.com/reactor/reactor-core/issues/167", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-26 02:16:13", "closed": "2016-08-26 02:41:56", "commits": {"7f9d8588ee60d4b9aebf462e20fd4aa88e00240e": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "7f9d8588ee60d4b9aebf462e20fd4aa88e00240e", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["c8557525dd4d1e1c73608348d50e66a3a257f21b"], "nameRev": "7f9d8588ee60d4b9aebf462e20fd4aa88e00240e tags/v3.0.1.RELEASE~35", "commitMessage": "fix #167 Tweaks and correctly apply publishOn on prefetched Flux.subscribe\nAdd simple subscribe null consumer check\nAdd cancel on first for Mono.subscribe(consumer...)\n", "commitDateTime": "2016-08-26 03:41:47", "authoredDateTime": "2016-08-26 03:41:47", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 17, "deletions": 16, "lines": 33}, {"filePath": "src/main/java/reactor/core/publisher/LambdaFirstSubscriber.java", "insertions": 167, "deletions": 0, "lines": 167}, {"filePath": "src/main/java/reactor/core/publisher/LambdaSubscriber.java", "insertions": 37, "deletions": 76, "lines": 113}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 6, "deletions": 2, "lines": 8}, {"filePath": "src/test/java/reactor/core/publisher/tck/FluxWithSchedulerTests.java", "insertions": 1, "deletions": 1, "lines": 2}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function,int)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable,int)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.groupJoin(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.join(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LambdaFirstSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LambdaFirstSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "LambdaSubscriber.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.cancel()", "TOT": 6, "UPD": 1, "INS": 0, "MOV": 4, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber", "TOT": 9, "UPD": 2, "INS": 2, "MOV": 3, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.dispose()", "TOT": 7, "UPD": 3, "INS": 1, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.requestMore(long)", "TOT": 6, "UPD": 3, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.doSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.onComplete()", "TOT": 5, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 3}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.onError(java.lang.Throwable)", "TOT": 9, "UPD": 0, "INS": 2, "MOV": 6, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.onNext(java.lang.Object)", "TOT": 9, "UPD": 0, "INS": 0, "MOV": 8, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.doNext(java.lang.Object)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.LambdaSubscriber.isTerminated()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer,java.util.function.Consumer)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxWithSchedulerTests.java", "spoonMethods": []}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["7f9d8588ee60d4b9aebf462e20fd4aa88e00240e"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 227, "deletions": 94, "lines": 321, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 75, "UPD": 11, "INS": 20, "MOV": 28, "DEL": 16, "spoonFilesChanged": 4, "spoonMethodsChanged": 22}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,java.util.function.Consumer)", "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer)", "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,int)", "reactor.core.publisher.LambdaSubscriber.isTerminated()", "reactor.core.publisher.LambdaSubscriber.dispose()", "reactor.core.publisher.Flux.join(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)", "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable)", "reactor.core.publisher.LambdaSubscriber.doNext(java.lang.Object)", "reactor.core.publisher.LambdaSubscriber.doSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer)", "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer,java.util.function.Consumer)", "reactor.core.publisher.LambdaSubscriber.cancel()", "reactor.core.publisher.LambdaSubscriber.onComplete()", "reactor.core.publisher.LambdaSubscriber", "reactor.core.publisher.LambdaFirstSubscriber", "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer,java.util.function.Consumer,java.lang.Runnable,int)", "reactor.core.publisher.Flux.sampleTimeout(java.util.function.Function,int)", "reactor.core.publisher.LambdaSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.LambdaSubscriber.requestMore(long)", "reactor.core.publisher.LambdaSubscriber.onNext(java.lang.Object)", "reactor.core.publisher.LambdaSubscriber.onSubscribe(org.reactivestreams.Subscription)", "reactor.core.publisher.Flux.groupJoin(org.reactivestreams.Publisher,java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)"]}, {"title": "Subscribers to a windowing `Flux` are running on an interrupted thread", "body": "This can be observed by running:\n\n```\npublic class FluxSample {\n\n    public static void main(String[] args) throws IOException {\n        Flux.interval(Duration.ofMillis(500))\n                .window(Duration.ofSeconds(5), Duration.ofSeconds(2))\n                .flatMap(w -> w.reduce(\"\", (x,y)-> x + \"-\" + y))\n                .subscribe(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) {\n                        System.out.println(Thread.currentThread());\n                        System.out.println(Thread.currentThread().isInterrupted());\n                    }\n                });\n        System.in.read();\n    }\n}\n```\n\nAs a result, any interruptible call made from within `accept` will be automatically interrupted. \nNote that this doesn't happy for count-based windowing.\n", "url": "https://github.com/reactor/reactor-core/issues/159", "user": "mbogoevici", "labels": ["type/bug"], "created": "2016-08-24 01:22:19", "closed": "2016-08-24 14:33:59", "commits": {"de003cc38697730f8ca5d81e4ec2d30f6d262122": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "de003cc38697730f8ca5d81e4ec2d30f6d262122", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["3bb7956eec7918289b8a6c74cc93159f24957988"], "nameRev": "de003cc38697730f8ca5d81e4ec2d30f6d262122 tags/v3.0.1.RELEASE~48", "commitMessage": "fix #159 Refine interruptability fixed-worker Schedulers\n- Cancel(false) on future for single schedulers and parallel schedulers\n- Cancel(option) on executor service scheduler\n- if shutdown marker available, cancel(true)\n- avoid extra cancel in MonoDelay\n", "commitDateTime": "2016-08-24 15:33:52", "authoredDateTime": "2016-08-24 15:33:52", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoDelay.java", "insertions": 4, "deletions": 3, "lines": 7}, {"filePath": "src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java", "insertions": 9, "deletions": 5, "lines": 14}, {"filePath": "src/main/java/reactor/core/scheduler/ParallelScheduler.java", "insertions": 3, "deletions": 3, "lines": 6}, {"filePath": "src/main/java/reactor/core/scheduler/Schedulers.java", "insertions": 17, "deletions": 1, "lines": 18}, {"filePath": "src/main/java/reactor/core/scheduler/SingleScheduler.java", "insertions": 4, "deletions": 4, "lines": 8}, {"filePath": "src/main/java/reactor/core/scheduler/SingleTimedScheduler.java", "insertions": 4, "deletions": 4, "lines": 8}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoDelay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoDelay.MonoDelayRunnable.run()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.MonoDelay.MonoDelayRunnable", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoDelay.MonoDelayRunnable.cancel()", "TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "ExecutorServiceScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.createWorker()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.schedule(java.lang.Runnable)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.ScheduledRunnable.doCancel(java.util.concurrent.Future)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ExecutorServiceScheduler.ExecutorServiceWorker", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "ParallelScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.ParallelScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ParallelScheduler.ParallelWorker.ParallelWorkerTask.setFuture(java.util.concurrent.Future)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.ParallelScheduler.ParallelWorker.ParallelWorkerTask.dispose()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}, {"spoonFilePath": "Schedulers.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService)", "TOT": 4, "UPD": 1, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService,boolean)", "TOT": 3, "UPD": 0, "INS": 3, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SingleScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SingleScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.setFuture(java.util.concurrent.Future)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.cancelFuture()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.dispose()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "SingleTimedScheduler.java", "spoonMethods": [{"spoonMethodName": "reactor.core.scheduler.SingleTimedScheduler.schedule(java.lang.Runnable)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleTimedScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleTimedScheduler.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.scheduler.SingleTimedScheduler.TimedPeriodicScheduledRunnable.doCancel(java.util.concurrent.Future)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["de003cc38697730f8ca5d81e4ec2d30f6d262122"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 41, "deletions": 20, "lines": 61, "gitFilesChange": 6}, "spoonStatsSummary": {"TOT": 39, "UPD": 11, "INS": 18, "MOV": 5, "DEL": 5, "spoonFilesChanged": 6, "spoonMethodsChanged": 21}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher", "src/main/java/reactor/core/scheduler"], "changesInPackagesSPOON": ["reactor.core.scheduler.SingleTimedScheduler.schedule(java.lang.Runnable)", "reactor.core.scheduler.ParallelScheduler.schedule(java.lang.Runnable)", "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.cancelFuture()", "reactor.core.scheduler.ExecutorServiceScheduler.createWorker()", "reactor.core.publisher.MonoDelay.MonoDelayRunnable.run()", "reactor.core.scheduler.ExecutorServiceScheduler.schedule(java.lang.Runnable)", "reactor.core.scheduler.ExecutorServiceScheduler", "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.dispose()", "reactor.core.scheduler.SingleTimedScheduler.TimedPeriodicScheduledRunnable.doCancel(java.util.concurrent.Future)", "reactor.core.scheduler.SingleScheduler.schedule(java.lang.Runnable)", "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService)", "reactor.core.scheduler.ParallelScheduler.ParallelWorker.ParallelWorkerTask.setFuture(java.util.concurrent.Future)", "reactor.core.publisher.MonoDelay.MonoDelayRunnable", "reactor.core.scheduler.ParallelScheduler.ParallelWorker.ParallelWorkerTask.dispose()", "reactor.core.scheduler.SingleScheduler.SingleWorker.SingleWorkerTask.setFuture(java.util.concurrent.Future)", "reactor.core.scheduler.SingleTimedScheduler.schedulePeriodically(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)", "reactor.core.scheduler.ExecutorServiceScheduler.ScheduledRunnable.doCancel(java.util.concurrent.Future)", "reactor.core.scheduler.Schedulers.fromExecutorService(java.util.concurrent.ExecutorService,boolean)", "reactor.core.scheduler.ExecutorServiceScheduler.ExecutorServiceWorker", "reactor.core.publisher.MonoDelay.MonoDelayRunnable.cancel()", "reactor.core.scheduler.SingleTimedScheduler.schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)"]}, {"title": "NPE on filtered hooks", "body": "`Hooks.onOperator(hooks -> hooks.ifName(\"peek\").log(\"reactor.\", Level.INFO))` fails with NPE\n", "url": "https://github.com/reactor/reactor-core/issues/154", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-23 00:02:44", "closed": "2016-08-23 00:02:59", "commits": {"0c3bf8c2518ef40174b86c1dc31424cd75f2ffce": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "0c3bf8c2518ef40174b86c1dc31424cd75f2ffce", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["aca14f3757e4ba6b230e1ada1c74da83bfff4eaa"], "nameRev": "0c3bf8c2518ef40174b86c1dc31424cd75f2ffce tags/v3.0.1.RELEASE~53", "commitMessage": "fix #154 NPE on filtered Hooks\n", "commitDateTime": "2016-08-23 01:02:54", "authoredDateTime": "2016-08-23 01:02:54", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Hooks.java", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Hooks.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Hooks.OperatorHook.log(java.lang.String,java.util.logging.Level,reactor.core.publisher.SignalType[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["0c3bf8c2518ef40174b86c1dc31424cd75f2ffce"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 0, "lines": 1, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Hooks.OperatorHook.log(java.lang.String,java.util.logging.Level,reactor.core.publisher.SignalType[])"]}, {"title": "Buffer boundary issue with early completion", "body": "Reported first on https://gitter.im/reactor/reactor?at=57bb5dcb87f779f0691b64d0\n", "url": "https://github.com/reactor/reactor-core/issues/152", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-22 22:19:16", "closed": "2016-08-22 22:20:40", "commits": {"d38d1ea4c7bdbf11b3039b1a2fee086d222e17fa": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "d38d1ea4c7bdbf11b3039b1a2fee086d222e17fa", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["441961b258537839f2bfaca705620b5b903374b1"], "nameRev": "d38d1ea4c7bdbf11b3039b1a2fee086d222e17fa tags/v3.0.1.RELEASE~57", "commitMessage": "fix #152\n", "commitDateTime": "2016-08-22 23:20:31", "authoredDateTime": "2016-08-22 23:20:31", "commitGitStats": [{"filePath": "src/main/java/reactor/core/Exceptions.java", "insertions": 0, "deletions": 3, "lines": 3}, {"filePath": "src/main/java/reactor/core/publisher/FluxBufferBoundary.java", "insertions": 26, "deletions": 5, "lines": 31}, {"filePath": "src/main/java/reactor/core/publisher/MonoCollectList.java", "insertions": 91, "deletions": 83, "lines": 174}, {"filePath": "src/test/groovy/reactor/core/FluxSpec.groovy", "insertions": 23, "deletions": 0, "lines": 23}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions.throwIfFatal(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 2}]}, {"spoonFilePath": "FluxBufferBoundary.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.otherNext()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.onComplete()", "TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoCollectList.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoBufferAllSubscriber.onError(java.lang.Throwable)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoCollectList.MonoBufferAllSubscriber.onComplete()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["d38d1ea4c7bdbf11b3039b1a2fee086d222e17fa"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 117, "deletions": 91, "lines": 208, "gitFilesChange": 3}, "spoonStatsSummary": {"TOT": 15, "UPD": 0, "INS": 10, "MOV": 2, "DEL": 3, "spoonFilesChanged": 3, "spoonMethodsChanged": 6}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core", "src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.otherNext()", "reactor.core.publisher.MonoCollectList.MonoBufferAllSubscriber.onComplete()", "reactor.core.Exceptions.throwIfFatal(java.lang.Throwable)", "reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.onComplete()", "reactor.core.publisher.MonoCollectList.MonoBufferAllSubscriber.onError(java.lang.Throwable)", "reactor.core.publisher.FluxBufferBoundary.BufferBoundaryMain.onError(java.lang.Throwable)"]}, {"title": "Add missing concatDelayError", "body": "", "url": "https://github.com/reactor/reactor-core/issues/148", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-15 17:02:13", "closed": "2016-08-15 17:02:27", "commits": {"58a5ee3f9059b53c90b61a36ca4926c3e72538ac": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "58a5ee3f9059b53c90b61a36ca4926c3e72538ac", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["ef8d97e7ea16a07071637d818074330909398600"], "nameRev": "58a5ee3f9059b53c90b61a36ca4926c3e72538ac tags/v3.0.0.RELEASE~14", "commitMessage": "fix #148 + concatDelayError\n", "commitDateTime": "2016-08-15 18:02:23", "authoredDateTime": "2016-08-15 18:02:23", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/Flux.java", "insertions": 83, "deletions": 0, "lines": 83}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Flux.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher,boolean,int)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["58a5ee3f9059b53c90b61a36ca4926c3e72538ac"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 83, "deletions": 0, "lines": 83, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4, "UPD": 0, "INS": 4, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 4}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher)", "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher,boolean,int)", "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher[])", "reactor.core.publisher.Flux.concatDelayError(org.reactivestreams.Publisher,int)"]}, {"title": "Fix Map, Peek and Filter Fusion on thread barrier", "body": "", "url": "https://github.com/reactor/reactor-core/issues/147", "user": "smaldini", "labels": ["type/bug"], "created": "2016-08-15 16:25:57", "closed": "2016-08-15 16:25:59", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "NPE when creating Mono<Void> from CompletableFuture<Void>", "body": "When creating a Mono from a CompletableFuture<Void> an NPE is thrown since MonoCompletableFuture does not accept a null value.\n\n``` java\nCompletableFuture<Void> myFuture = CompletableFuture.runAsync(() -> System.out.println(\"Doing some background work without result ...\"));\nMono<Void> myMono = Mono.fromFuture(myFuture);\nmyMono.blockMillis(100);\n```\n", "url": "https://github.com/reactor/reactor-core/issues/141", "user": "stylismo", "labels": ["type/bug", "type/enhancement"], "created": "2016-08-09 08:47:35", "closed": "2016-08-09 13:30:17", "commits": {"c7b236674ef4418d10e798eb946aabae92da1a42": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "c7b236674ef4418d10e798eb946aabae92da1a42", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["6ee75200da9255032896ca34022dd3484f92de9c"], "nameRev": "c7b236674ef4418d10e798eb946aabae92da1a42 tags/v3.0.0.RC2~22", "commitMessage": "fix #141 : Relax NPE rule on empty CompletableFuture and complete Mono\n", "commitDateTime": "2016-08-09 14:30:08", "authoredDateTime": "2016-08-09 14:30:08", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/MonoCompletableFuture.java", "insertions": 1, "deletions": 1, "lines": 2}, {"filePath": "src/test/groovy/reactor/core/PublisherConversionSpec.groovy", "insertions": 11, "deletions": 0, "lines": 11}], "commitSpoonAstDiffStats": [{"spoonFilePath": "MonoCompletableFuture.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoCompletableFuture.subscribe(org.reactivestreams.Subscriber)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["c7b236674ef4418d10e798eb946aabae92da1a42"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 1, "deletions": 1, "lines": 2, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.MonoCompletableFuture.subscribe(org.reactivestreams.Subscriber)"]}, {"title": "Flux.create with OverflowStrategy.LATEST duplicates elements", "body": "The following code snippet:\n\n``` java\n@Test\npublic void testFluxCreateOverflowLatest() {\n    Flux<Integer> flux = Flux.create(emitter -> {\n        for (int i = 0; i < 5; i++) {\n            emitter.next(i);\n        }\n        emitter.complete();\n    }, OverflowStrategy.LATEST);\n\n    TestSubscriber.subscribe(flux.log()).await().assertValues(0, 1, 2, 3, 4);\n}\n```\n\nProduces:\n\n```\n18:41:40.776 [main] INFO  reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxCreate$DefaultFluxSink@14bf9759)\n18:41:40.848 [main] INFO  reactor.core.publisher.FluxLog -  request(unbounded)\n18:41:40.851 [main] INFO  reactor.core.publisher.FluxLog -  onNext(0)\n18:41:40.851 [main] INFO  reactor.core.publisher.FluxLog -  onNext(0)\n18:41:40.855 [main] INFO  reactor.core.publisher.FluxLog -  onNext(1)\n18:41:40.855 [main] INFO  reactor.core.publisher.FluxLog -  onNext(1)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(2)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(2)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(3)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(3)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(4)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onNext(4)\n18:41:40.856 [main] INFO  reactor.core.publisher.FluxLog -  onComplete()\n\njava.lang.AssertionError: The element with index 1 does not match: expected = 1 (Integer), actual = 0 (Integer)\n```\n\nThis behaviour is unexpected to me, but I might be overlooking something.\n", "url": "https://github.com/reactor/reactor-core/issues/130", "user": "praseodym", "labels": ["type/bug"], "created": "2016-08-01 16:44:23", "closed": "2016-08-01 21:16:27", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Mono<T[]> Mono#when(Iterable<? extends Mono<? extends T>>) failed with ClassCastException", "body": "The underlying code snippet will failed with `java.lang.ClassCastException`, this happens at 3.0.0.RC1.\n\nWhen I call\n\n``` java\nMono<String[]> mono = Mono.when(new Mono[]{Mono.just(\"hello\"), Mono.just(\"world\")});\nmono.subscribe(results -> {});\n```\n\nI got\n\n``` java\nreactor.core.Exceptions$BubblingException: java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;\n\n    at reactor.core.Exceptions.bubble(Exceptions.java:95)\n    at reactor.core.Exceptions.onErrorDropped(Exceptions.java:199)\n    at reactor.core.publisher.LambdaSubscriber.onError(LambdaSubscriber.java:126)\n    at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:145)\n    at reactor.core.publisher.Operators$DeferredScalarSubscriber.complete(Operators.java:797)\n    at reactor.core.publisher.MonoWhen$MonoWhenCoordinator.signal(MonoWhen.java:171)\n    at reactor.core.publisher.MonoWhen$MonoWhenSubscriber.onNext(MonoWhen.java:215)\n    at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:1293)\n    at reactor.core.publisher.MonoWhen$MonoWhenSubscriber.onSubscribe(MonoWhen.java:205)\n    at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:49)\n    at reactor.core.publisher.MonoWhen$MonoWhenCoordinator.subscribe(MonoWhen.java:109)\n    at reactor.core.publisher.MonoWhen.subscribe(MonoWhen.java:81)\n    at reactor.core.publisher.Mono.subscribeWith(Mono.java:2243)\n    at reactor.core.publisher.Mono.subscribe(Mono.java:2205)\n    at reactor.core.publisher.Mono.subscribe(Mono.java:2164)\nCaused by: java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;\n    at reactor.core.publisher.LambdaSubscriber.doNext(LambdaSubscriber.java:155)\n    at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:136)\n```\n\nThis is caused by having an `Object[]` in `reactor.core.publisher.MonoWhen$MonoWhenCoordinator.signal()` to accumulate the value of type-parameterized `Iterable<Mono<T>>`. In this case, an `Object[]` is used to store element with `java.lang.String` type, and finally class cast to `String[]` at runtime. Casting `String[]` to `Object[]` is OK because the Class of `Object[]` is super of the Class of `String[]`, but not the case inverse.\n\nUnfortunely, due to the limitation of Java generic type erasing at runtime, we're unable to instantiate a generic type array, and `complete((T[])o)` will pass compiler checking at `reactor.core.publisher.MonoWhen$MonoWhenCoordinator.signal(MonoWhen.java:171)` because compiler will treat as `complete((Object[])o)`, but fail eventually.\n", "url": "https://github.com/reactor/reactor-core/issues/123", "user": "raymondhjm", "labels": ["type/bug"], "created": "2016-07-27 12:05:39", "closed": "2016-07-30 16:24:03", "commits": {"deb149a2d5e5ea87c62dd60fb36bdf15f5fbb247": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 3.000277777777778, "commitsDetails": [{"commitHash": "deb149a2d5e5ea87c62dd60fb36bdf15f5fbb247", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["a6e1958af0068154f9cd3a47120a821e8a319d13"], "nameRev": "deb149a2d5e5ea87c62dd60fb36bdf15f5fbb247 tags/v3.0.0.RC2~51", "commitMessage": "Fix #123 - rework unusable when(array) and when(iterable) producing T[]\nForce a combinator for anything not Publisher<Void>\n", "commitDateTime": "2016-07-30 17:23:49", "authoredDateTime": "2016-07-30 17:23:49", "commitGitStats": [{"filePath": "src/main/java/reactor/core/Exceptions.java", "insertions": 11, "deletions": 1, "lines": 12}, {"filePath": "src/main/java/reactor/core/publisher/FluxZip.java", "insertions": 6, "deletions": 5, "lines": 11}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 98, "deletions": 41, "lines": 139}, {"filePath": "src/main/java/reactor/core/publisher/MonoWhen.java", "insertions": 85, "deletions": 53, "lines": 138}, {"filePath": "src/test/java/reactor/core/publisher/MonoWhenTest.java", "insertions": 8, "deletions": 1, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.Exceptions.mapOperatorError(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "TOT": 4, "UPD": 0, "INS": 3, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "FluxZip.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxZip.ZipCoordinator.drain()", "TOT": 7, "UPD": 0, "INS": 5, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "Mono.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.Mono.when(java.lang.Iterable)", "TOT": 7, "UPD": 4, "INS": 1, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnTerminate(java.util.function.BiConsumer)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono[])", "TOT": 6, "UPD": 1, "INS": 2, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 6, "UPD": 1, "INS": 1, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 5, "UPD": 1, "INS": 0, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono[])", "TOT": 4, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.compose(java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.elapsed()", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.mapError(java.util.function.Predicate,java.util.function.Function)", "TOT": 3, "UPD": 1, "INS": 1, "MOV": 0, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.mapError(java.util.function.Function)", "TOT": 3, "UPD": 1, "INS": 0, "MOV": 2, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwise(java.util.function.Predicate,java.util.function.Function)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Class,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.otherwiseReturn(java.util.function.Predicate,java.lang.Object)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "TOT": 3, "UPD": 3, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 1}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "TOT": 4, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.Mono.when(java.util.function.Function,java.lang.Iterable)", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.when(java.util.function.Function,reactor.core.publisher.Mono[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.whenDelayError(org.reactivestreams.Publisher[])", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.zip(java.util.function.Function,reactor.core.publisher.Mono[])", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.Mono.mapError(java.lang.Class,java.util.function.Function)", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 1, "DEL": 0}]}, {"spoonFilePath": "MonoWhen.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoWhen", "TOT": 9, "UPD": 3, "INS": 6, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoWhen.subscribe(org.reactivestreams.Subscriber)", "TOT": 4, "UPD": 4, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoWhen.MonoWhenCoordinator", "TOT": 5, "UPD": 1, "INS": 4, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoWhen.MonoWhenCoordinator.subscribe(reactor.core.publisher.Mono[])", "TOT": 1, "UPD": 1, "INS": 0, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoWhen.MonoWhenCoordinator.signal()", "TOT": 8, "UPD": 0, "INS": 5, "MOV": 1, "DEL": 2}, {"spoonMethodName": "reactor.core.publisher.MonoWhen.MonoWhenSubscriber", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "MonoWhenTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.MonoWhenTest.castCheck()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.MonoWhenTest.allNonEmpty()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["deb149a2d5e5ea87c62dd60fb36bdf15f5fbb247"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 200, "deletions": 100, "lines": 300, "gitFilesChange": 4}, "spoonStatsSummary": {"TOT": 119, "UPD": 37, "INS": 33, "MOV": 33, "DEL": 16, "spoonFilesChanged": 4, "spoonMethodsChanged": 39}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core", "src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.compose(java.util.function.Function)", "reactor.core.publisher.Mono.elapsed()", "reactor.core.publisher.Mono.doOnError(java.util.function.Predicate,java.util.function.Consumer)", "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate)", "reactor.core.publisher.Mono.otherwiseReturn(java.util.function.Predicate,java.lang.Object)", "reactor.core.publisher.Mono.when(java.util.function.Function,java.lang.Iterable)", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.FluxZip.ZipCoordinator.drain()", "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Object)", "reactor.core.publisher.Mono.mapError(java.util.function.Function)", "reactor.core.publisher.MonoWhen.MonoWhenCoordinator.subscribe(reactor.core.publisher.Mono[])", "reactor.core.publisher.MonoWhen.MonoWhenCoordinator.signal()", "reactor.core.publisher.Mono.otherwise(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function)", "reactor.core.Exceptions.mapOperatorError(org.reactivestreams.Subscription,java.lang.Throwable,java.lang.Object)", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono[])", "reactor.core.publisher.Mono.mapError(java.util.function.Predicate,java.util.function.Function)", "reactor.core.publisher.Mono.mapError(java.lang.Class,java.util.function.Function)", "reactor.core.publisher.MonoWhen.MonoWhenSubscriber", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.MonoWhen.MonoWhenCoordinator", "reactor.core.publisher.Mono.zip(java.util.function.Function,reactor.core.publisher.Mono[])", "reactor.core.publisher.Mono.doOnTerminate(java.util.function.BiConsumer)", "reactor.core.publisher.Mono.when(java.util.function.Function,reactor.core.publisher.Mono[])", "reactor.core.publisher.Mono", "reactor.core.publisher.MonoWhen.subscribe(org.reactivestreams.Subscriber)", "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.otherwiseReturn(java.lang.Class,java.lang.Object)", "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono[])", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.whenDelayError(org.reactivestreams.Publisher[])", "reactor.core.publisher.MonoWhen", "reactor.core.publisher.Mono.when(java.lang.Iterable)", "reactor.core.publisher.Mono.when(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)", "reactor.core.publisher.Mono.whenDelayError(reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono,reactor.core.publisher.Mono)"]}, {"title": "Fix log() capslock on event (ON_NEXT vs onNext())", "body": "Due to recent changes and consolidation including SignalType, we need a custom toString to be less painful to read in logs as it used to be.\n", "url": "https://github.com/reactor/reactor-core/issues/122", "user": "smaldini", "labels": ["type/bug"], "created": "2016-07-19 13:07:03", "closed": "2016-07-20 15:55:40", "commits": {"74a9a853f438ac0926af5eb818d777e53e8460fa": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "74a9a853f438ac0926af5eb818d777e53e8460fa", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["c52df483196da77c1804c3df75f6d03ff179bd57"], "nameRev": "74a9a853f438ac0926af5eb818d777e53e8460fa tags/v3.0.0.RC2~66", "commitMessage": "fix #122\n", "commitDateTime": "2016-07-20 16:55:29", "authoredDateTime": "2016-07-20 16:55:29", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/SignalType.java", "insertions": 21, "deletions": 1, "lines": 22}], "commitSpoonAstDiffStats": [{"spoonFilePath": "SignalType.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.SignalType.toString()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.SignalType", "TOT": 2, "UPD": 0, "INS": 0, "MOV": 2, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["74a9a853f438ac0926af5eb818d777e53e8460fa"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 21, "deletions": 1, "lines": 22, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.SignalType.toString()", "reactor.core.publisher.SignalType"]}, {"title": "100% CPU load on 32 bit Linux", "body": "**Environment**\nVirtualBox guest: Debian 7.11 i686. Host: Mac OS X x64.\nOracle JDK 1.8.0_92.\nReactor 2.5.0.M4.\n**Description**\nOn production we have observed that app installed on 32 bit Linux without load consumes 100% CPU. Consumption was measured using _top_ utility.\nI created a sample [program](https://gist.github.com/TanyaGaleyev/7eb3d8093344ca404dc31859402deb5c) which reproduces same 100% CPU consumption.\nSome results from VisualVM are provided. Sampling tells us that CPU spends all time waiting using parking strategy (`Parking.waitFor`).\n![screen shot 2016-07-05 at 17 31 17](https://cloud.githubusercontent.com/assets/1092664/16588180/11c4e314-42df-11e6-8d2a-ace80f1342fd.png)\n![screen shot 2016-07-05 at 17 29 14](https://cloud.githubusercontent.com/assets/1092664/16588195/210d7a16-42df-11e6-982f-ebb8e78ecf9f.png)\nOn 64 bit Linux platform production code consumes around 10% of CPU. I did not run sample app on 64 bit yet.\n", "url": "https://github.com/reactor/reactor-core/issues/112", "user": "TanyaGaleyev", "labels": ["type/bug", "type/enhancement"], "created": "2016-07-05 14:42:13", "closed": "2016-07-18 18:35:06", "commits": {}, "ttf": 13.000277777777777, "commitsDetails": []}, {"title": "NPE in PeekFuseableConditionalSubscriber#poll", "body": "When using `Flux.concatMap` I am hitting a code path that throws a NPE at [FluxPeekFuseable.java#L472](https://github.com/reactor/reactor-core/blob/0d459836c9b3621846bedc48a3b839e465167726/src/main/java/reactor/core/publisher/FluxPeekFuseable.java:472).\n\nEarlier in that same file there is a `poll` method that includes null pointer checks.\n", "url": "https://github.com/reactor/reactor-core/issues/109", "user": "sskrla", "labels": ["type/bug"], "created": "2016-06-30 18:43:59", "closed": "2016-06-30 18:55:43", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "RxJava1CompletableConverter has no public methods", "body": "Maybe I'm missing something obvious but `RxJava1CompletableConverter` appears unusable with all package private methods. What the [tests show](https://github.com/reactor/reactor-core/blob/0d459836c9b3621846bedc48a3b839e465167726/src/test/java/reactor/core/converter/RxJavaCompletableTests.java) for example cannot be done from any other package. \n", "url": "https://github.com/reactor/reactor-core/issues/106", "user": "rstoyanchev", "labels": ["type/bug"], "created": "2016-06-23 21:30:21", "closed": "2016-06-27 09:37:10", "commits": {}, "ttf": 3.000277777777778, "commitsDetails": []}, {"title": "Backpressure-Handling of WorkQueueProcessor leads to unnecessarily dropped messages with bursty producers", "body": "## TL;DR\n\nBecause the following explanation are a bit long, I'll try to sum it up in a few bullet points:\n- I use a WorkQueueProcessor with RingBuffer-capacity 128.\n- There are never more than 15 slots occupied (WorkQueueProcessor.getPending() is always below 15).\n- The consumer faster than the producer.\n- But still: **Backpressure drops messages!**\n## Details\n\nIn the following situation, the producer publishes messages with a rate of 200 messages per second. It does so by always publishing bursts of 5 messages and then sleeping for 25ms.\n\nThe final consumer consumes the messages with a rate of 250 message per second.\n\nTo buffer the bursty producer, I wanted to use a workqueueprocessor with a capacity of 128. In the test it is initially filled with 10 messages (in a real application, this could be e.g. a remainder of a previous burst).\n\nUsing Backpressure strategy DROP, I would expect that no messages at all are dropped, because the consumer is much faster than the producer and the ringbuffer should take care of possible lags and bursts.\n\nBut actually after the first ~880 messages, there appear regular DROPs! To illustrate the problem, I created a small unit-test (see https://gist.github.com/mlex/a7349216f32c4f94acc0c9d7c10d6321 for the full test):\n\n``` java\n  public static final int PRODUCER_LATENCY = 5;\n  public static final int CONSUMER_LATENCY = 4;\n\n  public static final int RINGBUFFER_SIZE = 128;\n\n  public static final int INITAL_MESSAGES_COUNT   = 10;\n  public static final int PRODUCED_MESSAGES_COUNT = 1024;\n  public static final int BURST_SIZE              = 5;\n\n  @Test\n  public void test() throws Exception {\n    processor = WorkQueueProcessor.create(\"test-processor\", RINGBUFFER_SIZE);\n\n    Flux\n      .create((emitter) -> burstyProducer(emitter, PRODUCED_MESSAGES_COUNT, BURST_SIZE))\n      .onBackpressureDrop(this::incrementDroppedMessagesCounter)\n      .subscribe(processor);\n\n    Flux.from(processor)\n      .map(this::complicatedCalculation)\n      .subscribe(this::logConsumedValue);\n\n    waitForProducerFinish();\n\n    System.out.println(\"\\n\\nMax ringbuffer pending: \" + maxRingBufferPending.get());\n\n    assertEquals(0, getDroppedMessagesCount(), \"Expect zero dropped messages\");\n  }\n```\n## Possible explanation\n\nThe reason for the observed behaviour lies in the way `Subscription.request()` is called in `reactor.queue.RequestTask` (which is used by `WorkQueueProcessor`). The `RequestTask` initially requests `bufferSize-1` messages (in our case 127). It then waits for the ringbuffer to consume `bufferSize*3/4` (in our case 96) messages and then requests another `bufferSize*3/4` messages.\n\nAs far as I can see, the intention behind this is the following: In the case of a fast producer and slow consumer, this would lead to a ringbuffer, that is always filled with 31 to 127 elements. In case of a slow producer and fast consumer, this would lead to a number of pending requests being constantly between 31 and 127 elements.\n\nUnfortunately the condition `waitStrategy.waitFor(cursor + limit, readCount, spinObserver);` (see [RingBuffer.java:868](https://github.com/reactor/reactor-core/blob/0d459836c9b3621846bedc48a3b839e465167726/src/main/java/reactor/core/queue/RingBuffer.java#L868)) that should wait for the next `limit`(=96) elements to be processed, is not triggered after exactly 96 elements. It is triggered after _at least_ 96 elements, because the `signalAllWhenBlocking()` in `WorkQueueProcessor` is only called after `nextSequence > cachedAvailableSequence` is reached (see [WorkQueueProcessor.java:818](https://github.com/reactor/reactor-core/blob/0d459836c9b3621846bedc48a3b839e465167726/src/main/java/reactor/core/publisher/WorkQueueProcessor.java#L818)).\n\nIn the case of bursty producer, the `cachedAvailableSequence` does not increase constantly, but makes jumps (the size of the jumps being the burstSize). In the above example, this causes `waitFor` to return after 100 elements have been processed (not after 96 as expected)! So we actually \"loose\" 4 slots (\"loose\", because they will never be filled again - even if the producer starts producing at a much faster rate). \n\nAfter 800 elements, we have already lost 8*4 = 32 slots. This means, that the next `Subscription.request()` is only triggered when the number of pending requests equals zero - in which case we start dropping messages.\n", "url": "https://github.com/reactor/reactor-core/issues/104", "user": "mlex", "labels": ["type/bug"], "created": "2016-06-15 08:24:07", "closed": "2016-07-30 22:51:49", "commits": {"add70ed0a8abfce2d073ab85049d31431c6527cc": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 45.000277777777775, "commitsDetails": [{"commitHash": "add70ed0a8abfce2d073ab85049d31431c6527cc", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["4240e9941335d090b6bd53ad992680bbc426f83f"], "nameRev": "add70ed0a8abfce2d073ab85049d31431c6527cc tags/v3.0.0.RC2~47", "commitMessage": "fix #104 : use a constant slot position to request regularly\n", "commitDateTime": "2016-07-30 23:51:42", "authoredDateTime": "2016-07-30 23:48:03", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/EventLoopProcessor.java", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "src/test/java/reactor/core/publisher/scenarios/BurstyWorkQueueProcessorTests.java", "insertions": 132, "deletions": 0, "lines": 132}, {"filePath": "src/test/java/reactor/core/publisher/tck/WorkQueueProcessorTests.java", "insertions": 8, "deletions": 1, "lines": 9}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EventLoopProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EventLoopProcessor.RequestTask.run()", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0}]}, {"spoonFilePath": "BurstyWorkQueueProcessorTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.scenarios.BurstyWorkQueueProcessorTests", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "WorkQueueProcessorTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.tck.WorkQueueProcessorTests.highRate()", "TOT": 1, "UPD": 0, "INS": 0, "MOV": 0, "DEL": 1}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["add70ed0a8abfce2d073ab85049d31431c6527cc"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2, "deletions": 1, "lines": 3, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 3, "UPD": 0, "INS": 1, "MOV": 2, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 1}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.EventLoopProcessor.RequestTask.run()"]}, {"title": "Data item hangs in WorkQueueProcessor buffered with time and size", "body": "Consider `WorkQueueProcessor` buffered with some duration and max buffer size. If data items consuming and new data element submission happen in the same time then this new data element will not be consumed. Most likely hanging element will be consumed after additional elements (at least once) are submitted.\nSee [gist](https://gist.github.com/TanyaGaleyev/10152bc999c8276fd4754a7b35a7d230) reproducing the problem. My setup is OS X 10.11.4, Intel Core i7 4 cores,16 GB RAM.\n", "url": "https://github.com/reactor/reactor-core/issues/103", "user": "TanyaGaleyev", "labels": ["type/bug"], "created": "2016-06-14 16:10:31", "closed": "2016-07-30 22:21:43", "commits": {"4240e9941335d090b6bd53ad992680bbc426f83f": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 46.000277777777775, "commitsDetails": [{"commitHash": "4240e9941335d090b6bd53ad992680bbc426f83f", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["46cc130a35dcacef10d1d32098794e77dfaf14d1"], "nameRev": "4240e9941335d090b6bd53ad992680bbc426f83f tags/v3.0.0.RC2~48", "commitMessage": "Fix #103 : arrange buffer and window time or size operators\n- simplify runtime paths\n- check concurrent index update\n- implementation might be reevaluated\n", "commitDateTime": "2016-07-30 23:21:38", "authoredDateTime": "2016-07-30 23:21:16", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/FluxBatch.java", "insertions": 139, "deletions": 166, "lines": 305}, {"filePath": "src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java", "insertions": 14, "deletions": 27, "lines": 41}, {"filePath": "src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java", "insertions": 2, "deletions": 5, "lines": 7}, {"filePath": "src/main/java/reactor/core/publisher/Mono.java", "insertions": 4, "deletions": 5, "lines": 9}, {"filePath": "src/main/java/reactor/core/scheduler/SingleTimedScheduler.java", "insertions": 3, "deletions": 1, "lines": 4}, {"filePath": "src/test/java/reactor/core/publisher/tck/WorkQueueProcessorTests.java", "insertions": 98, "deletions": 0, "lines": 98}, {"filePath": "src/test/resources/logback.xml", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": "tooManyChanges"}], "filteredCommits": ["4240e9941335d090b6bd53ad992680bbc426f83f"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 162, "deletions": 204, "lines": 366, "gitFilesChange": 5}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/scheduler", "src/main/java/reactor/core/publisher"]}, {"title": "Computations.parallel() gums up after first request", "body": "If I do this:\n\n```\n    private ExecutorService scheduler = Executors.newFixedThreadPool(4);\n\n    @RequestMapping(\"/parallel\")\n    public Mono<Result> parallel() {\n        log.info(\"Handling /parallel\");\n        return Flux.range(1, 10) // <1>\n                .log() //\n                .flatMap( // <2>\n                        value -> Mono.fromCallable(() -> block(value)) // <3>\n                                .subscribeOn(scheduler), // <4>\n                        4) // <5>\n                .collect(Result::new, Result::add) // <6>\n                .doOnSuccess(result -> {\n                    result.stop(); // <7>\n                });\n    private ExecutorService scheduler = Executors.newFixedThreadPool(4);\n\n    @RequestMapping(\"/parallel\")\n    public Mono<Result> parallel() {\n        log.info(\"Handling /parallel\");\n        return Flux.range(1, 10) // <1>\n                .log() //\n                .flatMap( // <2>\n                        value -> Mono.fromCallable(() -> block(value)) // <3>\n                                .subscribeOn(scheduler), // <4>\n                        4) // <5>\n                .collect(Result::new, Result::add) // <6>\n                .doOnSuccess(result -> {\n                    result.stop(); // <7>\n                });\n    }\n```\n\nit's fine, but slow. Replacing `Executors.newFixedThreadPool(4)` with `Computations.parallel()` causes the app to freeze (HTTP connections all time out) on second and subsequent requests. Creating a new `Computations.parallel()` per request and calling `shutdown()` in the `doOnSuccess()` is fine too, and faster. I want the faster, without the fuss of calling `shutdown()` if possible.\n", "url": "https://github.com/reactor/reactor-core/issues/94", "user": "dsyer", "labels": ["type/bug", "type/enhancement"], "created": "2016-05-27 11:57:17", "closed": "2016-05-27 13:54:28", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Logger blew up under load", "body": "I'm not sure if this is a Reactor problem or something to do with the environment, or the Spring Boot logging system or what. But the stack trace looks clean and points at reactor:\n\n```\n2016-05-27 11:54:25.898  INFO 3750 --- [   parallel-2-1] reactor.core.publisher.FluxLog           :  onNext(7)\n[WARNING] \n2016-05-27 11:54:28.450  INFO 3750 --- [   parallel-2-1] reactor.core.publisher.FluxLog           :  request(1)\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n    at java.util.Arrays.copyOf(Arrays.java:3332)\n    at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:137)\n    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:121)\n    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:421)\n    at java.lang.StringBuilder.append(StringBuilder.java:136)\n    at ch.qos.logback.classic.spi.ThrowableProxyUtil.subjoinPackagingData(ThrowableProxyUtil.java:123)\n    at ch.qos.logback.classic.pattern.ExtendedThrowableProxyConverter.extraData(ExtendedThrowableProxyConverter.java:24)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.printStackLine(ThrowableProxyConverter.java:222)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.subjoinSTEPArray(ThrowableProxyConverter.java:199)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.recursiveAppend(ThrowableProxyConverter.java:161)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.recursiveAppend(ThrowableProxyConverter.java:168)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.throwableProxyToString(ThrowableProxyConverter.java:151)\n    at org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter.throwableProxyToString(ExtendedWhitespaceThrowableProxyConverter.java:35)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.convert(ThrowableProxyConverter.java:145)\n    at ch.qos.logback.classic.pattern.ThrowableProxyConverter.convert(ThrowableProxyConverter.java:1)\n    at ch.qos.logback.core.pattern.FormattingConverter.write(FormattingConverter.java:36)\n    at ch.qos.logback.core.pattern.PatternLayoutBase.writeLoopOnConverters(PatternLayoutBase.java:114)\n    at ch.qos.logback.classic.PatternLayout.doLayout(PatternLayout.java:141)\n    at ch.qos.logback.classic.PatternLayout.doLayout(PatternLayout.java:1)\n    at ch.qos.logback.core.encoder.LayoutWrappingEncoder.doEncode(LayoutWrappingEncoder.java:130)\n    at ch.qos.logback.core.OutputStreamAppender.writeOut(OutputStreamAppender.java:187)\n    at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:212)\n    at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100)\n    at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84)\n    at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:48)\n    at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270)\n    at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257)\n    at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421)\n    at ch.qos.logback.classic.Logger.filterAndLog_0_Or3Plus(Logger.java:383)\n    at ch.qos.logback.classic.Logger.error(Logger.java:538)\n    at reactor.core.util.Logger$Slf4JLogger.error(Logger.java:477)\n    at reactor.core.publisher.Computations$ProcessorWorker.routeError(Computations.java:951)\n```\n\nThis happened in a Tomcat app under load, but as you can see it's from a thread created by `Computations`.\n", "url": "https://github.com/reactor/reactor-core/issues/93", "user": "dsyer", "labels": ["type/bug"], "created": "2016-05-27 11:01:22", "closed": "2016-07-18 11:55:50", "commits": {}, "ttf": 52.000277777777775, "commitsDetails": []}, {"title": "Exception.unwrap() doesn't fully unwrap real exception when UpstreamException nests DownstreamException", "body": "In some circumstance the exception that gets thrown when using `Mono.get()` (e.g. when using flatMap)  has the real exception 2 levels down meaning that `Exception.unwrap()` returns `DownstreamException` and not the real exception.\n\n```\n- UpstreamException\n- - DownstreamException\n- - - RealException\n```\n", "url": "https://github.com/reactor/reactor-core/issues/87", "user": "dfeist", "labels": ["type/bug"], "created": "2016-05-12 16:04:30", "closed": "2016-05-12 17:42:04", "commits": {"04894c4dcfafdec24e1a709b3111c0aa4880178d": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "04894c4dcfafdec24e1a709b3111c0aa4880178d", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["2674750ff97a4f1f461f859ecb64760f40e731b5"], "nameRev": "04894c4dcfafdec24e1a709b3111c0aa4880178d tags/v2.5.0.M4~93", "commitMessage": "fix #87\n", "commitDateTime": "2016-05-12 18:41:57", "authoredDateTime": "2016-05-12 18:41:57", "commitGitStats": [{"filePath": "src/main/java/reactor/core/util/Exceptions.java", "insertions": 5, "deletions": 4, "lines": 9}, {"filePath": "src/test/java/reactor/core/util/ExceptionTests.java", "insertions": 36, "deletions": 0, "lines": 36}], "commitSpoonAstDiffStats": [{"spoonFilePath": "Exceptions.java", "spoonMethods": [{"spoonMethodName": "reactor.core.util.Exceptions.unwrap(java.lang.Throwable)", "TOT": 9, "UPD": 3, "INS": 2, "MOV": 3, "DEL": 1}, {"spoonMethodName": "reactor.core.util.Exceptions.bubble(java.lang.Throwable)", "TOT": 3, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 1}]}, {"spoonFilePath": "ExceptionTests.java", "spoonMethods": [{"spoonMethodName": "reactor.core.util.ExceptionTests", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["04894c4dcfafdec24e1a709b3111c0aa4880178d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 5, "deletions": 4, "lines": 9, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 12, "UPD": 3, "INS": 3, "MOV": 4, "DEL": 2, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/util"], "changesInPackagesSPOON": ["reactor.core.util.Exceptions.unwrap(java.lang.Throwable)", "reactor.core.util.Exceptions.bubble(java.lang.Throwable)"]}, {"title": "Missing API calls in documentation", "body": "From the docs:\n\n>  If you passed the integers 1, 2 and 3 into the Processor, you would see output in the console similar to this\n\nBut it doesn't show how to \"pass\" integers (or anything) into a processor. Only the output.\n", "url": "https://github.com/reactor/reactor-core/issues/77", "user": "dsyer", "labels": ["good first issue", "type/bug", "type/documentation", "type/enhancement"], "created": "2016-04-29 05:42:32", "closed": "2017-02-07 11:18:40", "commits": {}, "ttf": 284.0002777777778, "commitsDetails": []}, {"title": "Add Mono.whenComplete(Publisher<Void>...) or support Mono.when(Mono<Void>...)", "body": "", "url": "https://github.com/reactor/reactor-core/issues/60", "user": "smaldini", "labels": ["type/bug", "type/enhancement"], "created": "2016-04-09 00:59:02", "closed": "2016-04-15 13:28:08", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "Interrupt issue with PublishOn", "body": "Original from https://github.com/reactive-streams/reactive-streams-jvm/issues/310 by @sskrla\n\nWhen using .dispatchOn Flux calls .interrupt() on the current thread (via scheduler.accept(null)) before it calls the onError or onComplete.\n\nSpecifically, this caused issues using the ElasticSearch client as it throws an exception if the current thread is an interrupted state when you make a blocking API call.\n\nFor example:\n\n```\nFlux.from(documents)\n    .publishOn(processorsExecutorService)\n    .buffer(batchSize)\n    .onNext( requests -> {\n        BulkRequestBuilder builder = client.prepareBulk();\n        requests.forEach(builder::add);\n        builder.get() // Throws interrupted exception on last batch\n    })\n    .subscribe()\n```\n", "url": "https://github.com/reactor/reactor-core/issues/50", "user": "smaldini", "labels": ["type/bug"], "created": "2016-03-30 13:27:54", "closed": "2016-04-08 16:02:47", "commits": {}, "ttf": 9.000277777777777, "commitsDetails": []}, {"title": "repeatWhenEmpty() versions show different behaviour", "body": "We tried switching cf-java-client from using `.repeatWhenEmpty()` with a `maxRepeat` value, to using the version that just takes a `repeatFactory`. This leads to a number of test failures caused by 'insufficient' mocking in the tests - a test that successfully provided two responses to a repeated request [(example)](https://github.com/cloudfoundry/cf-java-client/blob/master/cloudfoundry-operations/src/test/java/org/cloudfoundry/operations/applications/DefaultApplicationsTest.java#L584-L594) before our change fails with a null pointer exception because it's being asked to supply a third response with the new approach.\n\nFor now we're using the two parameter version with `MAXINT-1` as a workaround [(example)](https://github.com/cloudfoundry/cf-java-client/blob/master/cloudfoundry-util/src/main/java/org/cloudfoundry/util/JobUtils.java#L47). Should the two versions of `.repeatWhenEmpty()` differ in this way?\n", "url": "https://github.com/reactor/reactor-core/issues/46", "user": "twoseat", "labels": ["type/bug"], "created": "2016-03-23 10:32:42", "closed": "2016-03-30 09:29:40", "commits": {}, "ttf": 6.000277777777778, "commitsDetails": []}, {"title": "Fluxes combined with Flux#combineLatest do not publish at the same pace", "body": "Example snippet:\n\n``` java\n    static class Iter implements Iterator<Long> {\n        long count = 0;\n        @Override public boolean hasNext() { return true; }\n        @Override public Long next() {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return count++; }\n\n    };\n\n\n        final Flux<Long> s1 = Flux.fromIterable(Iter::new).publishOn(SchedulerGroup.single());\n        final Flux<Long> s2 = Flux.fromIterable(Iter::new).publishOn(SchedulerGroup.single());\n\n\n        Flux.combineLatest(\n                v-> Tuple.of((long)v[0],(long)v[1]), 1,\n                s1, s2 //, (l,r) -> Tuple.of(l,r)\n        ).consume(t -> System.out.printf(\"(%d,%d)\\n\", t.getT1(),t.getT2()));\n```\n\nUsing e5a23a210351f46542c7832083298db84004c64c ; I would expect to see a pair of approx the same values on the two sides, instead there are sometimes large gaps between the values, e.g.:\n\n```\n\n(1438,5)\n(1439,5)\n(1440,5)\n(1441,5)\n(1442,5)\n(1443,5)\n(1444,5)\n(1445,5)\n(1446,5)\n(1447,5)\n(1448,5)\n(1449,5)\n(1450,5)\n(1451,5)\n(1452,5)\n(1453,5)\n(1454,5)\n(1455,5)\n\n```\n\nI'm not sure if I'm doing something wrong here\n", "url": "https://github.com/reactor/reactor-core/issues/45", "user": "evacchi", "labels": ["type/bug"], "created": "2016-03-21 12:09:53", "closed": "2016-06-01 17:08:51", "commits": {}, "ttf": 72.00027777777778, "commitsDetails": []}, {"title": "dispatchOn raises exception when prefetch=1", "body": "Problem not occurring in RxJava (see also https://gist.github.com/evacchi/ae362310dec8aacfdef4)\n\n``` java\npackage rxplayground;\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.SchedulerGroup;\n\nimport java.util.Iterator;\nimport java.util.function.Function;\n\npublic class ReactorPublish {\n    static class Iter implements Iterator<Long> {\n        long count = 0;\n        @Override public boolean hasNext() { return true; }\n        @Override public Long next() { return count++; }\n    };\n    final Flux<Long> doubleFlux = Flux.fromIterable(Iter::new).as(Shared());\n\n    void stream() {\n\n        doubleFlux.as(DropOld()).map(this::fastComputation).consume(i -> System.out.println(\"1) \" + i));\n        doubleFlux.as(DropOld()).map(this::slowComputation).consume(i -> System.err.println(\"2) \" + i));\n    }\n\n    public static <T> Function<Flux<T>, Flux<T>> DropOld() {\n        return (flux) -> flux.onBackpressureLatest().dispatchOn(SchedulerGroup.single(), 1);\n    }\n\n    public static <T> Function<Flux<T>, Flux<T>> Shared() {\n        return (flux) -> flux.publishOn(SchedulerGroup.single()).publish().refCount();\n    }\n\n\n    <T> T fastComputation(T in) {\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return in;\n    }\n\n    <T> T slowComputation(T in) {\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return in;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReactorPublish().stream();\n        Thread.currentThread().join();\n    }\n}\n```\n\n``` java\n2016-03-16 12:01:30 ERROR r.c.p.SchedulerGroup:477 - Unrouted exception\nreactor.core.util.Exceptions$UpstreamException: java.lang.IllegalStateException: Queue is full?!\n    at reactor.core.util.Exceptions.failUpstream(Exceptions.java:106)\n    at reactor.core.util.Exceptions.onErrorDropped(Exceptions.java:153)\n    at reactor.core.subscriber.ConsumerSubscriber.doError(ConsumerSubscriber.java:141)\n    at reactor.core.subscriber.ConsumerSubscriber.onError(ConsumerSubscriber.java:128)\n    at reactor.core.publisher.FluxMap$MapSubscriber.onError(FluxMap.java:137)\n    at reactor.core.publisher.FluxDispatchOn$DispatchOnSubscriber.checkTerminated(FluxDispatchOn.java:493)\n    at reactor.core.publisher.FluxDispatchOn$DispatchOnSubscriber.runAsync(FluxDispatchOn.java:417)\n    at reactor.core.publisher.FluxDispatchOn$DispatchOnSubscriber.run(FluxDispatchOn.java:476)\n    at reactor.core.publisher.SchedulerGroup$TaskSubscriber.onNext(SchedulerGroup.java:1081)\n    at reactor.core.publisher.SchedulerGroup$TaskSubscriber.onNext(SchedulerGroup.java:1063)\n    at reactor.core.publisher.TopicProcessor$TopicSubscriberLoop.run(TopicProcessor.java:877)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.IllegalStateException: Queue is full?!\n    at reactor.core.publisher.FluxDispatchOn$DispatchOnSubscriber.onNext(FluxDispatchOn.java:259)\n    at reactor.core.publisher.FluxLatest$LatestSubscriber.drain(FluxLatest.java:177)\n    at reactor.core.publisher.FluxLatest$LatestSubscriber.request(FluxLatest.java:97)\n    at reactor.core.publisher.FluxDispatchOn$DispatchOnSubscriber.runAsync(FluxDispatchOn.java:432)\n    ... 7 more\n```\n", "url": "https://github.com/reactor/reactor-core/issues/44", "user": "evacchi", "labels": ["type/bug"], "created": "2016-03-17 08:08:27", "closed": "2016-04-08 11:30:00", "commits": {}, "ttf": 22.00027777777778, "commitsDetails": []}, {"title": "Flux#combineLatest with 2 sources is using withLatestFrom", "body": "As the obvious title suggests it needs to be replaced before the next milestone/candidate. \nWorkaround in Reactor Core M2 involves using the combineLatest generic signature (Iterable or Varargs) that force use of the good CombineLatest operator class. E.g.\n\n``` java\nFlux.combineLatest(Tuple::fn2, source1, source2); //good, note that Tuple::fn2 will create Tuple2<Object, Object>, an explicit lambda casting away the Object[] values might be necessary, which is what we do usually in the T2-T6 versions.\n\nFlux.combineLatest(source1, source2, (a, b) -> Tuple.of(a,b)); //not good for now\n```\n\n/cc @evacchi\n", "url": "https://github.com/reactor/reactor-core/issues/37", "user": "smaldini", "labels": ["type/bug"], "created": "2016-03-09 00:27:07", "closed": "2016-03-09 12:03:09", "commits": {}, "ttf": 0.0002777777777777778, "commitsDetails": []}, {"title": "Issue with EmitterProcessor mixed multi-subscribe unbounded/bounded", "body": "Revealed by https://github.com/reactor/reactor-stream/blob/master/src/test/java/reactor/rx/StreamMulticastTest.java#L28\n", "url": "https://github.com/reactor/reactor-core/issues/22", "user": "smaldini", "labels": ["type/bug"], "created": "2016-02-18 12:45:58", "closed": "2016-02-29 12:30:42", "commits": {"e2059f57d7a9261ef3c1efc8ab2ec088c50ba60d": {"commitGHEventType": "closed", "commitUser": "smaldini"}}, "ttf": 10.000277777777777, "commitsDetails": [{"commitHash": "e2059f57d7a9261ef3c1efc8ab2ec088c50ba60d", "commitGHEventType": "closed", "commitUser": "smaldini", "commitParents": ["da96fffa2f727603fef1a4d38a188fefd4c39b6f"], "nameRev": "e2059f57d7a9261ef3c1efc8ab2ec088c50ba60d tags/v2.5.0.M2~115", "commitMessage": "fix #22\n", "commitDateTime": "2016-02-29 12:30:36", "authoredDateTime": "2016-02-29 12:30:36", "commitGitStats": [{"filePath": "src/main/java/reactor/core/publisher/EmitterProcessor.java", "insertions": 3, "deletions": 2, "lines": 5}], "commitSpoonAstDiffStats": [{"spoonFilePath": "EmitterProcessor.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.EmitterProcessor.checkTerminal(reactor.core.publisher.EmitterProcessor$EmitterSubscriber,reactor.core.util.Sequence,long)", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.EmitterProcessor.drainLoop()", "TOT": 2, "UPD": 0, "INS": 1, "MOV": 1, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": ["e2059f57d7a9261ef3c1efc8ab2ec088c50ba60d"], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 3, "deletions": 2, "lines": 5, "gitFilesChange": 1}, "spoonStatsSummary": {"TOT": 4, "UPD": 0, "INS": 2, "MOV": 2, "DEL": 0, "spoonFilesChanged": 1, "spoonMethodsChanged": 2}, "statsSkippedReason": "", "changesInPackagesGIT": ["src/main/java/reactor/core/publisher"], "changesInPackagesSPOON": ["reactor.core.publisher.EmitterProcessor.checkTerminal(reactor.core.publisher.EmitterProcessor$EmitterSubscriber,reactor.core.util.Sequence,long)", "reactor.core.publisher.EmitterProcessor.drainLoop()"]}, {"title": "Exception thrown from Stream.yield causes DuplicateOnSubscribeException", "body": "Currently, allowing an exception to escape from `Stream.yield` (i.e. not `catch`ing `Throwable`) causes a `DuplicateOnSubscribeException` to be thrown, masking the original exception.  The solution to this is to properly implement `Stream.yield` so that it doesn't allow exceptions to escape, but Reactor should behave slightly better in the face of a poor implementation.\n\n```\ncloud-foundry-3 cloudfoundry-client.request     POST   /v2/apps\ncloud-foundry-3 stream.upload                    onSubscribe(reactor.core.publisher.MonoNext$NextSubscriber@1fd2007b)\ncloud-foundry-3 stream.upload                    request(unbounded)\ncloud-foundry-2 reactor.core.publisher.SchedulerGroup Unrouted exception\nreactor.core.util.Exceptions$DuplicateOnSubscribeException: Spec. Rule 2.12 - Subscriber.onSubscribe MUST NOT be called more than once (based on object equality)\n    at reactor.core.util.Exceptions.duplicateOnSubscribeException(Exceptions.java:133) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.util.BackpressureUtils.reportSubscriptionSet(BackpressureUtils.java:440) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.util.DeferredSubscription.set(DeferredSubscription.java:62) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.FluxPublishOn$PublishOnPipeline.onSubscribe(FluxPublishOn.java:131) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.util.EmptySubscription.error(EmptySubscription.java:34) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.FluxYieldingEmitter.subscribe(FluxYieldingEmitter.java:51) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.rx.StreamSource.subscribe(StreamSource.java:69) ~[reactor-stream-2.5.0.BUILD-20160209.172643-328.jar:na]\n    at reactor.core.util.ScalarSubscription.trySubscribeScalarMap(ScalarSubscription.java:93) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:93) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.rx.StreamSource.subscribe(StreamSource.java:69) ~[reactor-stream-2.5.0.BUILD-20160209.172643-328.jar:na]\n    at reactor.core.publisher.FluxPublishOn$SourceSubscribeTask.run(FluxPublishOn.java:318) ~[reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.SchedulerGroup$TaskSubscriber.onNext(SchedulerGroup.java:1072) [reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.SchedulerGroup$TaskSubscriber.onNext(SchedulerGroup.java:1054) [reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at reactor.core.publisher.WorkQueueProcessor$QueueSubscriberLoop.run(WorkQueueProcessor.java:849) [reactor-core-2.5.0.BUILD-20160209.140333-334.jar:na]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_73]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_73]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_73]\n```\n", "url": "https://github.com/reactor/reactor-core/issues/20", "user": "nebhale", "labels": ["type/bug"], "created": "2016-02-09 18:50:29", "closed": "2016-02-09 23:24:11", "commits": {"1211eaf9e781da7f38a62d47941fce64554867e6": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "de48a82dbf47c927d8acef2f6f2adb6e836ea44d": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "1211eaf9e781da7f38a62d47941fce64554867e6", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "de48a82dbf47c927d8acef2f6f2adb6e836ea44d", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 2, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "spoonStatsSummary": {}, "statsSkippedReason": ""}, {"title": "Flux.replay / Flux.cache hangs or serves wrong values due to regressions in 3.3.[0-2]", "body": "In 3.3.0, #1185 introduced a change that aims at performing the minimum necessary request on a cached/replayed source upon `connect`. Comparing to `Californium` where the source would always be requested by `Long.MAX_VALUE` upon connection, 3.3.0 would attempt to take the maximum requested amount from early subscribers, ie these that subscribed to the `ConnectableFlux` **before** `connect()` is called.\r\n\r\nThere was several bugs with that new implementation, that led to underrequesting and hanging:\r\n\r\n - [x] Pre-connect subscribers would participate in the initial request, but if they request in \"batches\" their subsequent requests wouldn't get propagated (issue #1921, fixed in #1948)\r\n - [x] With that first change, having no early subscriber before `connect()` means no request was made _at all_, instead of falling back to the `MAX_VALUE` behavior (causes #2028 and spring-projects/spring-framework#24472, fixed in #2031)", "url": "https://github.com/reactor/reactor-core/issues/2030", "user": "simonbasle", "labels": ["type/bug", "warn/regression"], "created": "2020-02-04 17:03:07", "closed": "2020-02-05 09:59:03", "commits": {"2a26f31aa5be1f16c0b946c5263b4390e3fbf457": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "b70d59a47ca1f80bacb64b9f7c734690084d36ac": {"commitGHEventType": "closed", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "2a26f31aa5be1f16c0b946c5263b4390e3fbf457", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "b70d59a47ca1f80bacb64b9f7c734690084d36ac", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["309fd86f7b9ec83eb18e73e6dcf291dde2f17e90"], "nameRev": "b70d59a47ca1f80bacb64b9f7c734690084d36ac tags/v3.3.3.RELEASE~15", "commitMessage": "fix #2030 Let replay request(UNBOUNDED) when no early subscriber\n\nThis commit ensures that Flux.replay falls back to the 3.2.x behavior\r\nof requesting Long.MAX_VALUE when no early subscriber emitted requests\r\nbefore the `connect()`.\r\n\r\nAlso fixes #2028", "commitDateTime": "2020-02-05 10:58:59", "authoredDateTime": "2020-02-05 10:58:59", "commitGitStats": [{"filePath": "reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java", "insertions": 10, "deletions": 0, "lines": 10}, {"filePath": "reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java", "insertions": 40, "deletions": 0, "lines": 40}], "commitSpoonAstDiffStats": [{"spoonFilePath": "FluxReplay.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplay.ReplaySubscriber.onSubscribe(org.reactivestreams.Subscription)", "TOT": 2, "UPD": 0, "INS": 2, "MOV": 0, "DEL": 0}]}, {"spoonFilePath": "FluxReplayTest.java", "spoonMethods": [{"spoonMethodName": "reactor.core.publisher.FluxReplayTest.ifSubscribeBeforeConnectThenTrackFurtherRequests()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}, {"spoonMethodName": "reactor.core.publisher.FluxReplayTest.ifNoSubscriptionBeforeConnectThenUnbounded()", "TOT": 1, "UPD": 0, "INS": 1, "MOV": 0, "DEL": 0}]}], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0.0, "deletions": 0.0, "lines": 0.0, "gitFilesChange": 0}, "spoonStatsSummary": {"TOT": 0.0, "UPD": 0.0, "INS": 0.0, "MOV": 0.0, "DEL": 0.0, "spoonFilesChanged": 0, "spoonMethodsChanged": 0}, "statsSkippedReason": "", "changesInPackagesGIT": [], "changesInPackagesSPOON": []}, {"title": "Ensure docsZip defines a -docs classifier", "body": "since switching to `maven-publish`, maven naming conventions are enforced. this was missed as no warning is emitted by Gradle in case the archive's name doesn't follow said conventions (the plugin transparently renames \ud83d\ude22).\r\n\r\nthis impacts the zip of reference documentation, which ends up following the format `reactor-core-VERSION.zip` instead of (formerly) `reactor-core-docs-VERSION.zip`. Since there is no apparent way of keeping the name, the next best thing is to use a classifier and turn the filename into a deployable `reactor-core-VERSION-docs.zip`. Such a zip would still only be distributed to Artifactory.\r\n\r\n`3.2.13.RELEASE` and `3.3.1.RELEASE` where impacted, but the zip was renamed directly on artifactory. see also https://github.com/reactor/projectreactor.io/issues/48", "url": "https://github.com/reactor/reactor-core/issues/1975", "user": "simonbasle", "labels": ["type/bug", "type/chores", "warn/regression"], "created": "2019-11-26 14:11:53", "closed": "2019-11-27 10:55:17", "commits": {"84e9ba45b3fcd16a0d05250fd0ed9866822a7f47": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}, "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e": {"commitGHEventType": "closed", "commitUser": "simonbasle"}, "5ee0940904ae3fdf345e8726fca64d6834c9a824": {"commitGHEventType": "referenced", "commitUser": "simonbasle"}}, "ttf": 0.0002777777777777778, "commitsDetails": [{"commitHash": "84e9ba45b3fcd16a0d05250fd0ed9866822a7f47", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": [], "nameRev": "", "commitMessage": "", "commitDateTime": "", "authoredDateTime": "", "commitGitStats": [], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e", "commitGHEventType": "closed", "commitUser": "simonbasle", "commitParents": ["2ba476070751fd60804fce111eda78266ee4c0e4"], "nameRev": "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e tags/v3.2.14.RELEASE~8", "commitMessage": "fix #1975 Publish docsZip with -docs classifier\n", "commitDateTime": "2019-11-27 11:48:07", "authoredDateTime": "2019-11-26 15:58:51", "commitGitStats": [{"filePath": "gradle/doc.gradle", "insertions": 2, "deletions": 1, "lines": 3}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}, {"commitHash": "5ee0940904ae3fdf345e8726fca64d6834c9a824", "commitGHEventType": "referenced", "commitUser": "simonbasle", "commitParents": ["0acc568e62825a356d3d9d67beea1448494fc1c7", "f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e"], "nameRev": "5ee0940904ae3fdf345e8726fca64d6834c9a824 tags/v3.3.2.RELEASE~24", "commitMessage": "Merge #1975 into 3.3\n\n - propdeps was already reapplied in build.gradle on master, but\n propdeps-maven was not suppressed in setup.gradle\n - asciidoc.gradle changes to the target directory structure conflicts\n", "commitDateTime": "2019-11-27 11:53:16", "authoredDateTime": "2019-11-27 11:53:16", "commitGitStats": [{"filePath": "gradle/asciidoc.gradle", "insertions": 2, "deletions": 1, "lines": 3}, {"filePath": "gradle/setup.gradle", "insertions": 0, "deletions": 1, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": ["f2b940cbc0c3c1673e5d20e006d63d8e8ff4d42e"], "filteredCommitsReason": {"duplicated": 1, "alsoFixesPhrase": 0, "moreThanOneParent": 1, "multipleIssueFixes": 0, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 1, "gitStatsSummary": {"insertions": 2.0, "deletions": 1.0, "lines": 3.0, "gitFilesChange": 1}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": ["gradle"]}, {"title": "reactor-core 3.3 OSGI bundle issue reactor.blockhound is not optional", "body": "## Expected Behavior\r\nWhen using reactor-core bundle in OSGI environment, reactor.blockhound bundle would not be required as it is an optional dependency from reactor-core.\r\n\r\n## Actual Behavior\r\n`reactor.blockhound,reactor.blockhound.integration` are packages required at runtime. As reactor.blockhound is not exporting those packages, it is currently impossible to run reactor-core >= 3.3 in OSGI env.\r\n\r\n## Possible Solution\r\nThe section `bundleImportPackages` in the build.gradle file could specify `'reactor.blockhound.*;resolution:=optional'` juste as `io.micrometer`\r\n\r\n## Your Environment\r\n\r\n* Reactor-core version(s) used: v3.3.0.RELEASE\r\n* JVM version (`javar -version`):\r\nopenjdk version \"1.8.0_222\"\r\nOpenJDK Runtime Environment (build 1.8.0_222-8u222-b10-1~deb9u1-b10)\r\nOpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode)\r\n* OS and version (eg `uname -a`):\r\n`Linux 90b5161a77a8 4.18.0-0.bpo.1-amd64 #1 SMP Debian 4.18.6-1~bpo9+1 (2018-09-13) x86_64 GNU/Linux`\r\n", "url": "https://github.com/reactor/reactor-core/issues/1932", "user": "simondaudin", "labels": ["type/bug", "warn/regression"], "created": "2019-10-31 08:22:46", "closed": "2019-11-01 10:50:41", "commits": {"fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e": {"commitGHEventType": "closed", "commitUser": "bsideup"}}, "ttf": 1.0002777777777778, "commitsDetails": [{"commitHash": "fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e", "commitGHEventType": "closed", "commitUser": "bsideup", "commitParents": ["74b9bec73857177f700a902eecb42167295c588e"], "nameRev": "fb60d6d86a7bffbe29e6dfb731ab92f6ac37d22e tags/v3.3.1.RELEASE~21", "commitMessage": "fix #1932 Add reactor.blockhound to OSGI optional bundles (#1933)\n\nSince we only provide an SPI's implementation and not depend on\r\nBlockHound directly, we should mark it as an \"optional\" OSGI import.", "commitDateTime": "2019-11-01 11:50:39", "authoredDateTime": "2019-11-01 11:50:39", "commitGitStats": [{"filePath": "build.gradle", "insertions": 1, "deletions": 0, "lines": 1}], "commitSpoonAstDiffStats": [], "spoonStatsSkippedReason": ""}], "filteredCommits": [], "filteredCommitsReason": {"duplicated": 0, "alsoFixesPhrase": 0, "moreThanOneParent": 0, "multipleIssueFixes": 1, "unavailable": 0, "mergeCommitUsed": 0}, "numCommits": 0, "gitStatsSummary": {"insertions": 0, "deletions": 0, "lines": 0, "gitFilesChange": 0}, "spoonStatsSummary": {}, "statsSkippedReason": "", "changesInPackagesGIT": []}]}